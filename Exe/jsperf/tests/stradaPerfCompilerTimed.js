var Tools;
(function(Tools) {
    (function(CompilerDiagnostics) {
        CompilerDiagnostics.debug = false; 
        CompilerDiagnostics.diagnosticWriter = null; 
        CompilerDiagnostics.analysisPass = 0; 
        function Alert(output) {
            if(CompilerDiagnostics.diagnosticWriter != null) {
                CompilerDiagnostics.diagnosticWriter.Alert(output); 
            }
        }
        CompilerDiagnostics.Alert = Alert;
        function debugPrint(s) {
            if(CompilerDiagnostics.debug) {
                Alert(s); 
            }
        }
        CompilerDiagnostics.debugPrint = debugPrint;
    })(Tools.CompilerDiagnostics||(Tools.CompilerDiagnostics={}));
    var CompilerDiagnostics = Tools.CompilerDiagnostics;

    var NullLogger = (function () {
        function NullLogger() {
        }
        NullLogger.prototype.information = function() {
            return false; 
        };
        NullLogger.prototype.debug = function() {
            return false; 
        };
        NullLogger.prototype.warning = function() {
            return false; 
        };
        NullLogger.prototype.error = function() {
            return false; 
        };
        NullLogger.prototype.fatal = function() {
            return false; 
        };
        NullLogger.prototype.log = function(s) {
        };
        return NullLogger;
    })();
    Tools.NullLogger = NullLogger;
    
    var LoggerAdapter = (function () {
        function LoggerAdapter(logger) {
            this.logger = logger;
            this._information = this.logger.information(); 
            this._debug = this.logger.debug(); 
            this._warning = this.logger.warning(); 
            this._error = this.logger.error(); 
            this._fatal = this.logger.fatal(); 
        }
        LoggerAdapter.prototype.information = function() {
            return this._information; 
        };
        LoggerAdapter.prototype.debug = function() {
            return this._debug; 
        };
        LoggerAdapter.prototype.warning = function() {
            return this._warning; 
        };
        LoggerAdapter.prototype.error = function() {
            return this._error; 
        };
        LoggerAdapter.prototype.fatal = function() {
            return this._fatal; 
        };
        LoggerAdapter.prototype.log = function(s) {
            this.logger.log(s); 
        };
        return LoggerAdapter;
    })();
    Tools.LoggerAdapter = LoggerAdapter;
    
    var BufferedLogger = (function () {
        function BufferedLogger() {
            this.logContents = []; 
        }
        BufferedLogger.prototype.information = function() {
            return false; 
        };
        BufferedLogger.prototype.debug = function() {
            return false; 
        };
        BufferedLogger.prototype.warning = function() {
            return false; 
        };
        BufferedLogger.prototype.error = function() {
            return false; 
        };
        BufferedLogger.prototype.fatal = function() {
            return false; 
        };
        BufferedLogger.prototype.log = function(s) {
            this.logContents.push(s); 
        };
        return BufferedLogger;
    })();
    Tools.BufferedLogger = BufferedLogger;
    
    function timeFunction(logger, funcDescription, func) {
        var start = +new Date(); 
        var result = func(); 
        var end = +new Date(); 
        logger.log(((funcDescription + " completed in ") + (end - start)) + " msec"); 
        return result; 
    }
    Tools.timeFunction = timeFunction;
    function stringToLiteral(value, length) {
        var result = ""; 
        var addChar = function(index) {
            var ch = value.charCodeAt(index); 
            switch(ch) {
                case 9: {
                    result += "\\t"; 
                    break;

                }
                case 10: {
                    result += "\\n"; 
                    break;

                }
                case 11: {
                    result += "\\v"; 
                    break;

                }
                case 12: {
                    result += "\\f"; 
                    break;

                }
                case 13: {
                    result += "\\r"; 
                    break;

                }
                case 34: {
                    result += "\\\""; 
                    break;

                }
                case 39: {
                    result += "\\\'"; 
                    break;

                }
                case 92: {
                    result += "\\"; 
                    break;

                }
                default: {
                    result += value.charAt(index); 

                }
            }
        }; 
        var tooLong = (value.length > length); 
        if(tooLong) {
            var mid = length >> 1; 
            for(var i = 0; i < mid; i++) {
                addChar(i); 
            }
            result += "(...)"; 
            for(var i = value.length - mid; i < value.length; i++) {
                addChar(i); 
            }
        } else  {
            length = value.length; 
            for(var i = 0; i < length; i++) {
                addChar(i); 
            }
        }
        return result; 
    }
    Tools.stringToLiteral = stringToLiteral;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    function hasFlag(val, flag) {
        return (val & flag) != 0; 
    }
    Tools.hasFlag = hasFlag;
    (function(ErrorRecoverySet) {
        ErrorRecoverySet._map = []; 
        ErrorRecoverySet.None = 0; 
        ErrorRecoverySet.Comma = 1; 
        ErrorRecoverySet.SColon = 1 << 1; 
        ErrorRecoverySet.Asg = 1 << 2; 
        ErrorRecoverySet.BinOp = 1 << 3; 
        ErrorRecoverySet.RBrack = 1 << 4; 
        ErrorRecoverySet.RCurly = 1 << 5; 
        ErrorRecoverySet.RParen = 1 << 6; 
        ErrorRecoverySet.Dot = 1 << 7; 
        ErrorRecoverySet.Colon = 1 << 8; 
        ErrorRecoverySet.PrimType = 1 << 9; 
        ErrorRecoverySet.AddOp = 1 << 10; 
        ErrorRecoverySet.LCurly = 1 << 11; 
        ErrorRecoverySet.PreOp = 1 << 12; 
        ErrorRecoverySet.RegExp = 1 << 13; 
        ErrorRecoverySet.LParen = 1 << 14; 
        ErrorRecoverySet.LBrack = 1 << 15; 
        ErrorRecoverySet.Scope = 1 << 16; 
        ErrorRecoverySet.In = 1 << 17; 
        ErrorRecoverySet.SCase = 1 << 18; 
        ErrorRecoverySet.Else = 1 << 19; 
        ErrorRecoverySet.Catch = 1 << 20; 
        ErrorRecoverySet.Var = 1 << 21; 
        ErrorRecoverySet.Stmt = 1 << 22; 
        ErrorRecoverySet.While = 1 << 23; 
        ErrorRecoverySet.ID = 1 << 24; 
        ErrorRecoverySet.Prefix = 1 << 25; 
        ErrorRecoverySet.Literal = 1 << 26; 
        ErrorRecoverySet.RLit = 1 << 27; 
        ErrorRecoverySet.Func = 1 << 28; 
        ErrorRecoverySet.EOF = 1 << 29; 
        ErrorRecoverySet.StradaS = 1 << 30; 
        ErrorRecoverySet.ExprStart = ErrorRecoverySet.SColon | ErrorRecoverySet.AddOp | ErrorRecoverySet.LCurly | ErrorRecoverySet.PreOp | ErrorRecoverySet.RegExp | ErrorRecoverySet.LParen | ErrorRecoverySet.LBrack | ErrorRecoverySet.ID | ErrorRecoverySet.Prefix | ErrorRecoverySet.RLit | ErrorRecoverySet.Func | ErrorRecoverySet.Literal; 
        ErrorRecoverySet.StmtStart = ErrorRecoverySet.ExprStart | ErrorRecoverySet.SColon | ErrorRecoverySet.Var | ErrorRecoverySet.Stmt | ErrorRecoverySet.While | ErrorRecoverySet.StradaS; 
        ErrorRecoverySet.Postfix = ErrorRecoverySet.Dot | ErrorRecoverySet.LParen | ErrorRecoverySet.LBrack; 
    })(Tools.ErrorRecoverySet||(Tools.ErrorRecoverySet={}));
    var ErrorRecoverySet = Tools.ErrorRecoverySet;

    (function(AllowedElements) {
        AllowedElements._map = []; 
        AllowedElements.None = 0; 
        AllowedElements.Statements = 1; 
        AllowedElements.FunctionDecls = 1 << 1; 
        AllowedElements.ModuleDecls = 1 << 2; 
        AllowedElements.ClassDecls = 1 << 3; 
        AllowedElements.InterfaceDecls = 1 << 4; 
        AllowedElements.TypedFuncDecls = 1 << 5; 
        AllowedElements.TypedDecls = 1 << 6; 
        AllowedElements.TypedFuncSignatures = 1 << 8; 
        AllowedElements.TypedSignatures = 1 << 9; 
        AllowedElements.AmbientDecls = 1 << 10; 
        AllowedElements.Properties = 1 << 11; 
        AllowedElements.Block = AllowedElements.Statements | AllowedElements.FunctionDecls | AllowedElements.TypedFuncDecls | AllowedElements.TypedDecls; 
        AllowedElements.Global = AllowedElements.Statements | AllowedElements.FunctionDecls | AllowedElements.ModuleDecls | AllowedElements.ClassDecls | AllowedElements.InterfaceDecls | AllowedElements.AmbientDecls; 
        AllowedElements.FunctionBody = AllowedElements.Statements | AllowedElements.FunctionDecls; 
        AllowedElements.ModuleMembers = AllowedElements.TypedFuncDecls | AllowedElements.FunctionDecls | AllowedElements.ModuleDecls | AllowedElements.ClassDecls | AllowedElements.InterfaceDecls | AllowedElements.TypedDecls | AllowedElements.Statements | AllowedElements.AmbientDecls; 
        AllowedElements.ClassMembers = AllowedElements.TypedFuncDecls | AllowedElements.FunctionDecls | AllowedElements.Statements | AllowedElements.TypedDecls | AllowedElements.Properties; 
        AllowedElements.InterfaceMembers = AllowedElements.TypedFuncSignatures | AllowedElements.TypedSignatures; 
        AllowedElements.QuickParse = AllowedElements.Global | AllowedElements.Properties; 
    })(Tools.AllowedElements||(Tools.AllowedElements={}));
    var AllowedElements = Tools.AllowedElements;

    (function(Modifiers) {
        Modifiers._map = []; 
        Modifiers.None = 0; 
        Modifiers.Private = 1; 
        Modifiers.Public = 1 << 1; 
        Modifiers.Readonly = 1 << 2; 
        Modifiers.Ambient = 1 << 3; 
        Modifiers.Exported = 1 << 4; 
        Modifiers.Getter = 1 << 5; 
        Modifiers.Setter = 1 << 6; 
        Modifiers.Static = 1 << 7; 
    })(Tools.Modifiers||(Tools.Modifiers={}));
    var Modifiers = Tools.Modifiers;

    (function(ASTFlags) {
        ASTFlags._map = []; 
        ASTFlags.None = 0; 
        ASTFlags.ExplicitSemicolon = 1; 
        ASTFlags.AutomaticSemicolon = 1 << 1; 
        ASTFlags.Writeable = 1 << 2; 
        ASTFlags.Error = 1 << 3; 
        ASTFlags.DotLHSPartial = 1 << 4; 
        ASTFlags.DotLHS = 1 << 5; 
        ASTFlags.IsStatement = 1 << 6; 
        ASTFlags.StrictMode = 1 << 7; 
        ASTFlags.PossibleOptionalParameter = 1 << 8; 
        ASTFlags.ES6ClassBaseConstructorCall = 1 << 9; 
    })(Tools.ASTFlags||(Tools.ASTFlags={}));
    var ASTFlags = Tools.ASTFlags;

    (function(ModuleFlags) {
        ModuleFlags._map = []; 
        ModuleFlags.None = 0; 
        ModuleFlags.IsEnum = 1; 
        ModuleFlags.Ambient = 1 << 1; 
        ModuleFlags.ShouldEmitModuleDecl = 1 << 2; 
        ModuleFlags.Glo = 1 << 3; 
        ModuleFlags.Exported = 1 << 4; 
        ModuleFlags.IsWholeFile = 1 << 5; 
        ModuleFlags.IsDynamic = 1 << 6; 
    })(Tools.ModuleFlags||(Tools.ModuleFlags={}));
    var ModuleFlags = Tools.ModuleFlags;

    (function(SymbolFlags) {
        SymbolFlags._map = []; 
        SymbolFlags.None = 0; 
        SymbolFlags.Public = 1; 
        SymbolFlags.Private = 1 << 1; 
        SymbolFlags.Property = 1 << 2; 
        SymbolFlags.Ambient = 1 << 3; 
        SymbolFlags.Readonly = 1 << 4; 
        SymbolFlags.ModuleMember = 1 << 5; 
        SymbolFlags.InterfaceMember = 1 << 6; 
        SymbolFlags.ClassMember = 1 << 7; 
        SymbolFlags.Static = 1 << 8; 
        SymbolFlags.BuiltIn = 1 << 9; 
        SymbolFlags.Exported = 1 << 10; 
        SymbolFlags.TypeSetDuringScopeAssignment = 1 << 11; 
        SymbolFlags.Constant = 1 << 12; 
    })(Tools.SymbolFlags||(Tools.SymbolFlags={}));
    var SymbolFlags = Tools.SymbolFlags;

    (function(VarFlags) {
        VarFlags._map = []; 
        VarFlags.None = 0; 
        VarFlags.AutoInit = 1; 
        VarFlags.Static = 1 << 1; 
        VarFlags.Property = 1 << 2; 
        VarFlags.Private = 1 << 3; 
        VarFlags.Ambient = 1 << 4; 
        VarFlags.Public = 1 << 5; 
        VarFlags.Readonly = 1 << 6; 
        VarFlags.Exported = 1 << 7; 
        VarFlags.LocalStatic = 1 << 8; 
        VarFlags.ES6Class = 1 << 9; 
        VarFlags.ES6ClassProperty = 1 << 10; 
        VarFlags.ES6ClassBodyProperty = 1 << 11; 
        VarFlags.ES6ClassConstructorProperty = 1 << 12; 
        VarFlags.ES6ClassSuperMustBeFirstCallInConstructor = 1 << 13; 
        VarFlags.Constant = 1 << 14; 
    })(Tools.VarFlags||(Tools.VarFlags={}));
    var VarFlags = Tools.VarFlags;

    (function(FncFlags) {
        FncFlags._map = []; 
        FncFlags.None = 0; 
        FncFlags.Definition = 1; 
        FncFlags.Private = 1 << 1; 
        FncFlags.Signature = 1 << 2; 
        FncFlags.Method = 1 << 3; 
        FncFlags.HasReturnValue = 1 << 4; 
        FncFlags.Public = 1 << 5; 
        FncFlags.GetAccessor = 1 << 6; 
        FncFlags.CallMember = 1 << 7; 
        FncFlags.ConstructMember = 1 << 8; 
        FncFlags.HasSelfReference = 1 << 9; 
        FncFlags.IsFatArrowFunction = 1 << 10; 
        FncFlags.IndexerMember = 1 << 11; 
        FncFlags.Static = 1 << 12; 
        FncFlags.Ambient = 1 << 13; 
        FncFlags.Exported = 1 << 14; 
        FncFlags.SetAccessor = 1 << 15; 
        FncFlags.IsFunctionExpression = 1 << 16; 
        FncFlags.ES6ClassMethod = 1 << 17; 
    })(Tools.FncFlags||(Tools.FncFlags={}));
    var FncFlags = Tools.FncFlags;

    (function(TypeFlags) {
        TypeFlags._map = []; 
        TypeFlags.None = 0; 
        TypeFlags.HasImplementation = 1; 
        TypeFlags.HasSelfReference = 1 << 1; 
        TypeFlags.MergeResult = 1 << 2; 
        TypeFlags.IsEnum = 1 << 3; 
        TypeFlags.BuildingName = 1 << 4; 
        TypeFlags.HasBaseType = 1 << 5; 
        TypeFlags.HasBaseTypeOfObject = 1 << 6; 
    })(Tools.TypeFlags||(Tools.TypeFlags={}));
    var TypeFlags = Tools.TypeFlags;

    (function(CodeGenTarget) {
        CodeGenTarget._map = []; 
        CodeGenTarget.ES3 = 0; 
        CodeGenTarget.ES5 = 1; 
        CodeGenTarget.ES6 = 1 << 1; 
    })(Tools.CodeGenTarget||(Tools.CodeGenTarget={}));
    var CodeGenTarget = Tools.CodeGenTarget;

    (function(ModuleGenTarget) {
        ModuleGenTarget._map = []; 
        ModuleGenTarget.Synchronous = 0; 
        ModuleGenTarget.Asynchronous = 1; 
        ModuleGenTarget.Local = 1 << 1; 
    })(Tools.ModuleGenTarget||(Tools.ModuleGenTarget={}));
    var ModuleGenTarget = Tools.ModuleGenTarget;

    Tools.codeGenTarget = CodeGenTarget.ES5; 
    Tools.moduleGenTarget = ModuleGenTarget.Asynchronous; 
    Tools.optimizeModuleCodeGen = true; 
    function flagsToString(e, flags) {
        var builder = ""; 
        for(var i = 1; i < (1 << 31); i = i << 1) {
            if((flags & i) != 0) {
                for(var k in e) {
                    if(e[k] == i) {
                        if(builder.length > 0) {
                            builder += "|"; 
                        }
                        builder += k; 
                        break;
                    }
                }
            }
        }
        return builder; 
    }
    Tools.flagsToString = flagsToString;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    (function(NodeType) {
        NodeType._map = []; 
        NodeType._map[0] = "None"; 
        NodeType.None = 0; 
        NodeType._map[1] = "Empty"; 
        NodeType.Empty = 1; 
        NodeType._map[2] = "EmptyExpr"; 
        NodeType.EmptyExpr = 2; 
        NodeType._map[3] = "True"; 
        NodeType.True = 3; 
        NodeType._map[4] = "False"; 
        NodeType.False = 4; 
        NodeType._map[5] = "This"; 
        NodeType.This = 5; 
        NodeType._map[6] = "Self"; 
        NodeType.Self = 6; 
        NodeType._map[7] = "Super"; 
        NodeType.Super = 7; 
        NodeType._map[8] = "QString"; 
        NodeType.QString = 8; 
        NodeType._map[9] = "Regex"; 
        NodeType.Regex = 9; 
        NodeType._map[10] = "Null"; 
        NodeType.Null = 10; 
        NodeType._map[11] = "ArrayLit"; 
        NodeType.ArrayLit = 11; 
        NodeType._map[12] = "ObjectLit"; 
        NodeType.ObjectLit = 12; 
        NodeType._map[13] = "Void"; 
        NodeType.Void = 13; 
        NodeType._map[14] = "Comma"; 
        NodeType.Comma = 14; 
        NodeType._map[15] = "Pos"; 
        NodeType.Pos = 15; 
        NodeType._map[16] = "Neg"; 
        NodeType.Neg = 16; 
        NodeType._map[17] = "Delete"; 
        NodeType.Delete = 17; 
        NodeType._map[18] = "Await"; 
        NodeType.Await = 18; 
        NodeType._map[19] = "In"; 
        NodeType.In = 19; 
        NodeType._map[20] = "Dot"; 
        NodeType.Dot = 20; 
        NodeType._map[21] = "From"; 
        NodeType.From = 21; 
        NodeType._map[22] = "Is"; 
        NodeType.Is = 22; 
        NodeType._map[23] = "InstOf"; 
        NodeType.InstOf = 23; 
        NodeType._map[24] = "Typeof"; 
        NodeType.Typeof = 24; 
        NodeType._map[25] = "NumberLit"; 
        NodeType.NumberLit = 25; 
        NodeType._map[26] = "Name"; 
        NodeType.Name = 26; 
        NodeType._map[27] = "TypeRef"; 
        NodeType.TypeRef = 27; 
        NodeType._map[28] = "Index"; 
        NodeType.Index = 28; 
        NodeType._map[29] = "Call"; 
        NodeType.Call = 29; 
        NodeType._map[30] = "New"; 
        NodeType.New = 30; 
        NodeType._map[31] = "Asg"; 
        NodeType.Asg = 31; 
        NodeType._map[32] = "AsgAdd"; 
        NodeType.AsgAdd = 32; 
        NodeType._map[33] = "AsgSub"; 
        NodeType.AsgSub = 33; 
        NodeType._map[34] = "AsgDiv"; 
        NodeType.AsgDiv = 34; 
        NodeType._map[35] = "AsgMul"; 
        NodeType.AsgMul = 35; 
        NodeType._map[36] = "AsgMod"; 
        NodeType.AsgMod = 36; 
        NodeType._map[37] = "AsgAnd"; 
        NodeType.AsgAnd = 37; 
        NodeType._map[38] = "AsgXor"; 
        NodeType.AsgXor = 38; 
        NodeType._map[39] = "AsgOr"; 
        NodeType.AsgOr = 39; 
        NodeType._map[40] = "AsgLsh"; 
        NodeType.AsgLsh = 40; 
        NodeType._map[41] = "AsgRsh"; 
        NodeType.AsgRsh = 41; 
        NodeType._map[42] = "AsgRs2"; 
        NodeType.AsgRs2 = 42; 
        NodeType._map[43] = "QMark"; 
        NodeType.QMark = 43; 
        NodeType._map[44] = "LogOr"; 
        NodeType.LogOr = 44; 
        NodeType._map[45] = "LogAnd"; 
        NodeType.LogAnd = 45; 
        NodeType._map[46] = "Or"; 
        NodeType.Or = 46; 
        NodeType._map[47] = "Xor"; 
        NodeType.Xor = 47; 
        NodeType._map[48] = "And"; 
        NodeType.And = 48; 
        NodeType._map[49] = "Eq"; 
        NodeType.Eq = 49; 
        NodeType._map[50] = "Ne"; 
        NodeType.Ne = 50; 
        NodeType._map[51] = "Eqv"; 
        NodeType.Eqv = 51; 
        NodeType._map[52] = "NEqv"; 
        NodeType.NEqv = 52; 
        NodeType._map[53] = "Lt"; 
        NodeType.Lt = 53; 
        NodeType._map[54] = "Le"; 
        NodeType.Le = 54; 
        NodeType._map[55] = "Gt"; 
        NodeType.Gt = 55; 
        NodeType._map[56] = "Ge"; 
        NodeType.Ge = 56; 
        NodeType._map[57] = "Add"; 
        NodeType.Add = 57; 
        NodeType._map[58] = "Sub"; 
        NodeType.Sub = 58; 
        NodeType._map[59] = "Mul"; 
        NodeType.Mul = 59; 
        NodeType._map[60] = "Div"; 
        NodeType.Div = 60; 
        NodeType._map[61] = "Mod"; 
        NodeType.Mod = 61; 
        NodeType._map[62] = "Lsh"; 
        NodeType.Lsh = 62; 
        NodeType._map[63] = "Rsh"; 
        NodeType.Rsh = 63; 
        NodeType._map[64] = "Rs2"; 
        NodeType.Rs2 = 64; 
        NodeType._map[65] = "Not"; 
        NodeType.Not = 65; 
        NodeType._map[66] = "LogNot"; 
        NodeType.LogNot = 66; 
        NodeType._map[67] = "IncPre"; 
        NodeType.IncPre = 67; 
        NodeType._map[68] = "DecPre"; 
        NodeType.DecPre = 68; 
        NodeType._map[69] = "IncPost"; 
        NodeType.IncPost = 69; 
        NodeType._map[70] = "DecPost"; 
        NodeType.DecPost = 70; 
        NodeType._map[71] = "Cast"; 
        NodeType.Cast = 71; 
        NodeType._map[72] = "FuncDecl"; 
        NodeType.FuncDecl = 72; 
        NodeType._map[73] = "Member"; 
        NodeType.Member = 73; 
        NodeType._map[74] = "VarDecl"; 
        NodeType.VarDecl = 74; 
        NodeType._map[75] = "ArgDecl"; 
        NodeType.ArgDecl = 75; 
        NodeType._map[76] = "Return"; 
        NodeType.Return = 76; 
        NodeType._map[77] = "Break"; 
        NodeType.Break = 77; 
        NodeType._map[78] = "Continue"; 
        NodeType.Continue = 78; 
        NodeType._map[79] = "Throw"; 
        NodeType.Throw = 79; 
        NodeType._map[80] = "For"; 
        NodeType.For = 80; 
        NodeType._map[81] = "ForIn"; 
        NodeType.ForIn = 81; 
        NodeType._map[82] = "If"; 
        NodeType.If = 82; 
        NodeType._map[83] = "While"; 
        NodeType.While = 83; 
        NodeType._map[84] = "DoWhile"; 
        NodeType.DoWhile = 84; 
        NodeType._map[85] = "Block"; 
        NodeType.Block = 85; 
        NodeType._map[86] = "Case"; 
        NodeType.Case = 86; 
        NodeType._map[87] = "Switch"; 
        NodeType.Switch = 87; 
        NodeType._map[88] = "Try"; 
        NodeType.Try = 88; 
        NodeType._map[89] = "TryCatch"; 
        NodeType.TryCatch = 89; 
        NodeType._map[90] = "TryFinally"; 
        NodeType.TryFinally = 90; 
        NodeType._map[91] = "Finally"; 
        NodeType.Finally = 91; 
        NodeType._map[92] = "Catch"; 
        NodeType.Catch = 92; 
        NodeType._map[93] = "List"; 
        NodeType.List = 93; 
        NodeType._map[94] = "Script"; 
        NodeType.Script = 94; 
        NodeType._map[95] = "Class"; 
        NodeType.Class = 95; 
        NodeType._map[96] = "ES6Class"; 
        NodeType.ES6Class = 96; 
        NodeType._map[97] = "Interface"; 
        NodeType.Interface = 97; 
        NodeType._map[98] = "Module"; 
        NodeType.Module = 98; 
        NodeType._map[99] = "Import"; 
        NodeType.Import = 99; 
        NodeType._map[100] = "With"; 
        NodeType.With = 100; 
        NodeType._map[101] = "Label"; 
        NodeType.Label = 101; 
        NodeType._map[102] = "LabeledStatement"; 
        NodeType.LabeledStatement = 102; 
        NodeType._map[103] = "EBStart"; 
        NodeType.EBStart = 103; 
        NodeType._map[104] = "GotoEB"; 
        NodeType.GotoEB = 104; 
        NodeType._map[105] = "EndCode"; 
        NodeType.EndCode = 105; 
        NodeType._map[106] = "Error"; 
        NodeType.Error = 106; 
        NodeType._map[107] = "Comment"; 
        NodeType.Comment = 107; 
        NodeType.GeneralNode = NodeType.FuncDecl; 
        NodeType.LastAsg = NodeType.AsgRs2; 
    })(Tools.NodeType||(Tools.NodeType={}));
    var NodeType = Tools.NodeType;

})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    Tools.HashSmallSize = 7; 
    Tools.HashMediumSize = 16; 
    Tools.HashLargeSize = 128; 
    var StringHashEntry = (function () {
        function StringHashEntry(key, data) {
            this.key = key;
            this.data = data;
            this.next = null; 
        }
        return StringHashEntry;
    })();
    Tools.StringHashEntry = StringHashEntry;
    
    function StringHashFn(key) {
        var val = 0; 
        for(var i = 0; i < key.length; i++) {
            val = (val << i) ^ key.charCodeAt(i); 
        }
        if(val > 0) {
            return val; 
        } else  {
            return -val; 
        }
    }
    Tools.StringHashFn = StringHashFn;
    var StringHashTableOld = (function () {
        function StringHashTableOld(size) {
            this.size = size;
            this.itemCount = 0; 
            this.table = new Array(); 
            for(var j = 0; j < this.size; j++) {
                this.table[j] = null; 
            }
        }
        StringHashTableOld.prototype.getAllKeys = function() {
            var result = []; 
            for(var i = 0; i < this.size; i++) {
                for(var current = this.table[i]; current != null; current = current.next) {
                    result[result.length] = current.key; 
                }
            }
            return result; 
        };
        StringHashTableOld.prototype.add = function(key, data) {
            var current; 
            var entry = new StringHashEntry(key, data); 
            var val = StringHashFn(key); 
            val = val % this.size; 
            for(current = this.table[val]; current != null; current = current.next) {
                if(key == current.key) {
                    return false; 
                }
            }
            entry.next = this.table[val]; 
            this.table[val] = entry; 
            this.itemCount++; 
            return true; 
        };
        StringHashTableOld.prototype.map = function(fn, context) {
            for(var i = 0; i < this.size; i++) {
                for(var current = this.table[i]; current != null; current = current.next) {
                    fn(current.key, current.data, context); 
                }
            }
        };
        StringHashTableOld.prototype.census = function() {
            var current; 
            var pop = 0; 
            for(var i = 0; i < this.size; i++) {
                for(current = this.table[i]; current != null; current = current.next) {
                    pop++; 
                }
            }
            return pop; 
        };
        StringHashTableOld.prototype.every = function(fn, context) {
            for(var i = 0; i < this.size; i++) {
                for(var current = this.table[i]; current != null; current = current.next) {
                    if(!fn(current.key, current.data, context)) {
                        return false; 
                    }
                }
            }
            return true; 
        };
        StringHashTableOld.prototype.some = function(fn, context) {
            for(var i = 0; i < this.size; i++) {
                for(var current = this.table[i]; current != null; current = current.next) {
                    if(fn(current.key, current.data, context)) {
                        return true; 
                    }
                }
            }
            return false; 
        };
        StringHashTableOld.prototype.count = function() {
            return this.itemCount; 
        };
        StringHashTableOld.prototype.lookup = function(key) {
            var current; 
            var val = StringHashFn(key); 
            val = val % this.size; 
            for(current = this.table[val]; current != null; current = current.next) {
                if(key == current.key) {
                    return (current.data); 
                }
            }
            return (null); 
        };
        return StringHashTableOld;
    })();
    Tools.StringHashTableOld = StringHashTableOld;
    
    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.constructor = undefined; 
            this.prototype = undefined; 
            this.toString = undefined; 
            this.toLocaleString = undefined; 
            this.valueOf = undefined; 
            this.hasOwnProperty = undefined; 
            this.propertyIsEnumerable = undefined; 
            this.isPrototypeOf = undefined; 
        }
        return BlockIntrinsics;
    })();
    Tools.BlockIntrinsics = BlockIntrinsics;
    
    var StringHashTable = (function () {
        function StringHashTable() {
            this.itemCount = 0; 
            this.table = (new BlockIntrinsics()); 
        }
        StringHashTable.prototype.getAllKeys = function() {
            var result = []; 
            for(var k in this.table) {
                if(this.table[k] != undefined) {
                    result[result.length] = k; 
                }
            }
            return result; 
        };
        StringHashTable.prototype.add = function(key, data) {
            if(this.table[key] != undefined) {
                return false; 
            }
            this.table[key] = data; 
            this.itemCount++; 
            return true; 
        };
        StringHashTable.prototype.addOrUpdate = function(key, data) {
            if(this.table[key] != undefined) {
                this.table[key] = data; 
                return false; 
            }
            this.table[key] = data; 
            this.itemCount++; 
            return true; 
        };
        StringHashTable.prototype.map = function(fn, context) {
            for(var k in this.table) {
                var data = this.table[k]; 
                if(data != undefined) {
                    fn(k, this.table[k], context); 
                }
            }
        };
        StringHashTable.prototype.every = function(fn, context) {
            for(var k in this.table) {
                var data = this.table[k]; 
                if(data != undefined) {
                    if(!fn(k, this.table[k], context)) {
                        return false; 
                    }
                }
            }
            return true; 
        };
        StringHashTable.prototype.some = function(fn, context) {
            for(var k in this.table) {
                var data = this.table[k]; 
                if(data != undefined) {
                    if(fn(k, this.table[k], context)) {
                        return true; 
                    }
                }
            }
            return false; 
        };
        StringHashTable.prototype.count = function() {
            return this.itemCount; 
        };
        StringHashTable.prototype.lookup = function(key) {
            var data = this.table[key]; 
            if(data != undefined) {
                return data; 
            } else  {
                return (null); 
            }
        };
        return StringHashTable;
    })();
    Tools.StringHashTable = StringHashTable;
    
    var DualStringHashTable = (function () {
        function DualStringHashTable(primaryTable, secondaryTable) {
            this.primaryTable = primaryTable;
            this.secondaryTable = secondaryTable;
            this.insertPrimary = true; 
        }
        DualStringHashTable.prototype.getAllKeys = function() {
            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys()); 
        };
        DualStringHashTable.prototype.add = function(key, data) {
            if(this.insertPrimary) {
                return this.primaryTable.add(key, data); 
            } else  {
                return this.secondaryTable.add(key, data); 
            }
        };
        DualStringHashTable.prototype.addOrUpdate = function(key, data) {
            if(this.insertPrimary) {
                return this.primaryTable.addOrUpdate(key, data); 
            } else  {
                return this.secondaryTable.addOrUpdate(key, data); 
            }
        };
        DualStringHashTable.prototype.map = function(fn, context) {
            this.primaryTable.map(fn, context); 
            this.secondaryTable.map(fn, context); 
        };
        DualStringHashTable.prototype.every = function(fn, context) {
            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context); 
        };
        DualStringHashTable.prototype.some = function(fn, context) {
            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context); 
        };
        DualStringHashTable.prototype.count = function() {
            return this.primaryTable.count() + this.secondaryTable.count(); 
        };
        DualStringHashTable.prototype.lookup = function(key) {
            var data = this.primaryTable.lookup(key); 
            if(data != undefined) {
                return data; 
            } else  {
                return this.secondaryTable.lookup(key); 
            }
        };
        return DualStringHashTable;
    })();
    Tools.DualStringHashTable = DualStringHashTable;
    
    function numberHashFn(key) {
        var c2 = 668265261; 
        key = (key ^ 61) ^ (key >>> 16); 
        key = key + (key << 3); 
        key = key ^ (key >>> 4); 
        key = key * c2; 
        key = key ^ (key >>> 15); 
        return key; 
    }
    Tools.numberHashFn = numberHashFn;
    function combineHashes(key1, key2) {
        return key2 ^ ((key1 >> 5) + key1); 
    }
    Tools.combineHashes = combineHashes;
    var HashEntry = (function () {
        function HashEntry(key, data) {
            this.key = key;
            this.data = data;
            this.next = null; 
        }
        return HashEntry;
    })();
    Tools.HashEntry = HashEntry;
    
    var HashTable = (function () {
        function HashTable(size, hashFn, equalsFn) {
            this.size = size;
            this.hashFn = hashFn;
            this.equalsFn = equalsFn;
            this.itemCount = 0; 
            this.table = new Array(); 
            for(var i = 0; i < this.size; i++) {
                this.table[i] = null; 
            }
        }
        HashTable.prototype.add = function(key, data) {
            var current; 
            var entry = new HashEntry(key, data); 
            var val = this.hashFn(key); 
            val = val % this.size; 
            for(current = this.table[val]; current != null; current = current.next) {
                if(this.equalsFn(key, current.key)) {
                    return false; 
                }
            }
            entry.next = this.table[val]; 
            this.table[val] = entry; 
            this.itemCount++; 
            return true; 
        };
        HashTable.prototype.remove = function(key) {
            var current; 
            var val = this.hashFn(key); 
            val = val % this.size; 
            var result = null; 
            var prevEntry = null; 
            for(current = this.table[val]; current != null; current = current.next) {
                if(this.equalsFn(key, current.key)) {
                    result = current.data; 
                    this.itemCount--; 
                    if(prevEntry != null) {
                        prevEntry.next = current.next; 
                    } else  {
                        this.table[val] = current.next; 
                    }
                    break;
                }
                prevEntry = current; 
            }
            return result; 
        };
        HashTable.prototype.count = function() {
            return this.itemCount; 
        };
        HashTable.prototype.lookup = function(key) {
            var current; 
            var val = this.hashFn(key); 
            val = val % this.size; 
            for(current = this.table[val]; current != null; current = current.next) {
                if(this.equalsFn(key, current.key)) {
                    return (current.data); 
                }
            }
            return (null); 
        };
        return HashTable;
    })();
    Tools.HashTable = HashTable;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var BaseWalkContext = (function () {
        function BaseWalkContext() {
            this.goChildren = true; 
            this.goNextSibling = true; 
            this.reverseSiblings = false; 
        }
        return BaseWalkContext;
    })();
    Tools.BaseWalkContext = BaseWalkContext;
    
})(Tools||(Tools={}));

if (!(this._inheritsFrom)) {
    this._inheritsFrom=function(childCtor, parentCtor) {
        function Beget() { this.constructor = childCtor; }
        childCtor._super = parentCtor.prototype;
        Beget.prototype = parentCtor.prototype;
        childCtor.prototype = new Beget();
    }
}
var _inheritsFrom = this._inheritsFrom;
var Tools;
(function(Tools) {
    var AST = (function () {
        function AST(nodeType) {
            this.nodeType = nodeType;
            this.type = null; 
            this.flags = Tools.ASTFlags.Writeable; 
            this.minChar = -1; 
            this.limChar = -1; 
            this.passCreated = Tools.CompilerDiagnostics.analysisPass; 
            this.preComments = null; 
            this.postComments = null; 
            this.isParenthesized = false; 
        }
        AST.prototype.isStatementOrExpression = function() {
            return false; 
        };
        AST.prototype.isCompoundStatement = function() {
            return false; 
        };
        AST.prototype.isLeaf = function() {
            return this.isStatementOrExpression() && (!this.isCompoundStatement()); 
        };
        AST.prototype.typeCheck = function(typeFlow) {
            switch(this.nodeType) {
                case Tools.NodeType.Error: {

                }
                case Tools.NodeType.EmptyExpr: {
                    this.type = typeFlow.anyType; 
                    break;

                }
                case Tools.NodeType.Self: {
                    return typeFlow.typeCheckSelf(this); 

                }
                case Tools.NodeType.This: {
                    return typeFlow.typeCheckThis(this); 

                }
                case Tools.NodeType.Null: {
                    this.type = typeFlow.nullType; 
                    break;

                }
                case Tools.NodeType.False: {

                }
                case Tools.NodeType.True: {
                    this.type = typeFlow.booleanType; 
                    break;

                }
                case Tools.NodeType.Super: {
                    return typeFlow.typeCheckSuper(this); 

                }
                case Tools.NodeType.EndCode: {

                }
                case Tools.NodeType.Empty: {

                }
                case Tools.NodeType.Void: {
                    this.type = typeFlow.voidType; 
                    break;

                }
                default: {
                    throw new Error("please implement in derived class");

                }
            }
            return this; 
        };
        AST.prototype.emitType = function(emitter) {
        };
        AST.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            switch(this.nodeType) {
                case Tools.NodeType.This: {
                    if((emitter.thisFnc != null) && (Tools.hasFlag(emitter.thisFnc.fncFlags, Tools.FncFlags.IsFatArrowFunction))) {
                        emitter.writeToOutput("_self"); 
                    } else  {
                        emitter.writeToOutput("this"); 
                    }
                    break;

                }
                case Tools.NodeType.Self: {
                    if((emitter.thisFnc != null) && (!emitter.thisFnc.isMethod())) {
                        emitter.writeToOutput("_self"); 
                    } else  {
                        emitter.writeToOutput("this"); 
                    }
                    break;

                }
                case Tools.NodeType.Null: {
                    emitter.writeToOutput("null"); 
                    break;

                }
                case Tools.NodeType.False: {
                    emitter.writeToOutput("false"); 
                    break;

                }
                case Tools.NodeType.True: {
                    emitter.writeToOutput("true"); 
                    break;

                }
                case Tools.NodeType.Super: {
                    emitter.emitSuperReference(); 

                }
                case Tools.NodeType.EndCode: {
                    break;

                }
                case Tools.NodeType.Error: {

                }
                case Tools.NodeType.EmptyExpr: {
                    break;

                }
                case Tools.NodeType.Empty: {
                    emitter.writeToOutput(";"); 
                    break;

                }
                case Tools.NodeType.Void: {
                    emitter.writeToOutput("void "); 
                    break;

                }
                default: {
                    throw new Error("please implement in derived class");

                }
            }
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        AST.prototype.print = function(context) {
            context.startLine(); 
            var lineCol = {
                line: -1,
                col: -1
            }; 
            var limLineCol = {
                line: -1,
                col: -1
            }; 
            if(context.parser !== null) {
                context.parser.getSourceLineCol(lineCol, this.minChar); 
                context.parser.getSourceLineCol(limLineCol, this.limChar); 
                context.write((((((((("(" + lineCol.line) + ",") + lineCol.col) + ")--") + "(") + limLineCol.line) + ",") + limLineCol.col) + "): "); 
            }
            var lab = this.printLabel(); 
            if(Tools.hasFlag(this.flags, Tools.ASTFlags.Error)) {
                lab += " (Error)"; 
            }
            context.writeLine(lab); 
        };
        AST.prototype.printLabel = function() {
            if(Tools.nodeTypeTable[this.nodeType] !== undefined) {
                return Tools.nodeTypeTable[this.nodeType]; 
            } else  {
                return (Tools.NodeType)._map[this.nodeType]; 
            }
        };
        AST.prototype.addToControlFlow = function(context) {
            context.goChildren = false; 
            context.addContent(this); 
        };
        AST.prototype.netFreeUses = function(container, freeUses) {
        };
        AST.prototype.treeViewLabel = function() {
            return (Tools.NodeType)._map[this.nodeType]; 
        };
        AST.prototype.walkChildren = function(pre, post, parent, context) {
        };
        AST.prototype.walk = function(pre, post, parent, context) {
            var ast = pre(this, parent, context); 
            if(ast === undefined) {
                ast = this; 
            }
            if(context.goChildren) {
                var svGoSib = context.goNextSibling; 
                context.goNextSibling = true; 
                ast.walkChildren(pre, post, this, context); 
                context.goNextSibling = svGoSib; 
            } else  {
                context.goChildren = true; 
            }
            if(post != null) {
                var postAst = post(ast, parent, context); 
                if(postAst === undefined) {
                    postAst = ast; 
                }
                return postAst; 
            } else  {
                return ast; 
            }
        };
        return AST;
    })();
    Tools.AST = AST;
    
    var IncompleteAST = (function () {
        _inheritsFrom(IncompleteAST, AST);
        function IncompleteAST(min, lim) {
            IncompleteAST._super.constructor.call(this, Tools.NodeType.Error);
            this.minChar = min; 
            this.limChar = lim; 
        }
        return IncompleteAST;
    })();
    Tools.IncompleteAST = IncompleteAST;
    
    var ASTList = (function () {
        _inheritsFrom(ASTList, AST);
        function ASTList() {
            ASTList._super.constructor.call(this, Tools.NodeType.List);
            this.enclosingScope = null; 
            this.members = new Array(); 
        }
        ASTList.prototype.addToControlFlow = function(context) {
            var len = this.members.length; 
            for(var i = 0; i < len; i++) {
                if(context.noContinuation) {
                    context.addUnreachable(this.members[i]); 
                    break;
                } else  {
                    this.members[i] = this.members[i].walk(context.pre, null, this, context); 
                }
            }
            context.goChildren = false; 
        };
        ASTList.prototype.append = function(ast) {
            this.members[this.members.length] = ast; 
            return this; 
        };
        ASTList.prototype.appendAll = function(ast) {
            if(ast.nodeType == Tools.NodeType.List) {
                var list = ast; 
                for(var i = 0, len = list.members.length; i < len; i++) {
                    this.append(list.members[i]); 
                }
            } else  {
                this.append(ast); 
            }
            return this; 
        };
        ASTList.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitJavascriptList(this, null, Tools.TokenID.SColon, startLine, false, false); 
        };
        ASTList.prototype.typeCheck = function(typeFlow) {
            var len = this.members.length; 
            typeFlow.nestingLevel++; 
            for(var i = 0; i < len; i++) {
                if(this.members[i] != null) {
                    this.members[i] = this.members[i].typeCheck(typeFlow); 
                }
            }
            typeFlow.nestingLevel--; 
            return this; 
        };
        ASTList.prototype.walkChildren = function(pre, post, parent, context) {
            var len = this.members.length; 
            if(context.reverseSiblings) {
                for(var i = len - 1; i >= 0; i--) {
                    if(context.goNextSibling) {
                        this.members[i] = this.members[i].walk(pre, post, this, context); 
                    }
                }
            } else  {
                for(var i = 0; i < len; i++) {
                    if(context.goNextSibling) {
                        this.members[i] = this.members[i].walk(pre, post, this, context); 
                    }
                }
            }
        };
        return ASTList;
    })();
    Tools.ASTList = ASTList;
    
    var Identifier = (function () {
        _inheritsFrom(Identifier, AST);
        function Identifier(text) {
            this.text = text;
            Identifier._super.constructor.call(this, Tools.NodeType.Name);
            this.sym = null; 
            this.cloId = -1; 
        }
        Identifier.prototype.isMissing = function() {
            return false; 
        };
        Identifier.prototype.isLeaf = function() {
            return true; 
        };
        Identifier.prototype.treeViewLabel = function() {
            return "id: " + this.text; 
        };
        Identifier.prototype.printLabel = function() {
            if(this.text != null) {
                return "id: " + this.text; 
            } else  {
                return "name node"; 
            }
        };
        Identifier.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckName(this); 
        };
        Identifier.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitJavascriptName(this, true); 
        };
        return Identifier;
    })();
    Tools.Identifier = Identifier;
    
    var MissingIdentifier = (function () {
        _inheritsFrom(MissingIdentifier, Identifier);
        function MissingIdentifier() {
            MissingIdentifier._super.constructor.call(this, "__missing");
        }
        MissingIdentifier.prototype.isMissing = function() {
            return true; 
        };
        MissingIdentifier.prototype.emit = function(emitter, tokenId, startLine) {
        };
        return MissingIdentifier;
    })();
    Tools.MissingIdentifier = MissingIdentifier;
    
    var Label = (function () {
        _inheritsFrom(Label, AST);
        function Label(id) {
            this.id = id;
            Label._super.constructor.call(this, Tools.NodeType.Label);
        }
        Label.prototype.printLabel = function() {
            return this.id.text + ":"; 
        };
        Label.prototype.typeCheck = function(typeFlow) {
            this.type = typeFlow.voidType; 
            return this; 
        };
        Label.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.writeLineToOutput(this.id.text + ":"); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        return Label;
    })();
    Tools.Label = Label;
    
    var UnaryExpression = (function () {
        _inheritsFrom(UnaryExpression, AST);
        function UnaryExpression(nty, operand) {
            this.nty = nty;
            this.operand = operand;
            UnaryExpression._super.constructor.call(this, this.nty);
            this.acceptTargetType = false; 
            this.castTerm = null; 
        }
        UnaryExpression.prototype.isStatementOrExpression = function() {
            return true; 
        };
        UnaryExpression.prototype.addToControlFlow = function(context) {
            UnaryExpression._super.addToControlFlow.call(this, context); 
            if(this.nodeType == Tools.NodeType.Throw) {
                context.returnStmt(); 
            }
        };
        UnaryExpression.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.castTerm != null) {
                this.castTerm = this.castTerm.walk(pre, post, this, context); 
            }
            if(this.operand != null) {
                this.operand = this.operand.walk(pre, post, this, context); 
            }
        };
        UnaryExpression.prototype.typeCheck = function(typeFlow) {
            switch(this.nty) {
                case Tools.NodeType.Not: {
                    return typeFlow.typeCheckBitNot(this); 

                }
                case Tools.NodeType.LogNot: {
                    return typeFlow.typeCheckLogNot(this); 

                }
                case Tools.NodeType.Pos: {

                }
                case Tools.NodeType.Neg: {
                    return typeFlow.typeCheckUnaryNumberOperator(this); 

                }
                case Tools.NodeType.IncPost: {

                }
                case Tools.NodeType.IncPre: {

                }
                case Tools.NodeType.DecPost: {

                }
                case Tools.NodeType.DecPre: {
                    return typeFlow.typeCheckIncOrDec(this); 

                }
                case Tools.NodeType.ArrayLit: {
                    typeFlow.typeCheckArrayLit(this); 
                    return this; 

                }
                case Tools.NodeType.ObjectLit: {
                    typeFlow.typeCheckObjectLit(this); 
                    return this; 

                }
                case Tools.NodeType.Throw: {
                    this.operand = typeFlow.typeCheck(this.operand); 
                    this.type = typeFlow.voidType; 
                    return this; 

                }
                case Tools.NodeType.Typeof: {
                    this.operand = typeFlow.typeCheck(this.operand); 
                    this.type = typeFlow.stringType; 
                    return this; 

                }
                case Tools.NodeType.Await: {
                    this.operand = typeFlow.typeCheck(this.operand); 
                    this.type = this.operand.type; 
                    return this; 

                }
                case Tools.NodeType.Delete: {
                    this.operand = typeFlow.typeCheck(this.operand); 
                    this.type = typeFlow.voidType; 
                    break;

                }
                case Tools.NodeType.Cast: {
                    this.castTerm = typeFlow.typeCheck(this.castTerm); 
                    var applyTargetType = !this.operand.isParenthesized; 
                    typeFlow.checker.typeCheckWithTargetType(this.castTerm.type, applyTargetType, this.operand); 
                    var castNode = typeFlow.castWithCoercion(this.operand, this.castTerm.type, applyTargetType); 
                    this.type = castNode.type; 
                    return this; 

                }
                case Tools.NodeType.Void: {
                    this.operand = typeFlow.typeCheck(this.operand); 
                    this.type = typeFlow.anyType; 
                    break;

                }
                default: {
                    throw new Error("please implement in derived class");

                }
            }
            return this; 
        };
        UnaryExpression.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            switch(this.nty) {
                case Tools.NodeType.IncPost: {
                    emitter.emitJavascript(this.operand, Tools.TokenID.Inc, false); 
                    emitter.writeToOutput("++"); 
                    break;

                }
                case Tools.NodeType.LogNot: {
                    emitter.writeToOutput("!"); 
                    emitter.emitJavascript(this.operand, Tools.TokenID.Bang, false); 
                    break;

                }
                case Tools.NodeType.DecPost: {
                    emitter.emitJavascript(this.operand, Tools.TokenID.Dec, false); 
                    emitter.writeToOutput("--"); 
                    break;

                }
                case Tools.NodeType.ObjectLit: {
                    emitter.emitObjectLiteral(this.operand); 
                    break;

                }
                case Tools.NodeType.ArrayLit: {
                    emitter.emitArrayLiteral(this.operand); 
                    break;

                }
                case Tools.NodeType.Not: {
                    emitter.writeToOutput("~"); 
                    emitter.emitJavascript(this.operand, Tools.TokenID.Tilde, false); 
                    break;

                }
                case Tools.NodeType.Neg: {
                    emitter.writeToOutput("-"); 
                    if(this.operand.nodeType == Tools.NodeType.Neg) {
                        this.operand.isParenthesized = true; 
                    }
                    emitter.emitJavascript(this.operand, Tools.TokenID.Sub, false); 
                    break;

                }
                case Tools.NodeType.Pos: {
                    emitter.writeToOutput("+"); 
                    if(this.operand.nodeType == Tools.NodeType.Pos) {
                        this.operand.isParenthesized = true; 
                    }
                    emitter.emitJavascript(this.operand, Tools.TokenID.Add, false); 
                    break;

                }
                case Tools.NodeType.IncPre: {
                    emitter.writeToOutput("++"); 
                    emitter.emitJavascript(this.operand, Tools.TokenID.Inc, false); 
                    break;

                }
                case Tools.NodeType.DecPre: {
                    emitter.writeToOutput("--"); 
                    emitter.emitJavascript(this.operand, Tools.TokenID.Dec, false); 
                    break;

                }
                case Tools.NodeType.Throw: {
                    emitter.writeToOutput("throw "); 
                    emitter.emitJavascript(this.operand, Tools.TokenID.Tilde, false); 
                    emitter.writeToOutput(";"); 
                    break;

                }
                case Tools.NodeType.Typeof: {
                    emitter.writeToOutput("typeof "); 
                    emitter.emitJavascript(this.operand, Tools.TokenID.Tilde, false); 
                    break;

                }
                case Tools.NodeType.Await: {
                    emitter.emitJavascript(this.operand, Tools.TokenID.Tilde, false); 
                    break;

                }
                case Tools.NodeType.Delete: {
                    emitter.writeToOutput("delete "); 
                    emitter.emitJavascript(this.operand, Tools.TokenID.Tilde, false); 
                    break;

                }
                case Tools.NodeType.Void: {
                    emitter.writeToOutput("void "); 
                    emitter.emitJavascript(this.operand, Tools.TokenID.Tilde, false); 
                    break;

                }
                case Tools.NodeType.Cast: {
                    emitter.emitJavascript(this.operand, Tools.TokenID.Tilde, false); 
                    break;

                }
                default: {
                    throw new Error("please implement in derived class");

                }
            }
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        return UnaryExpression;
    })();
    Tools.UnaryExpression = UnaryExpression;
    
    var CallExpression = (function () {
        _inheritsFrom(CallExpression, AST);
        function CallExpression(nty, target, args) {
            this.nty = nty;
            this.target = target;
            this.args = args;
            CallExpression._super.constructor.call(this, this.nty);
            this.minChar = this.target.minChar; 
            this.signature = null; 
        }
        CallExpression.prototype.isStatementOrExpression = function() {
            return true; 
        };
        CallExpression.prototype.typeCheck = function(typeFlow) {
            if(this.nty == Tools.NodeType.New) {
                return typeFlow.typeCheckNew(this); 
            } else  {
                return typeFlow.typeCheckCall(this); 
            }
        };
        CallExpression.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            if(this.nty == Tools.NodeType.New) {
                emitter.emitNew(this.target, this.args); 
            } else  {
                emitter.emitCall(this, this.target, this.args); 
            }
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        CallExpression.prototype.walkChildren = function(pre, post, parent, context) {
            if(!context.reverseSiblings) {
                this.target = this.target.walk(pre, post, this, context); 
            }
            if((this.args != null) && (context.goNextSibling)) {
                this.args.walk(pre, post, this, context); 
            }
            if((context.reverseSiblings) && (context.goNextSibling)) {
                this.target = this.target.walk(pre, post, this, context); 
            }
        };
        return CallExpression;
    })();
    Tools.CallExpression = CallExpression;
    
    var BinaryExpression = (function () {
        _inheritsFrom(BinaryExpression, AST);
        function BinaryExpression(nty, operand1, operand2) {
            this.nty = nty;
            this.operand1 = operand1;
            this.operand2 = operand2;
            BinaryExpression._super.constructor.call(this, this.nty);
        }
        BinaryExpression.prototype.isStatementOrExpression = function() {
            return true; 
        };
        BinaryExpression.prototype.walkChildren = function(pre, post, parent, context) {
            var visitOperand1 = this.operand1; 
            var visitOperand2 = this.operand2; 
            if(context.reverseSiblings) {
                visitOperand1 = this.operand2; 
                visitOperand2 = this.operand1; 
            }
            if(visitOperand1 != null) {
                visitOperand1 = visitOperand1.walk(pre, post, this, context); 
            }
            if((visitOperand2 != null) && (context.goNextSibling)) {
                visitOperand2 = visitOperand2.walk(pre, post, this, context); 
            }
        };
        BinaryExpression.prototype.typeCheck = function(typeFlow) {
            switch(this.nty) {
                case Tools.NodeType.Dot: {
                    return typeFlow.typeCheckDotOperator(this); 

                }
                case Tools.NodeType.Asg: {
                    return typeFlow.typeCheckAsgOperator(this); 

                }
                case Tools.NodeType.Add: {

                }
                case Tools.NodeType.Sub: {

                }
                case Tools.NodeType.Mul: {

                }
                case Tools.NodeType.Div: {

                }
                case Tools.NodeType.Mod: {

                }
                case Tools.NodeType.Or: {

                }
                case Tools.NodeType.And: {
                    return typeFlow.typeCheckArithmeticOperator(this, false); 

                }
                case Tools.NodeType.Xor: {
                    return typeFlow.typeCheckBitwiseOperator(this, false); 

                }
                case Tools.NodeType.Ne: {

                }
                case Tools.NodeType.Eq: {
                    var text; 
                    if(typeFlow.checker.styleSettings.eqeqeq) {
                        text = Tools.nodeTypeTable[this.nty]; 
                        typeFlow.checker.errorReporter.styleError(this, "use of " + text); 
                    } else  {
                        if(typeFlow.checker.styleSettings.eqnull) {
                            text = Tools.nodeTypeTable[this.nty]; 
                            if((this.operand2 !== null) && (this.operand2.nodeType == Tools.NodeType.Null)) {
                                typeFlow.checker.errorReporter.styleError(this, ("use of " + text) + " to compare with null"); 
                            }
                        }
                    }

                }
                case Tools.NodeType.Eqv: {

                }
                case Tools.NodeType.NEqv: {

                }
                case Tools.NodeType.Lt: {

                }
                case Tools.NodeType.Le: {

                }
                case Tools.NodeType.Ge: {

                }
                case Tools.NodeType.Gt: {
                    return typeFlow.typeCheckBooleanOperator(this); 

                }
                case Tools.NodeType.Index: {
                    return typeFlow.typeCheckIndex(this); 

                }
                case Tools.NodeType.Member: {
                    this.type = typeFlow.voidType; 
                    return this; 

                }
                case Tools.NodeType.LogOr: {
                    return typeFlow.typeCheckLogOr(this); 

                }
                case Tools.NodeType.LogAnd: {
                    return typeFlow.typeCheckLogAnd(this); 

                }
                case Tools.NodeType.AsgAdd: {

                }
                case Tools.NodeType.AsgSub: {

                }
                case Tools.NodeType.AsgMul: {

                }
                case Tools.NodeType.AsgDiv: {

                }
                case Tools.NodeType.AsgMod: {

                }
                case Tools.NodeType.AsgOr: {

                }
                case Tools.NodeType.AsgAnd: {
                    return typeFlow.typeCheckArithmeticOperator(this, true); 

                }
                case Tools.NodeType.AsgXor: {
                    return typeFlow.typeCheckBitwiseOperator(this, true); 

                }
                case Tools.NodeType.Lsh: {

                }
                case Tools.NodeType.Rsh: {

                }
                case Tools.NodeType.Rs2: {
                    return typeFlow.typeCheckShift(this, false); 

                }
                case Tools.NodeType.AsgLsh: {

                }
                case Tools.NodeType.AsgRsh: {

                }
                case Tools.NodeType.AsgRs2: {
                    return typeFlow.typeCheckShift(this, true); 

                }
                case Tools.NodeType.Comma: {
                    return typeFlow.typeCheckCommaOperator(this); 

                }
                case Tools.NodeType.InstOf: {
                    return typeFlow.typeCheckInstOf(this); 

                }
                case Tools.NodeType.In: {
                    return typeFlow.typeCheckInOperator(this); 

                }
                case Tools.NodeType.From: {
                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of 'from' keyword in binary expression"); 
                    break;

                }
                default: {
                    throw new Error("please implement in derived class");

                }
            }
            return this; 
        };
        BinaryExpression.prototype.emit = function(emitter, tokenId, startLine) {
            var binTokenId = Tools.nodeTypeToTokTable[this.nodeType]; 
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            if(binTokenId != undefined) {
                emitter.emitJavascript(this.operand1, binTokenId, false); 
                if(Tools.tokenTable[binTokenId].text == "instanceof") {
                    emitter.writeToOutput(" instanceof "); 
                } else  {
                    if(Tools.tokenTable[binTokenId].text == "in") {
                        emitter.writeToOutput(" in "); 
                    } else  {
                        emitter.writeToOutputTrimmable((" " + Tools.tokenTable[binTokenId].text) + " "); 
                    }
                }
                emitter.emitJavascript(this.operand2, binTokenId, false); 
            } else  {
                switch(this.nty) {
                    case Tools.NodeType.Dot: {
                        if(!emitter.tryEmitConstant(this)) {
                            emitter.emitJavascript(this.operand1, Tools.TokenID.Dot, false); 
                            emitter.writeToOutput("."); 
                            emitter.emitJavascriptName(this.operand2, false); 
                        }
                        break;

                    }
                    case Tools.NodeType.Index: {
                        emitter.emitIndex(this.operand1, this.operand2); 
                        break;

                    }
                    case Tools.NodeType.Member: {
                        if(this.operand2.nodeType == Tools.NodeType.FuncDecl && (this.operand2).isAccessor()) {
                            var funcDecl = this.operand2; 
                            if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.GetAccessor)) {
                                emitter.writeToOutput("get "); 
                            } else  {
                                emitter.writeToOutput("set "); 
                            }
                            emitter.emitJavascript(this.operand1, Tools.TokenID.Colon, false); 
                        } else  {
                            emitter.emitJavascript(this.operand1, Tools.TokenID.Colon, false); 
                            emitter.writeToOutputTrimmable(": "); 
                        }
                        emitter.emitJavascript(this.operand2, Tools.TokenID.Comma, false); 
                        break;

                    }
                    case Tools.NodeType.Comma: {
                        emitter.emitJavascript(this.operand1, Tools.TokenID.Comma, false); 
                        if(emitter.emitState.inObjectLiteral) {
                            emitter.writeLineToOutput(", "); 
                        } else  {
                            emitter.writeToOutput(","); 
                        }
                        emitter.emitJavascript(this.operand2, Tools.TokenID.Comma, false); 
                        break;

                    }
                    case Tools.NodeType.Is: {
                        throw new Error("should be de-sugared during type check");

                    }
                    default: {
                        throw new Error("please implement in derived class");

                    }
                }
            }
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        return BinaryExpression;
    })();
    Tools.BinaryExpression = BinaryExpression;
    
    var TrinaryExpression = (function () {
        _inheritsFrom(TrinaryExpression, AST);
        function TrinaryExpression(nty, operand1, operand2, operand3) {
            this.nty = nty;
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.operand3 = operand3;
            TrinaryExpression._super.constructor.call(this, this.nty);
        }
        TrinaryExpression.prototype.isStatementOrExpression = function() {
            return true; 
        };
        TrinaryExpression.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckQMark(this); 
        };
        TrinaryExpression.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.emitJavascript(this.operand1, Tools.TokenID.QMark, false); 
            emitter.writeToOutput(" ? "); 
            emitter.emitJavascript(this.operand2, Tools.TokenID.QMark, false); 
            emitter.writeToOutput(" : "); 
            emitter.emitJavascript(this.operand3, Tools.TokenID.QMark, false); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        TrinaryExpression.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.operand1 != null) {
                this.operand1 = this.operand1.walk(pre, post, this, context); 
            }
            if((this.operand2 != null) && (context.goNextSibling)) {
                this.operand2 = this.operand2.walk(pre, post, this, context); 
            }
            if((this.operand3 != null) && (context.goNextSibling)) {
                this.operand3 = this.operand3.walk(pre, post, this, context); 
            }
        };
        return TrinaryExpression;
    })();
    Tools.TrinaryExpression = TrinaryExpression;
    
    var NumberLiteral = (function () {
        _inheritsFrom(NumberLiteral, AST);
        function NumberLiteral(value) {
            this.value = value;
            NumberLiteral._super.constructor.call(this, Tools.NodeType.NumberLit);
            this.isNegativeZero = false; 
        }
        NumberLiteral.prototype.isStatementOrExpression = function() {
            return true; 
        };
        NumberLiteral.prototype.typeCheck = function(typeFlow) {
            this.type = typeFlow.doubleType; 
            return this; 
        };
        NumberLiteral.prototype.treeViewLabel = function() {
            return "num: " + this.value; 
        };
        NumberLiteral.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            if(this.isNegativeZero) {
                emitter.writeToOutput("-"); 
            }
            emitter.writeToOutput(this.value.toString()); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        NumberLiteral.prototype.printLabel = function() {
            if(Math.floor(this.value) != this.value) {
                return this.value.toFixed(2).toString(); 
            } else  {
                return this.value.toString(); 
            }
        };
        return NumberLiteral;
    })();
    Tools.NumberLiteral = NumberLiteral;
    
    var RegexLiteral = (function () {
        _inheritsFrom(RegexLiteral, AST);
        function RegexLiteral(regex) {
            this.regex = regex;
            RegexLiteral._super.constructor.call(this, Tools.NodeType.Regex);
        }
        RegexLiteral.prototype.isStatementOrExpression = function() {
            return true; 
        };
        RegexLiteral.prototype.typeCheck = function(typeFlow) {
            this.type = typeFlow.regexType; 
            return this; 
        };
        RegexLiteral.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.writeToOutput(this.regex.toString()); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        return RegexLiteral;
    })();
    Tools.RegexLiteral = RegexLiteral;
    
    var StringLiteral = (function () {
        _inheritsFrom(StringLiteral, AST);
        function StringLiteral(text) {
            this.text = text;
            StringLiteral._super.constructor.call(this, Tools.NodeType.QString);
        }
        StringLiteral.prototype.isStatementOrExpression = function() {
            return true; 
        };
        StringLiteral.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.emitStringLiteral(this.text); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        StringLiteral.prototype.typeCheck = function(typeFlow) {
            this.type = typeFlow.stringType; 
            return this; 
        };
        StringLiteral.prototype.treeViewLabel = function() {
            return "st: " + this.text; 
        };
        StringLiteral.prototype.printLabel = function() {
            return this.text; 
        };
        return StringLiteral;
    })();
    Tools.StringLiteral = StringLiteral;
    
    var ImportDecl = (function () {
        _inheritsFrom(ImportDecl, AST);
        function ImportDecl(id, alias) {
            this.id = id;
            this.alias = alias;
            ImportDecl._super.constructor.call(this, Tools.NodeType.Import);
            this.varFlags = Tools.VarFlags.None; 
            this.isDynamicImport = false; 
        }
        ImportDecl.prototype.isStatementOrExpression = function() {
            return true; 
        };
        ImportDecl.prototype.emit = function(emitter, tokenId, startLine) {
            var mod = this.alias.type; 
            if(!this.isDynamicImport || (this.id.sym != null && !(this.id.sym).onlyReferencedAsTypeRef)) {
                var prevModAliasId = emitter.modAliasId; 
                var prevFirstModAlias = emitter.firstModAlias; 
                emitter.recordSourceMappingStart(this); 
                emitter.emitParensAndCommentsInPlace(this, true); 
                emitter.writeToOutput(("var " + this.id.text) + " = "); 
                emitter.modAliasId = this.id.text; 
                emitter.firstModAlias = this.firstAliasedModToString(); 
                emitter.emitJavascript(this.alias, Tools.TokenID.Tilde, false); 
                if(!this.isDynamicImport) {
                    emitter.writeToOutput(";"); 
                }
                emitter.emitParensAndCommentsInPlace(this, false); 
                emitter.recordSourceMappingEnd(this); 
                emitter.modAliasId = prevModAliasId; 
                emitter.firstModAlias = prevFirstModAlias; 
            }
        };
        ImportDecl.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckImportDecl(this); 
        };
        ImportDecl.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.id != null) {
                this.id = this.id.walk(pre, post, this, context); 
            }
            if(this.alias != null) {
                this.alias = this.alias.walk(pre, post, this, context); 
            }
        };
        ImportDecl.prototype.firstAliasedModToString = function() {
            if(this.alias.nodeType == Tools.NodeType.Name) {
                return (this.alias).text; 
            } else  {
                var dotExpr = this.alias; 
                var firstMod = dotExpr.operand1; 
                return firstMod.text; 
            }
        };
        return ImportDecl;
    })();
    Tools.ImportDecl = ImportDecl;
    
    var BoundDecl = (function () {
        _inheritsFrom(BoundDecl, AST);
        function BoundDecl(id, nodeType, nestingLevel) {
            this.id = id;
            this.nestingLevel = nestingLevel;
            BoundDecl._super.constructor.call(this, nodeType);
            this.init = null; 
            this.typeExpr = null; 
            this.varFlags = Tools.VarFlags.None; 
            this.sym = null; 
        }
        BoundDecl.prototype.isStatementOrExpression = function() {
            return true; 
        };
        BoundDecl.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckBoundDecl(this); 
        };
        BoundDecl.prototype.printLabel = function() {
            return this.treeViewLabel(); 
        };
        BoundDecl.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.id != null) {
                this.id = this.id.walk(pre, post, this, context); 
            }
            if(this.init != null) {
                this.init = this.init.walk(pre, post, this, context); 
            }
            if((this.typeExpr != null) && (context.goNextSibling)) {
                this.typeExpr = this.typeExpr.walk(pre, post, this, context); 
            }
        };
        return BoundDecl;
    })();
    Tools.BoundDecl = BoundDecl;
    
    var VarDecl = (function () {
        _inheritsFrom(VarDecl, BoundDecl);
        function VarDecl(id, nest) {
            VarDecl._super.constructor.call(this, id, Tools.NodeType.VarDecl, nest);
        }
        VarDecl.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitJavascriptVarDecl(this, tokenId); 
        };
        VarDecl.prototype.emitType = function(emitter) {
            if(Tools.hasFlag(this.varFlags, Tools.VarFlags.Property)) {
                emitter.emitVarType(this); 
            }
        };
        VarDecl.prototype.treeViewLabel = function() {
            return "var " + this.id.text; 
        };
        return VarDecl;
    })();
    Tools.VarDecl = VarDecl;
    
    var ArgDecl = (function () {
        _inheritsFrom(ArgDecl, BoundDecl);
        function ArgDecl(id) {
            ArgDecl._super.constructor.call(this, id, Tools.NodeType.ArgDecl, 0);
            this.isOptional = false; 
        }
        ArgDecl.prototype.isOptionalArg = function() {
            return this.isOptional || (this.init != null); 
        };
        ArgDecl.prototype.treeViewLabel = function() {
            return "arg: " + this.id.text; 
        };
        ArgDecl.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.writeToOutput(this.id.text); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        return ArgDecl;
    })();
    Tools.ArgDecl = ArgDecl;
    
    var internalId = 0; 
    var FuncDecl = (function () {
        _inheritsFrom(FuncDecl, AST);
        function FuncDecl(name, bod, isConstructor, args, vars, scopes, statics, nodeType) {
            this.name = name;
            this.bod = bod;
            this.isConstructor = isConstructor;
            this.args = args;
            this.vars = vars;
            this.scopes = scopes;
            this.statics = statics;
            FuncDecl._super.constructor.call(this, nodeType);
            this.hint = null; 
            this.fncFlags = Tools.FncFlags.None; 
            this.returnTypeAnnotation = null; 
            this.symbols = null; 
            this.variableArgList = false; 
            this.signature = null; 
            this.envids = null; 
            this.jumpRefs = null; 
            this.internalNameCache = null; 
            this.tmp1Declared = false; 
            this.enclosingFnc = null; 
            this.freeVariables = new Array(); 
            this.unitIndex = -1; 
            this.classDecl = null; 
            this.boundToProperty = null; 
            this.isOverload = false; 
            this.innerStaticFuncs = []; 
            this.isTargetTypedAsMethod = false; 
            this.isInlineCallLiteral = false; 
            this.accessorSymbol = null; 
            this.leftCurlyCount = 0; 
            this.rightCurlyCount = 0; 
            this.returnStatements = []; 
        }
        FuncDecl.prototype.isAccessor = function() {
            return Tools.hasFlag(this.fncFlags, Tools.FncFlags.GetAccessor) || Tools.hasFlag(this.fncFlags, Tools.FncFlags.SetAccessor); 
        };
        FuncDecl.prototype.internalName = function() {
            if(this.internalNameCache == null) {
                var extName = this.getNameText(); 
                if(extName != null) {
                    this.internalNameCache = "_internal_" + extName; 
                } else  {
                    this.internalNameCache = "_internal_" + internalId++; 
                }
            }
            return this.internalNameCache; 
        };
        FuncDecl.prototype.hasSelfReference = function() {
            return Tools.hasFlag(this.fncFlags, Tools.FncFlags.HasSelfReference); 
        };
        FuncDecl.prototype.setHasSelfReference = function() {
            this.fncFlags |= Tools.FncFlags.HasSelfReference; 
        };
        FuncDecl.prototype.addCloRef = function(id, sym) {
            if(this.envids == null) {
                this.envids = new Array(); 
            }
            this.envids[this.envids.length] = id; 
            var outerFnc = this.enclosingFnc; 
            if(sym != null) {
                while((outerFnc != null) && (outerFnc.type.symbol != sym.container)) {
                    outerFnc.addJumpRef(sym); 
                    outerFnc = outerFnc.enclosingFnc; 
                }
            }
            return this.envids.length - 1; 
        };
        FuncDecl.prototype.addJumpRef = function(sym) {
            if(this.jumpRefs == null) {
                this.jumpRefs = new Array(); 
            }
            var id = new Identifier(sym.name); 
            this.jumpRefs[this.jumpRefs.length] = id; 
            id.sym = sym; 
            id.cloId = this.addCloRef(id, null); 
        };
        FuncDecl.prototype.buildControlFlow = function() {
            function controlFlowPrefix(ast, parent, context) {
                ast.addToControlFlow(context); 
                return ast; 
            }
            var entry = new Tools.BasicBlock(); 
            var exit = new Tools.BasicBlock(); 
            var context = new Tools.ControlFlowContext(entry, exit, controlFlowPrefix); 
            this.bod.walk(controlFlowPrefix, null, this, context); 
            return context; 
        };
        FuncDecl.prototype.emitType = function(emitter) {
            if(this.isMethod()) {
                emitter.emitFuncType(this); 
            }
        };
        FuncDecl.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckFunction(this); 
        };
        FuncDecl.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitJavascriptFunction(this); 
        };
        FuncDecl.prototype.getNameText = function() {
            if(this.name != null) {
                return this.name.text; 
            } else  {
                return this.hint; 
            }
        };
        FuncDecl.prototype.isMethod = function() {
            return (this.fncFlags & Tools.FncFlags.Method) != Tools.FncFlags.None; 
        };
        FuncDecl.prototype.isCallMember = function() {
            return Tools.hasFlag(this.fncFlags, Tools.FncFlags.CallMember); 
        };
        FuncDecl.prototype.isConstructMember = function() {
            return Tools.hasFlag(this.fncFlags, Tools.FncFlags.ConstructMember); 
        };
        FuncDecl.prototype.isIndexerMember = function() {
            return Tools.hasFlag(this.fncFlags, Tools.FncFlags.IndexerMember); 
        };
        FuncDecl.prototype.isSpecialFn = function() {
            return this.isCallMember() || this.isIndexerMember() || this.isConstructMember(); 
        };
        FuncDecl.prototype.isAnonymousFn = function() {
            return this.name === null; 
        };
        FuncDecl.prototype.treeViewLabel = function() {
            if(this.name == null) {
                return "funcExpr"; 
            } else  {
                return "func: " + this.name.text; 
            }
        };
        FuncDecl.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.name != null) {
                this.name = this.name.walk(pre, post, this, context); 
            }
            if((this.args != null) && (this.args.members.length > 0) && (context.goNextSibling)) {
                this.args = this.args.walk(pre, post, this, context); 
            }
            if((this.returnTypeAnnotation != null) && (context.goNextSibling)) {
                this.returnTypeAnnotation = this.returnTypeAnnotation.walk(pre, post, this, context); 
            }
            if((this.bod != null) && (this.bod.members.length > 0) && (context.goNextSibling)) {
                this.bod = this.bod.walk(pre, post, this, context); 
            }
        };
        FuncDecl.prototype.ClearFlags = function() {
            this.fncFlags = Tools.FncFlags.None; 
        };
        FuncDecl.prototype.isSignature = function() {
            return (this.fncFlags & Tools.FncFlags.Signature) != Tools.FncFlags.None; 
        };
        return FuncDecl;
    })();
    Tools.FuncDecl = FuncDecl;
    
    var LocationInfo = (function () {
        function LocationInfo(filename, lineMap, unitIndex) {
            this.filename = filename;
            this.lineMap = lineMap;
            this.unitIndex = unitIndex;
        }
        return LocationInfo;
    })();
    Tools.LocationInfo = LocationInfo;
    
    Tools.unknownLocationInfo = new LocationInfo("unknown", null, -1); 
    var Script = (function () {
        _inheritsFrom(Script, FuncDecl);
        function Script(vars, scopes) {
            this.vars = vars;
            this.scopes = scopes;
            Script._super.constructor.call(this, new Identifier("script"), null, false, null, this.vars, this.scopes, null, Tools.NodeType.Script);
            this.locationInfo = null; 
            this.requiresGlobal = false; 
            this.requiresInherits = false; 
            this.isResident = false; 
            this.isDeclareFile = false; 
            this.hasBeenTypeChecked = false; 
            this.topLevelMod = null; 
            this.leftCurlyCount = 0; 
            this.rightCurlyCount = 0; 
        }
        Script.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckScript(this); 
        };
        Script.prototype.treeViewLabel = function() {
            return "Script"; 
        };
        Script.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.bod != null) {
                this.bod = this.bod.walk(pre, post, this, context); 
            }
        };
        Script.prototype.emitRequired = function() {
            if(!this.isDeclareFile && !this.isResident && this.bod != null) {
                for(var i = 0, len = this.bod.members.length; i < len; i++) {
                    var stmt = this.bod.members[i]; 
                    if(stmt.nodeType == Tools.NodeType.Module) {
                        if(!Tools.hasFlag((stmt).modFlags, Tools.ModuleFlags.ShouldEmitModuleDecl | Tools.ModuleFlags.Ambient)) {
                            return true; 
                        }
                    } else  {
                        if(stmt.nodeType == Tools.NodeType.Class) {
                            if(!Tools.hasFlag((stmt).varFlags, Tools.VarFlags.Ambient)) {
                                return true; 
                            }
                        } else  {
                            if(stmt.nodeType == Tools.NodeType.ES6Class) {
                                if(!Tools.hasFlag((stmt).varFlags, Tools.VarFlags.Ambient)) {
                                    return true; 
                                }
                            } else  {
                                if(stmt.nodeType == Tools.NodeType.VarDecl) {
                                    if(!Tools.hasFlag((stmt).varFlags, Tools.VarFlags.Ambient)) {
                                        return true; 
                                    }
                                } else  {
                                    if(stmt.nodeType == Tools.NodeType.FuncDecl) {
                                        if(!(stmt).isSignature()) {
                                            return true; 
                                        }
                                    } else  {
                                        if(stmt.nodeType != Tools.NodeType.Interface) {
                                            return true; 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false; 
        };
        Script.prototype.emitType = function(emitter) {
            emitter.emitTypeList(this.bod); 
        };
        Script.prototype.emit = function(emitter, tokenId, startLine) {
            if(this.emitRequired()) {
                emitter.emitParensAndCommentsInPlace(this, true); 
                emitter.recordSourceMappingStart(this); 
                emitter.emitPrologue(this.requiresInherits); 
                emitter.emitJavascriptList(this.bod, null, Tools.TokenID.SColon, true, false, false); 
                emitter.recordSourceMappingEnd(this); 
                emitter.emitParensAndCommentsInPlace(this, false); 
            }
        };
        return Script;
    })();
    Tools.Script = Script;
    
    var Record = (function () {
        _inheritsFrom(Record, AST);
        function Record(nty, name, members) {
            this.nty = nty;
            this.name = name;
            this.members = members;
            Record._super.constructor.call(this, this.nty);
        }
        Record.prototype.walkChildren = function(pre, post, parent, context) {
            this.name = this.name.walk(pre, post, this, context); 
            if((context.goNextSibling) && (this.members != null)) {
                this.members = this.members.walk(pre, post, this, context); 
            }
        };
        return Record;
    })();
    Tools.Record = Record;
    
    var ModuleDecl = (function () {
        _inheritsFrom(ModuleDecl, Record);
        function ModuleDecl(name, members, vars, scopes) {
            this.name = name;
            this.members = members;
            this.vars = vars;
            this.scopes = scopes;
            ModuleDecl._super.constructor.call(this, Tools.NodeType.Module, this.name, this.members);
            this.modFlags = Tools.ModuleFlags.ShouldEmitModuleDecl; 
            this.mod = null; 
            this.alias = null; 
            this.isAnonInnerMod = false; 
            this.anonParentMod = null; 
            this.anonExportedSymbols = null; 
            this.leftCurlyCount = 0; 
            this.rightCurlyCount = 0; 
            this.prettyName = this.name.text; 
            this.amdDependencies = []; 
        }
        ModuleDecl.prototype.recordNonInterface = function() {
            this.modFlags &= ~Tools.ModuleFlags.ShouldEmitModuleDecl; 
        };
        ModuleDecl.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckModule(this); 
        };
        ModuleDecl.prototype.emit = function(emitter, tokenId, startLine) {
            if(!Tools.hasFlag(this.modFlags, Tools.ModuleFlags.ShouldEmitModuleDecl)) {
                emitter.emitParensAndCommentsInPlace(this, true); 
                emitter.emitJavascriptModule(this); 
                emitter.emitParensAndCommentsInPlace(this, false); 
            }
        };
        ModuleDecl.prototype.emitType = function(emitter) {
            if(!Tools.hasFlag(this.modFlags, Tools.ModuleFlags.Ambient)) {
                emitter.emitModuleType(this); 
            }
        };
        ModuleDecl.prototype.walkChildren = function(pre, post, parent, context) {
            ModuleDecl._super.walkChildren.call(this, pre, post, this, context); 
            if((context.goNextSibling) && (this.alias != null)) {
                this.alias = this.alias.walk(pre, post, this, context); 
            }
        };
        return ModuleDecl;
    })();
    Tools.ModuleDecl = ModuleDecl;
    
    var NamedType = (function () {
        _inheritsFrom(NamedType, Record);
        function NamedType(nty, name, extendsList, implementsList, members) {
            this.name = name;
            this.extendsList = extendsList;
            this.implementsList = implementsList;
            this.members = members;
            NamedType._super.constructor.call(this, nty, this.name, this.members);
        }
        return NamedType;
    })();
    Tools.NamedType = NamedType;
    
    var ES6ClassDecl = (function () {
        _inheritsFrom(ES6ClassDecl, NamedType);
        function ES6ClassDecl(name, definitionMembers, baseClass, implementsList) {
            this.name = name;
            this.definitionMembers = definitionMembers;
            this.baseClass = baseClass;
            this.implementsList = implementsList;
            ES6ClassDecl._super.constructor.call(this, Tools.NodeType.ES6Class, this.name, this.baseClass, this.implementsList, this.definitionMembers);
            this.varFlags = Tools.VarFlags.None; 
            this.leftCurlyCount = 0; 
            this.rightCurlyCount = 0; 
            this.knownMemberNames = {
            }; 
            this.constructorDecl = null; 
            this.constructorNestingLevel = 0; 
            this.allMemberDefinitions = new ASTList(); 
            this.baseConstructorCall = new ASTList(); 
        }
        ES6ClassDecl.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckES6Class(this); 
        };
        ES6ClassDecl.prototype.emit = function(emitter, tokenId, startLine) {
            if(!Tools.hasFlag(this.varFlags, Tools.VarFlags.Ambient)) {
                emitter.emitJavascriptES6Class(this); 
            }
        };
        ES6ClassDecl.prototype.walkChildren = function(pre, post, parent, context) {
            ES6ClassDecl._super.walkChildren.call(this, pre, post, this, context); 
            if((context.goNextSibling) && (this.baseClass != null)) {
                this.baseClass = this.baseClass.walk(pre, post, this, context); 
            }
            if((context.goNextSibling) && (this.implementsList != null)) {
                this.implementsList = this.implementsList.walk(pre, post, this, context); 
            }
        };
        return ES6ClassDecl;
    })();
    Tools.ES6ClassDecl = ES6ClassDecl;
    
    var TypeDecl = (function () {
        _inheritsFrom(TypeDecl, NamedType);
        function TypeDecl(nty, name, members, args, extendsList, implementsList) {
            this.nty = nty;
            this.name = name;
            this.members = members;
            this.args = args;
            this.extendsList = extendsList;
            this.implementsList = implementsList;
            TypeDecl._super.constructor.call(this, this.nty, this.name, this.extendsList, this.implementsList, this.members);
            this.varFlags = Tools.VarFlags.None; 
            this.isOverload = false; 
            this.leftCurlyCount = 0; 
            this.rightCurlyCount = 0; 
        }
        TypeDecl.prototype.typeCheck = function(typeFlow) {
            if(this.nty == Tools.NodeType.Class) {
                return typeFlow.typeCheckClass(this); 
            } else  {
                if(this.nty == Tools.NodeType.Interface) {
                    return typeFlow.typeCheckInterface(this); 
                } else  {
                    throw new Error("please implement type check for node type" + this.nty);
                }
            }
        };
        TypeDecl.prototype.emit = function(emitter, tokenId, startLine) {
            if(this.nty == Tools.NodeType.Class) {
                emitter.emitJavascriptClass(this); 
            } else  {
                if(this.nty == Tools.NodeType.Interface) {
                } else  {
                    throw new Error("please implement emit for node type" + this.nty);
                }
            }
        };
        TypeDecl.prototype.walkChildren = function(pre, post, parent, context) {
            TypeDecl._super.walkChildren.call(this, pre, post, this, context); 
            if((context.goNextSibling) && (this.extendsList != null)) {
                this.extendsList = this.extendsList.walk(pre, post, this, context); 
            }
            if((context.goNextSibling) && (this.implementsList != null)) {
                this.implementsList = this.implementsList.walk(pre, post, this, context); 
            }
        };
        return TypeDecl;
    })();
    Tools.TypeDecl = TypeDecl;
    
    var Statement = (function () {
        _inheritsFrom(Statement, AST);
        function Statement(nty) {
            Statement._super.constructor.call(this, nty);
            this.flags |= Tools.ASTFlags.IsStatement; 
        }
        Statement.prototype.isLoop = function() {
            return false; 
        };
        Statement.prototype.isCompoundStatement = function() {
            return this.isLoop(); 
        };
        Statement.prototype.typeCheck = function(typeFlow) {
            this.type = typeFlow.voidType; 
            return this; 
        };
        return Statement;
    })();
    Tools.Statement = Statement;
    
    var GotoExtendedBlock = (function () {
        _inheritsFrom(GotoExtendedBlock, Statement);
        function GotoExtendedBlock(cont, withRet) {
            this.cont = cont;
            this.withRet = withRet;
            GotoExtendedBlock._super.constructor.call(this, Tools.NodeType.GotoEB);
        }
        return GotoExtendedBlock;
    })();
    Tools.GotoExtendedBlock = GotoExtendedBlock;
    
    var ExtendedBlockStart = (function () {
        _inheritsFrom(ExtendedBlockStart, Statement);
        function ExtendedBlockStart(cont) {
            this.cont = cont;
            ExtendedBlockStart._super.constructor.call(this, Tools.NodeType.EBStart);
        }
        return ExtendedBlockStart;
    })();
    Tools.ExtendedBlockStart = ExtendedBlockStart;
    
    var LabeledStatement = (function () {
        _inheritsFrom(LabeledStatement, Statement);
        function LabeledStatement(labels, stmt) {
            this.labels = labels;
            this.stmt = stmt;
            LabeledStatement._super.constructor.call(this, Tools.NodeType.LabeledStatement);
        }
        LabeledStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            if(this.labels != null) {
                var labelsLen = this.labels.members.length; 
                for(var i = 0; i < labelsLen; i++) {
                    this.labels.members[i].emit(emitter, tokenId, startLine); 
                }
            }
            this.stmt.emit(emitter, tokenId, true); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        LabeledStatement.prototype.typeCheck = function(typeFlow) {
            typeFlow.typeCheck(this.labels); 
            this.stmt = this.stmt.typeCheck(typeFlow); 
            return this; 
        };
        LabeledStatement.prototype.addToControlFlow = function(context) {
            var beforeBB = context.current; 
            var bb = new Tools.BasicBlock(); 
            context.current = bb; 
            beforeBB.addSuccessor(bb); 
        };
        LabeledStatement.prototype.walkChildren = function(pre, post, parent, context) {
            this.labels = this.labels.walk(pre, post, this, context); 
            if(context.goNextSibling) {
                this.stmt = this.stmt.walk(pre, post, this, context); 
            }
        };
        return LabeledStatement;
    })();
    Tools.LabeledStatement = LabeledStatement;
    
    var Block = (function () {
        _inheritsFrom(Block, Statement);
        function Block(stmts, visible) {
            this.stmts = stmts;
            this.visible = visible;
            Block._super.constructor.call(this, Tools.NodeType.Block);
        }
        Block.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            if(this.visible) {
                emitter.writeLineToOutput(" {"); 
                emitter.increaseIndent(); 
            }
            var temp = emitter.setInObjectLiteral(false); 
            if(this.stmts != null) {
                emitter.emitJavascriptList(this.stmts, null, Tools.TokenID.SColon, true, false, false); 
            }
            if(this.visible) {
                emitter.decreaseIndent(); 
                emitter.emitIndent(); 
                emitter.writeToOutput("}"); 
            }
            emitter.setInObjectLiteral(temp); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        Block.prototype.addToControlFlow = function(context) {
            var afterIfNeeded = new Tools.BasicBlock(); 
            context.pushStatement(this, context.current, afterIfNeeded); 
            if(this.stmts != null) {
                this.stmts.walk(context.pre, null, this, context); 
            }
            context.goChildren = false; 
            context.popStatement(); 
            if(afterIfNeeded.predecessors.length > 0) {
                context.current.addSuccessor(afterIfNeeded); 
                context.current = afterIfNeeded; 
            }
        };
        Block.prototype.typeCheck = function(typeFlow) {
            if(!typeFlow.checker.styleSettings.emptyBlocks) {
                if((this.stmts === null) || (this.stmts.members.length == 0)) {
                    typeFlow.checker.errorReporter.styleError(this, "empty block"); 
                }
            }
            typeFlow.typeCheck(this.stmts); 
            return this; 
        };
        Block.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.stmts != null) {
                this.stmts = this.stmts.walk(pre, post, this, context); 
            }
        };
        return Block;
    })();
    Tools.Block = Block;
    
    var Jump = (function () {
        _inheritsFrom(Jump, Statement);
        function Jump(nty) {
            this.nty = nty;
            Jump._super.constructor.call(this, this.nty);
            this.target = null; 
            this.resolvedTarget = null; 
        }
        Jump.prototype.hasExplicitTarget = function() {
            return (this.target != null); 
        };
        Jump.prototype.setResolvedTarget = function(parser, stmt) {
            if(stmt.isLoop()) {
                this.resolvedTarget = stmt; 
                return true; 
            }
            if(this.nty === Tools.NodeType.Continue) {
                parser.reportParseError("continue statement applies only to loops"); 
                return false; 
            } else  {
                if((stmt.nodeType == Tools.NodeType.Switch) || this.hasExplicitTarget()) {
                    this.resolvedTarget = stmt; 
                    return true; 
                } else  {
                    parser.reportParseError("break statement with no label can apply only to a loop or switch statement"); 
                    return false; 
                }
            }
        };
        Jump.prototype.addToControlFlow = function(context) {
            Jump._super.addToControlFlow.call(this, context); 
            context.unconditionalBranch(this.resolvedTarget, (this.nty == Tools.NodeType.Continue)); 
        };
        Jump.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            if(this.nty == Tools.NodeType.Break) {
                emitter.writeToOutput("break"); 
            } else  {
                emitter.writeToOutput("continue"); 
            }
            if(this.hasExplicitTarget()) {
                emitter.writeToOutput(" " + this.target); 
            }
            emitter.writeToOutput(";"); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        return Jump;
    })();
    Tools.Jump = Jump;
    
    var WhileStatement = (function () {
        _inheritsFrom(WhileStatement, Statement);
        function WhileStatement(cond) {
            this.cond = cond;
            WhileStatement._super.constructor.call(this, Tools.NodeType.While);
            this.body = null; 
        }
        WhileStatement.prototype.isStatementOrExpression = function() {
            return true; 
        };
        WhileStatement.prototype.isLoop = function() {
            return true; 
        };
        WhileStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            var temp = emitter.setInObjectLiteral(false); 
            emitter.writeToOutput("while("); 
            emitter.emitJavascript(this.cond, Tools.TokenID.WHILE, false); 
            emitter.writeToOutput(")"); 
            emitter.emitJavascriptStatements(this.body, false, false); 
            emitter.setInObjectLiteral(temp); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        WhileStatement.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckWhile(this); 
        };
        WhileStatement.prototype.addToControlFlow = function(context) {
            var loopHeader = context.current; 
            var loopStart = new Tools.BasicBlock(); 
            var afterLoop = new Tools.BasicBlock(); 
            loopHeader.addSuccessor(loopStart); 
            context.current = loopStart; 
            context.addContent(this.cond); 
            var condBlock = context.current; 
            var targetInfo = null; 
            if(this.body != null) {
                context.current = new Tools.BasicBlock(); 
                condBlock.addSuccessor(context.current); 
                context.pushStatement(this, loopStart, afterLoop); 
                this.body.walk(context.pre, null, this, context); 
                targetInfo = context.popStatement(); 
            }
            if(!(context.noContinuation)) {
                var loopEnd = context.current; 
                loopEnd.addSuccessor(loopStart); 
            }
            context.current = afterLoop; 
            condBlock.addSuccessor(afterLoop); 
            context.noContinuation = false; 
            context.goChildren = false; 
        };
        WhileStatement.prototype.walkChildren = function(pre, post, parent, context) {
            this.cond = this.cond.walk(pre, post, this, context); 
            if((this.body != null) && (context.goNextSibling)) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return WhileStatement;
    })();
    Tools.WhileStatement = WhileStatement;
    
    var DoWhileStatement = (function () {
        _inheritsFrom(DoWhileStatement, Statement);
        function DoWhileStatement() {
            DoWhileStatement._super.constructor.call(this, Tools.NodeType.DoWhile);
            this.body = null; 
            this.whileAST = null; 
            this.cond = null; 
        }
        DoWhileStatement.prototype.isStatementOrExpression = function() {
            return true; 
        };
        DoWhileStatement.prototype.isLoop = function() {
            return true; 
        };
        DoWhileStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            var temp = emitter.setInObjectLiteral(false); 
            emitter.writeToOutput("do"); 
            emitter.emitJavascriptStatements(this.body, true, false); 
            emitter.recordSourceMappingStart(this.whileAST); 
            emitter.writeToOutput("while"); 
            emitter.recordSourceMappingEnd(this.whileAST); 
            emitter.writeToOutput('('); 
            emitter.emitJavascript(this.cond, Tools.TokenID.RParen, false); 
            emitter.writeToOutput(")"); 
            emitter.setInObjectLiteral(temp); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        DoWhileStatement.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckDoWhile(this); 
        };
        DoWhileStatement.prototype.addToControlFlow = function(context) {
            var loopHeader = context.current; 
            var loopStart = new Tools.BasicBlock(); 
            var afterLoop = new Tools.BasicBlock(); 
            loopHeader.addSuccessor(loopStart); 
            context.current = loopStart; 
            var targetInfo = null; 
            if(this.body != null) {
                context.pushStatement(this, loopStart, afterLoop); 
                this.body.walk(context.pre, null, this, context); 
                targetInfo = context.popStatement(); 
            }
            if(!(context.noContinuation)) {
                var loopEnd = context.current; 
                loopEnd.addSuccessor(loopStart); 
                context.addContent(this.cond); 
                context.current = afterLoop; 
                loopEnd.addSuccessor(afterLoop); 
            } else  {
                context.addUnreachable(this.cond); 
            }
            context.goChildren = false; 
        };
        DoWhileStatement.prototype.walkChildren = function(pre, post, parent, context) {
            this.cond = this.cond.walk(pre, post, this, context); 
            if((this.body != null) && (context.goNextSibling)) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return DoWhileStatement;
    })();
    Tools.DoWhileStatement = DoWhileStatement;
    
    var IfStatement = (function () {
        _inheritsFrom(IfStatement, Statement);
        function IfStatement(cond) {
            this.cond = cond;
            IfStatement._super.constructor.call(this, Tools.NodeType.If);
            this.thenBod = null; 
            this.elseBod = null; 
        }
        IfStatement.prototype.isStatementOrExpression = function() {
            return true; 
        };
        IfStatement.prototype.isCompoundStatement = function() {
            return true; 
        };
        IfStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            var temp = emitter.setInObjectLiteral(false); 
            emitter.writeToOutput("if("); 
            emitter.emitJavascript(this.cond, Tools.TokenID.IF, false); 
            emitter.writeToOutput(")"); 
            emitter.emitJavascriptStatements(this.thenBod, true, false); 
            if(this.elseBod != null) {
                emitter.writeToOutput(" else "); 
                emitter.emitJavascriptStatements(this.elseBod, true, true); 
            }
            emitter.setInObjectLiteral(temp); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        IfStatement.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckIf(this); 
        };
        IfStatement.prototype.addToControlFlow = function(context) {
            this.cond.addToControlFlow(context); 
            var afterIf = new Tools.BasicBlock(); 
            var beforeIf = context.current; 
            context.pushStatement(this, beforeIf, afterIf); 
            var hasContinuation = false; 
            context.current = new Tools.BasicBlock(); 
            beforeIf.addSuccessor(context.current); 
            this.thenBod.walk(context.pre, null, this, context); 
            if(!context.noContinuation) {
                hasContinuation = true; 
                context.current.addSuccessor(afterIf); 
            }
            if(this.elseBod != null) {
                context.current = new Tools.BasicBlock(); 
                context.noContinuation = false; 
                beforeIf.addSuccessor(context.current); 
                this.elseBod.walk(context.pre, null, this, context); 
                if(!context.noContinuation) {
                    hasContinuation = true; 
                    context.current.addSuccessor(afterIf); 
                } else  {
                    if(hasContinuation) {
                        context.noContinuation = false; 
                    }
                }
            } else  {
                beforeIf.addSuccessor(afterIf); 
                context.noContinuation = false; 
                hasContinuation = true; 
            }
            var targetInfo = context.popStatement(); 
            if(afterIf.predecessors.length > 0) {
                context.noContinuation = false; 
                hasContinuation = true; 
            }
            if(hasContinuation) {
                context.current = afterIf; 
            }
            context.goChildren = false; 
        };
        IfStatement.prototype.walkChildren = function(pre, post, parent, context) {
            this.cond = this.cond.walk(pre, post, this, context); 
            if((this.thenBod != null) && (context.goNextSibling)) {
                this.thenBod = this.thenBod.walk(pre, post, this, context); 
            }
            if((this.elseBod != null) && (context.goNextSibling)) {
                this.elseBod = this.elseBod.walk(pre, post, this, context); 
            }
        };
        return IfStatement;
    })();
    Tools.IfStatement = IfStatement;
    
    var ReturnStatement = (function () {
        _inheritsFrom(ReturnStatement, Statement);
        function ReturnStatement() {
            ReturnStatement._super.constructor.call(this, Tools.NodeType.Return);
            this.returnExpression = null; 
        }
        ReturnStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            var temp = emitter.setInObjectLiteral(false); 
            if(this.returnExpression != null) {
                emitter.writeToOutput("return "); 
                emitter.emitJavascript(this.returnExpression, Tools.TokenID.SColon, false); 
            } else  {
                emitter.writeToOutput("return;"); 
            }
            emitter.setInObjectLiteral(temp); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        ReturnStatement.prototype.addToControlFlow = function(context) {
            ReturnStatement._super.addToControlFlow.call(this, context); 
            context.returnStmt(); 
        };
        ReturnStatement.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckReturn(this); 
        };
        ReturnStatement.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.returnExpression != null) {
                this.returnExpression = this.returnExpression.walk(pre, post, this, context); 
            }
        };
        return ReturnStatement;
    })();
    Tools.ReturnStatement = ReturnStatement;
    
    var EndCode = (function () {
        _inheritsFrom(EndCode, AST);
        function EndCode() {
            EndCode._super.constructor.call(this, Tools.NodeType.EndCode);
        }
        return EndCode;
    })();
    Tools.EndCode = EndCode;
    
    var ForInStatement = (function () {
        _inheritsFrom(ForInStatement, Statement);
        function ForInStatement(lval, obj) {
            this.lval = lval;
            this.obj = obj;
            ForInStatement._super.constructor.call(this, Tools.NodeType.ForIn);
            if((this.lval != null) && (this.lval.nodeType == Tools.NodeType.VarDecl)) {
                (this.lval).varFlags |= Tools.VarFlags.AutoInit; 
            }
            this.body = null; 
        }
        ForInStatement.prototype.isStatementOrExpression = function() {
            return true; 
        };
        ForInStatement.prototype.isLoop = function() {
            return true; 
        };
        ForInStatement.prototype.isFiltered = function() {
            if(this.body != null) {
                var singleItem = null; 
                if(this.body.nodeType == Tools.NodeType.List) {
                    var stmts = this.body; 
                    if(stmts.members.length == 1) {
                        singleItem = stmts.members[0]; 
                    }
                } else  {
                    singleItem = this.body; 
                }
                if(singleItem !== null) {
                    if(singleItem.nodeType == Tools.NodeType.Block) {
                        var block = singleItem; 
                        if((block.stmts !== null) && (block.stmts.members.length == 1)) {
                            singleItem = block.stmts.members[0]; 
                        }
                    }
                    if(singleItem.nodeType == Tools.NodeType.If) {
                        var cond = (singleItem).cond; 
                        if(cond.nodeType == Tools.NodeType.Call) {
                            var target = (cond).target; 
                            if(target.nodeType == Tools.NodeType.Dot) {
                                var binex = target; 
                                if((binex.operand1.nodeType == Tools.NodeType.Name) && (this.obj.nodeType == Tools.NodeType.Name) && ((binex.operand1).text == (this.obj).text)) {
                                    var prop = binex.operand2; 
                                    if(prop.text == "hasOwnProperty") {
                                        var args = (cond).args; 
                                        if((args !== null) && (args.members.length == 1)) {
                                            var arg = args.members[0]; 
                                            if((arg.nodeType == Tools.NodeType.Name) && (this.lval.nodeType == Tools.NodeType.Name)) {
                                                if(((this.lval).text) == (arg).text) {
                                                    return true; 
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false; 
        };
        ForInStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            var temp = emitter.setInObjectLiteral(false); 
            emitter.writeToOutput("for("); 
            emitter.emitJavascript(this.lval, Tools.TokenID.FOR, false); 
            emitter.writeToOutput(" in "); 
            emitter.emitJavascript(this.obj, Tools.TokenID.FOR, false); 
            emitter.writeToOutput(")"); 
            emitter.emitJavascriptStatements(this.body, true, false); 
            emitter.setInObjectLiteral(temp); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        ForInStatement.prototype.typeCheck = function(typeFlow) {
            if(typeFlow.checker.styleSettings.forin) {
                if(!this.isFiltered()) {
                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter"); 
                }
            }
            return typeFlow.typeCheckForIn(this); 
        };
        ForInStatement.prototype.addToControlFlow = function(context) {
            if(this.lval != null) {
                context.addContent(this.lval); 
            }
            if(this.obj != null) {
                context.addContent(this.obj); 
            }
            var loopHeader = context.current; 
            var loopStart = new Tools.BasicBlock(); 
            var afterLoop = new Tools.BasicBlock(); 
            loopHeader.addSuccessor(loopStart); 
            context.current = loopStart; 
            if(this.body != null) {
                context.pushStatement(this, loopStart, afterLoop); 
                this.body.walk(context.pre, null, this, context); 
                context.popStatement(); 
            }
            if(!(context.noContinuation)) {
                var loopEnd = context.current; 
                loopEnd.addSuccessor(loopStart); 
            }
            context.current = afterLoop; 
            context.noContinuation = false; 
            loopHeader.addSuccessor(afterLoop); 
            context.goChildren = false; 
        };
        ForInStatement.prototype.walkChildren = function(pre, post, parent, context) {
            this.lval = this.lval.walk(pre, post, this, context); 
            if(context.goNextSibling) {
                this.obj = this.obj.walk(pre, post, this, context); 
            }
            if((this.body != null) && (context.goNextSibling)) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return ForInStatement;
    })();
    Tools.ForInStatement = ForInStatement;
    
    var ForStatement = (function () {
        _inheritsFrom(ForStatement, Statement);
        function ForStatement(init) {
            this.init = init;
            ForStatement._super.constructor.call(this, Tools.NodeType.For);
            this.cond = null; 
            this.body = null; 
            this.incr = null; 
        }
        ForStatement.prototype.isStatementOrExpression = function() {
            return true; 
        };
        ForStatement.prototype.isLoop = function() {
            return true; 
        };
        ForStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            var temp = emitter.setInObjectLiteral(false); 
            emitter.writeToOutput("for("); 
            if(this.init != null) {
                if(this.init.nodeType != Tools.NodeType.List) {
                    emitter.emitJavascript(this.init, Tools.TokenID.FOR, false); 
                } else  {
                    emitter.emitForVarList(this.init); 
                }
            }
            emitter.writeToOutput("; "); 
            emitter.emitJavascript(this.cond, Tools.TokenID.FOR, false); 
            emitter.writeToOutput("; "); 
            emitter.emitJavascript(this.incr, Tools.TokenID.FOR, false); 
            emitter.writeToOutput(")"); 
            emitter.emitJavascriptStatements(this.body, true, false); 
            emitter.setInObjectLiteral(temp); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        ForStatement.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckFor(this); 
        };
        ForStatement.prototype.addToControlFlow = function(context) {
            if(this.init != null) {
                context.addContent(this.init); 
            }
            var loopHeader = context.current; 
            var loopStart = new Tools.BasicBlock(); 
            var afterLoop = new Tools.BasicBlock(); 
            loopHeader.addSuccessor(loopStart); 
            context.current = loopStart; 
            var condBlock = null; 
            var continueTarget = loopStart; 
            var incrBB = null; 
            if(this.incr != null) {
                incrBB = new Tools.BasicBlock(); 
                continueTarget = incrBB; 
            }
            if(this.cond != null) {
                condBlock = context.current; 
                context.addContent(this.cond); 
                context.current = new Tools.BasicBlock(); 
                condBlock.addSuccessor(context.current); 
            }
            var targetInfo = null; 
            if(this.body != null) {
                context.pushStatement(this, continueTarget, afterLoop); 
                this.body.walk(context.pre, null, this, context); 
                targetInfo = context.popStatement(); 
            }
            if(this.incr != null) {
                if(context.noContinuation) {
                    if(incrBB.predecessors.length == 0) {
                        context.addUnreachable(this.incr); 
                    }
                } else  {
                    context.current.addSuccessor(incrBB); 
                    context.current = incrBB; 
                    context.addContent(this.incr); 
                }
            }
            var loopEnd = context.current; 
            if(!(context.noContinuation)) {
                loopEnd.addSuccessor(loopStart); 
            }
            if(condBlock != null) {
                condBlock.addSuccessor(afterLoop); 
                context.noContinuation = false; 
            }
            if(afterLoop.predecessors.length > 0) {
                context.noContinuation = false; 
                context.current = afterLoop; 
            }
            context.goChildren = false; 
        };
        ForStatement.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.init != null) {
                this.init = this.init.walk(pre, post, this, context); 
            }
            if((this.cond != null) && context.goNextSibling) {
                this.cond = this.cond.walk(pre, post, this, context); 
            }
            if((this.incr != null) && context.goNextSibling) {
                this.incr = this.incr.walk(pre, post, this, context); 
            }
            if((this.body != null) && context.goNextSibling) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return ForStatement;
    })();
    Tools.ForStatement = ForStatement;
    
    var WithStatement = (function () {
        _inheritsFrom(WithStatement, Statement);
        function WithStatement(expr) {
            this.expr = expr;
            WithStatement._super.constructor.call(this, Tools.NodeType.With);
            this.body = null; 
            this.withSym = null; 
        }
        WithStatement.prototype.isStatementOrExpression = function() {
            return true; 
        };
        WithStatement.prototype.isCompoundStatement = function() {
            return true; 
        };
        WithStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.writeToOutput("with ("); 
            if(this.expr != null) {
                emitter.emitJavascript(this.expr, Tools.TokenID.WITH, false); 
            }
            emitter.writeToOutput(")"); 
            emitter.emitJavascriptStatements(this.body, true, false); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        WithStatement.prototype.typeCheck = function(typeFlow) {
            return typeFlow.typeCheckWith(this); 
        };
        WithStatement.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.expr != null) {
                this.expr = this.expr.walk(pre, post, this, context); 
            }
            if((this.body != null) && context.goNextSibling) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return WithStatement;
    })();
    Tools.WithStatement = WithStatement;
    
    var SwitchStatement = (function () {
        _inheritsFrom(SwitchStatement, Statement);
        function SwitchStatement(val) {
            this.val = val;
            SwitchStatement._super.constructor.call(this, Tools.NodeType.Switch);
            this.caseList = null; 
            this.defaultCase = null; 
        }
        SwitchStatement.prototype.isStatementOrExpression = function() {
            return true; 
        };
        SwitchStatement.prototype.isCompoundStatement = function() {
            return true; 
        };
        SwitchStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            var temp = emitter.setInObjectLiteral(false); 
            emitter.writeToOutput("switch("); 
            emitter.emitJavascript(this.val, Tools.TokenID.ID, false); 
            emitter.writeLineToOutput(") {"); 
            emitter.increaseIndent(); 
            var casesLen = this.caseList.members.length; 
            for(var i = 0; i < casesLen; i++) {
                var caseExpr = this.caseList.members[i]; 
                emitter.emitJavascript(caseExpr, Tools.TokenID.CASE, true); 
                emitter.writeLineToOutput(""); 
            }
            emitter.decreaseIndent(); 
            emitter.emitIndent(); 
            emitter.writeToOutput("}"); 
            emitter.setInObjectLiteral(temp); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        SwitchStatement.prototype.typeCheck = function(typeFlow) {
            var len = this.caseList.members.length; 
            this.val = typeFlow.typeCheck(this.val); 
            for(var i = 0; i < len; i++) {
                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]); 
            }
            this.defaultCase = typeFlow.typeCheck(this.defaultCase); 
            this.type = typeFlow.voidType; 
            return this; 
        };
        SwitchStatement.prototype.addToControlFlow = function(context) {
            var condBlock = context.current; 
            context.addContent(this.val); 
            var execBlock = new Tools.BasicBlock(); 
            var afterSwitch = new Tools.BasicBlock(); 
            condBlock.addSuccessor(execBlock); 
            context.pushSwitch(execBlock); 
            context.current = execBlock; 
            context.pushStatement(this, execBlock, afterSwitch); 
            this.caseList.walk(context.pre, null, this, context); 
            context.popSwitch(); 
            var targetInfo = context.popStatement(); 
            var hasCondContinuation = (this.defaultCase == null); 
            if(this.defaultCase == null) {
                condBlock.addSuccessor(afterSwitch); 
            }
            if(afterSwitch.predecessors.length > 0) {
                context.noContinuation = false; 
                context.current = afterSwitch; 
            } else  {
                context.noContinuation = true; 
            }
            context.goChildren = false; 
        };
        SwitchStatement.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.val != null) {
                this.val = this.val.walk(pre, post, this, context); 
            }
            if((this.caseList != null) && context.goNextSibling) {
                this.caseList = this.caseList.walk(pre, post, this, context); 
            }
        };
        return SwitchStatement;
    })();
    Tools.SwitchStatement = SwitchStatement;
    
    var CaseStatement = (function () {
        _inheritsFrom(CaseStatement, Statement);
        function CaseStatement() {
            CaseStatement._super.constructor.call(this, Tools.NodeType.Case);
            this.expr = null; 
            this.body = null; 
        }
        CaseStatement.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            if(this.expr != null) {
                emitter.writeToOutput("case "); 
                emitter.emitJavascript(this.expr, Tools.TokenID.ID, false); 
            } else  {
                emitter.writeToOutput("default"); 
            }
            emitter.writeToOutput(":"); 
            emitter.emitJavascriptStatements(this.body, false, false); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        CaseStatement.prototype.typeCheck = function(typeFlow) {
            this.expr = typeFlow.typeCheck(this.expr); 
            typeFlow.typeCheck(this.body); 
            this.type = typeFlow.voidType; 
            return this; 
        };
        CaseStatement.prototype.addToControlFlow = function(context) {
            var execBlock = new Tools.BasicBlock(); 
            var sw = context.currentSwitch[context.currentSwitch.length - 1]; 
            if(this.expr != null) {
                var exprBlock = new Tools.BasicBlock(); 
                context.current = exprBlock; 
                sw.addSuccessor(exprBlock); 
                context.addContent(this.expr); 
                exprBlock.addSuccessor(execBlock); 
            } else  {
                sw.addSuccessor(execBlock); 
            }
            context.current = execBlock; 
            if(this.body != null) {
                this.body.walk(context.pre, null, this, context); 
            }
            context.noContinuation = false; 
            context.goChildren = false; 
        };
        CaseStatement.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.expr != null) {
                this.expr = this.expr.walk(pre, post, this, context); 
            }
            if((this.body != null) && context.goNextSibling) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return CaseStatement;
    })();
    Tools.CaseStatement = CaseStatement;
    
    var TypeReference = (function () {
        _inheritsFrom(TypeReference, AST);
        function TypeReference(term, arrayCount) {
            this.term = term;
            this.arrayCount = arrayCount;
            TypeReference._super.constructor.call(this, Tools.NodeType.TypeRef);
        }
        TypeReference.prototype.emit = function(emitter, tokenId, startLine) {
            throw new Error("should not emit a type ref");
        };
        TypeReference.prototype.typeCheck = function(typeFlow) {
            var prevInTCTR = typeFlow.inTypeRefTypeCheck; 
            typeFlow.inTypeRefTypeCheck = true; 
            var typeLink = Tools.getTypeLink(this, typeFlow.checker, true); 
            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false); 
            typeFlow.checkForVoidConstructor(typeLink.type, this); 
            this.type = typeLink.type; 
            if(this.term) {
                this.term.type = this.type; 
            }
            typeFlow.inTypeRefTypeCheck = prevInTCTR; 
            return this; 
        };
        TypeReference.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.term != null) {
                this.term = this.term.walk(pre, post, this, context); 
            }
        };
        return TypeReference;
    })();
    Tools.TypeReference = TypeReference;
    
    var TryFinally = (function () {
        _inheritsFrom(TryFinally, Statement);
        function TryFinally(tryNode, finallyNode) {
            this.tryNode = tryNode;
            this.finallyNode = finallyNode;
            TryFinally._super.constructor.call(this, Tools.NodeType.TryFinally);
        }
        TryFinally.prototype.isStatementOrExpression = function() {
            return true; 
        };
        TryFinally.prototype.isCompoundStatement = function() {
            return true; 
        };
        TryFinally.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.recordSourceMappingStart(this); 
            emitter.emitJavascript(this.tryNode, Tools.TokenID.TRY, false); 
            emitter.emitJavascript(this.finallyNode, Tools.TokenID.FINALLY, false); 
            emitter.recordSourceMappingEnd(this); 
        };
        TryFinally.prototype.typeCheck = function(typeFlow) {
            this.tryNode = typeFlow.typeCheck(this.tryNode); 
            this.finallyNode = typeFlow.typeCheck(this.finallyNode); 
            this.type = typeFlow.voidType; 
            return this; 
        };
        TryFinally.prototype.addToControlFlow = function(context) {
            var afterFinally = new Tools.BasicBlock(); 
            this.tryNode.walk(context.pre, null, this, context); 
            var finBlock = new Tools.BasicBlock(); 
            if(context.current != null) {
                context.current.addSuccessor(finBlock); 
            }
            context.current = finBlock; 
            context.pushStatement(this, null, afterFinally); 
            this.finallyNode.walk(context.pre, null, this, context); 
            if((!context.noContinuation) && (context.current != null)) {
                context.current.addSuccessor(afterFinally); 
            }
            if(afterFinally.predecessors.length > 0) {
                context.current = afterFinally; 
            } else  {
                context.noContinuation = true; 
            }
            context.popStatement(); 
            context.goChildren = false; 
        };
        TryFinally.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.tryNode != null) {
                this.tryNode = this.tryNode.walk(pre, post, this, context); 
            }
            if((this.finallyNode != null) && context.goNextSibling) {
                this.finallyNode = this.finallyNode.walk(pre, post, this, context); 
            }
        };
        return TryFinally;
    })();
    Tools.TryFinally = TryFinally;
    
    var TryCatch = (function () {
        _inheritsFrom(TryCatch, Statement);
        function TryCatch(tryNode, catchNode) {
            this.tryNode = tryNode;
            this.catchNode = catchNode;
            TryCatch._super.constructor.call(this, Tools.NodeType.TryCatch);
        }
        TryCatch.prototype.isStatementOrExpression = function() {
            return true; 
        };
        TryCatch.prototype.isCompoundStatement = function() {
            return true; 
        };
        TryCatch.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.emitJavascript(this.tryNode, Tools.TokenID.TRY, false); 
            emitter.emitJavascript(this.catchNode, Tools.TokenID.CATCH, false); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        TryCatch.prototype.addToControlFlow = function(context) {
            var beforeTry = context.current; 
            var tryBlock = new Tools.BasicBlock(); 
            beforeTry.addSuccessor(tryBlock); 
            context.current = tryBlock; 
            var afterTryCatch = new Tools.BasicBlock(); 
            context.pushStatement(this, null, afterTryCatch); 
            this.tryNode.walk(context.pre, null, this, context); 
            if(!context.noContinuation) {
                if(context.current != null) {
                    context.current.addSuccessor(afterTryCatch); 
                }
            }
            context.current = new Tools.BasicBlock(); 
            beforeTry.addSuccessor(context.current); 
            this.catchNode.walk(context.pre, null, this, context); 
            context.popStatement(); 
            if(!context.noContinuation) {
                if(context.current != null) {
                    context.current.addSuccessor(afterTryCatch); 
                }
            }
            context.current = afterTryCatch; 
            context.goChildren = false; 
        };
        TryCatch.prototype.typeCheck = function(typeFlow) {
            this.tryNode = typeFlow.typeCheck(this.tryNode); 
            this.catchNode = typeFlow.typeCheck(this.catchNode); 
            this.type = typeFlow.voidType; 
            return this; 
        };
        TryCatch.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.tryNode != null) {
                this.tryNode = this.tryNode.walk(pre, post, this, context); 
            }
            if((this.catchNode != null) && context.goNextSibling) {
                this.catchNode = this.catchNode.walk(pre, post, this, context); 
            }
        };
        return TryCatch;
    })();
    Tools.TryCatch = TryCatch;
    
    var Try = (function () {
        _inheritsFrom(Try, Statement);
        function Try(body) {
            this.body = body;
            Try._super.constructor.call(this, Tools.NodeType.Try);
        }
        Try.prototype.isStatementOrExpression = function() {
            return true; 
        };
        Try.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.writeToOutput("try "); 
            emitter.emitJavascript(this.body, Tools.TokenID.TRY, false); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        Try.prototype.typeCheck = function(typeFlow) {
            this.body = typeFlow.typeCheck(this.body); 
            return this; 
        };
        Try.prototype.addToControlFlow = function(context) {
            if(this.body != null) {
                this.body.walk(context.pre, null, this, context); 
            }
            context.goChildren = false; 
            context.noContinuation = false; 
        };
        Try.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.body != null) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return Try;
    })();
    Tools.Try = Try;
    
    var Catch = (function () {
        _inheritsFrom(Catch, Statement);
        function Catch(param, body) {
            this.param = param;
            this.body = body;
            Catch._super.constructor.call(this, Tools.NodeType.Catch);
            if(this.param != null) {
                this.param.varFlags |= Tools.VarFlags.AutoInit; 
            }
            this.containedScope = null; 
        }
        Catch.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.writeToOutput(" catch ("); 
            emitter.emitJavascript(this.param, Tools.TokenID.LParen, false); 
            emitter.writeToOutput(")"); 
            emitter.emitJavascript(this.body, Tools.TokenID.CATCH, false); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        Catch.prototype.addToControlFlow = function(context) {
            if(this.param != null) {
                context.addContent(this.param); 
                var bodBlock = new Tools.BasicBlock(); 
                context.current.addSuccessor(bodBlock); 
                context.current = bodBlock; 
            }
            if(this.body != null) {
                this.body.walk(context.pre, null, this, context); 
            }
            context.noContinuation = false; 
            context.goChildren = false; 
        };
        Catch.prototype.typeCheck = function(typeFlow) {
            var prevScope = typeFlow.scope; 
            typeFlow.scope = this.containedScope; 
            this.param = typeFlow.typeCheck(this.param); 
            var exceptVar = new Tools.ValueLocation(); 
            var varSym = new Tools.VariableSymbol((this.param).id.text, this.param.minChar, typeFlow.checker.locationInfo.unitIndex, exceptVar); 
            exceptVar.symbol = varSym; 
            exceptVar.typeLink = new Tools.TypeLink(); 
            exceptVar.typeLink.type = typeFlow.anyType; 
            var thisFnc = typeFlow.thisFnc; 
            if((thisFnc != null) && (thisFnc.type != null)) {
                exceptVar.symbol.container = thisFnc.type.symbol; 
            } else  {
                exceptVar.symbol.container = null; 
            }
            this.param.sym = exceptVar.symbol; 
            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol, typeFlow.checker.errorReporter, false, false, false); 
            this.body = typeFlow.typeCheck(this.body); 
            this.type = typeFlow.voidType; 
            typeFlow.scope = prevScope; 
            return this; 
        };
        Catch.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.param != null) {
                this.param = this.param.walk(pre, post, this, context); 
            }
            if((this.body != null) && context.goNextSibling) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return Catch;
    })();
    Tools.Catch = Catch;
    
    var Finally = (function () {
        _inheritsFrom(Finally, Statement);
        function Finally(body) {
            this.body = body;
            Finally._super.constructor.call(this, Tools.NodeType.Finally);
        }
        Finally.prototype.emit = function(emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true); 
            emitter.recordSourceMappingStart(this); 
            emitter.writeToOutput("finally"); 
            emitter.emitJavascript(this.body, Tools.TokenID.FINALLY, false); 
            emitter.recordSourceMappingEnd(this); 
            emitter.emitParensAndCommentsInPlace(this, false); 
        };
        Finally.prototype.addToControlFlow = function(context) {
            if(this.body != null) {
                this.body.walk(context.pre, null, this, context); 
            }
            context.goChildren = false; 
            context.noContinuation = false; 
        };
        Finally.prototype.typeCheck = function(typeFlow) {
            this.body = typeFlow.typeCheck(this.body); 
            return this; 
        };
        Finally.prototype.walkChildren = function(pre, post, parent, context) {
            if(this.body != null) {
                this.body = this.body.walk(pre, post, this, context); 
            }
        };
        return Finally;
    })();
    Tools.Finally = Finally;
    
    var Comment = (function () {
        _inheritsFrom(Comment, AST);
        function Comment(content, isBlockComment, endsLine) {
            this.content = content;
            this.isBlockComment = isBlockComment;
            this.endsLine = endsLine;
            Comment._super.constructor.call(this, Tools.NodeType.Comment);
            this.text = null; 
        }
        Comment.prototype.getText = function() {
            if(this.text == null) {
                if(this.isBlockComment) {
                    this.text = this.content.split("\n"); 
                    for(var i = 0; i < this.text.length; i++) {
                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, ''); 
                    }
                } else  {
                    this.text = [                        (this.content.replace(/^\s+|\s+$/g, ''))
]; 
                }
            }
            return this.text; 
        };
        return Comment;
    })();
    Tools.Comment = Comment;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    function lastOf(items) {
        return (items === null || items.length === 0) ? null : items[items.length - 1]; 
    }
    Tools.lastOf = lastOf;
    function max(a, b) {
        return a >= b ? a : b; 
    }
    Tools.max = max;
    function min(a, b) {
        return a <= b ? a : b; 
    }
    Tools.min = min;
    var AstPath = (function () {
        function AstPath() {
            this.asts = []; 
            this.top = -1; 
        }
        function reverseIndexOf(items, index) {
            return (items === null || items.length <= index) ? null : items[(items.length - index) - 1]; 
        }
        AstPath.reverseIndexOf = reverseIndexOf;
        AstPath.prototype.clone = function() {
            var clone = new AstPath(); 
            clone.asts = this.asts.map(function(value) {
                return value; 
            }); 
            clone.top = this.top; 
            return clone; 
        };
        AstPath.prototype.pop = function() {
            var head = this.ast(); 
            this.up(); 
            while(this.asts.length > this.count()) {
                this.asts.pop(); 
            }
            return head; 
        };
        AstPath.prototype.push = function(ast) {
            while(this.asts.length > this.count()) {
                this.asts.pop(); 
            }
            this.top = this.asts.length; 
            this.asts.push(ast); 
        };
        AstPath.prototype.up = function() {
            if(this.top <= -1) {
                throw new Error("Invalid call to 'up'");
            }
            this.top--; 
        };
        AstPath.prototype.down = function() {
            if(this.top == this.ast.length - 1) {
                throw new Error("Invalid call to 'down'");
            }
            this.top++; 
        };
        AstPath.prototype.nodeType = function() {
            if(this.ast() == null) {
                return Tools.NodeType.None; 
            }
            return this.ast().nodeType; 
        };
        AstPath.prototype.ast = function() {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1)); 
        };
        AstPath.prototype.parent = function() {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - this.top); 
        };
        AstPath.prototype.count = function() {
            return this.top + 1; 
        };
        AstPath.prototype.get = function(index) {
            return this.asts[index]; 
        };
        AstPath.prototype.isNameOfClass = function() {
            if(this.ast() === null || this.parent() === null) {
                return false; 
            }
            return (this.ast().nodeType === Tools.NodeType.Name) && (this.parent().nodeType === Tools.NodeType.Class) && ((this.parent()).name === this.ast()); 
        };
        AstPath.prototype.isNameOfES6Class = function() {
            if(this.ast() === null || this.parent() === null) {
                return false; 
            }
            return (this.ast().nodeType === Tools.NodeType.Name) && (this.parent().nodeType === Tools.NodeType.ES6Class) && ((this.parent()).name === this.ast()); 
        };
        AstPath.prototype.isNameOfInterface = function() {
            if(this.ast() === null || this.parent() === null) {
                return false; 
            }
            return (this.ast().nodeType === Tools.NodeType.Name) && (this.parent().nodeType === Tools.NodeType.Interface) && ((this.parent()).name === this.ast()); 
        };
        AstPath.prototype.isNameOfArgument = function() {
            if(this.ast() === null || this.parent() === null) {
                return false; 
            }
            return (this.ast().nodeType === Tools.NodeType.Name) && (this.parent().nodeType === Tools.NodeType.ArgDecl) && ((this.parent()).id === this.ast()); 
        };
        AstPath.prototype.isNameOfVariable = function() {
            if(this.ast() === null || this.parent() === null) {
                return false; 
            }
            return (this.ast().nodeType === Tools.NodeType.Name) && (this.parent().nodeType === Tools.NodeType.VarDecl) && ((this.parent()).id === this.ast()); 
        };
        AstPath.prototype.isNameOfModule = function() {
            if(this.ast() === null || this.parent() === null) {
                return false; 
            }
            return (this.ast().nodeType === Tools.NodeType.Name) && (this.parent().nodeType === Tools.NodeType.Module) && ((this.parent()).name === this.ast()); 
        };
        AstPath.prototype.isNameOfFunction = function() {
            if(this.ast() === null || this.parent() === null) {
                return false; 
            }
            return (this.ast().nodeType === Tools.NodeType.Name) && (this.parent().nodeType === Tools.NodeType.FuncDecl) && ((this.parent()).name === this.ast()); 
        };
        AstPath.prototype.isChildOfScript = function() {
            var ast = lastOf(this.asts); 
            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === Tools.NodeType.List && this.asts[this.top - 2].nodeType === Tools.NodeType.Script; 
        };
        AstPath.prototype.isChildOfModule = function() {
            var ast = lastOf(this.asts); 
            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === Tools.NodeType.List && this.asts[this.top - 2].nodeType === Tools.NodeType.Module; 
        };
        AstPath.prototype.isChildOfClass = function() {
            var ast = lastOf(this.asts); 
            return this.count() >= 4 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === Tools.NodeType.List && this.asts[this.top - 2].nodeType === Tools.NodeType.FuncDecl && this.asts[this.top - 3].nodeType === Tools.NodeType.Class; 
        };
        AstPath.prototype.isChildOfES6Class = function() {
            var ast = lastOf(this.asts); 
            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === Tools.NodeType.List && this.asts[this.top - 2].nodeType === Tools.NodeType.ES6Class; 
        };
        AstPath.prototype.isChildOfInterface = function() {
            var ast = lastOf(this.asts); 
            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === Tools.NodeType.List && this.asts[this.top - 2].nodeType === Tools.NodeType.Interface; 
        };
        AstPath.prototype.isTopLevelImplicitModule = function() {
            return this.count() >= 1 && this.asts[this.top].nodeType === Tools.NodeType.Module && Tools.hasFlag((this.asts[this.top]).modFlags, Tools.ModuleFlags.IsWholeFile); 
        };
        AstPath.prototype.isBodyOfTopLevelImplicitModule = function() {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === Tools.NodeType.List && this.asts[this.top - 1].nodeType === Tools.NodeType.Module && (this.asts[this.top - 1]).members == this.asts[this.top - 0] && Tools.hasFlag((this.asts[this.top - 1]).modFlags, Tools.ModuleFlags.IsWholeFile); 
        };
        AstPath.prototype.isBodyOfScript = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Script && (this.asts[this.top - 1]).bod == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfSwitch = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Switch && (this.asts[this.top - 1]).caseList == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfModule = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Module && (this.asts[this.top - 1]).members == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfClass = function() {
            return this.count() >= 3 && this.asts[this.top - 1].nodeType === Tools.NodeType.FuncDecl && this.asts[this.top - 2].nodeType === Tools.NodeType.Class && (this.asts[this.top - 1]).bod == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfES6Class = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.ES6Class && (this.asts[this.top - 1]).members == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfFunction = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.FuncDecl && (this.asts[this.top - 1]).bod == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfInterface = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Interface && (this.asts[this.top - 1]).members == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfBlock = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Block && (this.asts[this.top - 1]).stmts == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfFor = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.For && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfCase = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Case && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfTry = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Try && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfCatch = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Catch && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfDoWhile = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.DoWhile && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfWhile = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.While && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfForIn = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.ForIn && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfWith = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.With && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfFinally = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Finally && (this.asts[this.top - 1]).body == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isCaseOfSwitch = function() {
            return this.count() >= 3 && this.asts[this.top - 2].nodeType === Tools.NodeType.Switch && this.asts[this.top - 1].nodeType === Tools.NodeType.List && (this.asts[this.top - 2]).caseList == this.asts[this.top - 1]; 
        };
        AstPath.prototype.isDefaultCaseOfSwitch = function() {
            return this.count() >= 3 && this.asts[this.top - 2].nodeType === Tools.NodeType.Switch && this.asts[this.top - 1].nodeType === Tools.NodeType.List && (this.asts[this.top - 2]).caseList == this.asts[this.top - 1] && (this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isListOfObjectLit = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.ObjectLit && this.asts[this.top - 0].nodeType === Tools.NodeType.List && (this.asts[this.top - 1]).operand == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isListOfArrayLit = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.ArrayLit && this.asts[this.top - 0].nodeType === Tools.NodeType.List && (this.asts[this.top - 1]).operand == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isTargetOfMember = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Member && (this.asts[this.top - 1]).operand1 === this.asts[this.top - 0]; 
        };
        AstPath.prototype.isMemberOfMember = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.Member && (this.asts[this.top - 1]).operand2 === this.asts[this.top - 0]; 
        };
        AstPath.prototype.isItemOfList = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.List; 
        };
        AstPath.prototype.isThenOfIf = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.If && (this.asts[this.top - 1]).thenBod == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isElseOfIf = function() {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === Tools.NodeType.If && (this.asts[this.top - 1]).elseBod == this.asts[this.top - 0]; 
        };
        AstPath.prototype.isBodyOfDefaultCase = function() {
            return this.isBodyOfCase(); 
        };
        AstPath.prototype.isSingleStatementList = function() {
            return this.count() >= 1 && this.asts[this.top].nodeType === Tools.NodeType.List && (this.asts[this.top]).members.length === 1; 
        };
        AstPath.prototype.isArgumentListOfFunction = function() {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === Tools.NodeType.List && this.asts[this.top - 1].nodeType === Tools.NodeType.FuncDecl && (this.asts[this.top - 1]).args === this.asts[this.top - 0]; 
        };
        AstPath.prototype.isArgumentOfFunction = function() {
            return this.count() >= 3 && this.asts[this.top - 1].nodeType === Tools.NodeType.List && this.asts[this.top - 2].nodeType === Tools.NodeType.FuncDecl && (this.asts[this.top - 2]).args === this.asts[this.top - 1]; 
        };
        AstPath.prototype.isSynthesizedBlock = function() {
            return this.count() >= 1 && this.asts[this.top - 0].nodeType === Tools.NodeType.Block && (this.asts[this.top - 0]).visible === false; 
        };
        return AstPath;
    })();
    Tools.AstPath = AstPath;
    
    function isValidAstNode(ast) {
        if(ast === null) {
            return false; 
        }
        if(ast.minChar === -1 || ast.limChar === -1) {
            return false; 
        }
        return true; 
    }
    Tools.isValidAstNode = isValidAstNode;
    var AstPathContext = (function () {
        function AstPathContext() {
            this.goChildren = true; 
            this.goNextSibling = true; 
            this.reverseSiblings = false; 
            this.path = new Tools.AstPath(); 
        }
        return AstPathContext;
    })();
    Tools.AstPathContext = AstPathContext;
    
    (function(GetAstPathOptions) {
        GetAstPathOptions._map = []; 
        GetAstPathOptions.Default = 0; 
        GetAstPathOptions.EdgeInclusive = 1; 
        GetAstPathOptions.DontPruneSearchBasedOnPosition = 1 << 1; 
    })(Tools.GetAstPathOptions||(Tools.GetAstPathOptions={}));
    var GetAstPathOptions = Tools.GetAstPathOptions;

    function getAstPathToPosition(script, pos, options) {
        if (typeof options === "undefined") {options = GetAstPathOptions.Default; }
        var ctx = new AstPathContext(); 
        var lookInComments = function(comments) {
            if(comments && comments.length > 0) {
                for(var i = 0; i < comments.length; i++) {
                    var minChar = comments[i].minChar; 
                    var limChar = comments[i].limChar; 
                    if(!comments[i].isBlockComment) {
                        limChar++; 
                    }
                    if(pos >= minChar && pos < limChar) {
                        ctx.path.push(comments[i]); 
                    }
                }
            }
        }; 
        var pre = function(cur, parent, ctx) {
            if(isValidAstNode(cur)) {
                var inclusive = Tools.hasFlag(options, GetAstPathOptions.EdgeInclusive) || cur.nodeType === Tools.NodeType.Name; 
                var minChar = cur.minChar; 
                var limChar = cur.limChar + (inclusive ? 1 : 0); 
                if(pos >= minChar && pos < limChar) {
                    var previous = ctx.path.ast(); 
                    if(previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                        ctx.path.push(cur); 
                    } else  {
                    }
                }
                if(pos < limChar) {
                    lookInComments(cur.preComments); 
                }
                if(pos >= minChar) {
                    lookInComments(cur.postComments); 
                }
                if(!Tools.hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {
                    ctx.goChildren = (minChar <= pos && pos <= limChar); 
                }
            }
            return cur; 
        }; 
        script.walk(pre, null, null, ctx); 
        return ctx.path; 
    }
    Tools.getAstPathToPosition = getAstPathToPosition;
    function getTokenizationOffset(script, position) {
        var bestOffset = 0; 
        var context = new Tools.BaseWalkContext(); 
        var pre = function(cur, parent, context) {
            if(Tools.isValidAstNode(cur)) {
                if(cur.minChar < position) {
                    bestOffset = max(bestOffset, cur.minChar); 
                }
                if(cur.minChar > position || cur.limChar < bestOffset) {
                    context.goChildren = false; 
                }
            }
            return cur; 
        }; 
        script.walk(pre, null, script, context); 
        return bestOffset; 
    }
    Tools.getTokenizationOffset = getTokenizationOffset;
    function walkAST(ast, callback) {
        var path = new AstPath(); 
        var pre = function(cur, parent, ctx) {
            path.push(cur); 
            callback(path, ctx); 
            return cur; 
        }; 
        var post = function(cur, parent, ctx) {
            path.pop(); 
        }; 
        ast.walk(pre, post, null, new Tools.BaseWalkContext()); 
    }
    Tools.walkAST = walkAST;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var ASTEdit = (function () {
        function ASTEdit(ast1, ast2) {
            this.ast1 = ast1;
            this.ast2 = ast2;
        }
        return ASTEdit;
    })();
    Tools.ASTEdit = ASTEdit;
    
    var ASTComparer = (function () {
        function ASTComparer(script1, script2) {
            this.script1 = script1;
            this.script2 = script2;
        }
        ASTComparer.prototype.compareTopLevelTrees = function(oldScript, newScript) {
            return []; 
        };
        return ASTComparer;
    })();
    Tools.ASTComparer = ASTComparer;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var AstLogger = (function () {
        function AstLogger(logger) {
            this.logger = logger;
        }
        AstLogger.prototype.logScript = function(script) {
            var _self = this;
            this.logLinemap(script.locationInfo.lineMap); 
            var ctx = {
                goChildren: true,
                goNextSibling: true,
                reverseSiblings: false,
                stack: []
            }; 
            var pre = function(cur, parent, ctx) {
                ctx.stack.push(cur); 
                var indent = (ctx.stack.length - 1) * 2; 
                _self.logComments(script, cur.preComments, indent); 
                _self.logNode(script, cur, indent); 
                _self.logComments(script, cur.postComments, indent); 
                return cur; 
            }; 
            var post = function(cur, parent, ctx) {
                ctx.stack.pop(); 
                return cur; 
            }; 
            script.walk(pre, post, null, ctx); 
        };
        AstLogger.prototype.logNode = function(script, cur, indent) {
            var msg = this.addPadding("", indent, "| ", true); 
            msg = msg.concat("+ " + cur.treeViewLabel()); 
            msg = this.addPadding(msg, 70, " ", false); 
            msg = msg + this.addLineColumn(script, cur.minChar); 
            msg = this.addPadding(msg, 80, " ", false); 
            msg = msg + "=> "; 
            msg = msg + this.addLineColumn(script, cur.limChar); 
            msg = this.addPadding(msg, 102, " ", false); 
            msg = msg.concat(((("[" + this.addPadding(cur.minChar.toString(), 1, " ", true)) + ", ") + this.addPadding(cur.limChar.toString(), 1, " ", true)) + "]"); 
            msg = this.addPadding(msg, 115, " ", false); 
            msg = msg.concat("sym=" + (cur).sym); 
            msg = this.addPadding(msg, 135, " ", false); 
            msg = msg.concat("type=" + (cur.type === null ? "null" : cur.type.getTypeName())); 
            this.logger.log(msg); 
        };
        AstLogger.prototype.logComments = function(script, comments, indent) {
            if(comments == null) {
                return;
            }
            for(var i = 0; i < comments.length; i++) {
                this.logNode(script, comments[i], indent); 
            }
        };
        AstLogger.prototype.logLinemap = function(linemap) {
            var result = "["; 
            for(var i = 0; i < linemap.length; i++) {
                if(i > 0) {
                    result += ","; 
                }
                result += linemap[i]; 
            }
            result += "]"; 
            this.logger.log("linemap: " + result); 
        };
        AstLogger.prototype.addPadding = function(s, targetLength, paddingString, leftPadding) {
            var result = (leftPadding ? "" : s); 
            for(var i = s.length; i < targetLength; i++) {
                result = result + paddingString; 
            }
            result = result + (leftPadding ? s : ""); 
            return result; 
        };
        AstLogger.prototype.addLineColumn = function(script, position) {
            var lineInfo = {
                line: -1,
                col: -1
            }; 
            Tools.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap); 
            if(lineInfo.col !== -1) {
                lineInfo.col++; 
            }
            return ((("(" + lineInfo.line) + ", ") + lineInfo.col) + ")"; 
        };
        return AstLogger;
    })();
    Tools.AstLogger = AstLogger;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var Binder = (function () {
        function Binder(checker) {
            this.checker = checker;
        }
        Binder.prototype.resolveBaseTypeLinks = function(typeLinks, scope) {
            var extendsList = null; 
            if(typeLinks != null) {
                extendsList = new Array(); 
                for(var i = 0, len = typeLinks.length; i < len; i++) {
                    var typeLink = typeLinks[i]; 
                    this.checker.resolvingBases = true; 
                    this.checker.resolveTypeLink(scope, typeLink, true); 
                    this.checker.resolvingBases = false; 
                    if(typeLink.type.isClass()) {
                        extendsList[i] = typeLink.type.instanceType; 
                    } else  {
                        extendsList[i] = typeLink.type; 
                    }
                }
            }
            return extendsList; 
        };
        Binder.prototype.resolveBases = function(scope, type) {
            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope); 
            var i = 0; 
            var len = type.extendsList.length; 

            var derivedIsClass = type.isClassInstance(); 
            for(; i < len; i++) {
                var baseIsClass = type.extendsList[i].isClassInstance(); 
                if(type.extendsList[i] != this.checker.anyType) {
                    if(derivedIsClass) {
                        if(!baseIsClass) {
                            this.checker.errorReporter.simpleErrorFromSym(type.symbol, ("A export class may only extend other classes, " + type.extendsList[i].symbol.fullName()) + " is an interface."); 
                        }
                    } else  {
                        if(baseIsClass) {
                            this.checker.errorReporter.simpleErrorFromSym(type.symbol, ("An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName()) + " is a class."); 
                        }
                    }
                }
            }
            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope); 
            if(type.implementsList != null) {
                for(i = 0 , len = type.implementsList.length; i < len; i++) {
                    var iface = type.implementsList[i]; 
                    if(iface.isClassInstance()) {
                        if(derivedIsClass) {
                            this.checker.errorReporter.simpleErrorFromSym(type.symbol, ("A class may only implement an interface; " + iface.symbol.fullName()) + " is a class."); 
                        }
                    }
                }
            }
        };
        Binder.prototype.resolveSignatureGroup = function(signatureGroup, scope, instanceType) {
            var supplyVar = !(signatureGroup.hasImplementation); 
            for(var i = 0, len = signatureGroup.signatures.length; i < len; i++) {
                var signature = signatureGroup.signatures[i]; 
                if(instanceType != null) {
                    signature.returnType.type = instanceType; 
                } else  {
                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar); 
                }
                var paramLen = signature.parameters.length; 
                for(var j = 0; j < paramLen; j++) {
                    this.bindSymbol(scope, signature.parameters[j]); 
                }
                if(signature.hasVariableArgList) {
                    var lastParam = signature.parameters[paramLen - 1]; 
                    lastParam.argsOffset = paramLen - 1; 
                    if(!lastParam.getType().isArray()) {
                        this.checker.errorReporter.simpleErrorFromSym(lastParam, "... parameter must have array type"); 
                    }
                }
            }
        };
        Binder.prototype.bindType = function(scope, type, instanceType) {
            if(instanceType != null) {
                this.bindType(scope, instanceType, null); 
            }
            if(type.hasMembers()) {
                var members = type.members; 
                var ambientMembers = type.ambientMembers; 
                var typeMembers = type.getAllEnclosedTypes(); 
                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); 
                var memberScope = new Tools.SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol); 
                var agg = new Tools.SymbolAggregateScope(type.symbol); 
                var prevCurrentModDecl = this.checker.currentModDecl; 
                var prevBindStatus = this.checker.inBind; 
                agg.addParentScope(memberScope); 
                agg.addParentScope(scope); 
                if(type.isModuleType()) {
                    this.checker.currentModDecl = type.symbol.declAST; 
                    this.checker.inBind = true; 
                }
                if(members != null) {
                    this.bind(agg, type.members.allMembers); 
                }
                if(typeMembers != null) {
                    this.bind(agg, typeMembers.allMembers); 
                }
                if(ambientMembers != null) {
                    this.bind(agg, ambientMembers.allMembers); 
                }
                if(ambientTypeMembers != null) {
                    this.bind(agg, ambientTypeMembers.allMembers); 
                }
                this.checker.currentModDecl = prevCurrentModDecl; 
                this.checker.inBind = prevBindStatus; 
            }
            if(type.extendsTypeLinks != null) {
                this.resolveBases(scope, type); 
            }
            if(type.construct != null) {
                this.resolveSignatureGroup(type.construct, scope, instanceType); 
            }
            if(type.call != null) {
                this.resolveSignatureGroup(type.call, scope, null); 
            }
            if(type.index != null) {
                this.resolveSignatureGroup(type.index, scope, null); 
            }
            if(type.elementType != null) {
                this.bindType(scope, type.elementType, null); 
            }
        };
        Binder.prototype.bindSymbol = function(scope, symbol) {
            if(!symbol.bound) {
                var prevLocationInfo = this.checker.locationInfo; 
                if((this.checker.units != null) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {
                    this.checker.locationInfo = this.checker.units[symbol.unitIndex]; 
                }
                switch(symbol.kind()) {
                    case Tools.SymbolKind.Type: {
                        var typeSym = symbol; 
                        if(typeSym.type != this.checker.mod && !typeSym.isAlias) {
                            this.bindType(scope, typeSym.type, typeSym.instanceType); 
                            if(typeSym.type.isModuleType()) {
                                for(var i = 0; i < typeSym.expansions.length; i++) {
                                    this.bindType(scope, typeSym.expansions[i], typeSym.instanceType); 
                                }
                            }
                        }
                        break;

                    }
                    case Tools.SymbolKind.Field: {
                        this.checker.resolveTypeLink(scope, (symbol).field.typeLink, false); 
                        break;

                    }
                    case Tools.SymbolKind.Parameter: {
                        this.checker.resolveTypeLink(scope, (symbol).parameter.typeLink, true); 
                        break;

                    }
                }
                this.checker.locationInfo = prevLocationInfo; 
            }
            symbol.bound = true; 
        };
        Binder.prototype.bind = function(scope, table) {
            table.map(function(key, sym, binder) {
                binder.bindSymbol(scope, sym); 
            }, this); 
        };
        return Binder;
    })();
    Tools.Binder = Binder;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var Base64Format = (function () {
        function Base64Format() {}
        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/';
        Base64Format.encode = function encode(inValue) {
            if(inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue); 
            }
            throw TypeError(inValue + ": not a 64 based value");
        }
        return Base64Format;
    })();
    
    var Base64VLQFormat = (function () {
        function Base64VLQFormat() {}
        Base64VLQFormat.encode = function encode(inValue) {
            if(inValue < 0) {
                inValue = ((-inValue) << 1) + 1; 
            } else  {
                inValue = inValue << 1; 
            }
            var encodedStr = ""; 
            do {
                var currentDigit = inValue & 31; 
                inValue = inValue >> 5; 
                if(inValue > 0) {
                    currentDigit = currentDigit | 32; 
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit); 
            }while(inValue > 0)
            return encodedStr; 
        }
        return Base64VLQFormat;
    })();
    Tools.Base64VLQFormat = Base64VLQFormat;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var SourceMapping = (function () {
        function SourceMapping(ast) {

            this.parent = -1; 
            this.firstChild = -1; 
        }
        return SourceMapping;
    })();
    Tools.SourceMapping = SourceMapping;
    
    var SourceMapper = (function () {
        function SourceMapper(strFileName, jsFileName, jsFile, sourceMapOut) {
            this.jsFile = jsFile;
            this.sourceMapOut = sourceMapOut;

            this.sourceMappings = new Array(); 
            this.currentMapping = -1; 
            this.jsFileName = Tools.getPrettyName(jsFileName, false, true); 
            this.strFileName = Tools.getPrettyName(strFileName, false, true); 
        }
        SourceMapper.MapFileExtension = ".map";
        SourceMapper.CanEmitMapping = function CanEmitMapping(sourceMappings, currentMapping) {
            if(currentMapping.firstChild !== -1) {
                var childMapping = sourceMappings[currentMapping.firstChild]; 
                if(childMapping.emittedStartLine === currentMapping.emittedStartLine && childMapping.emittedStartColumn === currentMapping.emittedStartColumn) {
                    return false; 
                }
            }
            return true; 
        }
        SourceMapper.EmitSourceMapping = function EmitSourceMapping(allSourceMappers) {
            var sourceMapper = allSourceMappers[0]; 
            sourceMapper.jsFile.WriteLine(("//@ sourceMappingURL=" + sourceMapper.jsFileName) + SourceMapper.MapFileExtension); 
            var sourceMapOut = sourceMapper.sourceMapOut; 
            var mappingsString = ""; 
            var strFiles = []; 
            var prevEmittedColumn = 0; 
            var prevEmittedLine = 0; 
            var prevSourceColumn = 0; 
            var prevSourceLine = 0; 
            var prevSourceIndex = 0; 
            for(var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {
                sourceMapper = allSourceMappers[sourceMapperIndex]; 
                if(sourceMapper.sourceMappings != null) {
                    var currentSourceIndex = strFiles.length; 
                    strFiles.push(sourceMapper.strFileName); 
                    var sourceMappings = sourceMapper.sourceMappings; 
                    for(var i = 0, len = sourceMappings.length; i < len; i++) {
                        var sourceMapping = sourceMappings[i]; 
                        if(!SourceMapper.CanEmitMapping(sourceMappings, sourceMapping)) {
                            continue;
                        }
                        if(prevEmittedLine !== sourceMapping.emittedStartLine) {
                            prevEmittedColumn = 0; 
                            while(prevEmittedLine < sourceMapping.emittedStartLine) {
                                mappingsString = mappingsString + ";"; 
                                prevEmittedLine++; 
                            }
                        } else  {
                            if(i > 0) {
                                mappingsString = mappingsString + ","; 
                            }
                        }
                        mappingsString = mappingsString + Tools.Base64VLQFormat.encode(sourceMapping.emittedStartColumn - prevEmittedColumn); 
                        prevEmittedColumn = sourceMapping.emittedStartColumn; 
                        mappingsString = mappingsString + Tools.Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex); 
                        prevSourceIndex = currentSourceIndex; 
                        mappingsString = mappingsString + Tools.Base64VLQFormat.encode((sourceMapping.sourceStartLine - 1) - prevSourceLine); 
                        prevSourceLine = sourceMapping.sourceStartLine - 1; 
                        mappingsString = mappingsString + Tools.Base64VLQFormat.encode(sourceMapping.sourceStartColumn - prevSourceColumn); 
                        prevSourceColumn = sourceMapping.sourceStartColumn; 
                    }
                }
            }
            if(mappingsString != "") {
                sourceMapOut.Write('{'); 
                sourceMapOut.Write('"version":3,'); 
                sourceMapOut.Write(('"file":"' + sourceMapper.jsFileName) + '",'); 
                sourceMapOut.Write(('"sources":["' + strFiles.join('","')) + '"],'); 
                sourceMapOut.Write('"names":[],'); 
                sourceMapOut.Write('"mappings":"' + mappingsString); 
                sourceMapOut.Write('"'); 
                sourceMapOut.Write('}'); 
            }
            sourceMapOut.Close(); 
        }
        return SourceMapper;
    })();
    Tools.SourceMapper = SourceMapper;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    (function(EmitContainer) {
        EmitContainer._map = []; 
        EmitContainer._map[0] = "Prog"; 
        EmitContainer.Prog = 0; 
        EmitContainer._map[1] = "Module"; 
        EmitContainer.Module = 1; 
        EmitContainer._map[2] = "DynamicModule"; 
        EmitContainer.DynamicModule = 2; 
        EmitContainer._map[3] = "OldClass"; 
        EmitContainer.OldClass = 3; 
        EmitContainer._map[4] = "ES6Class"; 
        EmitContainer.ES6Class = 4; 
        EmitContainer._map[5] = "Constructor"; 
        EmitContainer.Constructor = 5; 
        EmitContainer._map[6] = "Function"; 
        EmitContainer.Function = 6; 
        EmitContainer._map[7] = "Args"; 
        EmitContainer.Args = 7; 
        EmitContainer._map[8] = "Interface"; 
        EmitContainer.Interface = 8; 
    })(Tools.EmitContainer||(Tools.EmitContainer={}));
    var EmitContainer = Tools.EmitContainer;

    var EmitState = (function () {
        function EmitState() {

            this.indentAmt = 0; 
            this.column = 0; 
            this.line = 0; 
            this.pretty = false; 
            this.inObjectLiteral = false; 
            this.container = EmitContainer.Prog; 
        }
        return EmitState;
    })();
    Tools.EmitState = EmitState;
    
    var Emitter = (function () {
        function Emitter(checker, outfile, emitOptions) {
            this.checker = checker;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.prologueEmitted = false; 
            this.indentStep = 4; 
            this.thisClassNode = null; 
            this.thisFnc = null; 
            this.moduleDeclList = []; 
            this.moduleName = ""; 
            this.emitState = new EmitState(); 
            this.indentStrings = []; 
            this.ambientModule = false; 
            this.modAliasId = null; 
            this.firstModAlias = null; 
            this.allSourceMappers = []; 
            this.sourceMapper = null; 
        }
        Emitter.prototype.setSourceMappings = function(mapper) {
            this.allSourceMappers.push(mapper); 
            this.sourceMapper = mapper; 
        };
        Emitter.prototype.increaseIndent = function() {
            this.emitState.indentAmt += this.indentStep; 
        };
        Emitter.prototype.decreaseIndent = function() {
            this.emitState.indentAmt -= this.indentStep; 
        };
        Emitter.prototype.writeToOutput = function(s) {
            this.outfile.Write(s); 
            this.emitState.column += s.length; 
        };
        Emitter.prototype.writeToOutputTrimmable = function(s) {
            if(this.emitOptions.minWhitespace) {
                s = s.replace(/[\s]*/g, ''); 
            }
            this.writeToOutput(s); 
        };
        Emitter.prototype.writeLineToOutput = function(s) {
            if(this.emitOptions.minWhitespace) {
                this.writeToOutput(s); 
                var c = s.charCodeAt(s.length - 1); 
                if(!((c == Tools.LexCodeSpace) || (c == Tools.LexCodeSMC) || (c == Tools.LexCodeLBR))) {
                    this.writeToOutput(' '); 
                }
            } else  {
                this.outfile.WriteLine(s); 
                this.emitState.column = 0; 
                this.emitState.line++; 
            }
        };
        Emitter.prototype.setInObjectLiteral = function(val) {
            var temp = this.emitState.inObjectLiteral; 
            this.emitState.inObjectLiteral = val; 
            return temp; 
        };
        Emitter.prototype.setContainer = function(c) {
            var temp = this.emitState.container; 
            this.emitState.container = c; 
            return temp; 
        };
        Emitter.prototype.emitIndent = function() {
            if(this.emitOptions.minWhitespace) {
            } else  {
                var indentString = this.indentStrings[this.emitState.indentAmt]; 
                if(indentString === undefined) {
                    indentString = ""; 
                    for(var i = 0; i < this.emitState.indentAmt; i++) {
                        indentString += " "; 
                    }
                    this.indentStrings[this.emitState.indentAmt] = indentString; 
                }
                this.writeToOutput(indentString); 
            }
        };
        Emitter.prototype.emitCommentInPlace = function(comment) {
            this.recordSourceMappingStart(comment); 
            var text = comment.getText(); 
            var hadNewLine = false; 
            if(comment.isBlockComment) {
                if(this.emitState.column == 0) {
                    this.emitIndent(); 
                }
                this.writeToOutput(text[0]); 
                if(text.length > 1 || comment.endsLine) {
                    this.writeLineToOutput(""); 
                    for(var i = 1; i < text.length; i++) {
                        this.emitIndent(); 
                        this.writeLineToOutput(text[i]); 
                    }
                    hadNewLine = true; 
                }
            } else  {
                if(this.emitState.column == 0) {
                    this.emitIndent(); 
                }
                this.writeLineToOutput(text[0]); 
                hadNewLine = true; 
            }
            if(hadNewLine) {
                this.emitIndent(); 
            } else  {
                this.writeToOutput(" "); 
            }
            this.recordSourceMappingEnd(comment); 
        };
        Emitter.prototype.emitParensAndCommentsInPlace = function(ast, pre) {
            var comments = pre ? ast.preComments : ast.postComments; 
            if(ast.isParenthesized && !pre) {
                this.writeToOutput(")"); 
            }
            if(this.emitOptions.emitComments && comments != null && comments.length != 0) {
                for(var i = 0; i < comments.length; i++) {
                    this.emitCommentInPlace(comments[i]); 
                }
            }
            if(ast.isParenthesized && pre) {
                this.writeToOutput("("); 
            }
        };
        Emitter.prototype.emitObjectLiteral = function(content) {
            this.writeLineToOutput("{"); 
            this.increaseIndent(); 
            var inObjectLiteral = this.setInObjectLiteral(true); 
            this.emitJavascriptList(content, ",", Tools.TokenID.Comma, true, false, false); 
            this.setInObjectLiteral(inObjectLiteral); 
            this.decreaseIndent(); 
            this.emitIndent(); 
            this.writeToOutput("}"); 
        };
        Emitter.prototype.emitArrayLiteral = function(content) {
            this.writeToOutput("["); 
            if(content != null) {
                this.writeToOutput(""); 
                this.increaseIndent(); 
                this.emitJavascriptList(content, ", ", Tools.TokenID.Comma, true, false, false); 
                this.decreaseIndent(); 
            }
            this.writeToOutput("]"); 
        };
        Emitter.prototype.emitNew = function(target, args) {
            this.recordSourceMappingStart(target); 
            this.writeToOutput("new "); 
            if(target.nodeType == Tools.NodeType.TypeRef) {
                this.writeToOutput("Array()"); 
            } else  {
                this.emitJavascript(target, Tools.TokenID.Tilde, false); 
                this.writeToOutput("("); 
                this.emitJavascriptList(args, ", ", Tools.TokenID.Comma, false, false, false); 
                this.writeToOutput(")"); 
            }
            this.recordSourceMappingEnd(target); 
        };
        Emitter.prototype.tryEmitConstant = function(dotExpr) {
            if(!this.emitOptions.propagateConstants) {
                return false; 
            }
            var propertyName = dotExpr.operand2; 
            if((propertyName != null) && (propertyName.sym != null) && (propertyName.sym.isVariable())) {
                if(Tools.hasFlag(propertyName.sym.flags, Tools.SymbolFlags.Constant)) {
                    if(propertyName.sym.declAST != null) {
                        var boundDecl = propertyName.sym.declAST; 
                        if((boundDecl.init != null) && (boundDecl.init.nodeType == Tools.NodeType.NumberLit)) {
                            var numLit = boundDecl.init; 
                            this.writeToOutput(numLit.value.toString()); 
                            var comment = " /* "; 
                            comment += propertyName.text; 
                            comment += " */ "; 
                            this.writeToOutput(comment); 
                            return true; 
                        }
                    }
                }
            }
            return false; 
        };
        Emitter.prototype.emitCall = function(callNode, target, args) {
            if(!this.emitSuperCall(callNode)) {
                if(!Tools.hasFlag(callNode.flags, Tools.ASTFlags.ES6ClassBaseConstructorCall)) {
                    if(target.nodeType == Tools.NodeType.FuncDecl) {
                        this.writeToOutput("("); 
                    }
                    this.emitJavascript(target, Tools.TokenID.LParen, false); 
                    if(target.nodeType == Tools.NodeType.FuncDecl) {
                        this.writeToOutput(")"); 
                    }
                    this.writeToOutput("("); 
                    this.emitJavascriptList(args, ", ", Tools.TokenID.Comma, false, false, false); 
                    this.writeToOutput(")"); 
                } else  {
                    this.decreaseIndent(); 
                    this.decreaseIndent(); 
                    this.emitConstructorCalls((this.thisClassNode).baseConstructorCall, this.thisClassNode); 
                    this.increaseIndent(); 
                    this.increaseIndent(); 
                }
            }
        };
        Emitter.prototype.defaultValue = function(type) {
            if(type == this.checker.anyType) {
                return "undefined"; 
            } else  {
                if(type == this.checker.doubleType) {
                    return "0"; 
                } else  {
                    if(type == this.checker.stringType) {
                        return '""'; 
                    } else  {
                        if(type == this.checker.booleanType) {
                            return "false"; 
                        } else  {
                            return "null"; 
                        }
                    }
                }
            }
        };
        Emitter.prototype.emitConstructorCalls = function(bases, classDecl) {
            if(bases == null) {
                return;
            }
            var basesLen = bases.members.length; 
            this.recordSourceMappingStart(classDecl); 
            for(var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i]; 
                var baseSymbol = null; 
                if(baseExpr.nodeType == Tools.NodeType.Call) {
                    baseSymbol = (baseExpr).target.type.symbol; 
                } else  {
                    baseSymbol = baseExpr.type.symbol; 
                }
                var baseName = baseSymbol.name; 
                if(baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName(); 
                }
                if(baseExpr.nodeType == Tools.NodeType.Call) {
                    this.emitIndent(); 
                    var callEx = baseExpr; 
                    this.writeToOutput(classDecl.name.text + "._super.constructor"); 
                    this.writeToOutput(".call(this"); 
                    var args = callEx.args; 
                    if((args != null) && (args.members.length > 0)) {
                        this.writeToOutput(", "); 
                        this.emitJavascriptList(args, ", ", Tools.TokenID.Comma, false, false, false); 
                    }
                    this.writeLineToOutput(");"); 
                } else  {
                    if((baseExpr.type != null) && (baseExpr.type.isClassInstance())) {
                        this.emitIndent(); 
                        this.writeToOutput(classDecl.name.text + "._super.constructor"); 
                        this.writeLineToOutput(".call(this);"); 
                    }
                }
            }
            this.recordSourceMappingEnd(classDecl); 
        };
        Emitter.prototype.emitInnerFunction = function(funcDecl, printName, isProtoMember, bases, hasSelfRef, classDecl) {
            var isES6ClassConstructor = funcDecl.isConstructor && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod); 
            var hasNonObjectBaseType = isES6ClassConstructor && Tools.hasFlag(this.thisClassNode.type.instanceType.typeFlags, Tools.TypeFlags.HasBaseType) && !Tools.hasFlag(this.thisClassNode.type.instanceType.typeFlags, Tools.TypeFlags.HasBaseTypeOfObject); 
            var es6PropertiesMustComeAfterSuperCall = hasNonObjectBaseType && Tools.hasFlag((this.thisClassNode).varFlags, Tools.VarFlags.ES6ClassSuperMustBeFirstCallInConstructor); 
            this.emitParensAndCommentsInPlace(funcDecl, true); 
            this.recordSourceMappingStart(funcDecl); 
            if(!(funcDecl.isAccessor() && (funcDecl.accessorSymbol).isObjectLitField)) {
                this.writeToOutput("function"); 
            }
            if(printName) {
                var id = funcDecl.getNameText(); 
                if(id != null && !funcDecl.isAccessor()) {
                    this.writeToOutput(" " + id); 
                }
            }
            this.writeToOutput("("); 
            var argsLen = 0; 
            var i = 0; 
            var arg; 
            var defaultArgs = []; 
            if(funcDecl.args != null) {
                var tempContainer = this.setContainer(EmitContainer.Args); 
                argsLen = funcDecl.args.members.length; 
                var printLen = argsLen; 
                if(funcDecl.variableArgList) {
                    printLen--; 
                }
                for(i = 0; i < printLen; i++) {
                    arg = funcDecl.args.members[i]; 
                    if(arg.init != null) {
                        defaultArgs.push(arg); 
                    }
                    this.emitJavascript(arg, Tools.TokenID.LParen, false); 
                    if(i < (printLen - 1)) {
                        this.writeToOutput(", "); 
                    }
                }
                this.setContainer(tempContainer); 
            }
            this.writeLineToOutput(") {"); 
            this.increaseIndent(); 
            for(i = 0; i < defaultArgs.length; i++) {
                var arg = defaultArgs[i]; 
                this.emitIndent(); 
                this.recordSourceMappingStart(arg); 
                this.writeToOutput(("if (typeof " + arg.id.text) + " === \"undefined\") {"); 
                this.recordSourceMappingStart(arg.id); 
                this.writeToOutput(arg.id.text); 
                this.recordSourceMappingEnd(arg.id); 
                this.writeToOutput(" = "); 
                this.emitJavascript(arg.init, Tools.TokenID.LParen, false); 
                this.writeLineToOutput("; }"); 
                this.recordSourceMappingEnd(arg); 
            }
            if(funcDecl.isConstructor && !es6PropertiesMustComeAfterSuperCall) {
                if(funcDecl.args != null) {
                    argsLen = funcDecl.args.members.length; 
                    for(i = 0; i < argsLen; i++) {
                        arg = funcDecl.args.members[i]; 
                        if((arg.varFlags & Tools.VarFlags.Property) != Tools.VarFlags.None) {
                            this.emitIndent(); 
                            this.recordSourceMappingStart(arg); 
                            this.recordSourceMappingStart(arg.id); 
                            this.writeToOutput("this." + arg.id.text); 
                            this.recordSourceMappingEnd(arg.id); 
                            this.writeToOutput(" = "); 
                            this.recordSourceMappingStart(arg.id); 
                            this.writeToOutput(arg.id.text); 
                            this.recordSourceMappingEnd(arg.id); 
                            this.writeLineToOutput(";"); 
                            this.recordSourceMappingEnd(arg); 
                        }
                    }
                }
                if(!Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod)) {
                    this.emitConstructorCalls(bases, classDecl); 
                }
            }
            if(hasSelfRef) {
                this.emitIndent(); 
                this.writeLineToOutput("var _self = this;"); 
            }
            if(funcDecl.variableArgList) {
                argsLen = funcDecl.args.members.length; 
                var lastArg = funcDecl.args.members[argsLen - 1]; 
                this.emitIndent(); 
                this.recordSourceMappingStart(lastArg); 
                this.writeToOutput("var "); 
                this.recordSourceMappingStart(lastArg.id); 
                this.writeToOutput(lastArg.id.text); 
                this.recordSourceMappingEnd(lastArg.id); 
                this.writeLineToOutput(" = [];"); 
                this.recordSourceMappingEnd(lastArg); 
                this.emitIndent(); 
                this.writeLineToOutput(("for (var _i = 0; _i < (arguments.length - " + (argsLen - 1)) + "); _i++) {"); 
                this.increaseIndent(); 
                this.emitIndent(); 
                this.writeLineToOutput(((lastArg.id.text + "[_i] = arguments[_i+") + (argsLen - 1)) + "];"); 
                this.decreaseIndent(); 
                this.emitIndent(); 
                this.writeLineToOutput("}"); 
            }
            if(funcDecl.isConstructor && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod) && !es6PropertiesMustComeAfterSuperCall) {
                var nProps = (this.thisClassNode.members).members.length; 
                for(var i = 0; i < nProps; i++) {
                    if((this.thisClassNode.members).members[i].nodeType == Tools.NodeType.VarDecl) {
                        var varDecl = (this.thisClassNode.members).members[i]; 
                        if(!Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Static) && varDecl.init) {
                            this.writeLineToOutput(""); 
                            this.emitIndent(); 
                            this.emitJavascriptVarDecl(varDecl, Tools.TokenID.Tilde); 
                        }
                    }
                }
                this.writeLineToOutput(""); 
            }
            this.emitBareJavascriptStatements(funcDecl.bod, es6PropertiesMustComeAfterSuperCall); 
            this.decreaseIndent(); 
            this.emitIndent(); 
            this.writeToOutput("}"); 
            if(!isProtoMember && !Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.IsFunctionExpression) && (Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Definition) || funcDecl.isConstructor)) {
                this.writeLineToOutput(""); 
            }
            if(!funcDecl.isConstructor && (funcDecl.statics.members.length > 0 || funcDecl.innerStaticFuncs.length > 0)) {
                this.writeLineToOutput(""); 
                this.emitIndent(); 
                var funcName = funcDecl.getNameText(); 
                this.writeLineToOutput(("(function(" + funcName) + ") {"); 
                this.increaseIndent(); 
                var len = 0; 
                var i = 0; 
                len = funcDecl.innerStaticFuncs.length; 
                for(i = 0; i < len; i++) {
                    var innerFunc = funcDecl.innerStaticFuncs[i]; 
                    if(innerFunc.isOverload) {
                        continue;
                    }
                    this.emitIndent(); 
                    if(innerFunc.isAccessor()) {
                        this.emitPropertyAccessor(innerFunc, funcDecl.name.text, false); 
                    } else  {
                        this.writeToOutput(((funcName + ".") + innerFunc.name.text) + " = "); 
                        this.emitInnerFunction(innerFunc, (innerFunc.name != null && !innerFunc.name.isMissing()), false, null, innerFunc.hasSelfReference(), null); 
                    }
                }
                if(funcDecl.statics != null) {
                    this.recordSourceMappingStart(funcDecl.statics); 
                    len = funcDecl.statics.members.length; 
                    for(i = 0; i < len; i++) {
                        this.emitIndent(); 
                        this.writeToOutput(funcName); 
                        this.emitJavascript(funcDecl.statics.members[i], Tools.TokenID.Tilde, false); 
                        this.writeLineToOutput(""); 
                    }
                    this.recordSourceMappingEnd(funcDecl.statics); 
                }
                this.decreaseIndent(); 
                this.emitIndent(); 
                var printProto = isProtoMember && (this.thisClassNode != null); 
                var prefix = printProto ? this.thisClassNode.name.text + ".prototype." : ""; 
                this.writeLineToOutput((("})(" + prefix) + funcName) + ");"); 
            }
            this.recordSourceMappingEnd(funcDecl); 
            this.emitParensAndCommentsInPlace(funcDecl, false); 
        };
        Emitter.prototype.emitTypeList = function(list) {
            if(list != null) {
                if(list.nodeType == Tools.NodeType.List) {
                    for(var i = 0, len = list.members.length; i < len; i++) {
                        var emitNode = list.members[i]; 
                        emitNode.emitType(this); 
                    }
                } else  {
                    list.emitType(this); 
                }
            }
        };
        Emitter.prototype.emitEnumMemberList = function(enumMembers) {
            this.recordSourceMappingStart(enumMembers); 
            for(var i = 0, len = enumMembers.members.length; i < len; i++) {
                var emitNode = enumMembers.members[i]; 
                if(emitNode.nodeType == Tools.NodeType.VarDecl) {
                    var varDecl = emitNode; 
                    if(varDecl.id.text != "_map") {
                        this.emitIndent(); 
                        this.writeLineToOutput(varDecl.id.text + ", "); 
                    }
                }
            }
            this.recordSourceMappingEnd(enumMembers); 
        };
        Emitter.prototype.emitEnumType = function(moduleDecl) {
            this.writeLineToOutput(("enum " + moduleDecl.name.text) + " {"); 
            this.increaseIndent(); 
            this.emitEnumMemberList(moduleDecl.members); 
            this.decreaseIndent(); 
            this.emitIndent(); 
            this.writeLineToOutput("}"); 
        };
        Emitter.prototype.emitArgTypes = function(args, indexer) {
            if((args != null) && (args.members.length > 0)) {
                if(indexer) {
                    this.writeToOutput("["); 
                } else  {
                    this.writeToOutput("("); 
                }
                for(var j = 0, argsLen = args.members.length; j < argsLen; j++) {
                    var arg = args.members[j]; 
                    if(j > 0) {
                        this.writeToOutput(", "); 
                    }
                    if(Tools.hasFlag(arg.varFlags, Tools.VarFlags.Property)) {
                        this.writeToOutput("property "); 
                    }
                    if(arg.type == null) {
                        arg.type = this.checker.anyType; 
                    }
                    this.writeToOutput((arg.id.text + ": ") + arg.type.getTypeName()); 
                }
                if(indexer) {
                    this.writeToOutput("]"); 
                } else  {
                    this.writeToOutput(")"); 
                }
            }
        };
        Emitter.prototype.emitFuncType = function(funcDecl) {
            this.emitIndent(); 
            if(this.emitState.container != EmitContainer.Interface) {
                this.writeToOutput("function "); 
            }
            if(funcDecl.isConstructMember()) {
                this.writeToOutput("new"); 
            } else  {
                if(funcDecl.isCallMember() || funcDecl.isIndexerMember()) {
                } else  {
                    this.writeToOutput(funcDecl.getNameText()); 
                }
            }
            if(funcDecl.isSignature()) {
                this.writeLineToOutput(funcDecl.signature.toString() + ";"); 
            } else  {
                this.emitArgTypes(funcDecl.args, funcDecl.isIndexerMember()); 
                if((funcDecl.args == null) || (funcDecl.args.members.length == 0)) {
                    this.writeToOutput("()"); 
                }
                if(funcDecl.signature.returnType.type == null) {
                    funcDecl.signature.returnType.type = this.checker.anyType; 
                }
                this.writeLineToOutput((": " + funcDecl.signature.returnType.type.getTypeName()) + ";"); 
            }
        };
        Emitter.prototype.emitVarType = function(varDecl) {
            this.emitIndent(); 
            if(this.emitState.container != EmitContainer.Interface) {
                this.writeToOutput("property "); 
            }
            var type = this.checker.anyType; 
            if(varDecl.typeExpr != null) {
                type = varDecl.typeExpr.type; 
            } else  {
                if(varDecl.sym != null) {
                    type = (varDecl.sym).getType(); 
                    if(type == null) {
                        type = this.checker.anyType; 
                    }
                }
            }
            this.writeLineToOutput(((varDecl.id.text + ": ") + type.getTypeName()) + ";"); 
        };
        Emitter.prototype.emitBaseList = function(bases, qual) {
            if((bases != null) && (bases.members.length > 0)) {
                this.writeToOutput((" " + qual) + " "); 
                var basesLen = bases.members.length; 
                for(var i = 0; i < basesLen; i++) {
                    var baseExpr = bases.members[i]; 
                    var baseSymbol; 
                    if(baseExpr.nodeType == Tools.NodeType.Call) {
                        baseSymbol = (baseExpr).target.type.symbol; 
                    } else  {
                        baseSymbol = baseExpr.type.symbol; 
                    }
                    var baseName = baseSymbol.name; 
                    if(i > 0) {
                        this.writeToOutput(", "); 
                    }
                    this.writeToOutput(baseName); 
                }
            }
        };
        Emitter.prototype.emitBaseTypes = function(typeDecl) {
            this.emitBaseList(typeDecl.extendsList, "extends"); 
            this.emitBaseList(typeDecl.implementsList, "implements"); 
        };
        Emitter.prototype.emitInterfaceType = function(interfaceDecl) {
            this.emitIndent(); 
            this.writeToOutput("interface " + interfaceDecl.name.text); 
            this.emitBaseTypes(interfaceDecl); 
            this.writeLineToOutput(" {"); 
            this.increaseIndent(); 
            var temp = this.setContainer(EmitContainer.Interface); 
            this.emitTypeList(interfaceDecl.members); 
            this.setContainer(temp); 
            this.decreaseIndent(); 
            this.emitIndent(); 
            this.writeLineToOutput("}"); 
        };
        Emitter.prototype.emitClassType = function(classDecl) {
            this.emitIndent(); 
            this.writeToOutput("class " + classDecl.name.text); 
            this.emitArgTypes(classDecl.args, false); 
            this.emitBaseTypes(classDecl); 
            this.writeLineToOutput(" {"); 
            this.increaseIndent(); 
            var constrDecl = classDecl.members; 
            this.emitTypeList(constrDecl.bod); 
            this.decreaseIndent(); 
            this.emitIndent(); 
            this.writeLineToOutput("}"); 
        };
        Emitter.prototype.emitModuleType = function(moduleDecl) {
            var svAmbientModule = this.ambientModule; 
            this.ambientModule = true; 
            this.emitIndent(); 
            if(!svAmbientModule) {
                this.writeToOutput("declare "); 
            }
            if(Tools.hasFlag(moduleDecl.modFlags, Tools.ModuleFlags.IsEnum)) {
                this.emitEnumType(moduleDecl); 
            } else  {
                this.writeLineToOutput(("module " + moduleDecl.name.text) + " {"); 
                this.increaseIndent(); 
                this.emitTypeList(moduleDecl.members); 
                this.decreaseIndent(); 
                this.emitIndent(); 
                this.writeLineToOutput("}"); 
            }
            this.ambientModule = svAmbientModule; 
        };
        Emitter.prototype.emitJavascriptModule = function(moduleDecl) {
            if(!moduleDecl.isAnonInnerMod) {
                var modName = moduleDecl.name.text; 
                if(modName.length > 4 && modName.substring(modName.length - 4, modName.length) == ".str") {
                    moduleDecl.name.text = modName.substring(0, modName.length - 4); 
                }
            }
            if(!Tools.hasFlag(moduleDecl.modFlags, Tools.ModuleFlags.Ambient)) {
                var temp = this.setContainer(EmitContainer.Module); 
                var svModuleName = this.moduleName; 
                var isExported = Tools.hasFlag(moduleDecl.modFlags, Tools.ModuleFlags.Exported); 
                var isDynamicMod = Tools.hasFlag(moduleDecl.modFlags, Tools.ModuleFlags.IsDynamic); 
                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl; 
                if(!moduleDecl.isAnonInnerMod) {
                    this.moduleName = moduleDecl.name.text; 
                }
                this.recordSourceMappingStart(moduleDecl); 
                if(isDynamicMod) {
                    var modFilePath = Tools.stripQuotes(moduleDecl.name.text) + ".js"; 
                    this.setContainer(EmitContainer.DynamicModule); 
                    if(Tools.moduleGenTarget == Tools.ModuleGenTarget.Asynchronous) {
                        var dependencyList = "[\"require\", \"exports\""; 
                        var importList = "require, exports"; 
                        var importStatement = null; 
                        for(var i = 0; i < (moduleDecl.mod).importedModules.length; i++) {
                            importStatement = (moduleDecl.mod).importedModules[i]; 
                            if(importStatement.id.sym != null && !(importStatement.id.sym).onlyReferencedAsTypeRef) {
                                if(i <= (moduleDecl.mod).importedModules.length - 1) {
                                    dependencyList += ", "; 
                                    importList += ", "; 
                                }
                                importList += ("__" + importStatement.id.text) + "__"; 
                                dependencyList += importStatement.firstAliasedModToString(); 
                            }
                        }
                        for(var i = 0; i < moduleDecl.amdDependencies.length; i++) {
                            dependencyList += (", \"" + moduleDecl.amdDependencies[i]) + "\""; 
                        }
                        dependencyList += "]"; 
                        this.writeLineToOutput((((("define(" + dependencyList) + ",") + " function(") + importList) + ") {"); 
                    } else  {
                    }
                } else  {
                    if(!isExported) {
                        this.writeLineToOutput(("var " + this.moduleName) + ";"); 
                        this.emitIndent(); 
                    }
                    if(moduleDecl.isAnonInnerMod) {
                        this.writeLineToOutput("(function() {"); 
                    } else  {
                        this.writeLineToOutput(("(function(" + this.moduleName) + ") {"); 
                    }
                }
                if(Tools.moduleGenTarget != Tools.ModuleGenTarget.Synchronous) {
                    this.increaseIndent(); 
                }
                this.emitJavascriptList(moduleDecl.members, null, Tools.TokenID.SColon, true, false, false); 
                if(Tools.moduleGenTarget != Tools.ModuleGenTarget.Synchronous) {
                    this.decreaseIndent(); 
                }
                this.emitIndent(); 
                if(isDynamicMod) {
                    if(Tools.moduleGenTarget == Tools.ModuleGenTarget.Asynchronous) {
                        this.writeLineToOutput("})"); 
                    } else  {
                    }
                } else  {
                    if(temp == EmitContainer.Prog && isExported) {
                        this.writeLineToOutput(((("})(this." + this.moduleName) + "||(this.") + this.moduleName) + "={}));"); 
                    } else  {
                        if(!moduleDecl.isAnonInnerMod && (isExported || temp == EmitContainer.Prog)) {
                            var dotMod = svModuleName != "" ? svModuleName + "." : svModuleName; 
                            this.writeLineToOutput(((((("})(" + dotMod) + this.moduleName) + "||(") + dotMod) + this.moduleName) + "={}));"); 
                        } else  {
                            if(!moduleDecl.isAnonInnerMod && (!isExported && temp != EmitContainer.Prog)) {
                                this.writeLineToOutput(((("})(" + this.moduleName) + "||(") + this.moduleName) + "={}));"); 
                            } else  {
                                this.writeLineToOutput("})();"); 
                            }
                        }
                    }
                    if(temp != EmitContainer.Prog && !moduleDecl.isAnonInnerMod && isExported) {
                        this.emitIndent(); 
                        this.writeLineToOutput(((((("var " + this.moduleName) + " = ") + svModuleName) + ".") + this.moduleName) + ";"); 
                    }
                }
                this.recordSourceMappingEnd(moduleDecl); 
                this.setContainer(temp); 
                this.moduleName = svModuleName; 
                this.moduleDeclList.length--; 
            }
        };
        Emitter.prototype.emitIndex = function(operand1, operand2) {
            var temp = this.setInObjectLiteral(false); 
            this.emitJavascript(operand1, Tools.TokenID.Tilde, false); 
            this.writeToOutput("["); 
            this.emitJavascriptList(operand2, ", ", Tools.TokenID.Comma, false, false, false); 
            this.writeToOutput("]"); 
            this.setInObjectLiteral(temp); 
        };
        Emitter.prototype.emitStringLiteral = function(text) {
            this.writeToOutput(text); 
        };
        Emitter.prototype.emitJavascriptFunction = function(funcDecl) {
            if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Signature) || funcDecl.isOverload) {
                return;
            }
            var temp; 
            var tempFnc = this.thisFnc; 
            this.thisFnc = funcDecl; 
            if(funcDecl.isConstructor) {
                temp = this.setContainer(EmitContainer.Constructor); 
            } else  {
                temp = this.setContainer(EmitContainer.Function); 
            }
            var bases = null; 
            var hasSelfRef = false; 
            var funcName = funcDecl.getNameText(); 
            if((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) && ((temp != EmitContainer.Constructor) || ((funcDecl.fncFlags & Tools.FncFlags.Method) == Tools.FncFlags.None))) {
                var tempLit = this.setInObjectLiteral(false); 
                if(this.thisClassNode != null) {
                    bases = this.thisClassNode.extendsList; 
                }
                hasSelfRef = funcDecl.hasSelfReference(); 
                this.recordSourceMappingStart(funcDecl); 
                if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Exported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {
                    this.writeToOutput(("this." + funcName) + " = "); 
                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode); 
                } else  {
                    this.emitInnerFunction(funcDecl, (funcDecl.name != null && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode); 
                }
                this.recordSourceMappingEnd(funcDecl); 
                this.setInObjectLiteral(tempLit); 
            }
            this.setContainer(temp); 
            this.thisFnc = tempFnc; 
            if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Definition)) {
                if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Static)) {
                    if(this.thisClassNode != null) {
                        if(funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.text, false); 
                        } else  {
                            this.emitIndent(); 
                            this.recordSourceMappingStart(funcDecl); 
                            this.writeLineToOutput(((((this.thisClassNode.name.text + ".") + funcName) + " = ") + funcName) + ";"); 
                            this.recordSourceMappingEnd(funcDecl); 
                        }
                    }
                } else  {
                    if((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Exported)) {
                        this.emitIndent(); 
                        var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : "exports"; 
                        this.recordSourceMappingStart(funcDecl); 
                        this.writeLineToOutput(((((modName + ".") + funcName) + " = ") + funcName) + ";"); 
                        this.recordSourceMappingEnd(funcDecl); 
                    }
                }
            }
        };
        Emitter.prototype.emitAmbientVarDecl = function(varDecl) {
            if(varDecl.init != null) {
                this.emitParensAndCommentsInPlace(varDecl, true); 
                this.recordSourceMappingStart(varDecl); 
                this.recordSourceMappingStart(varDecl.id); 
                this.writeToOutput(varDecl.id.text); 
                this.recordSourceMappingEnd(varDecl.id); 
                this.writeToOutput(" = "); 
                this.emitJavascript(varDecl.init, Tools.TokenID.Comma, false); 
                this.recordSourceMappingEnd(varDecl); 
                this.writeToOutput("; "); 
                this.emitParensAndCommentsInPlace(varDecl, false); 
            }
        };
        Emitter.prototype.emitForVarList = function(varDeclList) {
            if(varDeclList != null) {
                this.recordSourceMappingStart(varDeclList); 
                var len = varDeclList.members.length; 
                for(var i = 0; i < len; i++) {
                    var varDecl = varDeclList.members[i]; 
                    this.emitJavascriptVarDecl(varDecl, (i == 0) ? Tools.TokenID.FOR : Tools.TokenID.LParen); 
                    if(i < (len - 1)) {
                        this.writeToOutput(", "); 
                    }
                }
                this.recordSourceMappingEnd(varDeclList); 
            }
        };
        Emitter.prototype.emitJavascriptVarDecl = function(varDecl, tokenId) {
            if((varDecl.varFlags & Tools.VarFlags.Ambient) == Tools.VarFlags.Ambient) {
                this.emitAmbientVarDecl(varDecl); 
            } else  {
                var sym = varDecl.sym; 
                var hasInitializer = (varDecl.init != null); 
                this.emitParensAndCommentsInPlace(varDecl, true); 
                this.recordSourceMappingStart(varDecl); 
                if((sym != null) && (sym.isMember()) && (sym.container != null) && (sym.container.kind() == Tools.SymbolKind.Type)) {
                    var type = (sym.container).type; 
                    if(type.isClass() && (!Tools.hasFlag(sym.flags, Tools.SymbolFlags.ModuleMember))) {
                        if(this.emitState.container != EmitContainer.Args) {
                            if(Tools.hasFlag(sym.flags, Tools.SymbolFlags.Static)) {
                                this.writeToOutput(sym.container.name + "."); 
                            } else  {
                                this.writeToOutput("this."); 
                            }
                        }
                    } else  {
                        if(type.hasImplementation()) {
                            if(!Tools.hasFlag(sym.flags, Tools.SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !Tools.hasFlag(sym.flags, Tools.SymbolFlags.Property))) {
                                this.writeToOutput("var "); 
                            } else  {
                                if(Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.LocalStatic)) {
                                    this.writeToOutput("."); 
                                } else  {
                                    if(this.emitState.container == EmitContainer.DynamicModule) {
                                        this.writeToOutput("exports."); 
                                    } else  {
                                        this.writeToOutput(this.moduleName + "."); 
                                    }
                                }
                            }
                        } else  {
                            if(tokenId != Tools.TokenID.LParen) {
                                if(Tools.hasFlag(sym.flags, Tools.SymbolFlags.Exported) && sym.container == this.checker.gloMod) {
                                    this.writeToOutput("this."); 
                                } else  {
                                    this.writeToOutput("var "); 
                                }
                            }
                        }
                    }
                } else  {
                    if(tokenId != Tools.TokenID.LParen) {
                        this.writeToOutput("var "); 
                    }
                }
                this.recordSourceMappingStart(varDecl.id); 
                this.writeToOutput(varDecl.id.text); 
                this.recordSourceMappingEnd(varDecl.id); 
                if(hasInitializer) {
                    this.writeToOutputTrimmable(" = "); 
                    this.emitJavascript(varDecl.init, Tools.TokenID.Comma, false); 
                } else  {
                    if((sym != null) && (sym.isMember()) && (this.emitState.container == EmitContainer.Constructor)) {
                        this.writeToOutputTrimmable(" = "); 
                        this.writeToOutput(this.defaultValue(varDecl.type)); 
                    }
                }
                if((tokenId != Tools.TokenID.FOR) && (tokenId != Tools.TokenID.LParen)) {
                    this.writeToOutputTrimmable("; "); 
                }
                this.recordSourceMappingEnd(varDecl); 
            }
            this.emitParensAndCommentsInPlace(varDecl, false); 
        };
        Emitter.prototype.declEnclosed = function(moduleDecl) {
            if(moduleDecl == null) {
                return true; 
            }
            for(var i = 0, len = this.moduleDeclList.length; i < len; i++) {
                if(this.moduleDeclList[i] == moduleDecl) {
                    return true; 
                }
            }
            return false; 
        };
        Emitter.prototype.emitJavascriptName = function(name, addThis) {
            var sym = name.sym; 
            this.emitParensAndCommentsInPlace(name, true); 
            this.recordSourceMappingStart(name); 
            if(!name.isMissing()) {
                if(addThis && (this.emitState.container != EmitContainer.Args) && (sym != null)) {
                    if((sym.container != null) && (sym.container.name != Tools.globalId)) {
                        if(Tools.hasFlag(sym.flags, Tools.SymbolFlags.Static) && (Tools.hasFlag(sym.flags, Tools.SymbolFlags.Property))) {
                            if(sym.declModule != null && Tools.hasFlag(sym.declModule.modFlags, Tools.ModuleFlags.IsDynamic)) {
                                this.writeToOutput("exports."); 
                            } else  {
                                this.writeToOutput(sym.container.name + "."); 
                            }
                        } else  {
                            if(sym.kind() == Tools.SymbolKind.Field) {
                                var fieldSym = sym; 
                                if(Tools.hasFlag(fieldSym.flags, Tools.SymbolFlags.ModuleMember)) {
                                    if((sym.container != this.checker.gloMod) && ((Tools.hasFlag(sym.flags, Tools.SymbolFlags.Property)) || Tools.hasFlag(sym.flags, Tools.SymbolFlags.Exported))) {
                                        if(sym.declModule.isAnonInnerMod) {
                                            this.writeToOutput(sym.declModule.anonParentMod.name.text + "."); 
                                        } else  {
                                            if(Tools.hasFlag(sym.declModule.modFlags, Tools.ModuleFlags.IsDynamic)) {
                                                this.writeToOutput("exports."); 
                                            } else  {
                                                this.writeToOutput(sym.container.name + "."); 
                                            }
                                        }
                                    }
                                } else  {
                                    if(sym.isInstanceProperty()) {
                                        if((this.thisFnc != null) && (!this.thisFnc.isMethod()) && (!this.thisFnc.isConstructor)) {
                                            this.writeToOutput("_self."); 
                                        } else  {
                                            this.writeToOutput("this."); 
                                        }
                                    }
                                }
                            } else  {
                                if(sym.kind() == Tools.SymbolKind.Type) {
                                    if(sym.isInstanceProperty()) {
                                        var typeSym = sym; 
                                        var type = typeSym.type; 
                                        if((type.call != null) && (!Tools.hasFlag(sym.flags, Tools.SymbolFlags.ModuleMember))) {
                                            if((this.thisFnc != null) && (!this.thisFnc.isMethod()) && (!this.thisFnc.isConstructor)) {
                                                this.writeToOutput("_self."); 
                                            } else  {
                                                this.writeToOutput("this."); 
                                            }
                                        }
                                    } else  {
                                        if((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {
                                            this.writeToOutput(sym.container.name + "."); 
                                        }
                                    }
                                }
                            }
                        }
                    } else  {
                        if(sym.container == this.checker.gloMod && Tools.hasFlag(sym.flags, Tools.SymbolFlags.Exported) && !((sym.isType() || sym.isMember()) && sym.declModule != null && Tools.hasFlag(sym.declModule.modFlags, Tools.ModuleFlags.Ambient)) && this.emitState.container == EmitContainer.Prog && sym.declAST.nodeType != Tools.NodeType.FuncDecl) {
                            this.writeToOutput("this."); 
                        }
                    }
                }
                if(sym != null && sym.declAST != null && sym.declAST.nodeType == Tools.NodeType.Module && (Tools.hasFlag((sym.declAST).modFlags, Tools.ModuleFlags.IsDynamic))) {
                    var moduleDecl = sym.declAST; 
                    if(Tools.moduleGenTarget == Tools.ModuleGenTarget.Asynchronous) {
                        this.writeLineToOutput(("__" + this.modAliasId) + "__;"); 
                    } else  {
                        var modPath = name.text; 
                        var isAmbient = moduleDecl.mod.symbol.declAST != null && Tools.hasFlag((moduleDecl.mod.symbol.declAST).modFlags, Tools.ModuleFlags.Ambient); 
                        modPath = isAmbient ? modPath : this.firstModAlias != null ? this.firstModAlias : Tools.quoteBaseName(modPath); 
                        modPath = isAmbient ? modPath : (!Tools.isRelative(Tools.stripQuotes(modPath)) ? Tools.quoteStr("./" + Tools.stripQuotes(modPath)) : modPath); 
                        this.writeToOutput(("require(" + modPath) + ")"); 
                    }
                } else  {
                    this.writeToOutput(name.text); 
                }
            }
            this.recordSourceMappingEnd(name); 
            this.emitParensAndCommentsInPlace(name, false); 
        };
        Emitter.prototype.emitJavascriptStatements = function(stmts, emitEmptyBod, newlineAfterBlock) {
            if(stmts != null) {
                if(stmts.nodeType != Tools.NodeType.Block) {
                    this.recordSourceMappingStart(stmts); 
                    this.writeLineToOutput(" {"); 
                    this.increaseIndent(); 
                    this.emitJavascriptList(stmts, null, Tools.TokenID.SColon, true, false, false); 
                    this.writeLineToOutput(""); 
                    this.decreaseIndent(); 
                    this.emitIndent(); 
                    this.writeToOutput("}"); 
                    this.recordSourceMappingEnd(stmts); 
                } else  {
                    this.emitJavascript(stmts, Tools.TokenID.SColon, true); 
                }
            } else  {
                if(emitEmptyBod) {
                    this.writeToOutput("{ }"); 
                }
            }
        };
        Emitter.prototype.emitBareJavascriptStatements = function(stmts, emitES6ClassPropertiesAfterSuperCall) {
            if(stmts.nodeType != Tools.NodeType.Block) {
                if(stmts.nodeType == Tools.NodeType.List) {
                    var stmtList = stmts; 
                    if((stmtList.members.length == 2) && (stmtList.members[0].nodeType == Tools.NodeType.Block) && (stmtList.members[1].nodeType == Tools.NodeType.EndCode)) {
                        this.emitJavascript(stmtList.members[0], Tools.TokenID.SColon, true); 
                        this.writeLineToOutput(""); 
                    } else  {
                        this.emitJavascriptList(stmts, null, Tools.TokenID.SColon, true, false, emitES6ClassPropertiesAfterSuperCall); 
                    }
                } else  {
                    this.emitJavascript(stmts, Tools.TokenID.SColon, true); 
                }
            } else  {
                this.emitJavascript(stmts, Tools.TokenID.SColon, true); 
            }
        };
        Emitter.prototype.recordSourceMappingStart = function(ast) {
            if((this.sourceMapper != null) && (ast != null)) {
                var lineCol = {
                    line: -1,
                    col: -1
                }; 
                var sourceMapping = new Tools.SourceMapping(ast); 
                sourceMapping.emittedStartColumn = this.emitState.column; 
                sourceMapping.emittedStartLine = this.emitState.line; 
                Tools.getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap); 
                sourceMapping.sourceStartColumn = lineCol.col; 
                sourceMapping.sourceStartLine = lineCol.line; 
                Tools.getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap); 
                sourceMapping.sourceEndColumn = lineCol.col; 
                sourceMapping.sourceEndLine = lineCol.line; 
                sourceMapping.parent = this.sourceMapper.currentMapping; 
                this.sourceMapper.currentMapping = this.sourceMapper.sourceMappings.length; 
                this.sourceMapper.sourceMappings.push(sourceMapping); 
                if(sourceMapping.parent >= 0) {
                    var parentMapping = this.sourceMapper.sourceMappings[sourceMapping.parent]; 
                    if(parentMapping.firstChild == -1) {
                        parentMapping.firstChild = this.sourceMapper.currentMapping; 
                    }
                }
            }
        };
        Emitter.prototype.recordSourceMappingEnd = function(ast) {
            if((this.sourceMapper != null) && (ast != null)) {
                var currentMappingIndex = this.sourceMapper.currentMapping; 
                var sourceMapping = this.sourceMapper.sourceMappings[currentMappingIndex]; 
                sourceMapping.emittedEndColumn = this.emitState.column; 
                sourceMapping.emittedEndLine = this.emitState.line; 
                this.sourceMapper.currentMapping = sourceMapping.parent; 
            }
        };
        Emitter.prototype.emitSourceMappings = function() {
            Tools.SourceMapper.EmitSourceMapping(this.allSourceMappers); 
        };
        Emitter.prototype.emitJavascriptList = function(ast, delimiter, tokenId, startLine, onlyStatics, emitES6ClassPropertiesAfterSuperCall) {
            if(ast == null) {
                return;
            } else  {
                if(ast.nodeType != Tools.NodeType.List) {
                    this.emitJavascript(ast, tokenId, startLine); 
                } else  {
                    this.emitParensAndCommentsInPlace(ast, true); 
                    var list = ast; 
                    var len = list.members.length; 
                    for(var i = 0; i < len; i++) {
                        if(i == 1 && emitES6ClassPropertiesAfterSuperCall) {
                            var constructorDecl = (this.thisClassNode).constructorDecl; 
                            if(constructorDecl && constructorDecl.args != null) {
                                var argsLen = constructorDecl.args.members.length; 
                                for(var iArg = 0; iArg < argsLen; iArg++) {
                                    var arg = constructorDecl.args.members[iArg]; 
                                    if((arg.varFlags & Tools.VarFlags.Property) != Tools.VarFlags.None) {
                                        this.emitIndent(); 
                                        this.recordSourceMappingStart(arg); 
                                        this.recordSourceMappingStart(arg.id); 
                                        this.writeToOutput("this." + arg.id.text); 
                                        this.recordSourceMappingEnd(arg.id); 
                                        this.writeToOutput(" = "); 
                                        this.recordSourceMappingStart(arg.id); 
                                        this.writeToOutput(arg.id.text); 
                                        this.recordSourceMappingEnd(arg.id); 
                                        this.writeLineToOutput(";"); 
                                        this.recordSourceMappingEnd(arg); 
                                    }
                                }
                            }
                            var nProps = (this.thisClassNode.members).members.length; 
                            for(var iMember = 0; iMember < nProps; iMember++) {
                                if((this.thisClassNode.members).members[iMember].nodeType == Tools.NodeType.VarDecl) {
                                    var varDecl = (this.thisClassNode.members).members[iMember]; 
                                    if(!Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Static) && varDecl.init) {
                                        this.writeLineToOutput(""); 
                                        this.emitIndent(); 
                                        this.emitJavascriptVarDecl(varDecl, Tools.TokenID.Tilde); 
                                    }
                                }
                            }
                            this.writeLineToOutput(""); 
                        }
                        var emitNode = list.members[i]; 
                        var isStaticDecl = (emitNode.nodeType == Tools.NodeType.FuncDecl && Tools.hasFlag((emitNode).fncFlags, Tools.FncFlags.Static)) || (emitNode.nodeType == Tools.NodeType.VarDecl && Tools.hasFlag((emitNode).varFlags, Tools.VarFlags.Static)); 
                        if(onlyStatics ? !isStaticDecl : isStaticDecl) {
                            continue;
                        }
                        this.emitJavascript(emitNode, tokenId, startLine); 
                        if((delimiter != null) && (i < (len - 1))) {
                            if(startLine) {
                                this.writeLineToOutput(delimiter); 
                            } else  {
                                this.writeToOutput(delimiter); 
                            }
                        } else  {
                            if(startLine && (emitNode.nodeType != Tools.NodeType.Interface) && (!((emitNode.nodeType == Tools.NodeType.VarDecl) && ((((emitNode).varFlags) & Tools.VarFlags.Ambient) == Tools.VarFlags.Ambient) && (((emitNode).init) == null))) && (emitNode.nodeType != Tools.NodeType.EndCode) && (emitNode.nodeType != Tools.NodeType.FuncDecl)) {
                                this.writeLineToOutput(""); 
                            }
                        }
                    }
                    this.emitParensAndCommentsInPlace(ast, false); 
                }
            }
        };
        Emitter.prototype.emitJavascript = function(ast, tokenId, startLine) {
            if(ast == null) {
                return;
            }
            var parenthesize = false; 
            if(startLine && (this.emitState.indentAmt > 0) && (ast.nodeType != Tools.NodeType.List) && (ast.nodeType != Tools.NodeType.Block)) {
                if((ast.nodeType != Tools.NodeType.Interface) && (!((ast.nodeType == Tools.NodeType.VarDecl) && ((((ast).varFlags) & Tools.VarFlags.Ambient) == Tools.VarFlags.Ambient) && (((ast).init) == null))) && (ast.nodeType != Tools.NodeType.EndCode) && ((ast.nodeType != Tools.NodeType.FuncDecl) || (this.emitState.container != EmitContainer.Constructor))) {
                    this.emitIndent(); 
                }
            }
            var binopNodeTokenId = Tools.nodeTypeToTokTable[ast.nodeType]; 
            if(binopNodeTokenId != undefined) {
                var tokenInfo = Tools.tokenTable[tokenId]; 
                var prec = tokenInfo.unopPrecedence; 
                if(prec != Tools.OperatorPrecedence.No) {
                    parenthesize = !ast.isParenthesized && ast.nodeType != Tools.NodeType.Dot; 
                } else  {
                    prec = tokenInfo.binopPrecedence; 
                    var binopTokInfo = Tools.tokenTable[binopNodeTokenId]; 
                    parenthesize = !ast.isParenthesized && prec > binopTokInfo.binopPrecedence; 
                }
            }
            if(parenthesize) {
                this.writeToOutput("("); 
            }
            ast.emit(this, tokenId, startLine); 
            if(parenthesize) {
                this.writeToOutput(")"); 
            }
            if((tokenId == Tools.TokenID.SColon) && (ast.nodeType < Tools.NodeType.GeneralNode)) {
                this.writeToOutput("; "); 
            }
        };
        Emitter.prototype.emitPropertyAccessor = function(funcDecl, className, isProto) {
            if(!(funcDecl.accessorSymbol).hasBeenEmitted) {
                var accessorSymbol = funcDecl.accessorSymbol; 
                this.recordSourceMappingStart(funcDecl); 
                this.writeLineToOutput(("Object.defineProperty(" + className) + (isProto ? ".prototype," : ",")); 
                this.increaseIndent(); 
                this.emitIndent(); 
                this.writeLineToOutput((("\"" + funcDecl.name.text) + "\"") + ","); 
                this.emitIndent(); 
                if(accessorSymbol.getter != null) {
                    var getter = accessorSymbol.getter.declAST; 
                    this.writeLineToOutput("{ get: "); 
                    this.increaseIndent(); 
                    this.emitIndent(); 
                    this.emitInnerFunction(getter, false, isProto, null, funcDecl.hasSelfReference(), null); 
                    this.writeLineToOutput(","); 
                    this.decreaseIndent(); 
                    this.emitIndent(); 
                }
                if(accessorSymbol.setter != null) {
                    var setter = accessorSymbol.setter.declAST; 
                    this.writeLineToOutput(" set: "); 
                    this.increaseIndent(); 
                    this.emitIndent(); 
                    this.emitInnerFunction(setter, false, isProto, null, funcDecl.hasSelfReference(), null); 
                    this.writeLineToOutput(","); 
                    this.decreaseIndent(); 
                    this.emitIndent(); 
                }
                this.writeLineToOutput("enumerable: true,"); 
                this.emitIndent(); 
                this.writeLineToOutput("configurable: true });"); 
                this.recordSourceMappingEnd(funcDecl); 
                this.decreaseIndent(); 
                accessorSymbol.hasBeenEmitted = true; 
            }
        };
        Emitter.prototype.emitPrototypeMember = function(member, className) {
            if(member.nodeType == Tools.NodeType.FuncDecl) {
                var funcDecl = member; 
                if(funcDecl.isAccessor()) {
                    this.emitPropertyAccessor(funcDecl, className, true); 
                } else  {
                    this.emitIndent(); 
                    this.recordSourceMappingStart(funcDecl); 
                    this.writeToOutput(((className + ".prototype.") + funcDecl.getNameText()) + " = "); 
                    this.emitInnerFunction(funcDecl, false, true, null, funcDecl.hasSelfReference(), null); 
                    this.recordSourceMappingEnd(funcDecl); 
                    this.writeLineToOutput(";"); 
                }
            } else  {
                if(member.nodeType == Tools.NodeType.VarDecl) {
                    var varDecl = member; 
                    if(varDecl.init != null) {
                        this.emitIndent(); 
                        this.recordSourceMappingStart(varDecl); 
                        this.recordSourceMappingStart(varDecl.id); 
                        this.writeToOutput((className + ".prototype.") + varDecl.id.text); 
                        this.recordSourceMappingEnd(varDecl.id); 
                        this.writeToOutput(" = "); 
                        this.emitJavascript(varDecl.init, Tools.TokenID.Asg, false); 
                        this.recordSourceMappingEnd(varDecl); 
                        this.writeLineToOutput(";"); 
                    }
                }
            }
        };
        Emitter.prototype.emitAddBaseMethods = function(className, base, classDecl) {
            if(base.members != null) {
                var baseSymbol = base.symbol; 
                var baseName = baseSymbol.name; 
                if(baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName(); 
                }
                base.members.allMembers.map(function(key, s, c) {
                    var sym = s; 
                    if((sym.kind() == Tools.SymbolKind.Type) && ((sym).type.call != null)) {
                        this.recordSourceMappingStart(sym.declAST); 
                        this.writeLineToOutput(((((((className + ".prototype.") + sym.name) + " = ") + baseName) + ".prototype.") + sym.name) + ";"); 
                        this.recordSourceMappingEnd(sym.declAST); 
                    }
                }, null); 
            }
            if(base.extendsList != null) {
                for(var i = 0, len = base.extendsList.length; i < len; i++) {
                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl); 
                }
            }
        };
        Emitter.prototype.emitJavascriptES6Class = function(classDecl) {
            if(!Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Ambient)) {
                var svClassNode = this.thisClassNode; 
                var i = 0; 
                this.thisClassNode = classDecl; 
                var className = classDecl.name.text; 
                this.emitParensAndCommentsInPlace(classDecl, true); 
                this.recordSourceMappingStart(classDecl); 
                if(Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {
                    this.writeLineToOutput(("this." + className) + " = (function () {"); 
                } else  {
                    this.writeLineToOutput(("var " + className) + " = (function () {"); 
                }
                this.increaseIndent(); 
                var temp = this.setContainer(EmitContainer.ES6Class); 
                var _class = classDecl.type; 
                var instanceType = _class.instanceType; 
                var baseClass = instanceType ? instanceType.baseClass() : null; 
                var baseNameDecl = null; 
                var baseName = null; 
                if(baseClass != null) {
                    baseNameDecl = classDecl.extendsList.members[0]; 
                    baseName = baseNameDecl.nodeType == Tools.NodeType.Call ? (baseNameDecl).target : baseNameDecl; 
                    this.emitIndent(); 
                    this.writeToOutput(("_inheritsFrom(" + className) + ", "); 
                    this.emitJavascript(baseName, Tools.TokenID.Tilde, false); 
                    this.writeLineToOutput(");"); 
                    var elen = instanceType.extendsList.length; 
                    if(elen > 1) {
                        for(var i = 1; i < elen; i++) {
                            var base = instanceType.extendsList[i]; 
                            this.emitAddBaseMethods(className, base, classDecl); 
                        }
                    }
                }
                this.emitIndent(); 
                var constrDecl = classDecl.constructorDecl; 
                if(constrDecl) {
                    this.emitJavascript(classDecl.constructorDecl, Tools.TokenID.LParen, false); 
                } else  {
                    var wroteProps = 0; 
                    this.recordSourceMappingStart(classDecl); 
                    this.increaseIndent(); 
                    this.writeToOutput(("function " + classDecl.name.text) + "() {"); 
                    if(baseClass) {
                        this.writeLineToOutput(""); 
                        this.emitIndent(); 
                        this.emitJavascript(baseName, Tools.TokenID.Tilde, false); 
                        this.writeLineToOutput(".apply(this, arguments);"); 
                        wroteProps++; 
                    }
                    var nProps = (this.thisClassNode.members).members.length; 
                    for(var i = 0; i < nProps; i++) {
                        if((this.thisClassNode.members).members[i].nodeType == Tools.NodeType.VarDecl) {
                            var varDecl = (this.thisClassNode.members).members[i]; 
                            if(!Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Static) && varDecl.init) {
                                this.writeLineToOutput(""); 
                                this.emitIndent(); 
                                this.emitJavascriptVarDecl(varDecl, Tools.TokenID.Tilde); 
                                wroteProps++; 
                            }
                        }
                    }
                    if(wroteProps) {
                        this.writeLineToOutput(""); 
                        this.decreaseIndent(); 
                        this.emitIndent(); 
                    } else  {
                        this.decreaseIndent(); 
                    }
                    this.writeLineToOutput("}"); 
                    this.recordSourceMappingEnd(classDecl); 
                }
                var membersLen = classDecl.definitionMembers.members.length; 
                for(var j = 0; j < membersLen; j++) {
                    var memberDecl = classDecl.definitionMembers.members[j]; 
                    if(memberDecl.nodeType == Tools.NodeType.FuncDecl) {
                        var fn = memberDecl; 
                        if(Tools.hasFlag(fn.fncFlags, Tools.FncFlags.Method) && !fn.isSignature()) {
                            if(!Tools.hasFlag(fn.fncFlags, Tools.FncFlags.Static)) {
                                this.emitPrototypeMember(fn, className); 
                            } else  {
                                if(fn.isAccessor()) {
                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.text, false); 
                                } else  {
                                    this.emitIndent(); 
                                    this.recordSourceMappingStart(fn); 
                                    this.writeToOutput(((classDecl.name.text + ".") + fn.name.text) + " = "); 
                                    this.emitInnerFunction(fn, (fn.name != null && !fn.name.isMissing()), false, null, fn.hasSelfReference(), null); 
                                    this.recordSourceMappingEnd(fn); 
                                }
                            }
                        }
                    } else  {
                        if(memberDecl.nodeType == Tools.NodeType.VarDecl) {
                            var varDecl = memberDecl; 
                            if(Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Static)) {
                                this.emitIndent(); 
                                this.recordSourceMappingStart(varDecl); 
                                this.writeToOutput(((classDecl.name.text + ".") + varDecl.id.text) + " = "); 
                                if(varDecl.init != null) {
                                    this.emitJavascript(varDecl.init, Tools.TokenID.Asg, false); 
                                    this.writeLineToOutput(";"); 
                                } else  {
                                    this.writeLineToOutput(this.defaultValue(varDecl.type) + ";"); 
                                }
                                this.recordSourceMappingEnd(varDecl); 
                            }
                        }
                    }
                }
                this.emitIndent(); 
                this.recordSourceMappingStart(classDecl); 
                this.writeLineToOutput(("return " + className) + ";"); 
                this.recordSourceMappingEnd(classDecl); 
                this.decreaseIndent(); 
                this.emitIndent(); 
                this.writeLineToOutput("})();"); 
                if((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Exported)) {
                    this.emitIndent(); 
                    var modName = temp == EmitContainer.Module ? this.moduleName : "exports"; 
                    this.recordSourceMappingStart(classDecl); 
                    this.writeLineToOutput(((((modName + ".") + className) + " = ") + className) + ";"); 
                    this.recordSourceMappingEnd(classDecl); 
                }
                this.emitIndent(); 
                this.recordSourceMappingEnd(classDecl); 
                this.emitParensAndCommentsInPlace(classDecl, false); 
                this.setContainer(temp); 
                this.thisClassNode = svClassNode; 
            }
        };
        Emitter.prototype.emitJavascriptClass = function(classDecl) {
            if(!Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Ambient) && !classDecl.isOverload) {
                var svClassNode = this.thisClassNode; 
                var i = 0; 
                this.thisClassNode = classDecl; 
                var className = classDecl.name.text; 
                this.emitParensAndCommentsInPlace(classDecl, true); 
                this.recordSourceMappingStart(classDecl); 
                if(Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {
                    this.writeLineToOutput(("this." + className) + " = (function () {"); 
                } else  {
                    this.writeLineToOutput(("var " + className) + " = (function () {"); 
                }
                this.increaseIndent(); 
                var temp = this.setContainer(EmitContainer.OldClass); 
                var _class = classDecl.type; 
                var instanceType = _class.instanceType; 
                var baseClass = instanceType ? instanceType.baseClass() : null; 
                if(baseClass != null) {
                    var baseNameDecl = classDecl.extendsList.members[0]; 
                    var baseName = baseNameDecl.nodeType == Tools.NodeType.Call ? (baseNameDecl).target : baseNameDecl; 
                    this.emitIndent(); 
                    this.writeToOutput(("_inheritsFrom(" + className) + ", "); 
                    this.emitJavascript(baseName, Tools.TokenID.Tilde, false); 
                    this.writeLineToOutput(");"); 
                    var elen = instanceType.extendsList.length; 
                    if(elen > 1) {
                        for(var i = 1; i < elen; i++) {
                            var base = instanceType.extendsList[i]; 
                            this.emitAddBaseMethods(className, base, classDecl); 
                        }
                    }
                }
                this.emitIndent(); 
                this.emitJavascript(classDecl.members, Tools.TokenID.LParen, false); 
                this.emitJavascriptList((classDecl.members).bod, null, Tools.TokenID.SColon, true, true, false); 
                var constrDecl = classDecl.members; 
                var fns = constrDecl.scopes; 
                var fnsLen = fns.members.length; 
                for(var j = 0; j < fnsLen; j++) {
                    var fn = fns.members[j]; 
                    if(Tools.hasFlag(fn.fncFlags, Tools.FncFlags.Method) && (!Tools.hasFlag(fn.fncFlags, Tools.FncFlags.Static)) && (!fn.isSignature())) {
                        this.emitPrototypeMember(fn, className); 
                    }
                }
                this.emitIndent(); 
                this.recordSourceMappingStart(classDecl); 
                this.writeLineToOutput(("return " + className) + ";"); 
                this.recordSourceMappingEnd(classDecl); 
                this.decreaseIndent(); 
                this.emitIndent(); 
                this.writeLineToOutput("})();"); 
                if((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Exported)) {
                    this.emitIndent(); 
                    var modName = temp == EmitContainer.Module ? this.moduleName : "exports"; 
                    this.recordSourceMappingStart(classDecl); 
                    this.writeLineToOutput(((((modName + ".") + className) + " = ") + className) + ";"); 
                    this.recordSourceMappingEnd(classDecl); 
                }
                this.emitIndent(); 
                this.recordSourceMappingEnd(classDecl); 
                this.emitParensAndCommentsInPlace(classDecl, false); 
                this.setContainer(temp); 
                this.thisClassNode = svClassNode; 
            }
        };
        Emitter.prototype.emitPrologue = function(reqInherits) {
            if(!this.prologueEmitted) {
                if(reqInherits) {
                    this.prologueEmitted = true; 
                    this.writeLineToOutput("if (!(this._inheritsFrom)) {"); 
                    this.writeLineToOutput("    this._inheritsFrom=function(childCtor, parentCtor) {"); 
                    this.writeLineToOutput("        function Beget() { this.constructor = childCtor; }"); 
                    this.writeLineToOutput("        childCtor._super = parentCtor.prototype;"); 
                    this.writeLineToOutput("        Beget.prototype = parentCtor.prototype;"); 
                    this.writeLineToOutput("        childCtor.prototype = new Beget();"); 
                    this.writeLineToOutput("    }"); 
                    this.writeLineToOutput("}"); 
                    this.writeLineToOutput("var _inheritsFrom = this._inheritsFrom;"); 
                }
            }
        };
        Emitter.prototype.emitSuperReference = function() {
            if(this.thisClassNode != null) {
                this.writeToOutput(this.thisClassNode.name.text + "._super"); 
            } else  {
                this.writeToOutput("this._super"); 
            }
        };
        Emitter.prototype.emitSuperCall = function(callEx) {
            if(callEx.target.nodeType == Tools.NodeType.Dot) {
                var dotNode = callEx.target; 
                if(dotNode.operand1.nodeType == Tools.NodeType.Super) {
                    this.emitJavascript(dotNode, Tools.TokenID.LParen, false); 
                    this.writeToOutput(".call(this"); 
                    if(callEx.args != null) {
                        this.writeToOutput(", "); 
                        this.emitJavascriptList(callEx.args, ", ", Tools.TokenID.Comma, false, false, false); 
                    }
                    this.writeToOutput(")"); 
                    return true; 
                }
            }
            return false; 
        };
        return Emitter;
    })();
    Tools.Emitter = Emitter;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var ErrorReporter = (function () {
        function ErrorReporter(outfile) {
            this.outfile = outfile;
            this.parser = null; 
            this.checker = null; 
            this.lineCol = {
                line: 0,
                col: 0
            }; 
            this.emitAsComments = true; 
        }
        ErrorReporter.prototype.setErrOut = function(outerr) {
            this.outfile = outerr; 
            this.emitAsComments = false; 
        };
        ErrorReporter.prototype.emitPrefix = function() {
            if(this.emitAsComments) {
                this.outfile.Write("// "); 
            }
            this.outfile.Write(((((this.checker.locationInfo.filename + "(") + this.lineCol.line) + ",") + this.lineCol.col) + "): "); 
        };
        ErrorReporter.prototype.writePrefix = function(ast) {
            if(ast != null) {
                this.setError(ast); 
            } else  {
                this.lineCol.line = -1; 
                this.lineCol.col = -1; 
            }
            this.emitPrefix(); 
        };
        ErrorReporter.prototype.writePrefixFromSym = function(symbol) {
            if((symbol != null) && (this.checker.locationInfo.lineMap != null)) {
                Tools.getSourceLineColFromMap(this.lineCol, symbol.location, this.checker.locationInfo.lineMap); 
            } else  {
                this.lineCol.line = -1; 
                this.lineCol.col = -1; 
            }
            this.emitPrefix(); 
        };
        ErrorReporter.prototype.setError = function(ast) {
            if(ast != null) {
                ast.flags |= Tools.ASTFlags.Error; 
                if(this.checker.locationInfo.lineMap != null) {
                    Tools.getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap); 
                }
            }
        };
        ErrorReporter.prototype.reportError = function(ast, message) {
            var len = (ast.limChar - ast.minChar); 
            if(this.parser.errorRecovery && this.parser.errorCallback != null) {
                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex); 
            } else  {
                this.writePrefix(ast); 
                this.outfile.WriteLine(message); 
            }
        };
        ErrorReporter.prototype.reportErrorFromSym = function(symbol, message) {
            if(this.parser.errorRecovery && this.parser.errorCallback != null) {
                this.parser.errorCallback(symbol.location, 1, message, this.checker.locationInfo.unitIndex); 
            } else  {
                this.writePrefixFromSym(symbol); 
                this.outfile.WriteLine(message); 
            }
        };
        ErrorReporter.prototype.interfaceDeclNotImpl = function(t1, t2) {
            this.reportErrorFromSym(t2.symbol, ((("Class " + t2.getTypeName()) + " declares interface ") + t1.getTypeName()) + " but does not implement it"); 
        };
        ErrorReporter.prototype.duplicateIdentifier = function(ast, name) {
            this.reportError(ast, "Duplicate identifier " + name); 
        };
        ErrorReporter.prototype.showRef = function(ast, text, symbol) {
            var defLineCol = {
                line: -1,
                col: -1
            }; 
            this.parser.getSourceLineCol(defLineCol, symbol.location); 
            this.reportError(ast, ((((("symbol " + text) + " defined at (") + defLineCol.line) + ",") + defLineCol.col) + ")"); 
        };
        ErrorReporter.prototype.unresolvedSymbol = function(ast, name) {
            this.reportError(ast, "Unresolved symbol " + name); 
        };
        ErrorReporter.prototype.typeExpected = function(symbol) {
            this.reportErrorFromSym(symbol, ("Expected " + symbol.name) + " to be a type"); 
        };
        ErrorReporter.prototype.symbolDoesNotReferToAValue = function(ast, name) {
            this.reportError(ast, ("Symbol " + name) + " does not refer to a value"); 
        };
        ErrorReporter.prototype.styleError = function(ast, msg) {
            this.reportError(ast, "STYLE: " + msg); 
        };
        ErrorReporter.prototype.simpleError = function(ast, msg) {
            this.reportError(ast, msg); 
        };
        ErrorReporter.prototype.simpleErrorFromSym = function(sym, msg) {
            this.reportErrorFromSym(sym, msg); 
        };
        ErrorReporter.prototype.invalidThisReference = function(ast) {
            this.simpleError(ast, "Invalid this reference"); 
        };
        ErrorReporter.prototype.invalidSuperReference = function(ast) {
            this.simpleError(ast, "Invalid super reference"); 
        };
        ErrorReporter.prototype.valueCannotBeModified = function(ast) {
            this.simpleError(ast, "Illegal lhs of assignment expression"); 
        };
        ErrorReporter.prototype.invalidCall = function(ast, nodeType) {
            var opString = (nodeType == Tools.NodeType.Call) ? "call" : "new"; 
            var catString = (nodeType == Tools.NodeType.Call) ? "function" : "class"; 
            this.reportError(ast, (("Target of " + opString) + " is not var or ") + catString); 
        };
        ErrorReporter.prototype.indexLHS = function(ast) {
            this.simpleError(ast, "Illegal lhs of index expression"); 
        };
        ErrorReporter.prototype.incompatibleTypes = function(ast, t1, t2, op, scope) {
            if(t1 == null) {
                t1 = this.checker.anyType; 
            }
            if(t2 == null) {
                t2 = this.checker.anyType; 
            }
            var reason = ""; 
            if(op != null) {
                this.reportError(ast, (((((op + " can not be applied to types ") + t1.getScopedTypeName(scope)) + " and ") + t2.getScopedTypeName(scope)) + " ") + reason); 
            } else  {
                this.reportError(ast, (((("Can not convert " + t1.getScopedTypeName(scope)) + " to ") + t2.getScopedTypeName(scope)) + " ") + reason); 
            }
        };
        ErrorReporter.prototype.qMarkIncompatibleTypes = function(ast, t1, t2, scope) {
            this.reportError(ast, ((("Types " + t1.getScopedTypeName(scope)) + " and ") + t2.getScopedTypeName(scope)) + " are incompatible in ?: operator"); 
        };
        ErrorReporter.prototype.valuesCannotBeCompared = function(ast, t1, t2) {
            this.reportError(ast, ((("Values of type " + t1.getTypeName()) + " and ") + t2.getTypeName()) + " can not be compared"); 
        };
        ErrorReporter.prototype.expectedClassOrInterface = function(ast) {
            this.simpleError(ast, "Expected var, class, interface, or module"); 
        };
        ErrorReporter.prototype.unaryOperatorTypeError = function(ast, op, type) {
            this.reportError(ast, (("Can not apply " + op) + " to value of type ") + type.getTypeName()); 
        };
        return ErrorReporter;
    })();
    Tools.ErrorReporter = ErrorReporter;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    (function(TypeContext) {
        TypeContext._map = []; 
        TypeContext.NoTypes = 0; 
        TypeContext.ArraySuffix = 1; 
        TypeContext.Primitive = 2; 
        TypeContext.Named = 4; 
        TypeContext.AllSimpleTypes = TypeContext.Primitive | TypeContext.Named; 
        TypeContext.AllTypes = TypeContext.Primitive | TypeContext.Named | TypeContext.ArraySuffix; 
    })(Tools.TypeContext||(Tools.TypeContext={}));
    var TypeContext = Tools.TypeContext;

    (function(ParseState) {
        ParseState._map = []; 
        ParseState._map[0] = "None"; 
        ParseState.None = 0; 
        ParseState._map[1] = "StartScript"; 
        ParseState.StartScript = 1; 
        ParseState._map[2] = "StartStmtList"; 
        ParseState.StartStmtList = 2; 
        ParseState._map[3] = "StartStatement"; 
        ParseState.StartStatement = 3; 
        ParseState._map[4] = "StartFncDecl"; 
        ParseState.StartFncDecl = 4; 
        ParseState._map[5] = "FncDeclName"; 
        ParseState.FncDeclName = 5; 
        ParseState._map[6] = "FncDeclArgs"; 
        ParseState.FncDeclArgs = 6; 
        ParseState._map[7] = "FncDeclReturnType"; 
        ParseState.FncDeclReturnType = 7; 
        ParseState._map[8] = "ForInit"; 
        ParseState.ForInit = 8; 
        ParseState._map[9] = "ForInitAfterVar"; 
        ParseState.ForInitAfterVar = 9; 
        ParseState._map[10] = "ForCondStart"; 
        ParseState.ForCondStart = 10; 
        ParseState._map[11] = "EndStmtList"; 
        ParseState.EndStmtList = 11; 
        ParseState._map[12] = "EndScript"; 
        ParseState.EndScript = 12; 
    })(Tools.ParseState||(Tools.ParseState={}));
    var ParseState = Tools.ParseState;

    var QuickParseResult = (function () {
        function QuickParseResult(Script, endLexState) {
            this.Script = Script;
            this.endLexState = endLexState;
        }
        return QuickParseResult;
    })();
    Tools.QuickParseResult = QuickParseResult;
    
    var Parser = (function () {
        function Parser() {
            this.varLists = []; 
            this.scopeLists = []; 
            this.staticsLists = []; 
            this.scanner = new Tools.Scanner(); 
            this.tok = null; 
            this.needTerminator = false; 
            this.inFnc = false; 
            this.inStaticFnc = false; 
            this.inInterfaceDecl = false; 
            this.currentClassDecl = null; 
            this.inFncDecl = false; 
            this.anonId = new Tools.Identifier("_anonymous"); 
            this.style_requireSemi = false; 
            this.style_funcInLoop = true; 
            this.incremental = false; 
            this.errorRecovery = false; 
            this.outfile = undefined; 
            this.errorCallback = null; 
            this.state = ParseState.StartStmtList; 
            this.cursorLine = -1; 
            this.cursorColumn = -1; 
            this.cursorState = ParseState.None; 
            this.errorMessage = ""; 
            this.ambientModule = false; 
            this.ambientClass = false; 
            this.topLevel = true; 
            this.currentUnitIndex = (-1); 
            this.prevIDTok = null; 
            this.stmtStack = new Array(); 
            this.hasTopLevelImportOrExport = false; 
            this.strictMode = false; 
            this.nestingLevel = 0; 
            this.prevExpr = null; 
            this.currentES6ClassDefinition = null; 
            this.parsingES6ClassConstructorDefinition = false; 
            this.parsingDeclareFile = false; 
            this.amdDependencies = []; 
            this.inferPropertiesFromThisAssignment = false; 
            this.fname = ""; 
            this.parseError = false; 
        }
        Parser.prototype.resetStmtStack = function() {
            this.stmtStack = new Array(); 
        };
        Parser.prototype.inLoop = function() {
            for(var j = this.stmtStack.length - 1; j >= 0; j--) {
                if(this.stmtStack[j].stmt.isLoop()) {
                    return true; 
                }
            }
            return false; 
        };
        Parser.prototype.pushStmt = function(stmt, labels) {
            var info = {
                stmt: stmt,
                labels: labels
            }; 
            this.stmtStack.push(info); 
        };
        Parser.prototype.popStmt = function() {
            return this.stmtStack.pop(); 
        };
        Parser.prototype.resolveJumpTarget = function(jump) {
            var len = this.stmtStack.length; 
            for(var i = len - 1; i >= 0; i--) {
                var info = this.stmtStack[i]; 
                if(jump.target != null) {
                    if((info.labels != null) && (info.labels.members.length > 0)) {
                        for(var j = 0, labLen = info.labels.members.length; j < labLen; j++) {
                            var label = info.labels.members[j]; 
                            if(label.id.text == jump.target) {
                                jump.setResolvedTarget(this, info.stmt); 
                                return;
                            }
                        }
                    }
                } else  {
                    if(info.stmt.isLoop()) {
                        jump.setResolvedTarget(this, info.stmt); 
                        return;
                    } else  {
                        if((info.stmt.nodeType == Tools.NodeType.Switch) && (jump.nodeType == Tools.NodeType.Break)) {
                            jump.setResolvedTarget(this, info.stmt); 
                            return;
                        }
                    }
                }
            }
            if(jump.target != null) {
                this.reportParseError("could not find enclosing statement with label " + jump.target); 
            } else  {
                if(jump.nodeType == Tools.NodeType.Break) {
                    this.reportParseError("break statement requires enclosing loop or switch"); 
                } else  {
                    this.reportParseError("continue statement requires enclosing loop"); 
                }
            }
        };
        Parser.prototype.setNonInteractive = function() {
            this.errorRecovery = false; 
        };
        Parser.prototype.setErrorRecovery = function(outf, l, c) {
            this.outfile = outf; 
            this.cursorLine = l; 
            this.cursorColumn = c; 
            this.cursorState = ParseState.None; 
            this.errorRecovery = true; 
        };
        Parser.prototype.posMatchesCursor = function(pos) {
            var lineCol = {
                line: -1,
                col: -1
            }; 
            this.getSourceLineCol(lineCol, pos); 
            return (lineCol.line == this.cursorLine) && (lineCol.col == this.cursorColumn); 
        };
        Parser.prototype.getSourceLineCol = function(lineCol, minChar) {
            Tools.getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap); 
        };
        Parser.prototype.createRef = function(text, minChar) {
            var id = new Tools.Identifier(text); 
            id.minChar = minChar; 
            return id; 
        };
        Parser.prototype.reportParseStyleError = function(message) {
            this.reportParseError("STYLE: " + message); 
        };
        Parser.prototype.reportParseError = function(message) {
            var len = Math.max(1, this.scanner.pos - this.scanner.startPos); 
            if(this.errorCallback != null) {
                this.errorCallback(this.scanner.startPos, len, message, this.currentUnitIndex); 
            } else  {
                if(this.errorRecovery) {
                    var lineCol = {
                        line: -1,
                        col: -1
                    }; 
                    this.getSourceLineCol(lineCol, this.scanner.startPos); 
                    if(this.outfile != null) {
                        this.outfile.WriteLine((((((("// " + this.fname) + " (") + lineCol.line) + ",") + lineCol.col) + "): ") + message); 
                    }
                } else  {
                    throw new SyntaxError((((((this.fname + " (") + this.scanner.line) + ",") + this.scanner.col) + "): ") + message);
                }
            }
        };
        Parser.prototype.chkNxtTok = function(tokenId, errorText, errorRecoverySet) {
            this.tok = this.scanner.scan(); 
            this.chkCurTok(tokenId, errorText, errorRecoverySet); 
        };
        Parser.prototype.skip = function(errorRecoverySet) {
            errorRecoverySet |= Tools.ErrorRecoverySet.EOF; 
            var ersTok = Tools.ErrorRecoverySet.None; 
            var tokenInfo = Tools.lookupToken(this.tok.tokenId); 
            if(tokenInfo != undefined) {
                ersTok = tokenInfo.ers; 
            }
            while((ersTok & errorRecoverySet) == Tools.ErrorRecoverySet.None) {
                this.tok = this.scanner.scan(); 
                ersTok = Tools.ErrorRecoverySet.None; 
                tokenInfo = Tools.lookupToken(this.tok.tokenId); 
                if(tokenInfo != undefined) {
                    ersTok = tokenInfo.ers; 
                }
            }
        };
        Parser.prototype.chkCurTok = function(tokenId, errorText, errorRecoverySet) {
            if(this.tok.tokenId != tokenId) {
                this.reportParseError(errorText); 
                if(this.errorRecovery) {
                    this.skip(errorRecoverySet); 
                }
            } else  {
                this.tok = this.scanner.scan(); 
            }
        };
        Parser.prototype.pushDeclLists = function() {
            this.staticsLists.push(new Tools.ASTList()); 
            this.varLists.push(new Tools.ASTList()); 
            this.scopeLists.push(new Tools.ASTList()); 
        };
        Parser.prototype.popDeclLists = function() {
            this.staticsLists.pop(); 
            this.varLists.pop(); 
            this.scopeLists.pop(); 
        };
        Parser.prototype.topVarList = function() {
            return this.varLists[this.varLists.length - 1]; 
        };
        Parser.prototype.topScopeList = function() {
            return this.scopeLists[this.scopeLists.length - 1]; 
        };
        Parser.prototype.topStaticsList = function() {
            return this.staticsLists[this.staticsLists.length - 1]; 
        };
        Parser.prototype.parseComment = function(comment) {
            if(comment != null) {
                var c = new Tools.Comment(comment.value, comment.isBlock, comment.endsLine); 
                c.minChar = comment.startPos; 
                c.limChar = comment.startPos + comment.value.length; 
                if(!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == "///") {
                    var dependencyPath = Tools.getAdditionalDependencyPath(comment.value); 
                    if(dependencyPath) {
                        this.amdDependencies.push(dependencyPath); 
                    }
                }
                return c; 
            } else  {
                return null; 
            }
        };
        Parser.prototype.parseCommentsInner = function(comments) {
            if(comments != null) {
                var commentASTs = new Array(); 
                for(var i = 0; i < comments.length; i++) {
                    commentASTs.push(this.parseComment(comments[i])); 
                }
                return commentASTs; 
            } else  {
                return null; 
            }
        };
        Parser.prototype.parseComments = function() {
            var comments = this.scanner.getComments(); 
            return this.parseCommentsInner(comments); 
        };
        Parser.prototype.parseCommentsForLine = function(line) {
            var comments = this.scanner.getCommentsForLine(line); 
            return this.parseCommentsInner(comments); 
        };
        Parser.prototype.combineComments = function(comment1, comment2) {
            if(comment1 == null) {
                return comment2; 
            } else  {
                if(comment2 == null) {
                    return comment1; 
                } else  {
                    return comment1.concat(comment2); 
                }
            }
        };
        Parser.prototype.parseEnumDecl = function(errorRecoverySet, modifiers) {
            var leftCurlyCount = this.scanner.leftCurlyCount; 
            var rightCurlyCount = this.scanner.rightCurlyCount; 
            var name = null; 
            if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                name = new Tools.Identifier(this.tok.getText()); 
                name.minChar = this.scanner.startPos; 
                name.limChar = this.scanner.pos; 
                this.tok = this.scanner.scan(); 
            } else  {
                this.reportParseError("enum declaration requires identifier"); 
                if(this.errorRecovery) {
                    name = new Tools.MissingIdentifier(); 
                    name.minChar = this.scanner.startPos; 
                    name.limChar = this.scanner.startPos; 
                    name.flags |= Tools.ASTFlags.Error; 
                }
            }
            var membersMinChar = this.scanner.startPos; 
            this.chkCurTok(Tools.TokenID.LCurly, "expected '{'", errorRecoverySet | Tools.ErrorRecoverySet.ID); 
            this.pushDeclLists(); 
            var members = new Tools.ASTList(); 
            members.minChar = membersMinChar; 
            var mapDecl = new Tools.VarDecl(new Tools.Identifier("_map"), 0); 
            mapDecl.varFlags |= Tools.VarFlags.Exported; 
            mapDecl.varFlags |= Tools.VarFlags.Private; 
            mapDecl.varFlags |= (Tools.VarFlags.Property | Tools.VarFlags.Public); 
            mapDecl.init = new Tools.UnaryExpression(Tools.NodeType.ArrayLit, null); 
            members.append(mapDecl); 
            var lastValue = null; 
            for(; ; ) {
                var minChar = this.scanner.startPos; 
                var limChar; 
                var memberName = null; 
                var memberValue = null; 
                var preComments = null; 
                var postComments = null; 
                if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToIDName(this.tok)) {
                    memberName = new Tools.Identifier(this.tok.getText()); 
                    memberName.minChar = this.scanner.startPos; 
                    memberName.limChar = this.scanner.pos; 
                } else  {
                    if(this.tok.tokenId == Tools.TokenID.RCurly) {
                        break;
                    } else  {
                        this.reportParseError("expected identifer of enum member"); 
                        if(this.errorRecovery) {
                            memberName = new Tools.MissingIdentifier(); 
                            memberName.minChar = this.scanner.startPos; 
                            memberName.limChar = this.scanner.startPos; 
                            memberName.flags |= Tools.ASTFlags.Error; 
                        }
                    }
                }
                limChar = this.scanner.pos; 
                preComments = this.parseComments(); 
                this.tok = this.scanner.scan(); 
                postComments = this.parseComments(); 
                if(this.tok.tokenId == Tools.TokenID.Asg) {
                    this.tok = this.scanner.scan(); 
                    memberValue = this.parseExpr(errorRecoverySet, Tools.OperatorPrecedence.Cma, true, TypeContext.NoTypes); 
                    lastValue = memberValue; 
                    limChar = memberValue.limChar; 
                } else  {
                    if(lastValue == null) {
                        memberValue = new Tools.NumberLiteral(0); 
                        lastValue = memberValue; 
                    } else  {
                        memberValue = new Tools.NumberLiteral(lastValue.value + 1); 
                        lastValue = memberValue; 
                    }
                    var map = new Tools.BinaryExpression(Tools.NodeType.Asg, new Tools.BinaryExpression(Tools.NodeType.Index, new Tools.Identifier("_map"), memberValue), new Tools.StringLiteral(('"' + memberName.text) + '"')); 
                    members.append(map); 
                }
                var member = new Tools.VarDecl(memberName, this.nestingLevel); 
                member.minChar = minChar; 
                member.limChar = limChar; 
                member.init = memberValue; 
                member.typeExpr = new Tools.TypeReference(this.createRef(name.text, -1), 0); 
                member.varFlags |= (Tools.VarFlags.Readonly | Tools.VarFlags.Property); 
                if(memberValue.nodeType == Tools.NodeType.NumberLit) {
                    member.varFlags |= Tools.VarFlags.Constant; 
                }
                member.preComments = preComments; 
                members.append(member); 
                member.postComments = postComments; 
                member.varFlags |= Tools.VarFlags.Exported; 
                if(this.tok.tokenId == Tools.TokenID.Comma) {
                    this.tok = this.scanner.scan(); 
                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine)); 
                    if((this.tok.tokenId == Tools.TokenID.ID) || (Tools.convertTokToIDName(this.tok))) {
                        continue;
                    }
                }
                break;
            }
            this.chkCurTok(Tools.TokenID.RCurly, "expected }", errorRecoverySet); 
            members.limChar = this.scanner.lastTokenLimChar(); 
            var modDecl = new Tools.ModuleDecl(name, members, this.topVarList(), this.topScopeList()); 
            modDecl.modFlags |= Tools.ModuleFlags.IsEnum; 
            this.popDeclLists(); 
            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount; 
            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount; 
            return modDecl; 
        };
        Parser.prototype.parseDottedName = function(enclosedList) {
            this.tok = this.scanner.scan(); 
            if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                var id = new Tools.Identifier(this.tok.getText()); 
                id.preComments = this.parseComments(); 
                enclosedList[enclosedList.length] = id; 
                id.minChar = this.scanner.startPos; 
                id.limChar = this.scanner.pos; 
                this.tok = this.scanner.scan(); 
                if(this.tok.tokenId == Tools.TokenID.Dot) {
                    this.parseDottedName(enclosedList); 
                }
            } else  {
                this.reportParseError("need identifier after '.'"); 
            }
        };
        Parser.prototype.isValidImportPath = function(importPath) {
            importPath = Tools.stripQuotes(importPath); 
            if(!importPath || importPath.indexOf(':') != -1 || importPath.indexOf('\\') != -1 || importPath.charAt(0) == '/') {
                return false; 
            }
            return true; 
        };
        Parser.prototype.parseImportDecl = function(errorRecoverySet, modifiers) {
            var name = null; 
            var alias = null; 
            var importDecl = null; 
            var minChar = this.scanner.startPos; 
            var isDynamicImport = false; 
            this.tok = this.scanner.scan(); 
            if(this.tok.tokenId == Tools.TokenID.ID || Tools.convertTokToID(this.tok, this.strictMode)) {
                name = new Tools.Identifier(this.tok.getText()); 
            } else  {
                this.reportParseError("Expected identifer after 'import'"); 
                name = new Tools.MissingIdentifier(); 
            }
            name.minChar = this.scanner.startPos; 
            name.limChar = this.scanner.pos; 
            this.tok = this.scanner.scan(); 
            this.chkCurTok(Tools.TokenID.Asg, "expected =", errorRecoverySet | Tools.ErrorRecoverySet.ID); 
            var aliasPreComments = this.parseComments(); 
            if(this.tok.tokenId == Tools.TokenID.ID || Tools.convertTokToID(this.tok, this.strictMode)) {
                if(this.tok.tokenId == Tools.TokenID.MODULE) {
                    this.tok = this.scanner.scan(); 
                    if(this.tok.tokenId == Tools.TokenID.LParen) {
                        this.tok = this.scanner.scan(); 
                        if(this.tok.tokenId == Tools.TokenID.QString || this.tok.tokenId == Tools.TokenID.ID || Tools.convertTokToID(this.tok, this.strictMode)) {
                            if(this.tok.tokenId == Tools.TokenID.QString) {
                                if(this.topLevel) {
                                    this.hasTopLevelImportOrExport = true; 
                                }
                                var aliasText = this.tok.getText(); 
                                if(!this.isValidImportPath(aliasText)) {
                                    this.reportParseError("Invalid import path"); 
                                }
                                alias = new Tools.Identifier(aliasText); 
                                alias.minChar = this.scanner.startPos; 
                                alias.limChar = this.scanner.pos; 
                                isDynamicImport = true; 
                                this.tok = this.scanner.scan(); 
                                alias.preComments = aliasPreComments; 
                            } else  {
                                alias = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.SColon, Tools.OperatorPrecedence.Asg, true, TypeContext.NoTypes); 
                                alias.preComments = aliasPreComments; 
                            }
                        }
                        this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet | Tools.ErrorRecoverySet.ID); 
                        if(alias) {
                            alias.postComments = this.parseComments(); 
                        }
                        if(this.tok.tokenId == Tools.TokenID.SColon) {
                            this.tok = this.scanner.scan(); 
                        }
                    }
                } else  {
                    alias = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.SColon, Tools.OperatorPrecedence.Asg, true, TypeContext.NoTypes); 
                }
            } else  {
                this.reportParseError("Expected module name"); 
                alias = new Tools.MissingIdentifier(); 
            }
            importDecl = new Tools.ImportDecl(name, alias); 
            importDecl.isDynamicImport = isDynamicImport; 
            if(Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                importDecl.varFlags |= Tools.VarFlags.Exported; 
            }
            importDecl.minChar = minChar; 
            importDecl.limChar = this.scanner.pos; 
            return importDecl; 
        };
        Parser.prototype.parseModuleDecl = function(errorRecoverySet, modifiers) {
            var leftCurlyCount = this.scanner.leftCurlyCount; 
            var rightCurlyCount = this.scanner.rightCurlyCount; 
            var svAmbient = this.ambientModule; 
            var svTopLevel = this.topLevel; 
            this.topLevel = false; 
            if(this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                this.ambientModule = true; 
            }
            this.tok = this.scanner.scan(); 
            var name = null; 
            var enclosedList = null; 
            this.pushDeclLists(); 
            var glo = false; 
            var modulePreComments = this.parseComments(); 
            var minChar = this.scanner.startPos; 
            var isAnonInnerMod = false; 
            var isDynamicMod = false; 
            if((this.tok.tokenId == Tools.TokenID.ID) || (this.tok.tokenId == Tools.TokenID.QString) || Tools.convertTokToID(this.tok, this.strictMode)) {
                var nameText = this.tok.getText(); 
                if(this.tok.tokenId == Tools.TokenID.QString) {
                    isDynamicMod = true; 
                    if(!this.ambientModule) {
                        this.reportParseError("Only ambient dynamic modules may have string literal names"); 
                    }
                }
                name = new Tools.Identifier(nameText); 
                name.minChar = this.scanner.startPos; 
                name.limChar = this.scanner.pos; 
                this.tok = this.scanner.scan(); 
            } else  {
                if(this.tok.tokenId == Tools.TokenID.LCurly) {
                    if(svTopLevel) {
                        glo = true; 
                        name = new Tools.Identifier(Tools.globalId); 
                    } else  {
                        name = new Tools.Identifier("__INNER_MOD"); 
                        isAnonInnerMod = true; 
                    }
                    name.minChar = minChar; 
                    name.limChar = minChar; 
                }
            }
            if(this.tok.tokenId == Tools.TokenID.Dot) {
                enclosedList = new Array(); 
                this.parseDottedName(enclosedList); 
            }
            if(name == null) {
                name = new Tools.MissingIdentifier(); 
            }
            var moduleBody = new Tools.ASTList(); 
            var bodyMinChar = this.scanner.startPos; 
            this.chkCurTok(Tools.TokenID.LCurly, "expected {", errorRecoverySet | Tools.ErrorRecoverySet.ID); 
            this.parseStmtList(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, moduleBody, true, true, Tools.AllowedElements.ModuleMembers, modifiers); 
            moduleBody.minChar = bodyMinChar; 
            moduleBody.limChar = this.scanner.pos; 
            this.chkCurTok(Tools.TokenID.RCurly, "expected }", errorRecoverySet); 
            var limChar = this.scanner.pos; 
            var moduleDecl; 
            if((enclosedList != null) && (enclosedList.length > 0)) {
                var len = enclosedList.length; 
                var innerName = enclosedList[len - 1]; 
                var innerDecl = new Tools.ModuleDecl(innerName, moduleBody, this.topVarList(), this.topScopeList()); 
                if(this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                    innerDecl.modFlags |= Tools.ModuleFlags.Ambient; 
                }
                innerDecl.modFlags |= Tools.ModuleFlags.Exported; 
                innerDecl.minChar = minChar; 
                innerDecl.limChar = limChar; 
                this.popDeclLists(); 
                var outerModBod; 
                for(var i = len - 2; i >= 0; i--) {
                    outerModBod = new Tools.ASTList(); 
                    outerModBod.append(innerDecl); 
                    innerName = enclosedList[i]; 
                    innerDecl = new Tools.ModuleDecl(innerName, outerModBod, new Tools.ASTList(), new Tools.ASTList()); 
                    outerModBod.minChar = innerDecl.minChar = minChar; 
                    outerModBod.limChar = innerDecl.limChar = limChar; 
                    if(this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                        innerDecl.modFlags |= Tools.ModuleFlags.Ambient; 
                    }
                    innerDecl.modFlags |= Tools.ModuleFlags.Exported; 
                }
                outerModBod = new Tools.ASTList(); 
                outerModBod.append(innerDecl); 
                outerModBod.minChar = minChar; 
                outerModBod.limChar = limChar; 
                moduleDecl = new Tools.ModuleDecl(name, outerModBod, new Tools.ASTList(), new Tools.ASTList()); 
            } else  {
                moduleDecl = new Tools.ModuleDecl(name, moduleBody, this.topVarList(), this.topScopeList()); 
                this.popDeclLists(); 
            }
            if(glo) {
                moduleDecl.modFlags |= Tools.ModuleFlags.Glo; 
            }
            if(this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                moduleDecl.modFlags |= Tools.ModuleFlags.Ambient; 
            }
            if(Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                moduleDecl.modFlags |= Tools.ModuleFlags.Exported; 
            }
            if(isDynamicMod) {
                moduleDecl.modFlags |= Tools.ModuleFlags.IsDynamic; 
            }
            moduleDecl.preComments = modulePreComments; 
            moduleDecl.postComments = this.parseComments(); 
            moduleDecl.isAnonInnerMod = isAnonInnerMod; 
            this.ambientModule = svAmbient; 
            this.topLevel = svTopLevel; 
            moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount; 
            moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount; 
            return moduleDecl; 
        };
        Parser.prototype.parseTypeReferenceTail = function(errorRecoverySet, minChar, term) {
            var result = new Tools.TypeReference(term, 0); 
            result.minChar = minChar; 
            while(this.tok.tokenId == Tools.TokenID.LBrack) {
                this.tok = this.scanner.scan(); 
                result.arrayCount++; 
                this.chkCurTok(Tools.TokenID.RBrack, "expected ']'", errorRecoverySet | Tools.ErrorRecoverySet.LBrack); 
            }
            result.limChar = this.scanner.lastTokenLimChar(); 
            return result; 
        };
        Parser.prototype.parseNamedType = function(errorRecoverySet, minChar, term, tail) {
            this.tok = this.scanner.scan(); 
            if(this.tok.tokenId == Tools.TokenID.Dot) {
                var curpos = this.scanner.pos; 
                this.tok = this.scanner.scan(); 
                if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                    var op2 = new Tools.Identifier(this.tok.getText()); 
                    op2.minChar = this.scanner.startPos; 
                    op2.limChar = this.scanner.pos; 
                    var dotNode = new Tools.BinaryExpression(Tools.NodeType.Dot, term, op2); 
                    dotNode.minChar = term.minChar; 
                    dotNode.limChar = op2.limChar; 
                    return this.parseNamedType(errorRecoverySet, minChar, dotNode, tail); 
                } else  {
                    this.reportParseError("need identifier after '.'"); 
                    if(this.errorRecovery) {
                        term.flags |= Tools.ASTFlags.DotLHS; 
                        term.limChar = this.scanner.lastTokenLimChar(); 
                        return term; 
                    } else  {
                        var eop2 = new Tools.MissingIdentifier(); 
                        eop2.minChar = this.scanner.pos; 
                        eop2.limChar = this.scanner.pos; 
                        var edotNode = new Tools.BinaryExpression(Tools.NodeType.Dot, term, eop2); 
                        edotNode.flags |= Tools.ASTFlags.Error; 
                        edotNode.minChar = term.minChar; 
                        edotNode.limChar = eop2.limChar; 
                        return this.parseNamedType(errorRecoverySet, minChar, edotNode, tail); 
                    }
                }
            } else  {
                if(tail) {
                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, term); 
                } else  {
                    return term; 
                }
            }
        };
        Parser.prototype.parseTypeReference = function(errorRecoverySet, allowVoid) {
            var minChar = this.scanner.startPos; 
            var isConstructorMember = false; 
            switch(this.tok.tokenId) {
                case Tools.TokenID.VOID: {
                    if(!allowVoid) {
                        this.reportParseError("void not a valid type in this context"); 
                    }

                }
                case Tools.TokenID.NUMBER: {

                }
                case Tools.TokenID.BOOL: {

                }
                case Tools.TokenID.ANY: {

                }
                case Tools.TokenID.STRING: {
 {
                        var text = Tools.tokenTable[this.tok.tokenId].text; 
                        var primId = new Tools.Identifier(text); 
                        primId.minChar = minChar; 
                        primId.limChar = this.scanner.pos; 
                        this.tok = this.scanner.scan(); 
                        return this.parseTypeReferenceTail(errorRecoverySet, minChar, primId); 
                    }

                }
                case Tools.TokenID.ID: {
                    var ident = this.createRef(this.tok.getText(), minChar); 
                    ident.limChar = this.scanner.pos; 
                    return this.parseNamedType(errorRecoverySet, minChar, ident, true); 

                }
                case Tools.TokenID.LCurly: {
                    this.tok = this.scanner.scan(); 
                    var members = new Tools.ASTList(); 
                    members.minChar = minChar; 
                    var prevInInterfaceDecl = this.inInterfaceDecl; 
                    this.inInterfaceDecl = true; 
                    this.parseInterfaceMembers(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, members); 
                    this.inInterfaceDecl = prevInInterfaceDecl; 
                    this.chkCurTok(Tools.TokenID.RCurly, "expected }", errorRecoverySet); 
                    var interfaceDecl = new Tools.TypeDecl(Tools.NodeType.Interface, this.anonId, members, null, null, null); 
                    interfaceDecl.minChar = minChar; 
                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl); 

                }
                case Tools.TokenID.NEW: {
                    this.tok = this.scanner.scan(); 
                    if(this.tok.tokenId != Tools.TokenID.LParen) {
                        this.reportParseError("Expected '('"); 
                    } else  {
                        isConstructorMember = true; 
                    }

                }
                case Tools.TokenID.LParen: {
 {
                        var formals = new Tools.ASTList(); 
                        var variableArgList = this.parseFormalParameterList(errorRecoverySet | Tools.ErrorRecoverySet.RParen, formals, false, false, true, false, false, false, null); 
                        this.chkCurTok(Tools.TokenID.Arrow, "expected =>", errorRecoverySet); 
                        var returnType = this.parseTypeReference(errorRecoverySet, true); 
                        var funcDecl = new Tools.FuncDecl(null, null, false, formals, null, null, null, Tools.NodeType.FuncDecl); 
                        funcDecl.returnTypeAnnotation = returnType; 
                        funcDecl.variableArgList = variableArgList; 
                        funcDecl.fncFlags |= Tools.FncFlags.Signature; 
                        if(isConstructorMember) {
                            funcDecl.fncFlags |= Tools.FncFlags.ConstructMember; 
                            funcDecl.hint = "_construct"; 
                            funcDecl.classDecl = null; 
                        }
                        funcDecl.minChar = minChar; 
                        return this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl); 
                    }

                }
                default: {
                    this.reportParseError("expected type name"); 
                    var etr = new Tools.TypeReference(null, 0); 
                    etr.flags |= Tools.ASTFlags.Error; 
                    etr.minChar = this.scanner.pos; 
                    etr.limChar = this.scanner.pos; 
                    return etr; 

                }
            }
        };
        Parser.prototype.parseFunctionStatements = function(errorRecoverySet, name, isConstructor, isMethod, args, allowedElements, minChar, requiresSignature, parentModifiers) {
            this.pushDeclLists(); 
            var svStmtStack = this.stmtStack; 
            this.resetStmtStack(); 
            var bod = null; 
            var wasShorthand = false; 
            var isAnonLambda = false; 
            if(!requiresSignature) {
                bod = new Tools.ASTList(); 
                var bodMinChar = this.scanner.startPos; 
                if(this.tok.tokenId == Tools.TokenID.Arrow) {
                    wasShorthand = true; 
                    this.tok = this.scanner.scan(); 
                }
                if(wasShorthand && this.tok.tokenId != Tools.TokenID.LCurly) {
                    var retExpr = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.SColon, Tools.OperatorPrecedence.Asg, true, TypeContext.NoTypes); 
                    var retStmt = new Tools.ReturnStatement(); 
                    retStmt.returnExpression = retExpr; 
                    bod.minChar = bodMinChar; 
                    bod.append(retStmt); 
                } else  {
                    this.state = ParseState.StartStmtList; 
                    this.chkCurTok(Tools.TokenID.LCurly, "expected {", errorRecoverySet | Tools.ErrorRecoverySet.StmtStart); 
                    var svInFnc = this.inFnc; 
                    isAnonLambda = wasShorthand; 
                    this.inFnc = true; 
                    this.parseStmtList(errorRecoverySet | Tools.ErrorRecoverySet.RCurly | Tools.ErrorRecoverySet.StmtStart, bod, true, false, allowedElements, parentModifiers); 
                    bod.minChar = bodMinChar; 
                    bod.limChar = this.scanner.pos; 
                    this.inFnc = svInFnc; 
                    var ec = new Tools.EndCode(); 
                    ec.minChar = bod.limChar; 
                    ec.limChar = ec.minChar; 
                    bod.append(ec); 
                }
            }
            var funcDecl = new Tools.FuncDecl(name, bod, isConstructor, args, this.topVarList(), this.topScopeList(), this.topStaticsList(), Tools.NodeType.FuncDecl); 
            this.popDeclLists(); 
            var scopeList = this.topScopeList(); 
            scopeList.append(funcDecl); 
            var staticFuncDecl = false; 
            var limChar = this.scanner.pos; 
            if(requiresSignature) {
                if(this.tok.tokenId == Tools.TokenID.LCurly && (!isMethod || this.currentClassDecl == null || this.inStaticFnc)) {
                    this.state = ParseState.StartStmtList; 
                    var bodMinChar = this.scanner.startPos; 
                    this.tok = this.scanner.scan(); 
                    bod = new Tools.ASTList(); 
                    var svInFnc = this.inFnc; 
                    var svInStaticFnc = this.inStaticFnc; 
                    this.inFnc = true; 
                    this.inStaticFnc = true; 
                    this.parseStmtList(errorRecoverySet | Tools.ErrorRecoverySet.RCurly | Tools.ErrorRecoverySet.StmtStart, bod, true, false, Tools.AllowedElements.FunctionDecls, parentModifiers); 
                    this.inFnc = svInFnc; 
                    this.inStaticFnc = svInStaticFnc; 
                    bod.minChar = bodMinChar; 
                    bod.limChar = this.scanner.pos; 
                    var ec = new Tools.EndCode(); 
                    ec.minChar = bod.limChar; 
                    ec.limChar = ec.minChar; 
                    bod.append(ec); 
                    limChar = this.scanner.pos; 
                    this.chkCurTok(Tools.TokenID.RCurly, "expected }", errorRecoverySet); 
                } else  {
                    this.chkCurTok(Tools.TokenID.SColon, "expected semicolon", errorRecoverySet); 
                }
            } else  {
                if(!wasShorthand || isAnonLambda) {
                    this.chkCurTok(Tools.TokenID.RCurly, "expected }", errorRecoverySet); 
                    if(isAnonLambda) {
                        funcDecl.fncFlags |= Tools.FncFlags.IsFatArrowFunction; 
                    }
                } else  {
                    funcDecl.fncFlags |= Tools.FncFlags.IsFatArrowFunction; 
                    if(this.tok.tokenId == Tools.TokenID.SColon) {
                        this.tok = this.scanner.scan(); 
                    }
                }
            }
            funcDecl.minChar = minChar; 
            funcDecl.limChar = limChar; 
            if(!requiresSignature) {
                funcDecl.fncFlags |= Tools.FncFlags.Definition; 
            }
            this.stmtStack = svStmtStack; 
            return funcDecl; 
        };
        Parser.prototype.transformAnonymousArgsIntoFormals = function(formals, argList) {
            var _self = this;
            var translateBinExOperand = function(operand) {
                if(operand.nodeType == Tools.NodeType.Comma) {
                    _self.transformAnonymousArgsIntoFormals(formals, operand); 
                } else  {
                    if(operand.nodeType == Tools.NodeType.Name || operand.nodeType == Tools.NodeType.Asg) {
                        var opArg = operand.nodeType == Tools.NodeType.Asg ? (operand).operand1 : operand; 
                        var arg = new Tools.ArgDecl(opArg); 
                        arg.preComments = opArg.preComments; 
                        arg.postComments = opArg.postComments; 
                        arg.minChar = opArg.minChar; 
                        arg.limChar = opArg.limChar; 
                        if(Tools.hasFlag(opArg.flags, Tools.ASTFlags.PossibleOptionalParameter)) {
                            arg.isOptional = true; 
                        }
                        if(operand.nodeType == Tools.NodeType.Asg) {
                            arg.init = (operand).operand2; 
                        }
                        formals.append(arg); 
                    } else  {
                        _self.reportParseError("Invalid lambda argument"); 
                    }
                }
            }; 
            if(argList) {
                if(argList.nodeType == Tools.NodeType.Comma) {
                    var commaList = argList; 
                    translateBinExOperand(commaList.operand1); 
                    translateBinExOperand(commaList.operand2); 
                } else  {
                    translateBinExOperand(argList); 
                }
            }
        };
        Parser.prototype.parseFormalParameterList = function(errorRecoverySet, formals, isConstr, isES6Constr, isSig, isIndexer, isGetter, isSetter, preProcessedLambdaArgs) {
            formals.minChar = this.scanner.startPos; 
            if(isIndexer) {
                this.tok = this.scanner.scan(); 
            } else  {
                if(!preProcessedLambdaArgs) {
                    this.chkCurTok(Tools.TokenID.LParen, "expected '('", errorRecoverySet | Tools.ErrorRecoverySet.RParen); 
                }
            }
            var sawEllipsis = false; 
            var firstArg = true; 
            var hasOptional = false; 
            var haveFirstArgID = false; 
            var hasPartialArgList = false; 
            if(preProcessedLambdaArgs) {
                this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs); 
                haveFirstArgID = true; 
            }
            while(true) {
                var munchedArg = false; 
                var argFlags = Tools.VarFlags.None; 
                var argMinChar = this.scanner.startPos; 
                if(this.inferPropertiesFromThisAssignment && this.tok.tokenId == Tools.TokenID.THIS) {
                    if(!isES6Constr) {
                        this.reportParseError("Instance property declarations using 'this' may only be used in ES6-style class constructors"); 
                    }
                    this.tok = this.scanner.scan(); 
                    argFlags |= (Tools.VarFlags.Public | Tools.VarFlags.Property); 
                    if(this.currentES6ClassDefinition) {
                        this.currentES6ClassDefinition.varFlags |= Tools.VarFlags.ES6ClassSuperMustBeFirstCallInConstructor; 
                    }
                }
                if(this.tok.tokenId == Tools.TokenID.PROPERTY || this.tok.tokenId == Tools.TokenID.PUBLIC) {
                    argFlags |= (Tools.VarFlags.Public | Tools.VarFlags.Property); 
                    if(this.currentES6ClassDefinition) {
                        this.currentES6ClassDefinition.varFlags |= Tools.VarFlags.ES6ClassSuperMustBeFirstCallInConstructor; 
                    }
                } else  {
                    if(this.tok.tokenId == Tools.TokenID.PRIVATE) {
                        argFlags |= (Tools.VarFlags.Private | Tools.VarFlags.Property); 
                        if(this.currentES6ClassDefinition) {
                            this.currentES6ClassDefinition.varFlags |= Tools.VarFlags.ES6ClassSuperMustBeFirstCallInConstructor; 
                        }
                    }
                }
                if(argFlags != Tools.VarFlags.None) {
                    if(!isConstr) {
                        this.reportParseError("only constructor parameters can be properties"); 
                    }
                    this.tok = this.scanner.scan(); 
                    if(this.inferPropertiesFromThisAssignment && this.tok.tokenId == Tools.TokenID.THIS) {
                        if(!isES6Constr) {
                            this.reportParseError("Instance property declarations using 'this' may only be used in ES6-style class constructors"); 
                        }
                        this.tok = this.scanner.scan(); 
                        this.tok = this.scanner.scan(); 
                    }
                } else  {
                    if(this.tok.tokenId == Tools.TokenID.Ellipsis) {
                        sawEllipsis = true; 
                        this.tok = this.scanner.scan(); 
                    }
                }
                var argId = null; 
                if(!haveFirstArgID && (this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                    argId = new Tools.Identifier(this.tok.getText()); 
                    argId.minChar = this.scanner.startPos; 
                    argId.limChar = this.scanner.pos; 
                }
                if(haveFirstArgID || argId != null) {
                    munchedArg = true; 
                    var type = null; 
                    var arg = null; 
                    if(haveFirstArgID && formals.members.length) {
                        arg = formals.members[formals.members.length - 1]; 
                        if(arg.isOptional) {
                            hasOptional = true; 
                            hasPartialArgList = true; 
                        }
                    } else  {
                        arg = new Tools.ArgDecl(argId); 
                        if(isGetter) {
                            this.reportParseError("Property getters may not take any arguments"); 
                        }
                        if(isSetter && !firstArg) {
                            this.reportParseError("Property setters may only take one argument"); 
                        }
                        arg.minChar = argMinChar; 
                        arg.preComments = this.parseComments(); 
                        this.tok = this.scanner.scan(); 
                    }
                    if(this.tok.tokenId == Tools.TokenID.QMark) {
                        arg.isOptional = true; 
                        hasOptional = true; 
                        this.tok = this.scanner.scan(); 
                    }
                    if(this.tok.tokenId == Tools.TokenID.Colon) {
                        this.tok = this.scanner.scan(); 
                        type = this.parseTypeReference(errorRecoverySet, false); 
                        if(preProcessedLambdaArgs) {
                            hasPartialArgList = true; 
                        }
                    }
                    if(this.tok.tokenId == Tools.TokenID.Asg) {
                        if(isSig) {
                            this.reportParseError("Arguments in signatures may not have default values"); 
                        }
                        hasOptional = true; 
                        this.tok = this.scanner.scan(); 
                        arg.init = this.parseExpr(Tools.ErrorRecoverySet.Comma | errorRecoverySet, Tools.OperatorPrecedence.Cma, false, TypeContext.NoTypes); 
                    }
                    if(hasOptional && !arg.isOptionalArg()) {
                        this.reportParseError("Optional parameters may only be followed by other optional parameters"); 
                    }
                    if(sawEllipsis && arg.isOptionalArg()) {
                        this.reportParseError("Varargs may not be optional or have default parameters"); 
                    }
                    arg.postComments = this.parseComments(); 
                    arg.typeExpr = type; 
                    arg.limChar = this.scanner.lastTokenLimChar(); 
                    arg.varFlags |= argFlags; 
                    if(!haveFirstArgID) {
                        formals.append(arg); 
                    } else  {
                        haveFirstArgID = false; 
                    }
                }
                firstArg = false; 
                if(this.tok.tokenId == Tools.TokenID.Comma) {
                    if((munchedArg) && (!sawEllipsis)) {
                        this.tok = this.scanner.scan(); 
                        continue;
                    } else  {
                        this.reportParseError("unexpected ',' in argument list"); 
                        if(this.errorRecovery) {
                            this.tok = this.scanner.scan(); 
                            continue;
                        }
                    }
                } else  {
                    break;
                }
            }
            if(isIndexer) {
                this.chkCurTok(Tools.TokenID.RBrack, "expected ']'", errorRecoverySet | Tools.ErrorRecoverySet.LCurly | Tools.ErrorRecoverySet.SColon); 
            } else  {
                if(!preProcessedLambdaArgs || hasPartialArgList) {
                    this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet | Tools.ErrorRecoverySet.LCurly | Tools.ErrorRecoverySet.SColon); 
                }
            }
            formals.limChar = this.scanner.lastTokenLimChar(); 
            return sawEllipsis; 
        };
        Parser.prototype.parseFncDecl = function(errorRecoverySet, isDecl, requiresSignature, isMethod, methodName, indexer, isStatic, markedAsAmbient, modifiers, lambdaArgContext) {
            var leftCurlyCount = this.scanner.leftCurlyCount; 
            var rightCurlyCount = this.scanner.rightCurlyCount; 
            var name = null; 
            var fnMin = this.scanner.startPos; 
            var minChar = this.scanner.pos; 
            var prevNestingLevel = this.nestingLevel; 
            this.nestingLevel = 0; 
            if((!this.style_funcInLoop) && this.inLoop()) {
                this.reportParseStyleError("function declaration in loop"); 
            }
            if(!isMethod && !isStatic && !indexer && !lambdaArgContext) {
                this.tok = this.scanner.scan(); 
                this.state = ParseState.StartFncDecl; 
                if((this.tok.tokenId != Tools.TokenID.ID) && (!Tools.convertTokToID(this.tok, this.strictMode))) {
                    if(isDecl) {
                        this.reportParseError("Function declaration must include identifier"); 
                        this.nestingLevel = prevNestingLevel; 
                        return new Tools.IncompleteAST(fnMin, this.scanner.pos); 
                    }
                } else  {
                    name = new Tools.Identifier(this.tok.getText()); 
                    name.minChar = this.scanner.startPos; 
                    name.limChar = this.scanner.pos; 
                    this.tok = this.scanner.scan(); 
                }
            } else  {
                if(methodName != null) {
                    name = methodName; 
                }
            }
            this.state = ParseState.FncDeclName; 
            var args = new Tools.ASTList(); 
            var variableArgList = false; 
            var isOverload = false; 
            var isGetter = Tools.hasFlag(modifiers, Tools.Modifiers.Getter); 
            var isSetter = Tools.hasFlag(modifiers, Tools.Modifiers.Setter); 
            if((this.tok.tokenId == Tools.TokenID.LParen) || (indexer && (this.tok.tokenId == Tools.TokenID.LBrack)) || (lambdaArgContext != null && lambdaArgContext.preProcessedLambdaArgs != null)) {
                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, false, requiresSignature, indexer, isGetter, isSetter, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null); 
            }
            this.state = ParseState.FncDeclArgs; 
            var returnType = null; 
            if(this.tok.tokenId == Tools.TokenID.Colon) {
                this.tok = this.scanner.scan(); 
                if(Tools.hasFlag(modifiers, Tools.Modifiers.Setter)) {
                    this.reportParseError("Property setters may not declare a return type"); 
                }
                returnType = this.parseTypeReference(errorRecoverySet, true); 
            }
            if(indexer && args.members.length == 0) {
                this.reportParseError("Index signatures require a parameter type to be specified"); 
            }
            this.state = ParseState.FncDeclReturnType; 
            if(isDecl && !(this.parsingDeclareFile || markedAsAmbient) && (!isMethod || !(this.ambientModule || this.ambientClass || this.inInterfaceDecl)) && this.tok.tokenId == Tools.TokenID.SColon) {
                isOverload = true; 
                isDecl = false; 
                requiresSignature = true; 
            }
            var svInFncDecl = this.inFncDecl; 
            this.inFncDecl = true; 
            var funcDecl = this.parseFunctionStatements(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, name, false, isMethod, args, Tools.AllowedElements.FunctionBody, minChar, requiresSignature, Tools.Modifiers.None); 
            this.inFncDecl = svInFncDecl; 
            funcDecl.variableArgList = variableArgList; 
            funcDecl.isOverload = isOverload; 
            if(isDecl) {
                funcDecl.fncFlags |= Tools.FncFlags.Definition; 
            }
            if(isStatic) {
                funcDecl.fncFlags |= Tools.FncFlags.Static; 
            }
            if(requiresSignature) {
                funcDecl.fncFlags |= Tools.FncFlags.Signature; 
            }
            if(indexer) {
                funcDecl.fncFlags |= Tools.FncFlags.IndexerMember; 
            }
            funcDecl.returnTypeAnnotation = returnType; 
            if(isMethod) {
                funcDecl.fncFlags |= Tools.FncFlags.Method; 
                funcDecl.fncFlags |= Tools.FncFlags.Exported; 
            }
            funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount; 
            funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount; 
            this.nestingLevel = prevNestingLevel; 
            return funcDecl; 
        };
        Parser.prototype.convertToTypeReference = function(ast) {
            var result; 
            switch(ast.nodeType) {
                case Tools.NodeType.TypeRef: {
                    return ast; 

                }
                case Tools.NodeType.Name: {
                    result = new Tools.TypeReference(ast, 0); 
                    result.minChar = ast.minChar; 
                    result.limChar = ast.limChar; 
                    return result; 

                }
                case Tools.NodeType.Index: {
 {
                        var expr = ast; 
                        result = this.convertToTypeReference(expr.operand1); 
                        if(result) {
                            result.arrayCount++; 
                            result.minChar = expr.minChar; 
                            result.limChar = expr.limChar; 
                            return result; 
                        } else  {
                            var etr = new Tools.AST(Tools.NodeType.Error); 
                            return etr; 
                        }
                    }

                }
            }
            return null; 
        };
        Parser.prototype.parseArgList = function(errorRecoverySet) {
            var minChar = this.scanner.pos; 
            this.tok = this.scanner.scan(); 
            if(this.tok.tokenId == Tools.TokenID.RParen) {
                return null; 
            }
            var args = new Tools.ASTList(); 
            args.minChar = minChar; 
            while(true) {
                if(args.members.length > 65535) {
                    this.reportParseError("max number of args exceeded"); 
                    return args; 
                }
                var arg = this.parseExpr(Tools.ErrorRecoverySet.Comma | errorRecoverySet, Tools.OperatorPrecedence.Cma, false, TypeContext.NoTypes); 
                args.append(arg); 
                if(this.tok.tokenId != Tools.TokenID.Comma) {
                    break;
                }
                this.tok = this.scanner.scan(); 
            }
            args.limChar = this.scanner.lastTokenLimChar(); 
            return args; 
        };
        Parser.prototype.parseBaseList = function(extendsList, implementsList, errorRecoverySet, interfaceOnly, isES6Class) {
            var keyword = true; 
            var currentList = extendsList; 
            for(; ; ) {
                if(keyword) {
                    if(this.tok.tokenId == Tools.TokenID.IMPLEMENTS) {
                        if(interfaceOnly) {
                            this.reportParseError("interfaces can not implement other types"); 
                        }
                        currentList = implementsList; 
                    }
                    this.tok = this.scanner.scan(); 
                    keyword = false; 
                }
                var baseName = null; 
                if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                    var minChar = this.scanner.startPos; 
                    baseName = new Tools.Identifier(this.tok.getText()); 
                    baseName.minChar = minChar; 
                    baseName.limChar = this.scanner.pos; 
                    baseName = this.parseNamedType(errorRecoverySet | Tools.ErrorRecoverySet.LCurly, minChar, baseName, false); 
                } else  {
                    this.reportParseError("expected base name"); 
                    if(this.errorRecovery) {
                        baseName = new Tools.MissingIdentifier(); 
                        baseName.minChar = this.scanner.pos; 
                        baseName.limChar = this.scanner.pos; 
                        baseName.flags |= Tools.ASTFlags.Error; 
                    }
                }
                if(this.tok.tokenId == Tools.TokenID.LParen) {
                    if(isES6Class) {
                        this.reportParseError("ES6 base classes may only be initialized via a 'super' call within the constructor body"); 
                    }
                    var baseArgs = this.parseArgList(errorRecoverySet | Tools.ErrorRecoverySet.RParen); 
                    var callNode = new Tools.CallExpression(Tools.NodeType.Call, baseName, baseArgs); 
                    this.tok = this.scanner.scan(); 
                    callNode.limChar = this.scanner.pos; 
                    currentList.append(callNode); 
                } else  {
                    currentList.append(baseName); 
                }
                if(!interfaceOnly && currentList == extendsList && extendsList.members.length > 1) {
                    this.reportParseError("A class may only extend one other class"); 
                }
                if(this.tok.tokenId == Tools.TokenID.Comma) {
                    this.tok = this.scanner.scan(); 
                    continue;
                } else  {
                    if((this.tok.tokenId == Tools.TokenID.EXTENDS) || (this.tok.tokenId == Tools.TokenID.IMPLEMENTS)) {
                        currentList = extendsList; 
                        keyword = true; 
                        continue;
                    }
                }
                break;
            }
        };
        Parser.prototype.parseES6ClassDecl = function(errorRecoverySet, minChar, modifiers) {
            var leftCurlyCount = this.scanner.leftCurlyCount; 
            var rightCurlyCount = this.scanner.rightCurlyCount; 
            if((modifiers & Tools.Modifiers.Readonly) != Tools.Modifiers.None) {
                this.reportParseError("const modifier is implicit for class"); 
            }
            if(this.parsingDeclareFile || this.ambientModule) {
                modifiers |= Tools.Modifiers.Ambient; 
                modifiers |= Tools.Modifiers.Exported; 
            }
            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & Tools.Modifiers.Ambient) != Tools.Modifiers.None; 
            var svAmbientClass = this.ambientClass; 
            this.ambientClass = classIsMarkedAsAmbient; 
            this.tok = this.scanner.scan(); 
            var name = null; 
            if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                name = new Tools.Identifier(this.tok.getText()); 
                name.minChar = this.scanner.startPos; 
                name.limChar = this.scanner.pos; 
                this.tok = this.scanner.scan(); 
            } else  {
                this.reportParseError("class missing name"); 
                if(this.errorRecovery) {
                    name = new Tools.MissingIdentifier(); 
                    name.minChar = this.scanner.pos; 
                    name.limChar = this.scanner.pos; 
                    name.flags |= Tools.ASTFlags.Error; 
                }
            }
            var baseClass = null; 
            var interfacesImplemented = null; 
            var requiresSignature = false; 
            if((this.tok.tokenId == Tools.TokenID.EXTENDS) || (this.tok.tokenId == Tools.TokenID.IMPLEMENTS)) {
                baseClass = new Tools.ASTList(); 
                interfacesImplemented = new Tools.ASTList(); 
                this.parseBaseList(baseClass, interfacesImplemented, errorRecoverySet, false, true); 
            }
            var es6ClassDecl = new Tools.ES6ClassDecl(name, new Tools.ASTList(), baseClass, interfacesImplemented); 
            this.currentES6ClassDefinition = es6ClassDecl; 
            this.parseES6ClassElements(es6ClassDecl, errorRecoverySet, modifiers); 
            if(this.ambientModule || Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                es6ClassDecl.varFlags |= Tools.VarFlags.Exported; 
            }
            if(this.ambientModule || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                es6ClassDecl.varFlags |= Tools.VarFlags.Ambient; 
            }
            es6ClassDecl.varFlags |= Tools.VarFlags.ES6Class; 
            this.ambientClass = svAmbientClass; 
            es6ClassDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount; 
            es6ClassDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount; 
            return es6ClassDecl; 
        };
        Parser.prototype.parseES6ClassElements = function(es6ClassDecl, errorRecoverySet, parentModifiers) {
            var modifiers = parentModifiers; 
            var resetModifiers = false; 
            var membersMinChar = this.scanner.startPos; 
            this.chkCurTok(Tools.TokenID.LCurly, "expected '{'", errorRecoverySet); 
            this.nestingLevel++; 
            var currentMemberMinChar = this.scanner.startPos; 
            var wasGetOrSetId = false; 
            while(!(this.tok.tokenId == Tools.TokenID.RCurly || this.tok.tokenId == Tools.TokenID.EOF)) {
                var scanNext = true; 
                if(this.tok.tokenId == Tools.TokenID.GET) {
                    if(modifiers & Tools.Modifiers.Getter) {
                        this.reportParseError("Duplicate 'get' declaration in class body"); 
                    }
                    if(modifiers & Tools.Modifiers.Setter) {
                        this.reportParseError("Getter already marked as a setter"); 
                    }
                    modifiers |= Tools.Modifiers.Getter; 
                } else  {
                    if(this.tok.tokenId == Tools.TokenID.SET) {
                        if(modifiers & Tools.Modifiers.Setter) {
                            this.reportParseError("Duplicate 'set' declaration in class body"); 
                        }
                        if(modifiers & Tools.Modifiers.Getter) {
                            this.reportParseError("Setter already marked as a getter"); 
                        }
                        modifiers |= Tools.Modifiers.Setter; 
                    } else  {
                        if(this.tok.tokenId == Tools.TokenID.PRIVATE) {
                            if(modifiers & Tools.Modifiers.Private) {
                                this.reportParseError("Duplicate 'private' modifier"); 
                            }
                            modifiers |= Tools.Modifiers.Private; 
                        } else  {
                            if(this.tok.tokenId == Tools.TokenID.PUBLIC) {
                                modifiers |= Tools.Modifiers.Public; 
                            } else  {
                                if(this.tok.tokenId == Tools.TokenID.STATIC) {
                                    if(modifiers & Tools.Modifiers.Static) {
                                        this.reportParseError("Duplicate 'static' modifier"); 
                                    }
                                    modifiers |= Tools.Modifiers.Static; 
                                } else  {
                                    if(this.tok.tokenId == Tools.TokenID.CONSTRUCTOR) {
                                        if(modifiers != parentModifiers) {
                                            this.reportParseError("Constructors may not have modifiers"); 
                                        }
                                        this.parseES6ClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers); 
                                        scanNext = false; 
                                        resetModifiers = true; 
                                    } else  {
                                        if(wasGetOrSetId || this.tok.tokenId == Tools.TokenID.ID || Tools.convertTokToIDName(this.tok)) {
                                            var idText = wasGetOrSetId ? ((modifiers & Tools.Modifiers.Getter) ? "get" : "set") : this.tok.getText(); 
                                            var id = new Tools.Identifier(idText); 
                                            id.minChar = this.scanner.startPos; 
                                            id.limChar = this.scanner.pos; 
                                            if(wasGetOrSetId) {
                                                modifiers = modifiers ^ ((modifiers & Tools.Modifiers.Getter) ? Tools.Modifiers.Getter : Tools.Modifiers.Setter); 
                                                wasGetOrSetId = false; 
                                            } else  {
                                                this.tok = this.scanner.scan(); 
                                            }
                                            if(this.tok.tokenId == Tools.TokenID.LParen) {
                                                this.parseES6ClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers); 
                                                scanNext = false; 
                                            } else  {
                                                if(modifiers & Tools.Modifiers.Getter || modifiers & Tools.Modifiers.Setter) {
                                                    this.reportParseError("Property accessors must be functions"); 
                                                }
                                                var varDecl = this.parseES6ClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers); 
                                                if(varDecl.init && varDecl.init.nodeType == Tools.NodeType.FuncDecl) {
                                                    if(this.tok.tokenId == Tools.TokenID.RCurly) {
                                                        scanNext = false; 
                                                    }
                                                } else  {
                                                    if(this.tok.tokenId != Tools.TokenID.SColon) {
                                                        this.reportParseError("expected ';'"); 
                                                        scanNext = false; 
                                                    }
                                                }
                                            }
                                            resetModifiers = true; 
                                        } else  {
                                            if(this.tok.tokenId == Tools.TokenID.SUPER) {
                                                this.reportParseError("Base class initializers must be the first statement in a class definition"); 
                                            } else  {
                                                if(!wasGetOrSetId && ((modifiers & Tools.Modifiers.Getter) || (modifiers & Tools.Modifiers.Setter)) && (this.tok.tokenId == Tools.TokenID.LParen) || (this.tok.tokenId == Tools.TokenID.Asg)) {
                                                    wasGetOrSetId = true; 
                                                    scanNext = false; 
                                                } else  {
                                                    if(this.tok.tokenId != Tools.TokenID.SColon) {
                                                        this.reportParseError(("Unexpected '" + this.tok.getText()) + "' in class definition"); 
                                                        resetModifiers = true; 
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if(scanNext) {
                    this.tok = this.scanner.scan(); 
                }
                if(resetModifiers) {
                    modifiers = parentModifiers; 
                    currentMemberMinChar = this.scanner.startPos; 
                    resetModifiers = false; 
                }
            }
            var membersLimChar = this.scanner.pos; 
            if(this.tok.tokenId == Tools.TokenID.RCurly) {
                if(!this.currentES6ClassDefinition.definitionMembers.members.length) {
                    this.currentES6ClassDefinition.preComments = this.parseComments(); 
                }
                this.tok = this.scanner.scan(); 
            }
            this.nestingLevel--; 
            this.currentES6ClassDefinition.members.minChar = membersMinChar; 
            this.currentES6ClassDefinition.members.limChar = membersLimChar; 
            this.currentES6ClassDefinition.limChar = membersLimChar; 
            this.currentES6ClassDefinition = null; 
        };
        Parser.prototype.parseES6ClassConstructorDeclaration = function(minChar, errorRecoverySet, modifiers) {
            this.parsingES6ClassConstructorDefinition = true; 
            var isAmbient = this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient); 
            var args = new Tools.ASTList(); 
            var variableArgList = false; 
            var preComments = this.parseComments(); 
            this.tok = this.scanner.scan(); 
            if(this.tok.tokenId == Tools.TokenID.LParen) {
                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, true, isAmbient, false, false, false, null); 
                if(args.members.length > 0) {
                    var lastArg = args.members[args.members.length - 1]; 
                }
            }
            var requiresSignature = isAmbient || this.tok.tokenId == Tools.TokenID.SColon; 
            if(!requiresSignature) {
                this.currentES6ClassDefinition.constructorNestingLevel = this.nestingLevel + 1; 
            }
            var constructorFuncDecl = this.parseFunctionStatements(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, this.currentES6ClassDefinition.name, true, false, args, Tools.AllowedElements.ClassMembers, minChar, requiresSignature, modifiers); 
            constructorFuncDecl.preComments = preComments; 
            if(requiresSignature && !isAmbient) {
                constructorFuncDecl.isOverload = true; 
            }
            constructorFuncDecl.variableArgList = variableArgList; 
            this.currentClassDecl = null; 
            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentES6ClassDefinition.name); 
            constructorFuncDecl.classDecl = this.currentES6ClassDefinition; 
            if(isAmbient) {
                constructorFuncDecl.fncFlags |= Tools.FncFlags.Ambient; 
            }
            if(requiresSignature) {
                constructorFuncDecl.fncFlags |= Tools.FncFlags.Signature; 
            }
            if(this.ambientModule || Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                constructorFuncDecl.fncFlags |= Tools.FncFlags.Exported; 
            }
            if(this.currentES6ClassDefinition.constructorDecl) {
                if(!isAmbient && !this.currentES6ClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {
                    this.reportParseError("Duplicate constructor definition"); 
                }
            }
            if(isAmbient || !constructorFuncDecl.isSignature()) {
                this.currentES6ClassDefinition.constructorDecl = constructorFuncDecl; 
            }
            constructorFuncDecl.fncFlags |= Tools.FncFlags.ES6ClassMethod; 
            this.currentES6ClassDefinition.definitionMembers.members[this.currentES6ClassDefinition.definitionMembers.members.length] = constructorFuncDecl; 
            this.parsingES6ClassConstructorDefinition = false; 
            constructorFuncDecl.postComments = this.parseComments(); 
            return constructorFuncDecl; 
        };
        Parser.prototype.parseES6ClassMemberVariableDeclaration = function(text, minChar, isDeclaredInConstructor, errorRecoverySet, modifiers) {
            var varDecl = new Tools.VarDecl(text, this.nestingLevel); 
            varDecl.minChar = minChar; 
            var isStatic = false; 
            varDecl.preComments = this.parseComments(); 
            if(this.tok.tokenId == Tools.TokenID.Colon) {
                this.tok = this.scanner.scan(); 
                varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | Tools.ErrorRecoverySet.Asg | Tools.ErrorRecoverySet.Comma, false); 
            }
            if(this.tok.tokenId == Tools.TokenID.Asg) {
                if(this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                    this.reportParseError("context does not permit variable initializer"); 
                    if(this.errorRecovery) {
                        this.skip(errorRecoverySet); 
                        varDecl.flags |= Tools.ASTFlags.Error; 
                        varDecl.limChar = this.scanner.lastTokenLimChar(); 
                        return varDecl; 
                    }
                }
                this.tok = this.scanner.scan(); 
                varDecl.init = this.parseExpr(Tools.ErrorRecoverySet.Comma | errorRecoverySet, Tools.OperatorPrecedence.Cma, true, TypeContext.NoTypes); 
                varDecl.limChar = varDecl.init.limChar; 
                this.currentES6ClassDefinition.varFlags |= Tools.VarFlags.ES6ClassSuperMustBeFirstCallInConstructor; 
            } else  {
                varDecl.limChar = this.scanner.pos; 
            }
            if(modifiers & Tools.Modifiers.Static) {
                varDecl.varFlags |= Tools.VarFlags.Static; 
                isStatic = true; 
            }
            if((modifiers & Tools.Modifiers.Private) != Tools.Modifiers.None) {
                varDecl.varFlags |= Tools.VarFlags.Private; 
            } else  {
                varDecl.varFlags |= Tools.VarFlags.Public; 
            }
            varDecl.varFlags |= Tools.VarFlags.Property; 
            if(isDeclaredInConstructor) {
                varDecl.varFlags |= Tools.VarFlags.ES6ClassConstructorProperty; 
            }
            if(!isDeclaredInConstructor && !isStatic) {
                varDecl.varFlags |= Tools.VarFlags.ES6ClassBodyProperty; 
            }
            this.currentES6ClassDefinition.knownMemberNames[text.text] = true; 
            if(!isDeclaredInConstructor) {
                this.currentES6ClassDefinition.definitionMembers.members[this.currentES6ClassDefinition.definitionMembers.members.length] = varDecl; 
            }
            this.currentES6ClassDefinition.allMemberDefinitions.members[this.currentES6ClassDefinition.allMemberDefinitions.members.length] = varDecl; 
            varDecl.postComments = this.parseComments(); 
            return varDecl; 
        };
        Parser.prototype.parseES6ClassMemberFunctionDeclaration = function(methodName, minChar, errorRecoverySet, modifiers) {
            var wasAccessorID = this.prevIDTok != null; 
            var isAccessor = Tools.hasFlag(modifiers, Tools.Modifiers.Getter) || Tools.hasFlag(modifiers, Tools.Modifiers.Setter); 
            var isStatic = Tools.hasFlag(modifiers, Tools.Modifiers.Static); 
            var isAmbient = this.ambientModule || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient); 
            errorRecoverySet |= Tools.ErrorRecoverySet.RParen; 
            var preComments = this.parseComments(); 
            var ast = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null); 
            if(ast.nodeType == Tools.NodeType.Error) {
                return ast; 
            }
            var funcDecl = ast; 
            funcDecl.preComments = preComments; 
            funcDecl.minChar = minChar; 
            if(funcDecl.bod !== null) {
                funcDecl.limChar = funcDecl.bod.limChar; 
            }
            if(modifiers & Tools.Modifiers.Private) {
                funcDecl.fncFlags |= Tools.FncFlags.Private; 
            } else  {
                funcDecl.fncFlags |= Tools.FncFlags.Public; 
            }
            if(isStatic) {
                funcDecl.fncFlags |= Tools.FncFlags.Static; 
            }
            if(isAmbient) {
                funcDecl.fncFlags |= Tools.FncFlags.Ambient; 
            }
            if(isAccessor) {
                if(Tools.hasFlag(modifiers, Tools.Modifiers.Getter)) {
                    funcDecl.fncFlags |= Tools.FncFlags.GetAccessor; 
                    funcDecl.hint = "get" + funcDecl.name.text; 
                } else  {
                    funcDecl.fncFlags |= Tools.FncFlags.SetAccessor; 
                    funcDecl.hint = "set" + funcDecl.name.text; 
                }
                funcDecl.fncFlags |= Tools.FncFlags.IsFunctionExpression; 
            }
            funcDecl.fncFlags |= Tools.FncFlags.ES6ClassMethod; 
            this.currentES6ClassDefinition.knownMemberNames[methodName.text] = true; 
            this.currentES6ClassDefinition.definitionMembers.members[this.currentES6ClassDefinition.definitionMembers.members.length] = funcDecl; 
            funcDecl.postComments = this.parseComments(); 
            return funcDecl; 
        };
        Parser.prototype.parseClassDecl = function(errorRecoverySet, minChar, modifiers) {
            var leftCurlyCount = this.scanner.leftCurlyCount; 
            var rightCurlyCount = this.scanner.rightCurlyCount; 
            if((modifiers & Tools.Modifiers.Readonly) != Tools.Modifiers.None) {
                this.reportParseError("const modifier is implicit for class"); 
            }
            if(this.parsingDeclareFile || this.ambientModule) {
                modifiers |= Tools.Modifiers.Ambient; 
                modifiers |= Tools.Modifiers.Exported; 
            }
            var isAmbient = (modifiers & Tools.Modifiers.Ambient) != Tools.Modifiers.None; 
            var svAmbientClass = this.ambientClass; 
            this.ambientClass = isAmbient; 
            this.tok = this.scanner.scan(); 
            var name = null; 
            if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                name = new Tools.Identifier(this.tok.getText()); 
                name.minChar = this.scanner.startPos; 
                name.limChar = this.scanner.pos; 
                this.tok = this.scanner.scan(); 
            } else  {
                this.reportParseError("class missing name"); 
                if(this.errorRecovery) {
                    name = new Tools.MissingIdentifier(); 
                    name.minChar = this.scanner.pos; 
                    name.limChar = this.scanner.pos; 
                    name.flags |= Tools.ASTFlags.Error; 
                }
            }
            var args = new Tools.ASTList(); 
            var variableArgList = false; 
            if(this.tok.tokenId == Tools.TokenID.LParen) {
                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, false, isAmbient, false, false, false, null); 
                if(args.members.length > 0) {
                    var lastArg = args.members[args.members.length - 1]; 
                }
            }
            var bases = null; 
            var interfaces = null; 
            var requiresSignature = false; 
            var isOverload = false; 
            if((this.tok.tokenId == Tools.TokenID.EXTENDS) || (this.tok.tokenId == Tools.TokenID.IMPLEMENTS)) {
                bases = new Tools.ASTList(); 
                interfaces = new Tools.ASTList(); 
                this.parseBaseList(bases, interfaces, errorRecoverySet, false, false); 
            } else  {
                if(this.tok.tokenId == Tools.TokenID.SColon) {
                    requiresSignature = true; 
                    isOverload = requiresSignature; 
                }
            }
            var classDecl = new Tools.TypeDecl(Tools.NodeType.Class, name, null, args, bases, interfaces); 
            classDecl.isOverload = isOverload; 
            this.currentClassDecl = classDecl; 
            var constr = this.parseFunctionStatements(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, name, true, true, args, Tools.AllowedElements.ClassMembers, minChar, requiresSignature, modifiers); 
            constr.variableArgList = variableArgList; 
            this.currentClassDecl = null; 
            constr.returnTypeAnnotation = this.convertToTypeReference(name); 
            classDecl.members = constr; 
            constr.classDecl = classDecl; 
            if((modifiers & Tools.Modifiers.Private) != Tools.Modifiers.None) {
                classDecl.varFlags |= Tools.VarFlags.Private; 
            }
            if((modifiers & Tools.Modifiers.Public) != Tools.Modifiers.None) {
                classDecl.varFlags |= Tools.VarFlags.Public; 
            }
            if(this.parsingDeclareFile || this.ambientModule || (Tools.hasFlag(modifiers, Tools.Modifiers.Ambient))) {
                classDecl.varFlags |= Tools.VarFlags.Ambient; 
                constr.fncFlags |= Tools.FncFlags.Ambient; 
            }
            if(this.parsingDeclareFile || this.ambientModule || Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                classDecl.varFlags |= Tools.VarFlags.Exported; 
                constr.fncFlags |= Tools.FncFlags.Exported; 
            }
            if(requiresSignature) {
                constr.fncFlags |= Tools.FncFlags.Signature; 
            }
            constr.isOverload = classDecl.isOverload; 
            this.ambientClass = svAmbientClass; 
            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount; 
            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount; 
            return classDecl; 
        };
        Parser.prototype.parseInterfaceMember = function(errorRecoverySet) {
            var minChar = this.scanner.startPos; 
            var propertyDecl = this.parsePropertyDecl(errorRecoverySet, Tools.Modifiers.Public, true, false); 
            if(propertyDecl.nodeType == Tools.NodeType.VarDecl) {
                this.chkCurTok(Tools.TokenID.SColon, "expected ';'", errorRecoverySet); 
            }
            if(propertyDecl != null) {
                propertyDecl.minChar = minChar; 
            }
            return propertyDecl; 
        };
        Parser.prototype.parseInterfaceMembers = function(errorRecoverySet, members) {
            for(; ; ) {
                switch(this.tok.tokenId) {
                    case Tools.TokenID.RCurly: {

                    }
                    case Tools.TokenID.EOF: {
                        members.limChar = this.scanner.pos; 
                        return;

                    }
                }
                var element = this.parseInterfaceMember(errorRecoverySet | Tools.ErrorRecoverySet.StradaS); 
                if(element != null) {
                    members.append(element); 
                }
            }
        };
        Parser.prototype.parseInterfaceDecl = function(errorRecoverySet, modifiers) {
            var leftCurlyCount = this.scanner.leftCurlyCount; 
            var rightCurlyCount = this.scanner.rightCurlyCount; 
            this.tok = this.scanner.scan(); 
            var minChar = this.scanner.pos; 
            var name = null; 
            if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                name = new Tools.Identifier(this.tok.getText()); 
                name.minChar = this.scanner.startPos; 
                name.limChar = this.scanner.pos; 
                this.tok = this.scanner.scan(); 
            } else  {
                this.reportParseError("interface missing name"); 
                if(this.errorRecovery) {
                    name = new Tools.MissingIdentifier(); 
                    name.minChar = this.scanner.pos; 
                    name.limChar = this.scanner.pos; 
                    name.flags |= Tools.ASTFlags.Error; 
                }
            }
            var interfaces = null; 
            if(this.tok.tokenId == Tools.TokenID.EXTENDS) {
                interfaces = new Tools.ASTList(); 
                interfaces.minChar = this.scanner.startPos; 
                this.parseBaseList(interfaces, null, errorRecoverySet, true, false); 
            }
            var membersMinChar = this.scanner.startPos; 
            this.chkCurTok(Tools.TokenID.LCurly, "expected {", errorRecoverySet | Tools.ErrorRecoverySet.StradaS); 
            var members = new Tools.ASTList(); 
            members.minChar = membersMinChar; 
            var prevInInterfaceDecl = this.inInterfaceDecl; 
            this.inInterfaceDecl = true; 
            this.parseInterfaceMembers(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, members); 
            this.inInterfaceDecl = prevInInterfaceDecl; 
            this.chkCurTok(Tools.TokenID.RCurly, "expected }", errorRecoverySet); 
            var interfaceDecl = new Tools.TypeDecl(Tools.NodeType.Interface, name, members, null, interfaces, null); 
            if(Tools.hasFlag(modifiers, Tools.Modifiers.Private)) {
                interfaceDecl.varFlags |= Tools.VarFlags.Private; 
            }
            if(Tools.hasFlag(modifiers, Tools.Modifiers.Public)) {
                interfaceDecl.varFlags |= Tools.VarFlags.Public; 
            }
            if(Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                interfaceDecl.varFlags |= Tools.VarFlags.Exported; 
            }
            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount; 
            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount; 
            return interfaceDecl; 
        };
        Parser.prototype.makeVarDecl = function(id, nest) {
            var varDecl = new Tools.VarDecl(id, nest); 
            var currentVarList = this.topVarList(); 
            if(currentVarList != null) {
                currentVarList.append(varDecl); 
            }
            return varDecl; 
        };
        Parser.prototype.parsePropertyDecl = function(errorRecoverySet, modifiers, requireSignature, isStatic) {
            var text = null; 
            var minChar = this.scanner.startPos; 
            var nameLimChar = minChar; 
            var isNew = false; 
            var isIndexer = false; 
            var wasAccessorID = this.prevIDTok != null; 
            var isAccessor = Tools.hasFlag(modifiers, Tools.Modifiers.Getter) || Tools.hasFlag(modifiers, Tools.Modifiers.Setter); 
            if(this.parsingDeclareFile || this.ambientModule || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                requireSignature = true; 
            }
            if(this.tok.tokenId == Tools.TokenID.LParen && !wasAccessorID) {
                if(!requireSignature && !isStatic) {
                    this.reportParseError("expected identifier in property declaration"); 
                    if(this.errorRecovery) {
                        this.skip(errorRecoverySet); 
                        text = new Tools.MissingIdentifier(); 
                    }
                }
            } else  {
                if(this.tok.tokenId == Tools.TokenID.NEW) {
                    if(requireSignature) {
                        this.tok = this.scanner.scan(); 
                        if(this.tok.tokenId == Tools.TokenID.LParen) {
                            isNew = true; 
                        }
                    }
                    if(!isNew) {
                        if(!requireSignature) {
                            this.tok = this.scanner.scan(); 
                        }
                        text = new Tools.Identifier("new"); 
                        text.minChar = this.scanner.pos - 3; 
                        text.limChar = this.scanner.pos; 
                        nameLimChar = this.scanner.pos; 
                    }
                } else  {
                    if((this.tok.tokenId == Tools.TokenID.LBrack) && requireSignature) {
                        isIndexer = true; 
                        text = new Tools.Identifier("__item"); 
                    } else  {
                        if((this.tok.tokenId != Tools.TokenID.ID) && (!Tools.convertTokToIDName(this.tok)) && !wasAccessorID) {
                            this.reportParseError("expected identifier in property declaration"); 
                            if(this.errorRecovery) {
                                var eminChar = this.scanner.startPos; 
                                var curpos = this.scanner.pos; 
                                this.skip(errorRecoverySet & (~Tools.ErrorRecoverySet.Comma)); 
                                if(this.scanner.pos == curpos) {
                                    this.tok = this.scanner.scan(); 
                                }
                                var epd = new Tools.VarDecl(new Tools.MissingIdentifier(), this.nestingLevel); 
                                epd.flags |= Tools.ASTFlags.Error; 
                                epd.minChar = eminChar; 
                                epd.limChar = this.scanner.lastTokenLimChar(); 
                                return epd; 
                            }
                        } else  {
                            if(wasAccessorID) {
                                text = new Tools.Identifier(this.prevIDTok.getText()); 
                                text.minChar = this.scanner.lastTokenLimChar() - 3; 
                                text.limChar = this.scanner.lastTokenLimChar(); 
                                nameLimChar = text.limChar; 
                                if(Tools.codeGenTarget < Tools.CodeGenTarget.ES5) {
                                    this.reportParseError("Property accessors are only available when targeting ES5 or greater"); 
                                }
                                if(this.tok.getText() == text.text && this.tok != this.prevIDTok) {
                                    this.tok = this.scanner.scan(); 
                                }
                                this.prevIDTok = null; 
                            } else  {
                                text = new Tools.Identifier(this.tok.getText()); 
                                text.minChar = this.scanner.startPos; 
                                text.limChar = this.scanner.pos; 
                                nameLimChar = this.scanner.pos; 
                                this.tok = this.scanner.scan(); 
                            }
                        }
                    }
                }
            }
            if((this.tok.tokenId == Tools.TokenID.LParen) || (isIndexer && (this.tok.tokenId == Tools.TokenID.LBrack))) {
                var ers = errorRecoverySet | Tools.ErrorRecoverySet.RParen; 
                if(isIndexer) {
                    ers = errorRecoverySet | Tools.ErrorRecoverySet.RBrack; 
                }
                var ast = this.parseFncDecl(ers, true, requireSignature, !this.inFncDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)), modifiers, null); 
                var funcDecl; 
                if(ast.nodeType == Tools.NodeType.Error) {
                    return ast; 
                } else  {
                    funcDecl = ast; 
                }
                if(funcDecl.name != null) {
                    funcDecl.name.minChar = minChar; 
                    funcDecl.name.limChar = nameLimChar; 
                }
                if((modifiers & Tools.Modifiers.Public) != Tools.Modifiers.None) {
                    funcDecl.fncFlags |= Tools.FncFlags.Public; 
                }
                if((modifiers & Tools.Modifiers.Private) != Tools.Modifiers.None) {
                    funcDecl.fncFlags |= Tools.FncFlags.Private; 
                }
                if(isStatic) {
                    funcDecl.fncFlags |= Tools.FncFlags.Static; 
                }
                if(this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                    funcDecl.fncFlags |= Tools.FncFlags.Ambient; 
                }
                if(isAccessor) {
                    if(Tools.hasFlag(modifiers, Tools.Modifiers.Getter)) {
                        funcDecl.fncFlags |= Tools.FncFlags.GetAccessor; 
                        funcDecl.hint = "get" + funcDecl.name.text; 
                    } else  {
                        funcDecl.fncFlags |= Tools.FncFlags.SetAccessor; 
                        funcDecl.hint = "set" + funcDecl.name.text; 
                    }
                    funcDecl.fncFlags |= Tools.FncFlags.IsFunctionExpression; 
                }
                if(text == null) {
                    if(isNew) {
                        funcDecl.fncFlags |= Tools.FncFlags.ConstructMember; 
                        funcDecl.hint = "_construct"; 
                        funcDecl.classDecl = this.currentClassDecl; 
                    } else  {
                        funcDecl.hint = "_call"; 
                        funcDecl.fncFlags |= Tools.FncFlags.CallMember; 
                    }
                }
                return funcDecl; 
            } else  {
                var varDecl = new Tools.VarDecl(text, this.nestingLevel); 
                varDecl.minChar = minChar; 
                if(this.tok.tokenId == Tools.TokenID.Colon) {
                    this.tok = this.scanner.scan(); 
                    varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | Tools.ErrorRecoverySet.Asg | Tools.ErrorRecoverySet.Comma, false); 
                }
                if(this.tok.tokenId == Tools.TokenID.Asg) {
                    if(requireSignature) {
                        this.reportParseError("context does not permit variable initializer"); 
                        if(this.errorRecovery) {
                            this.skip(errorRecoverySet); 
                            varDecl.flags |= Tools.ASTFlags.Error; 
                            varDecl.limChar = this.scanner.lastTokenLimChar(); 
                            return varDecl; 
                        }
                    }
                    this.tok = this.scanner.scan(); 
                    varDecl.init = this.parseExpr(Tools.ErrorRecoverySet.Comma | errorRecoverySet, Tools.OperatorPrecedence.Cma, true, TypeContext.NoTypes); 
                    varDecl.limChar = varDecl.init.limChar; 
                    if(varDecl.init.nodeType == Tools.NodeType.FuncDecl) {
                        var funcDecl = varDecl.init; 
                        funcDecl.hint = varDecl.id.text; 
                        funcDecl.boundToProperty = varDecl; 
                        if(isAccessor) {
                            if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.IsFatArrowFunction)) {
                                if(Tools.hasFlag(modifiers, Tools.Modifiers.Getter)) {
                                    funcDecl.fncFlags |= Tools.FncFlags.GetAccessor; 
                                    funcDecl.hint = "get" + funcDecl.hint; 
                                } else  {
                                    funcDecl.fncFlags |= Tools.FncFlags.SetAccessor; 
                                    funcDecl.hint = "set" + funcDecl.hint; 
                                }
                                funcDecl.fncFlags |= Tools.FncFlags.IsFunctionExpression; 
                            } else  {
                                this.reportParseError("Accessors may only be functions"); 
                            }
                        }
                    } else  {
                        if(isAccessor) {
                            this.reportParseError("Accessors may only be functions"); 
                        }
                    }
                } else  {
                    varDecl.limChar = this.scanner.pos; 
                }
                if((modifiers & Tools.Modifiers.Readonly) != Tools.Modifiers.None) {
                    varDecl.varFlags |= Tools.VarFlags.Readonly; 
                }
                if(isStatic) {
                    varDecl.varFlags |= Tools.VarFlags.Static; 
                }
                if((modifiers & Tools.Modifiers.Public) != Tools.Modifiers.None) {
                    varDecl.varFlags |= Tools.VarFlags.Public; 
                }
                if((modifiers & Tools.Modifiers.Private) != Tools.Modifiers.None) {
                    varDecl.varFlags |= Tools.VarFlags.Private; 
                }
                varDecl.varFlags |= Tools.VarFlags.Property; 
                return varDecl; 
            }
        };
        Parser.prototype.parseVarDecl = function(errorRecoverySet, modifiers, allowIn, requireSignature, isStatic) {
            var isConst = Tools.hasFlag(modifiers, Tools.Modifiers.Readonly); 
            var minChar = this.scanner.startPos; 
            this.tok = this.scanner.scan(); 
            var varDecl = null; 
            var declList = null; 
            var multivar = false; 
            var varDeclPreComments = this.parseComments(); 
            for(; ; ) {
                if((this.tok.tokenId != Tools.TokenID.ID) && (!Tools.convertTokToID(this.tok, this.strictMode))) {
                    this.reportParseError("expected identifier in variable declaration"); 
                    if(this.errorRecovery) {
                        varDecl = new Tools.VarDecl(new Tools.MissingIdentifier(), this.nestingLevel); 
                        varDecl.minChar = minChar; 
                        this.skip(errorRecoverySet); 
                        varDecl.flags |= Tools.ASTFlags.Error; 
                        varDecl.limChar = this.scanner.lastTokenLimChar(); 
                        return varDecl; 
                    }
                }
                var text = this.tok.getText(); 
                if(this.strictMode && (text == "eval")) {
                    this.reportParseError("can not name a variable eval in strict mode"); 
                }
                varDecl = this.makeVarDecl(new Tools.Identifier(text), this.nestingLevel); 
                varDecl.id.minChar = this.scanner.startPos; 
                varDecl.id.limChar = this.scanner.pos; 
                varDecl.preComments = varDeclPreComments; 
                if(isStatic) {
                    varDecl.varFlags |= Tools.VarFlags.Static; 
                }
                if(Tools.hasFlag(modifiers, Tools.Modifiers.Readonly)) {
                    varDecl.varFlags |= Tools.VarFlags.Readonly; 
                }
                if(this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                    varDecl.varFlags |= Tools.VarFlags.Ambient; 
                }
                if(Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                    varDecl.varFlags |= Tools.VarFlags.Exported; 
                }
                varDecl.minChar = minChar; 
                if(declList != null) {
                    declList.append(varDecl); 
                }
                this.tok = this.scanner.scan(); 
                if(this.tok.tokenId == Tools.TokenID.Colon) {
                    this.tok = this.scanner.scan(); 
                    var prevInFncDecl = this.inFncDecl; 
                    this.inFncDecl = false; 
                    varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | Tools.ErrorRecoverySet.Asg | Tools.ErrorRecoverySet.Comma, false); 
                    this.inFncDecl = prevInFncDecl; 
                }
                if(this.tok.tokenId == Tools.TokenID.Asg) {
                    if(requireSignature) {
                        this.reportParseError("context does not permit variable initializer"); 
                        if(this.errorRecovery) {
                            this.skip(errorRecoverySet); 
                            varDecl.flags |= Tools.ASTFlags.Error; 
                            return varDecl; 
                        }
                    }
                    this.tok = this.scanner.scan(); 
                    varDecl.init = this.parseExpr(Tools.ErrorRecoverySet.Comma | errorRecoverySet, Tools.OperatorPrecedence.Cma, allowIn, TypeContext.NoTypes); 
                    varDecl.limChar = varDecl.init.limChar; 
                    if(varDecl.init.nodeType == Tools.NodeType.FuncDecl) {
                        var funcDecl = varDecl.init; 
                        funcDecl.hint = varDecl.id.text; 
                    }
                } else  {
                    if(isConst) {
                        this.reportParseError("const declaration requires initializer"); 
                    }
                    varDecl.limChar = this.scanner.pos; 
                }
                varDecl.postComments = this.parseCommentsForLine(this.scanner.line); 
                if(this.tok.tokenId != Tools.TokenID.Comma) {
                    if(declList != null) {
                        declList.limChar = varDecl.limChar; 
                        return declList; 
                    } else  {
                        return varDecl; 
                    }
                }
                if(!multivar) {
                    declList = new Tools.ASTList(); 
                    declList.minChar = varDecl.minChar; 
                    declList.append(varDecl); 
                    multivar = true; 
                }
                this.tok = this.scanner.scan(); 
                minChar = this.scanner.startPos; 
            }
        };
        Parser.prototype.parseMemberList = function(errorRecoverySet) {
            var elements = new Tools.ASTList(); 
            if(this.tok.tokenId == Tools.TokenID.RCurly) {
                return elements; 
            }
            var idHint = null; 
            var memberName = null; 
            var memberExpr = null; 
            var member = null; 
            var minChar = this.scanner.startPos; 
            var isSet = false; 
            var skippedTokenForGetSetId = false; 
            var getSetTok = null; 
            var getSetStartPos = 0; 
            var getSetPos = 0; 
            for(; ; ) {
                var accessorPattern = false; 
                if(this.tok.tokenId == Tools.TokenID.GET || this.tok.tokenId == Tools.TokenID.SET) {
                    isSet = this.tok.tokenId == Tools.TokenID.SET; 
                    getSetTok = this.tok; 
                    getSetStartPos = this.scanner.startPos; 
                    getSetPos = this.scanner.pos; 
                    this.tok = this.scanner.scan(); 
                    if(Tools.codeGenTarget < Tools.CodeGenTarget.ES5) {
                        this.reportParseError("Property accessors are only available when targeting ES5 or greater"); 
                    }
                    if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToIDName(this.tok)) {
                        idHint = isSet ? "set" : "get"; 
                        idHint = idHint + this.tok.getText(); 
                        memberName = new Tools.Identifier(this.tok.getText()); 
                        memberName.minChar = this.scanner.startPos; 
                        accessorPattern = true; 
                    } else  {
                        if(this.tok.tokenId != Tools.TokenID.Colon) {
                            this.reportParseError("expected identifier, string or number as accessor name"); 
                        } else  {
                            skippedTokenForGetSetId = true; 
                            memberName = new Tools.Identifier(getSetTok.getText()); 
                            memberName.minChar = getSetStartPos; 
                            memberName.limChar = getSetPos; 
                        }
                    }
                } else  {
                    if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToIDName(this.tok)) {
                        idHint = this.tok.getText(); 
                        memberName = new Tools.Identifier(idHint); 
                        memberName.minChar = this.scanner.startPos; 
                        memberName.limChar = this.scanner.pos; 
                    } else  {
                        if(this.tok.tokenId == Tools.TokenID.QString) {
                            idHint = this.tok.getText(); 
                            memberName = new Tools.StringLiteral(idHint); 
                            memberName.minChar = this.scanner.startPos; 
                            memberName.limChar = this.scanner.pos; 
                        } else  {
                            if(this.tok.tokenId == Tools.TokenID.NumberLit) {
                                var ntok = this.tok; 
                                idHint = ntok.value.toString(); 
                                memberName = new Tools.StringLiteral(idHint); 
                                memberName.minChar = this.scanner.startPos; 
                                memberName.limChar = this.scanner.pos; 
                            } else  {
                                this.reportParseError("expected identifier, string or number as member name"); 
                                if(this.errorRecovery) {
                                    memberName = new Tools.MissingIdentifier(); 
                                    memberName.minChar = this.scanner.startPos; 
                                    memberName.flags |= Tools.ASTFlags.Error; 
                                    this.skip(errorRecoverySet | Tools.ErrorRecoverySet.Comma); 
                                    memberName.limChar = this.scanner.lastTokenLimChar(); 
                                }
                            }
                        }
                    }
                }
                if(!skippedTokenForGetSetId) {
                    this.tok = this.scanner.scan(); 
                } else  {
                    skippedTokenForGetSetId = false; 
                }
                if(accessorPattern) {
                    var args = new Tools.ASTList(); 
                    this.parseFormalParameterList(errorRecoverySet | Tools.ErrorRecoverySet.RParen, args, false, false, true, false, !isSet, isSet, null); 
                    var funcDecl = this.parseFunctionStatements(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, memberName, false, true, args, Tools.AllowedElements.FunctionDecls, this.scanner.startPos, false, Tools.Modifiers.None); 
                    if(isSet && funcDecl.returnTypeAnnotation != null) {
                        this.reportParseError("Property setters may not declare a return type"); 
                    }
                    funcDecl.fncFlags |= isSet ? Tools.FncFlags.SetAccessor : Tools.FncFlags.GetAccessor; 
                    funcDecl.fncFlags |= Tools.FncFlags.IsFunctionExpression; 
                    funcDecl.hint = idHint; 
                    memberExpr = funcDecl; 
                    member = new Tools.BinaryExpression(Tools.NodeType.Member, memberName, memberExpr); 
                    member.minChar = memberName.minChar; 
                    if(memberExpr.nodeType == Tools.NodeType.FuncDecl) {
                        var funcDecl = memberExpr; 
                        funcDecl.hint = idHint; 
                    }
                } else  {
                    if(this.tok.tokenId == Tools.TokenID.Colon) {
                        this.tok = this.scanner.scan(); 
                        memberExpr = this.parseExpr(Tools.ErrorRecoverySet.Comma | errorRecoverySet, Tools.OperatorPrecedence.Cma, true, TypeContext.NoTypes); 
                        if(memberExpr.nodeType == Tools.NodeType.TypeRef) {
                            this.reportParseError("Expected 'new' on array declaration in member definition"); 
                        }
                        member = new Tools.BinaryExpression(Tools.NodeType.Member, memberName, memberExpr); 
                        member.minChar = memberName.minChar; 
                        if(memberExpr.nodeType == Tools.NodeType.FuncDecl) {
                            var funcDecl = memberExpr; 
                            funcDecl.hint = idHint; 
                        }
                    } else  {
                        this.reportParseError("expected ':' in member definition"); 
                        if(this.errorRecovery) {
                            this.skip(errorRecoverySet); 
                            elements.flags |= Tools.ASTFlags.Error; 
                            elements.minChar = minChar; 
                            elements.limChar = this.scanner.lastTokenLimChar(); 
                            return elements; 
                        }
                    }
                }
                idHint = null; 
                elements.append(member); 
                member.limChar = this.scanner.lastTokenLimChar(); 
                if(this.tok.tokenId != Tools.TokenID.Comma) {
                    break;
                } else  {
                    this.tok = this.scanner.scan(); 
                }
                if(this.tok.tokenId == Tools.TokenID.RCurly) {
                    break;
                }
            }
            if(member != null) {
                elements.limChar = member.limChar; 
            }
            elements.minChar = minChar; 
            return elements; 
        };
        Parser.prototype.parseArrayList = function(errorRecoverySet) {
            var elements = null; 
            if(this.tok.tokenId == Tools.TokenID.RBrack) {
                return elements; 
            } else  {
                elements = new Tools.ASTList(); 
                elements.minChar = this.scanner.startPos; 
            }
            var arg; 
            for(; ; ) {
                if((this.tok.tokenId == Tools.TokenID.Comma) || (this.tok.tokenId == Tools.TokenID.RBrack)) {
                    arg = new Tools.AST(Tools.NodeType.EmptyExpr); 
                } else  {
                    arg = this.parseExpr(Tools.ErrorRecoverySet.Comma | errorRecoverySet, Tools.OperatorPrecedence.Cma, true, TypeContext.NoTypes); 
                }
                elements.append(arg); 
                if(this.tok.tokenId != Tools.TokenID.Comma) {
                    break;
                }
                this.tok = this.scanner.scan(); 
            }
            elements.limChar = this.scanner.lastTokenLimChar(); 
            return elements; 
        };
        Parser.prototype.parseArrayLiteral = function(errorRecoverySet) {
            var arrayLiteral = null; 
            arrayLiteral = new Tools.UnaryExpression(Tools.NodeType.ArrayLit, this.parseArrayList(errorRecoverySet)); 
            return arrayLiteral; 
        };
        Parser.prototype.parseTerm = function(errorRecoverySet, allowCall, typeContext, inCast) {
            var ast = null; 
            var sawId = false; 
            var inNew = false; 
            var minChar = this.scanner.startPos; 
            var limChar = this.scanner.pos; 
            var parseAsLambda = false; 
            switch(this.tok.tokenId) {
                case Tools.TokenID.NUMBER: {

                }
                case Tools.TokenID.BOOL: {

                }
                case Tools.TokenID.ANY: {

                }
                case Tools.TokenID.STRING: {
                    var tid = new Tools.Identifier(Tools.tokenTable[this.tok.tokenId].text); 
                    if(Tools.hasFlag(typeContext, TypeContext.Primitive)) {
                        ast = new Tools.TypeReference(tid, 0); 
                        sawId = true; 
                    } else  {
                        ast = tid; 
                        sawId = true; 
                    }
                    ast.minChar = minChar; 
                    this.tok = this.scanner.scan(); 
                    limChar = this.scanner.lastTokenLimChar(); 
                    break;

                }
                case Tools.TokenID.THIS: {
                    ast = new Tools.AST(Tools.NodeType.This); 
                    ast.minChar = minChar; 
                    this.tok = this.scanner.scan(); 
                    limChar = this.scanner.lastTokenLimChar(); 
                    break;

                }
                case Tools.TokenID.SUPER: {
                    ast = new Tools.AST(Tools.NodeType.Super); 
                    ast.minChar = minChar; 
                    this.tok = this.scanner.scan(); 
                    limChar = this.scanner.lastTokenLimChar(); 
                    break;

                }
                case Tools.TokenID.TRUE: {
                    ast = new Tools.AST(Tools.NodeType.True); 
                    this.tok = this.scanner.scan(); 
                    ast.minChar = minChar; 
                    break;

                }
                case Tools.TokenID.FALSE: {
                    ast = new Tools.AST(Tools.NodeType.False); 
                    this.tok = this.scanner.scan(); 
                    ast.minChar = minChar; 
                    break;

                }
                case Tools.TokenID.NULL: {
                    ast = new Tools.AST(Tools.NodeType.Null); 
                    this.tok = this.scanner.scan(); 
                    ast.minChar = minChar; 
                    break;

                }
                case Tools.TokenID.NEW: {
                    minChar = this.scanner.pos; 
                    this.tok = this.scanner.scan(); 
                    ast = new Tools.CallExpression(Tools.NodeType.New, this.parseTerm(errorRecoverySet, false, TypeContext.AllSimpleTypes, inCast), null); 
                    ast.minChar = minChar; 
                    limChar = this.scanner.lastTokenLimChar(); 
                    inNew = true; 
                    break;

                }
                case Tools.TokenID.FUNCTION: {
                    minChar = this.scanner.pos; 
                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Tools.Modifiers.None, null); 
                    (ast).fncFlags |= Tools.FncFlags.IsFunctionExpression; 
                    ast.minChar = minChar; 
                    limChar = this.scanner.lastTokenLimChar(); 
                    ast.limChar = limChar; 
                    break;

                }
            }
            if(ast == null) {
                if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                    var idText = this.tok.getText(); 
                    if((this.currentClassDecl != null) && (idText == "self")) {
                        ast = new Tools.AST(Tools.NodeType.Self); 
                    } else  {
                        ast = this.createRef(idText, minChar); 
                        sawId = true; 
                    }
                    ast.minChar = minChar; 
                    this.tok = this.scanner.scan(); 
                    if(this.tok.tokenId == Tools.TokenID.QMark) {
                        ast.flags |= Tools.ASTFlags.PossibleOptionalParameter; 
                    } else  {
                        if(this.tok.tokenId == Tools.TokenID.Arrow) {
                            parseAsLambda = true; 
                        }
                    }
                    limChar = this.scanner.lastTokenLimChar(); 
                }
            }
            if(inCast) {
                this.chkCurTok(Tools.TokenID.GT, "expected '>'", errorRecoverySet); 
            }
            if(ast == null) {
                switch(this.tok.tokenId) {
                    case Tools.TokenID.LParen: {
                        minChar = this.scanner.pos; 
                        var prevTokId = this.scanner.previousToken().tokenId; 
                        this.tok = this.scanner.scan(); 
                        var couldBeLambda = prevTokId == Tools.TokenID.LParen || prevTokId == Tools.TokenID.Comma || prevTokId == Tools.TokenID.EQ || prevTokId == Tools.TokenID.Colon; 
                        if(couldBeLambda && this.tok.tokenId == Tools.TokenID.RParen) {
                            parseAsLambda = true; 
                            this.tok = this.scanner.scan(); 
                        } else  {
                            ast = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.RParen, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                            limChar = this.scanner.lastTokenLimChar(); 
                            parseAsLambda = couldBeLambda && (ast.nodeType == Tools.NodeType.Name || ast.nodeType == Tools.NodeType.Comma) && (this.tok.tokenId == Tools.TokenID.Colon || this.tok.tokenId == Tools.TokenID.QMark); 
                        }
                        if((ast && !parseAsLambda)) {
                            this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet); 
                            ast.isParenthesized = true; 
                        }
                        break;

                    }
                    case Tools.TokenID.NumberLit: {
 {
                            var numTok = this.tok; 
                            this.tok = this.scanner.scan(); 
                            ast = new Tools.NumberLiteral(numTok.value); 
                            ast.minChar = minChar; 
                            limChar = this.scanner.lastTokenLimChar(); 
                            break;
                        }

                    }
                    case Tools.TokenID.QString: {
                        ast = new Tools.StringLiteral(this.tok.getText()); 
                        this.tok = this.scanner.scan(); 
                        ast.minChar = minChar; 
                        limChar = this.scanner.lastTokenLimChar(); 
                        break;

                    }
                    case Tools.TokenID.Regex: {
 {
                            var rtok = this.tok; 
                            ast = new Tools.RegexLiteral(rtok.regex); 
                            this.tok = this.scanner.scan(); 
                            ast.minChar = minChar; 
                            limChar = this.scanner.lastTokenLimChar(); 
                            break;
                        }

                    }
                    case Tools.TokenID.LBrack: {
                        minChar = this.scanner.startPos; 
                        this.tok = this.scanner.scan(); 
                        ast = this.parseArrayLiteral(Tools.ErrorRecoverySet.RBrack | errorRecoverySet); 
                        ast.minChar = minChar; 
                        this.chkCurTok(Tools.TokenID.RBrack, "expected ']'", errorRecoverySet); 
                        limChar = this.scanner.lastTokenLimChar(); 
                        break;

                    }
                    case Tools.TokenID.LCurly: {
                        minChar = this.scanner.startPos; 
                        this.tok = this.scanner.scan(); 
                        var members = this.parseMemberList(Tools.ErrorRecoverySet.RCurly | errorRecoverySet); 
                        this.chkCurTok(Tools.TokenID.RCurly, "expected '}'", errorRecoverySet); 
                        ast = new Tools.UnaryExpression(Tools.NodeType.ObjectLit, members); 
                        ast.minChar = minChar; 
                        limChar = this.scanner.lastTokenLimChar(); 
                        members.minChar = minChar; 
                        members.limChar = limChar; 
                        break;

                    }
                    case Tools.TokenID.LT: {
                        minChar = this.scanner.startPos; 
                        this.tok = this.scanner.scan(); 
                        var term = this.parseTypeReference(Tools.ErrorRecoverySet.BinOp, false); 
                        this.chkCurTok(Tools.TokenID.GT, "expected '>'", errorRecoverySet); 
                        ast = new Tools.UnaryExpression(Tools.NodeType.Cast, this.parseExpr(errorRecoverySet, Tools.OperatorPrecedence.Uni, false, TypeContext.NoTypes)); 
                        (ast).castTerm = term; 
                        break;

                    }
                    default: {
                        if(this.prevExpr && Tools.hasFlag(this.prevExpr.flags, Tools.ASTFlags.PossibleOptionalParameter)) {
                            parseAsLambda = true; 
                            ast = this.prevExpr; 
                        } else  {
                            this.reportParseError("check format of expression term"); 
                            if(this.errorRecovery) {
                                var ident = new Tools.MissingIdentifier(); 
                                ident.minChar = minChar; 
                                ident.flags |= Tools.ASTFlags.Error; 
                                this.skip(errorRecoverySet | Tools.ErrorRecoverySet.Postfix); 
                                if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                                    ident.text = this.tok.getText(); 
                                    this.tok = this.scanner.scan(); 
                                    limChar = this.scanner.lastTokenLimChar(); 
                                } else  {
                                    limChar = this.scanner.lastTokenLimChar(); 
                                }
                                ast = ident; 
                            }
                        }

                    }
                }
            }
            if(parseAsLambda) {
                if(this.tok.tokenId == Tools.TokenID.Arrow || this.tok.tokenId == Tools.TokenID.Colon || this.tok.tokenId == Tools.TokenID.Comma || this.tok.tokenId == Tools.TokenID.RParen) {
                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Tools.Modifiers.None, {
                        preProcessedLambdaArgs: ast
                    }); 
                    (ast).fncFlags |= Tools.FncFlags.IsFunctionExpression; 
                    (ast).fncFlags |= Tools.FncFlags.IsFatArrowFunction; 
                    ast.minChar = minChar; 
                    limChar = this.scanner.lastTokenLimChar(); 
                    ast.limChar = limChar; 
                } else  {
                    if(ast) {
                        ast.isParenthesized = true; 
                    }
                }
            }
            if(sawId) {
                typeContext |= TypeContext.ArraySuffix; 
            }
            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar); 
            if(postFix != null) {
                if(sawId && (postFix.nodeType == Tools.NodeType.Index)) {
                    var binExpr = postFix; 
                    if(binExpr.operand2 == null) {
                        postFix = this.convertToTypeReference(postFix); 
                    }
                }
                postFix.minChar = minChar; 
                postFix.limChar = this.scanner.lastTokenLimChar(); 
                return postFix; 
            } else  {
                return new Tools.AST(Tools.NodeType.Error); 
            }
        };
        Parser.prototype.parseExpr = function(errorRecoverySet, minPrecedence, allowIn, typeContext) {
            var ast = null; 
            var tokenInfo = Tools.lookupToken(this.tok.tokenId); 
            var canAssign = true; 
            var idHint = null; 
            var minChar = this.scanner.startPos; 
            var preComments = this.parseComments(); 
            var exprIsAnonLambda = false; 
            if((tokenInfo != undefined) && (tokenInfo.unopNodeType != Tools.NodeType.None)) {
                canAssign = false; 
                this.tok = this.scanner.scan(); 
                var tempExpr = this.parseExpr(Tools.ErrorRecoverySet.BinOp | errorRecoverySet, tokenInfo.unopPrecedence, allowIn, TypeContext.NoTypes); 
                if((tokenInfo.unopNodeType == Tools.NodeType.Pos) && (tempExpr.nodeType == Tools.NodeType.NumberLit)) {
                    ast = tempExpr; 
                } else  {
                    if((tokenInfo.unopNodeType == Tools.NodeType.Neg) && (tempExpr.nodeType == Tools.NodeType.NumberLit)) {
                        var numLit = tempExpr; 
                        numLit.value = (-numLit.value); 
                        if(numLit.value == 0) {
                            numLit.isNegativeZero = true; 
                        }
                        ast = tempExpr; 
                    } else  {
                        ast = new Tools.UnaryExpression(tokenInfo.unopNodeType, tempExpr); 
                        ast.limChar = tempExpr.limChar; 
                    }
                }
                ast.minChar = minChar; 
            } else  {
                ast = this.parseTerm(Tools.ErrorRecoverySet.BinOp | Tools.ErrorRecoverySet.AddOp | errorRecoverySet, true, typeContext, false); 
                var id; 
                var temp; 
                if(ast.nodeType == Tools.NodeType.Name) {
                    id = ast; 
                    idHint = id.text; 
                } else  {
                    if(ast.nodeType == Tools.NodeType.Dot) {
                        var subsumedExpr = false; 
                        if(this.inferPropertiesFromThisAssignment && (this.tok.tokenId == Tools.TokenID.Colon || this.tok.tokenId == Tools.TokenID.Asg) && this.parsingES6ClassConstructorDefinition && this.nestingLevel == this.currentES6ClassDefinition.constructorNestingLevel && (ast).operand1.nodeType == Tools.NodeType.This) {
                            if((ast).operand2.nodeType == Tools.NodeType.Name) {
                                var op2ID = ((ast).operand2); 
                                if(!this.currentES6ClassDefinition.knownMemberNames[op2ID.text]) {
                                    ast = this.parseES6ClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, Tools.Modifiers.Public); 
                                    subsumedExpr = true; 
                                }
                            }
                        }
                        if(!subsumedExpr) {
                            temp = ast; 
                            while(temp.nodeType == Tools.NodeType.Dot) {
                                var binExpr = temp; 
                                temp = binExpr.operand2; 
                            }
                            if(temp.nodeType == Tools.NodeType.Name) {
                                id = temp; 
                                idHint = id.text; 
                            }
                        }
                    }
                }
                if((!this.scanner.lastTokenHadNewline()) && ((this.tok.tokenId == Tools.TokenID.Inc) || (this.tok.tokenId == Tools.TokenID.Dec))) {
                    canAssign = false; 
                    var operand = ast; 
                    ast = new Tools.UnaryExpression((this.tok.tokenId == Tools.TokenID.Inc) ? Tools.NodeType.IncPost : Tools.NodeType.DecPost, operand); 
                    ast.limChar = this.scanner.pos; 
                    ast.minChar = operand.minChar; 
                    this.tok = this.scanner.scan(); 
                }
            }
            for(; ; ) {
                tokenInfo = Tools.lookupToken(this.tok.tokenId); 
                if((tokenInfo == undefined) || (tokenInfo.binopNodeType == Tools.NodeType.None)) {
                    break;
                }
                if((!allowIn) && (tokenInfo.binopNodeType == Tools.NodeType.In)) {
                    break;
                }
                if(tokenInfo.binopPrecedence == Tools.OperatorPrecedence.Asg) {
                    if(tokenInfo.binopPrecedence < minPrecedence) {
                        break;
                    }
                    if(!canAssign) {
                        this.reportParseError("illegal assignment"); 
                    }
                } else  {
                    if(tokenInfo.binopPrecedence <= minPrecedence) {
                        break;
                    }
                }
                this.tok = this.scanner.scan(); 
                canAssign = false; 
                if(tokenInfo.binopNodeType == Tools.NodeType.QMark) {
                    this.prevExpr = ast; 
                    var qmarkNode = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.Colon, Tools.OperatorPrecedence.Asg, allowIn, TypeContext.NoTypes); 
                    this.prevExpr = null; 
                    if(!(qmarkNode.nodeType == Tools.NodeType.FuncDecl && Tools.hasFlag((qmarkNode).fncFlags, Tools.FncFlags.IsFatArrowFunction))) {
                        this.chkCurTok(Tools.TokenID.Colon, "expected :", errorRecoverySet | Tools.ErrorRecoverySet.ExprStart); 
                        ast = new Tools.TrinaryExpression(Tools.NodeType.QMark, ast, qmarkNode, this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.BinOp, Tools.OperatorPrecedence.Asg, allowIn, TypeContext.NoTypes)); 
                    } else  {
                        ast = qmarkNode; 
                        exprIsAnonLambda = true; 
                    }
                } else  {
                    var tc = TypeContext.NoTypes; 
                    var binExpr2; 
                    binExpr2 = new Tools.BinaryExpression(tokenInfo.binopNodeType, ast, this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.BinOp, tokenInfo.binopPrecedence, allowIn, TypeContext.NoTypes)); 
                    if(binExpr2.operand2.nodeType == Tools.NodeType.FuncDecl) {
                        var funcDecl = binExpr2.operand2; 
                        funcDecl.hint = idHint; 
                    }
                    binExpr2.minChar = ast.minChar; 
                    binExpr2.limChar = this.scanner.lastTokenLimChar(); 
                    idHint = null; 
                    ast = binExpr2; 
                }
            }
            if(canAssign) {
                ast.flags |= Tools.ASTFlags.Writeable; 
            }
            if(!exprIsAnonLambda) {
                ast.minChar = minChar; 
                ast.limChar = this.scanner.lastTokenLimChar(); 
                ast.preComments = preComments; 
                ast.postComments = this.parseCommentsForLine(this.scanner.line); 
            }
            return ast; 
        };
        Parser.prototype.parsePostfixOperators = function(errorRecoverySet, ast, allowCall, inNew, typeContext, lhsMinChar, lhsLimChar) {
            var count = 0; 
            if(ast != null) {
                ast.minChar = lhsMinChar; 
                ast.limChar = lhsLimChar; 
            }
            for(; ; ) {
                switch(this.tok.tokenId) {
                    case Tools.TokenID.LParen: {
                        if(inNew) {
                            var callExpr = ast; 
                            callExpr.args = this.parseArgList(errorRecoverySet); 
                            inNew = false; 
                        } else  {
                            if(!allowCall) {
                                return ast; 
                            }
                            ast = new Tools.CallExpression(Tools.NodeType.Call, ast, this.parseArgList(errorRecoverySet)); 
                            ast.minChar = lhsMinChar; 
                        }
                        this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet); 
                        ast.limChar = this.scanner.pos; 
                        break;

                    }
                    case Tools.TokenID.LBrack: {
                        this.tok = this.scanner.scan(); 
                        if(this.tok.tokenId == Tools.TokenID.RBrack) {
                            if(Tools.hasFlag(typeContext, TypeContext.ArraySuffix)) {
                                this.tok = this.scanner.scan(); 
                                if(ast.nodeType == Tools.NodeType.TypeRef) {
                                    var typeRef = ast; 
                                    typeRef.arrayCount++; 
                                } else  {
                                    ast = new Tools.BinaryExpression(Tools.NodeType.Index, ast, null); 
                                }
                                ast.limChar = this.scanner.pos; 
                                break;
                            }
                        }
                        ast = new Tools.BinaryExpression(Tools.NodeType.Index, ast, this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.RBrack, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes)); 
                        ast.minChar = lhsMinChar; 
                        this.chkCurTok(Tools.TokenID.RBrack, "expected ']'", errorRecoverySet); 
                        ast.limChar = this.scanner.pos; 
                        break;

                    }
                    case Tools.TokenID.Dot: {
 {
                            var name = null; 
                            var curpos = this.scanner.pos; 
                            this.tok = this.scanner.scan(); 
                            if((this.tok.tokenId == Tools.TokenID.ID) || (!this.scanner.lastTokenHadNewline() && Tools.convertTokToIDName(this.tok))) {
                                ast.flags |= Tools.ASTFlags.DotLHS; 
                                name = this.createRef(this.tok.getText(), this.scanner.startPos); 
                                name.limChar = this.scanner.pos; 
                                this.tok = this.scanner.scan(); 
                            } else  {
                                this.reportParseError("expected identifier following dot"); 
                                if(this.errorRecovery) {
                                    this.skip(errorRecoverySet); 
                                    ast.flags |= (Tools.ASTFlags.Error | Tools.ASTFlags.DotLHS); 
                                    return ast; 
                                } else  {
                                    name = new Tools.MissingIdentifier(); 
                                }
                            }
                            ast = new Tools.BinaryExpression(Tools.NodeType.Dot, ast, name); 
                            ast.minChar = lhsMinChar; 
                            ast.limChar = this.scanner.lastTokenLimChar(); 
                            break;
                        }

                    }
                    case Tools.TokenID.Arrow: {
                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Tools.Modifiers.None, {
                            preProcessedLambdaArgs: ast
                        }); 
                        (ast).fncFlags |= Tools.FncFlags.IsFunctionExpression; 
                        ast.minChar = lhsMinChar; 
                        ast.limChar = this.scanner.lastTokenLimChar(); 
                        break;

                    }
                    default: {
                        return ast; 

                    }
                }
            }
        };
        Parser.prototype.parseTry = function(tryNode, errorRecoverySet, allowedElements, parentModifiers) {
            var minChar = this.scanner.startPos; 
            var preComments = this.parseComments(); 
            this.tok = this.scanner.scan(); 
            if(this.tok.tokenId != Tools.TokenID.LCurly) {
                this.reportParseError("expected '{'"); 
                if(this.errorRecovery) {
                    var etryNode = tryNode; 
                    etryNode.minChar = minChar; 
                    etryNode.limChar = this.scanner.lastTokenLimChar(); 
                    etryNode.flags |= Tools.ASTFlags.Error; 
                    return etryNode; 
                }
            }
            tryNode.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers); 
            tryNode.minChar = minChar; 
            tryNode.limChar = tryNode.body.limChar; 
            tryNode.preComments = preComments; 
            tryNode.postComments = this.parseComments(); 
            return tryNode; 
        };
        Parser.prototype.parseCatch = function(errorRecoverySet, allowedElements, parentModifiers) {
            var catchMinChar = this.scanner.startPos; 
            var preComments = this.parseComments(); 
            this.tok = this.scanner.scan(); 
            this.chkCurTok(Tools.TokenID.LParen, "expected '('", errorRecoverySet | Tools.ErrorRecoverySet.ExprStart); 
            if((this.tok.tokenId != Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                this.reportParseError("expected identifier in catch header"); 
                if(this.errorRecovery) {
                    this.skip(errorRecoverySet); 
                    var ecatch = new Tools.Catch(new Tools.VarDecl(new Tools.MissingIdentifier(), this.nestingLevel), new Tools.Statement(Tools.NodeType.Empty)); 
                    ecatch.minChar = this.scanner.startPos; 
                    ecatch.limChar = this.scanner.pos; 
                    ecatch.flags |= Tools.ASTFlags.Error; 
                    return ecatch; 
                }
            }
            var param = new Tools.VarDecl(new Tools.Identifier(this.tok.getText()), this.nestingLevel); 
            param.id.minChar = this.scanner.startPos; 
            param.id.limChar = this.scanner.pos; 
            param.minChar = param.id.minChar; 
            param.limChar = param.id.limChar; 
            this.tok = this.scanner.scan(); 
            this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet | Tools.ErrorRecoverySet.StmtStart); 
            if(this.tok.tokenId != Tools.TokenID.LCurly) {
                this.reportParseError("expected '{' to start catch body"); 
                if(this.errorRecovery) {
                    this.skip(errorRecoverySet); 
                    var ecatch = new Tools.Catch(new Tools.VarDecl(new Tools.MissingIdentifier(), this.nestingLevel), new Tools.Statement(Tools.NodeType.Empty)); 
                    ecatch.minChar = this.scanner.startPos; 
                    ecatch.limChar = this.scanner.pos; 
                    ecatch.flags |= Tools.ASTFlags.Error; 
                    return ecatch; 
                }
            }
            var catchStmt = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers); 
            var catchNode = new Tools.Catch(param, catchStmt); 
            catchNode.minChar = catchMinChar; 
            catchNode.limChar = catchStmt.limChar; 
            catchNode.preComments = preComments; 
            catchNode.postComments = this.parseComments(); 
            return catchNode; 
        };
        Parser.prototype.parseFinally = function(errorRecoverySet, allowedElements, parentModifiers) {
            var finMinChar = this.scanner.startPos; 
            var preComments = this.parseComments(); 
            this.tok = this.scanner.scan(); 
            if(this.tok.tokenId != Tools.TokenID.LCurly) {
                this.reportParseError("expected '{' to start body of finally statement"); 
                if(this.errorRecovery) {
                    this.skip(errorRecoverySet); 
                    var efin = new Tools.Finally(new Tools.Statement(Tools.NodeType.Empty)); 
                    efin.flags |= Tools.ASTFlags.Error; 
                    efin.minChar = this.scanner.startPos; 
                    efin.limChar = this.scanner.pos; 
                    return efin; 
                }
            }
            var finBody = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers); 
            var fin = new Tools.Finally(finBody); 
            fin.minChar = finMinChar; 
            fin.limChar = fin.body.limChar; 
            fin.preComments = preComments; 
            fin.postComments = this.parseComments(); 
            return fin; 
        };
        Parser.prototype.parseTryCatchFinally = function(errorRecoverySet, allowedElements, parentModifiers, labelList) {
            var tryPart = new Tools.Try(null); 
            var tryMinChar = this.scanner.startPos; 
            this.pushStmt(tryPart, labelList); 
            this.parseTry(tryPart, errorRecoverySet | Tools.ErrorRecoverySet.Catch, allowedElements, parentModifiers); 
            this.popStmt(); 
            var tc = null; 
            var tf = null; 
            if(this.tok.tokenId == Tools.TokenID.CATCH) {
                var catchPart = this.parseCatch(errorRecoverySet | Tools.ErrorRecoverySet.Catch, allowedElements, parentModifiers); 
                tc = new Tools.TryCatch(tryPart, catchPart); 
                tc.minChar = tryPart.minChar; 
                tc.limChar = catchPart.limChar; 
            }
            if(this.tok.tokenId != Tools.TokenID.FINALLY) {
                if(tc == null) {
                    this.reportParseError("try with neither catch nor finally"); 
                    if(this.errorRecovery) {
                        var etf = new Tools.TryFinally(tryPart, new Tools.Finally(new Tools.AST(Tools.NodeType.Empty))); 
                        etf.flags |= Tools.ASTFlags.Error; 
                        etf.minChar = this.scanner.startPos; 
                        etf.limChar = this.scanner.pos; 
                        return etf; 
                    }
                    return new Tools.TryFinally(tryPart, new Tools.Finally(new Tools.AST(Tools.NodeType.Empty))); 
                } else  {
                    return tc; 
                }
            } else  {
                if(tc != null) {
                    tryPart = tc; 
                }
                var finallyPart = this.parseFinally(errorRecoverySet, allowedElements, parentModifiers); 
                tf = new Tools.TryFinally(tryPart, finallyPart); 
                tf.minChar = tryMinChar; 
                tf.limChar = finallyPart.limChar; 
                return tf; 
            }
        };
        Parser.prototype.parseStatement = function(errorRecoverySet, allowedElements, parentModifiers) {
            var ast = null; 
            var labelList = null; 
            var astList = null; 
            var temp; 
            var modifiers = Tools.Modifiers.None; 
            var minChar = this.scanner.startPos; 
            var forInOk = false; 
            var needTerminator = false; 
            var fnOrVar = null; 
            var preComments = this.parseComments(); 
            this.state = ParseState.StartStatement; 
            function isAmbient() {
                return Tools.hasFlag(modifiers, Tools.Modifiers.Ambient) || Tools.hasFlag(parentModifiers, Tools.Modifiers.Ambient); 
            }
            function mayNotBeExported() {
                if(Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                    this.reportError("Statement may not be exported"); 
                }
            }
            for(; ; ) {
                switch(this.tok.tokenId) {
                    case Tools.TokenID.EOF: {
                        ast = new Tools.AST(Tools.NodeType.Error); 
                        ast.minChar = minChar; 
                        ast.limChar = this.scanner.pos; 
                        break;

                    }
                    case Tools.TokenID.FUNCTION: {
                        if(this.inStaticFnc) {
                            this.reportParseError("Ambient static function delarations may only contain other ambient static function declarations"); 
                        }
                        if(this.parsingDeclareFile || isAmbient() || this.ambientModule) {
                            modifiers |= Tools.Modifiers.Public; 
                            this.tok = this.scanner.scan(); 
                            fnOrVar = this.parsePropertyDecl(errorRecoverySet | Tools.ErrorRecoverySet.SColon, modifiers, true, false); 
                            if(fnOrVar.nodeType == Tools.NodeType.VarDecl) {
                                this.reportParseError("function keyword can only introduce function declaration"); 
                            } else  {
                                if((fnOrVar.nodeType == Tools.NodeType.FuncDecl) && ((fnOrVar).fncFlags , Tools.FncFlags.IsFatArrowFunction)) {
                                    needTerminator = true; 
                                }
                            }
                            ast = fnOrVar; 
                        } else  {
                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, isAmbient(), modifiers, null); 
                            if(Tools.hasFlag((ast).fncFlags, Tools.FncFlags.IsFatArrowFunction)) {
                                needTerminator = true; 
                            }
                            if(this.ambientModule) {
                                this.reportParseError("function declaration not permitted within ambient module"); 
                            }
                            if(Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                                (ast).fncFlags |= Tools.FncFlags.Exported; 
                            }
                        }
                        break;

                    }
                    case Tools.TokenID.MODULE: {
                        if((allowedElements & Tools.AllowedElements.ModuleDecls) == Tools.AllowedElements.None) {
                            this.reportParseError("module not allowed in this context"); 
                            this.tok = this.scanner.scan(); 
                            ast = new Tools.AST(Tools.NodeType.Error); 
                            ast.minChar = minChar; 
                            ast.limChar = this.scanner.lastTokenLimChar(); 
                        } else  {
                            ast = this.parseModuleDecl(errorRecoverySet, modifiers); 
                        }
                        break;

                    }
                    case Tools.TokenID.IMPORT: {
                        if((allowedElements & Tools.AllowedElements.ModuleDecls) == Tools.AllowedElements.None) {
                            this.reportParseError("module not allowed in this context"); 
                            this.tok = this.scanner.scan(); 
                            ast = new Tools.AST(Tools.NodeType.Error); 
                            ast.minChar = minChar; 
                            ast.limChar = this.scanner.lastTokenLimChar(); 
                        } else  {
                            ast = this.parseImportDecl(errorRecoverySet, modifiers); 
                        }
                        break;

                    }
                    case Tools.TokenID.EXPORT: {
                        if((allowedElements & Tools.AllowedElements.ModuleDecls) == Tools.AllowedElements.None) {
                            this.reportParseError("'export' statements are only allowed at the global and module levels"); 
                            this.tok = this.scanner.scan(); 
                            ast = new Tools.AST(Tools.NodeType.Error); 
                            ast.minChar = minChar; 
                            ast.limChar = this.scanner.lastTokenLimChar(); 
                        }
                        if(this.topLevel) {
                            this.hasTopLevelImportOrExport = true; 
                        }
                        modifiers |= Tools.Modifiers.Exported; 
                        this.tok = this.scanner.scan(); 
                        break;

                    }
                    case Tools.TokenID.PRIVATE: {
                        modifiers |= Tools.Modifiers.Private; 
                        this.tok = this.scanner.scan(); 
                        if(this.parsingES6ClassConstructorDefinition) {
                            if(!this.inferPropertiesFromThisAssignment) {
                                this.reportParseError("Property declarations are not permitted within constructor bodies"); 
                            }
                            minChar = this.scanner.pos; 
                            if(this.inferPropertiesFromThisAssignment && (this.tok.tokenId != Tools.TokenID.THIS || (this.tok = this.scanner.scan()).tokenId != Tools.TokenID.Dot)) {
                                this.reportParseError("Expected 'this.' for property declaration"); 
                                this.tok = this.scanner.scan(); 
                                ast = new Tools.AST(Tools.NodeType.Error); 
                                ast.minChar = minChar; 
                                ast.limChar = this.scanner.lastTokenLimChar(); 
                            } else  {
                                this.tok = this.scanner.scan(); 
                                var id = new Tools.Identifier(this.tok.getText()); 
                                id.minChar = this.scanner.startPos; 
                                id.limChar = this.scanner.pos; 
                                this.tok = this.scanner.scan(); 
                                ast = this.parseES6ClassMemberVariableDeclaration(id, minChar, this.parsingES6ClassConstructorDefinition, errorRecoverySet, modifiers); 
                            }
                        } else  {
                            if((this.tok.tokenId != Tools.TokenID.OLDCLASS) && (this.tok.tokenId != Tools.TokenID.INTERFACE)) {
                                if(this.tok.tokenId == Tools.TokenID.GET) {
                                    this.prevIDTok = this.tok; 
                                    this.tok = this.scanner.scan(); 
                                    if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                                        modifiers |= Tools.Modifiers.Getter; 
                                        this.prevIDTok = null; 
                                    }
                                } else  {
                                    if(this.tok.tokenId == Tools.TokenID.SET) {
                                        this.prevIDTok = this.tok; 
                                        this.tok = this.scanner.scan(); 
                                        if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                                            modifiers |= Tools.Modifiers.Setter; 
                                            this.prevIDTok = null; 
                                        }
                                    }
                                }
                                fnOrVar = this.parsePropertyDecl(errorRecoverySet | Tools.ErrorRecoverySet.SColon, modifiers, isAmbient(), false); 
                                if((fnOrVar.nodeType == Tools.NodeType.VarDecl) || ((fnOrVar.nodeType == Tools.NodeType.FuncDecl) && (Tools.hasFlag((fnOrVar).fncFlags, Tools.FncFlags.IsFatArrowFunction)))) {
                                    needTerminator = true; 
                                }
                                ast = fnOrVar; 
                            }
                        }
                        break;

                    }
                    case Tools.TokenID.PROPERTY: {

                    }
                    case Tools.TokenID.PUBLIC: {
                        if(this.parsingES6ClassConstructorDefinition) {
                            if(!this.inferPropertiesFromThisAssignment) {
                                this.reportParseError("Property declarations are not permitted within constructor bodies"); 
                            }
                            this.tok = this.scanner.scan(); 
                            minChar = this.scanner.pos; 
                            modifiers |= Tools.Modifiers.Public; 
                            if(this.inferPropertiesFromThisAssignment && (this.tok.tokenId != Tools.TokenID.THIS || (this.tok = this.scanner.scan()).tokenId != Tools.TokenID.Dot)) {
                                this.reportParseError("Expected 'this.' for property declaration"); 
                                this.tok = this.scanner.scan(); 
                                ast = new Tools.AST(Tools.NodeType.Error); 
                                ast.minChar = minChar; 
                                ast.limChar = this.scanner.lastTokenLimChar(); 
                            } else  {
                                this.tok = this.scanner.scan(); 
                                var id = new Tools.Identifier(this.tok.getText()); 
                                id.minChar = this.scanner.startPos; 
                                id.limChar = this.scanner.pos; 
                                this.tok = this.scanner.scan(); 
                                ast = this.parseES6ClassMemberVariableDeclaration(id, minChar, this.parsingES6ClassConstructorDefinition, errorRecoverySet, modifiers); 
                            }
                        } else  {
                            if((allowedElements & Tools.AllowedElements.Properties) == Tools.AllowedElements.None) {
                                this.reportParseError("'property' statements are only allowed within classes"); 
                                this.tok = this.scanner.scan(); 
                                ast = new Tools.AST(Tools.NodeType.Error); 
                                ast.minChar = minChar; 
                                ast.limChar = this.scanner.lastTokenLimChar(); 
                            } else  {
                                modifiers |= Tools.Modifiers.Public; 
                                this.tok = this.scanner.scan(); 
                                if(this.tok.tokenId == Tools.TokenID.GET) {
                                    this.prevIDTok = this.tok; 
                                    this.tok = this.scanner.scan(); 
                                    if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                                        modifiers |= Tools.Modifiers.Getter; 
                                        this.prevIDTok = null; 
                                    }
                                } else  {
                                    if(this.tok.tokenId == Tools.TokenID.SET) {
                                        this.prevIDTok = this.tok; 
                                        this.tok = this.scanner.scan(); 
                                        if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                                            modifiers |= Tools.Modifiers.Setter; 
                                            this.prevIDTok = null; 
                                        }
                                    }
                                }
                                fnOrVar = this.parsePropertyDecl(errorRecoverySet | Tools.ErrorRecoverySet.SColon, modifiers, isAmbient(), false); 
                                if((fnOrVar.nodeType == Tools.NodeType.VarDecl) || ((fnOrVar.nodeType == Tools.NodeType.FuncDecl) && Tools.hasFlag((fnOrVar).fncFlags, Tools.FncFlags.IsFatArrowFunction))) {
                                    needTerminator = true; 
                                }
                                ast = fnOrVar; 
                            }
                        }
                        break;

                    }
                    case Tools.TokenID.DECLARE: {
                        if(!(allowedElements & Tools.AllowedElements.AmbientDecls)) {
                            this.reportParseError("Ambient declarations are only allowed at the top-level or module scopes"); 
                        }
                        if(Tools.hasFlag(parentModifiers, Tools.Modifiers.Ambient)) {
                            this.reportParseError("Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)"); 
                        }
                        modifiers |= Tools.Modifiers.Ambient; 
                        this.tok = this.scanner.scan(); 
                        break;

                    }
                    case Tools.TokenID.OLDCLASS: {
                        if((allowedElements & Tools.AllowedElements.ClassDecls) == Tools.AllowedElements.None) {
                            this.reportParseError("class not allowed in this context"); 
                            this.tok = this.scanner.scan(); 
                            ast = new Tools.AST(Tools.NodeType.Error); 
                            ast.minChar = minChar; 
                            ast.limChar = this.scanner.lastTokenLimChar(); 
                        } else  {
                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers); 
                        }
                        break;

                    }
                    case Tools.TokenID.CLASS: {
                        if((allowedElements & Tools.AllowedElements.ClassDecls) == Tools.AllowedElements.None) {
                            this.reportParseError("class not allowed in this context"); 
                            this.tok = this.scanner.scan(); 
                            ast = new Tools.AST(Tools.NodeType.Error); 
                            ast.minChar = minChar; 
                            ast.limChar = this.scanner.lastTokenLimChar(); 
                        } else  {
                            ast = this.parseES6ClassDecl(errorRecoverySet, minChar, modifiers); 
                        }
                        break;

                    }
                    case Tools.TokenID.INTERFACE: {
                        if((allowedElements & Tools.AllowedElements.InterfaceDecls) == Tools.AllowedElements.None) {
                            this.reportParseError("interface not allowed in this context"); 
                            this.tok = this.scanner.scan(); 
                            ast = new Tools.AST(Tools.NodeType.Error); 
                            ast.minChar = minChar; 
                            ast.limChar = this.scanner.lastTokenLimChar(); 
                        } else  {
                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers); 
                        }
                        break;

                    }
                    case Tools.TokenID.VAR: {
                        var declAst = this.parseVarDecl(errorRecoverySet | Tools.ErrorRecoverySet.StmtStart, modifiers, true, false, false); 
                        if(declAst.nodeType == Tools.NodeType.VarDecl) {
                            ast = declAst; 
                        } else  {
                            ast = new Tools.Block(declAst, false); 
                        }
                        needTerminator = true; 
                        if(this.ambientModule && ast.nodeType == Tools.NodeType.VarDecl) {
                            (ast).varFlags |= Tools.VarFlags.Exported; 
                        }
                        break;

                    }
                    case Tools.TokenID.STATIC: {
                        if(this.currentClassDecl == null && !this.inFnc) {
                            this.reportParseError("Statics may only be in class or function bodies"); 
                        }
                        mayNotBeExported(); 
                        modifiers |= Tools.Modifiers.Public; 
                        this.tok = this.scanner.scan(); 
                        if(this.tok.tokenId == Tools.TokenID.GET) {
                            this.prevIDTok = this.tok; 
                            this.tok = this.scanner.scan(); 
                            if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                                modifiers |= Tools.Modifiers.Getter; 
                                this.prevIDTok = null; 
                            }
                        } else  {
                            if(this.tok.tokenId == Tools.TokenID.SET) {
                                this.tok = this.scanner.scan(); 
                                if((this.tok.tokenId == Tools.TokenID.ID) || Tools.convertTokToID(this.tok, this.strictMode)) {
                                    modifiers |= Tools.Modifiers.Setter; 
                                }
                            }
                        }
                        if(isAmbient()) {
                            modifiers |= Tools.Modifiers.Ambient; 
                        }
                        fnOrVar = this.parsePropertyDecl(errorRecoverySet | Tools.ErrorRecoverySet.SColon, modifiers, this.parsingDeclareFile || (modifiers & Tools.Modifiers.Ambient) != Tools.Modifiers.None, true); 
                        var staticsList = this.topStaticsList(); 
                        if(staticsList != null && fnOrVar.nodeType == Tools.NodeType.VarDecl) {
                            staticsList.append(fnOrVar); 
                        }
                        if(fnOrVar.nodeType == Tools.NodeType.VarDecl || ((fnOrVar.nodeType == Tools.NodeType.FuncDecl) && Tools.hasFlag((fnOrVar).fncFlags, Tools.FncFlags.IsFatArrowFunction))) {
                            needTerminator = true; 
                        }
                        ast = fnOrVar; 
                        break;

                    }
                    case Tools.TokenID.FOR: {
                        mayNotBeExported(); 
                        if(modifiers != Tools.Modifiers.None) {
                            this.reportParseError("syntax error: for statement does not take modifiers"); 
                        }
                        minChar = this.scanner.startPos; 
                        this.chkNxtTok(Tools.TokenID.LParen, "expected '('", errorRecoverySet | Tools.ErrorRecoverySet.ExprStart | Tools.ErrorRecoverySet.Var); 
                        this.state = ParseState.ForInit; 
                        forInOk = true; 
                        switch(this.tok.tokenId) {
                            case Tools.TokenID.VAR: {
                                temp = this.parseVarDecl(errorRecoverySet | Tools.ErrorRecoverySet.SColon | Tools.ErrorRecoverySet.In, Tools.Modifiers.None, false, false, false); 
                                break;

                            }
                            case Tools.TokenID.SColon: {
                                temp = null; 
                                this.state = ParseState.ForCondStart; 
                                break;

                            }
                            default: {
                                temp = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.SColon | Tools.ErrorRecoverySet.In, Tools.OperatorPrecedence.No, false, TypeContext.NoTypes); 
                                break;

                            }
                        }
                        this.state = ParseState.ForInitAfterVar; 
                        if(this.tok.tokenId == Tools.TokenID.IN) {
                            if((temp == null) || (!forInOk)) {
                                this.reportParseError("malformed for statement"); 
                                if(this.errorRecovery) {
                                    this.skip(errorRecoverySet | Tools.ErrorRecoverySet.StmtStart); 
                                    ast = new Tools.AST(Tools.NodeType.Empty); 
                                    ast.flags |= Tools.ASTFlags.Error; 
                                }
                            } else  {
                                this.tok = this.scanner.scan(); 
                                var forInStmt = new Tools.ForInStatement(temp, this.parseExpr(Tools.ErrorRecoverySet.RParen | errorRecoverySet, Tools.OperatorPrecedence.Cma, false, TypeContext.NoTypes)); 
                                forInStmt.limChar = this.scanner.pos; 
                                this.chkCurTok(Tools.TokenID.RParen, "expected ')'", Tools.ErrorRecoverySet.StmtStart | errorRecoverySet); 
                                this.pushStmt(forInStmt, labelList); 
                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers); 
                                this.popStmt(); 
                                forInStmt.minChar = minChar; 
                                ast = forInStmt; 
                            }
                        } else  {
                            var forStmt = new Tools.ForStatement(temp); 
                            forStmt.minChar = minChar; 
                            this.chkCurTok(Tools.TokenID.SColon, "expected ';'", errorRecoverySet); 
                            if(this.tok.tokenId == Tools.TokenID.SColon) {
                                forStmt.cond = null; 
                            } else  {
                                forStmt.cond = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.SColon | Tools.ErrorRecoverySet.RParen, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                                if(this.tok.tokenId != Tools.TokenID.SColon) {
                                    this.skip(errorRecoverySet | Tools.ErrorRecoverySet.StmtStart); 
                                    ast = forStmt; 
                                    ast.flags |= Tools.ASTFlags.Error; 
                                }
                            }
                            this.tok = this.scanner.scan(); 
                            if(this.tok.tokenId == Tools.TokenID.RParen) {
                                forStmt.incr = null; 
                            } else  {
                                forStmt.incr = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.SColon | Tools.ErrorRecoverySet.RParen, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                            }
                            this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet | Tools.ErrorRecoverySet.LCurly); 
                            this.pushStmt(forStmt, labelList); 
                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers); 
                            this.popStmt(); 
                            forStmt.limChar = forStmt.body.limChar; 
                            ast = forStmt; 
                        }
                        break;

                    }
                    case Tools.TokenID.WITH: {
 {
                            if(Tools.codeGenTarget < Tools.CodeGenTarget.ES5) {
                                this.reportParseError("'with' statements are only available in ES5 codegen mode or better"); 
                            }
                            if(this.strictMode) {
                                this.reportParseError("'with' statements are not available in strict mode"); 
                            }
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("with statement does not take modifiers"); 
                            }
                            minChar = this.scanner.startPos; 
                            this.chkNxtTok(Tools.TokenID.LParen, "expected '('", errorRecoverySet | Tools.ErrorRecoverySet.ExprStart | Tools.ErrorRecoverySet.Var); 
                            var expr = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.Colon, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                            this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet | Tools.ErrorRecoverySet.LCurly); 
                            var withStmt = new Tools.WithStatement(expr); 
                            withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers); 
                            withStmt.minChar = minChar; 
                            withStmt.limChar = withStmt.body.limChar; 
                            ast = withStmt; 
                        }
                        break;

                    }
                    case Tools.TokenID.SWITCH: {
 {
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("switch statement does not take modifiers"); 
                            }
                            this.chkNxtTok(Tools.TokenID.LParen, "expected '('", errorRecoverySet | Tools.ErrorRecoverySet.ExprStart); 
                            var switchStmt = new Tools.SwitchStatement(this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.RParen, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes)); 
                            this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet | Tools.ErrorRecoverySet.LCurly); 
                            var caseListMinChar = this.scanner.startPos; 
                            this.chkCurTok(Tools.TokenID.LCurly, "expected '{'", errorRecoverySet | Tools.ErrorRecoverySet.SCase); 
                            switchStmt.defaultCase = null; 
                            switchStmt.caseList = new Tools.ASTList(); 
                            var caseStmt = null; 
                            this.pushStmt(switchStmt, labelList); 
                            for(; ; ) {
                                if((this.tok.tokenId == Tools.TokenID.CASE) || (this.tok.tokenId == Tools.TokenID.DEFAULT)) {
                                    var isDefault = (this.tok.tokenId == Tools.TokenID.DEFAULT); 
                                    caseStmt = new Tools.CaseStatement(); 
                                    caseStmt.minChar = this.scanner.startPos; 
                                    this.tok = this.scanner.scan(); 
                                    if(isDefault) {
                                        switchStmt.defaultCase = caseStmt; 
                                    } else  {
                                        caseStmt.expr = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.Colon, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                                    }
                                    this.chkCurTok(Tools.TokenID.Colon, "expected ':'", errorRecoverySet | Tools.ErrorRecoverySet.StmtStart); 
                                    caseStmt.body = new Tools.ASTList(); 
                                    this.parseStmtList(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, caseStmt.body, false, true, allowedElements, modifiers); 
                                    caseStmt.limChar = caseStmt.body.limChar; 
                                    switchStmt.caseList.append(caseStmt); 
                                } else  {
                                    break;
                                }
                            }
                            switchStmt.caseList.minChar = caseListMinChar; 
                            switchStmt.caseList.limChar = this.scanner.pos; 
                            switchStmt.limChar = switchStmt.caseList.limChar; 
                            this.chkCurTok(Tools.TokenID.RCurly, "expected '}'", errorRecoverySet); 
                            this.popStmt(); 
                            ast = switchStmt; 
                            break;
                        }

                    }
                    case Tools.TokenID.WHILE: {
 {
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("while statement does not take modifiers"); 
                            }
                            minChar = this.scanner.startPos; 
                            this.chkNxtTok(Tools.TokenID.LParen, "expected '('", Tools.ErrorRecoverySet.ExprStart | errorRecoverySet); 
                            var whileStmt = new Tools.WhileStatement(this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.RParen, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes)); 
                            whileStmt.minChar = minChar; 
                            this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet | Tools.ErrorRecoverySet.StmtStart); 
                            this.pushStmt(whileStmt, labelList); 
                            whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers); 
                            whileStmt.limChar = whileStmt.body.limChar; 
                            this.popStmt(); 
                            ast = whileStmt; 
                            break;
                        }

                    }
                    case Tools.TokenID.DO: {
 {
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("do statement does not take modifiers"); 
                            }
                            minChar = this.scanner.startPos; 
                            this.tok = this.scanner.scan(); 
                            var doStmt = new Tools.DoWhileStatement(); 
                            doStmt.minChar = minChar; 
                            this.pushStmt(doStmt, labelList); 
                            doStmt.body = this.parseStatement(errorRecoverySet | Tools.ErrorRecoverySet.While, allowedElements, parentModifiers); 
                            this.popStmt(); 
                            doStmt.whileAST = new Tools.Identifier("while"); 
                            doStmt.whileAST.minChar = this.scanner.startPos; 
                            this.chkCurTok(Tools.TokenID.WHILE, "expected 'while'", errorRecoverySet | Tools.ErrorRecoverySet.LParen); 
                            doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5; 
                            this.chkCurTok(Tools.TokenID.LParen, "expected '('", errorRecoverySet | Tools.ErrorRecoverySet.ExprStart); 
                            doStmt.cond = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.RParen, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                            doStmt.limChar = this.scanner.pos; 
                            this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet); 
                            ast = doStmt; 
                            if(this.tok.tokenId == Tools.TokenID.SColon) {
                                this.tok = this.scanner.scan(); 
                            }
                            break;
                        }

                    }
                    case Tools.TokenID.IF: {
 {
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("if statement does not take modifiers"); 
                            }
                            minChar = this.scanner.startPos; 
                            this.chkNxtTok(Tools.TokenID.LParen, "expected '('", errorRecoverySet | Tools.ErrorRecoverySet.ExprStart); 
                            var ifStmt = new Tools.IfStatement(this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.LParen, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes)); 
                            ifStmt.minChar = minChar; 
                            this.chkCurTok(Tools.TokenID.RParen, "expected ')'", errorRecoverySet | Tools.ErrorRecoverySet.StmtStart); 
                            this.pushStmt(ifStmt, labelList); 
                            ifStmt.thenBod = this.parseStatement(Tools.ErrorRecoverySet.Else | errorRecoverySet, allowedElements, parentModifiers); 
                            ifStmt.limChar = ifStmt.thenBod.limChar; 
                            if(this.tok.tokenId == Tools.TokenID.ELSE) {
                                this.tok = this.scanner.scan(); 
                                ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers); 
                                ifStmt.limChar = ifStmt.elseBod.limChar; 
                            }
                            this.popStmt(); 
                            ast = ifStmt; 
                            break;
                        }

                    }
                    case Tools.TokenID.TRY: {
 {
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("try statement does not take modifiers"); 
                            }
                            minChar = this.scanner.startPos; 
                            ast = this.parseTryCatchFinally(errorRecoverySet, Tools.AllowedElements.FunctionBody, parentModifiers, labelList); 
                            break;
                        }

                    }
                    case Tools.TokenID.LCurly: {
 {
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("block does not take modifiers"); 
                            }
                            minChar = this.scanner.startPos; 
                            this.tok = this.scanner.scan(); 
                            var block = new Tools.Block(new Tools.ASTList(), true); 
                            this.pushStmt(block, labelList); 
                            this.parseStmtList(errorRecoverySet | Tools.ErrorRecoverySet.RCurly, block.stmts, false, false, Tools.AllowedElements.Block, modifiers); 
                            this.popStmt(); 
                            block.stmts.minChar = minChar; 
                            block.stmts.limChar = this.scanner.pos; 
                            block.minChar = block.stmts.minChar; 
                            block.limChar = block.stmts.limChar; 
                            this.chkCurTok(Tools.TokenID.RCurly, "expected '}'", errorRecoverySet); 
                            ast = block; 
                            break;
                        }

                    }
                    case Tools.TokenID.SColon: {
                        mayNotBeExported(); 
                        if(modifiers != Tools.Modifiers.None) {
                            this.reportParseError("modifier can not appear here"); 
                        }
                        ast = new Tools.AST(Tools.NodeType.Empty); 
                        this.tok = this.scanner.scan(); 
                        break;

                    }
                    case Tools.TokenID.BREAK: {

                    }
                    case Tools.TokenID.CONTINUE: {
 {
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("modifiers can not appear before jump statement"); 
                            }
                            var jump = new Tools.Jump((this.tok.tokenId == Tools.TokenID.BREAK) ? Tools.NodeType.Break : Tools.NodeType.Continue); 
                            this.tok = this.scanner.scan(); 
                            if((this.tok.tokenId == Tools.TokenID.ID) && (!this.scanner.lastTokenHadNewline())) {
                                jump.target = this.tok.getText(); 
                                this.tok = this.scanner.scan(); 
                            }
                            this.resolveJumpTarget(jump); 
                            ast = jump; 
                            needTerminator = true; 
                            break;
                        }

                    }
                    case Tools.TokenID.RETURN: {
 {
                            mayNotBeExported(); 
                            if(modifiers != Tools.Modifiers.None) {
                                this.reportParseError("modifiers can not appear before return statement"); 
                            }
                            if(!this.inFnc) {
                                this.reportParseError("return statement outside of function body"); 
                            }
                            minChar = this.scanner.startPos; 
                            this.tok = this.scanner.scan(); 
                            var retStmt = new Tools.ReturnStatement(); 
                            retStmt.minChar = minChar; 
                            if((this.tok.tokenId != Tools.TokenID.SColon) && (this.tok.tokenId != Tools.TokenID.RCurly) && (!(this.scanner.lastTokenHadNewline()))) {
                                retStmt.returnExpression = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.SColon, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                            }
                            needTerminator = true; 
                            retStmt.limChar = this.scanner.lastTokenLimChar(); 
                            ast = retStmt; 
                            break;
                        }

                    }
                    case Tools.TokenID.THROW: {
                        mayNotBeExported(); 
                        if(modifiers != Tools.Modifiers.None) {
                            this.reportParseError("modifiers can not appear before a throw statement"); 
                        }
                        minChar = this.scanner.startPos; 
                        this.tok = this.scanner.scan(); 
                        if((this.tok.tokenId != Tools.TokenID.SColon) && (this.tok.tokenId != Tools.TokenID.RCurly) && (!(this.scanner.lastTokenHadNewline()))) {
                            temp = this.parseExpr(errorRecoverySet | Tools.ErrorRecoverySet.SColon, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                        } else  {
                            this.reportParseError("throw with no target"); 
                            temp = null; 
                        }
                        ast = new Tools.UnaryExpression(Tools.NodeType.Throw, temp); 
                        ast.limChar = this.scanner.lastTokenLimChar(); 
                        needTerminator = true; 
                        break;

                    }
                    case Tools.TokenID.ENUM: {
                        this.tok = this.scanner.scan(); 
                        ast = this.parseEnumDecl(errorRecoverySet, modifiers); 
                        ast.minChar = minChar; 
                        ast.limChar = this.scanner.lastTokenLimChar(); 
                        if(this.parsingDeclareFile || Tools.hasFlag(modifiers, Tools.Modifiers.Ambient)) {
                            (ast).modFlags |= Tools.ModuleFlags.Ambient; 
                        }
                        if(Tools.hasFlag(modifiers, Tools.Modifiers.Exported)) {
                            (ast).modFlags |= Tools.ModuleFlags.Exported; 
                        }
                        break;

                    }
                    default: {
                        if(modifiers != Tools.Modifiers.None) {
                            this.reportParseError("modifiers can not appear before an expression statement or label"); 
                        }
                        minChar = this.scanner.startPos; 
                        var svPos = this.scanner.pos; 
                        temp = this.parseExpr(Tools.ErrorRecoverySet.Colon | Tools.ErrorRecoverySet.StmtStart | errorRecoverySet, Tools.OperatorPrecedence.No, true, TypeContext.NoTypes); 
                        if(this.scanner.pos == svPos) {
                            this.tok = this.scanner.scan(); 
                            ast = temp; 
                        } else  {
                            if((this.tok.tokenId == Tools.TokenID.Colon) && (!this.scanner.lastTokenHadNewline()) && (temp != null) && (temp.nodeType == Tools.NodeType.Name)) {
                                if(labelList == null) {
                                    labelList = new Tools.ASTList(); 
                                }
                                labelList.append(new Tools.Label(temp)); 
                                this.tok = this.scanner.scan(); 
                            } else  {
                                ast = temp; 
                                needTerminator = true; 
                            }
                        }

                    }
                }
                if(ast != null) {
                    break;
                }
            }
            if(needTerminator) {
                switch(this.tok.tokenId) {
                    case Tools.TokenID.SColon: {
                        this.tok = this.scanner.scan(); 
                        ast.flags |= Tools.ASTFlags.ExplicitSemicolon; 
                        break;

                    }
                    case Tools.TokenID.EOF: {

                    }
                    case Tools.TokenID.RCurly: {
                        ast.flags |= Tools.ASTFlags.AutomaticSemicolon; 
                        if(this.style_requireSemi) {
                            this.reportParseStyleError("no automatic semicolon"); 
                        }
                        break;

                    }
                    default: {
                        if(!this.scanner.lastTokenHadNewline()) {
                            this.reportParseError("';' expected"); 
                        } else  {
                            ast.flags |= Tools.ASTFlags.AutomaticSemicolon; 
                            if(this.style_requireSemi) {
                                this.reportParseStyleError("no automatic semicolon"); 
                            }
                        }
                        break;

                    }
                }
            }
            if(labelList != null) {
                ast = new Tools.LabeledStatement(labelList, ast); 
            }
            ast.minChar = minChar; 
            var scannerLimChar = this.scanner.lastTokenLimChar(); 
            ast.limChar = (ast.limChar > scannerLimChar ? ast.limChar : scannerLimChar); 
            ast.preComments = preComments; 
            if(this.ambientModule && (!this.okAmbientModuleMember(ast))) {
                this.reportParseError("statement not permitted within ambient module"); 
            }
            ast.flags |= Tools.ASTFlags.IsStatement; 
            return ast; 
        };
        Parser.prototype.okAmbientModuleMember = function(ast) {
            var nt = ast.nodeType; 
            return (nt == Tools.NodeType.Class) || (nt == Tools.NodeType.ES6Class) || (nt == Tools.NodeType.Import) || (nt == Tools.NodeType.Interface) || (nt == Tools.NodeType.Module) || ((nt == Tools.NodeType.VarDecl) && (Tools.hasFlag((ast).varFlags, Tools.VarFlags.Property) || Tools.hasFlag((ast).varFlags, Tools.VarFlags.Exported))) || ((nt == Tools.NodeType.FuncDecl) && ((ast).isMethod())); 
        };
        Parser.prototype.parseStmtList = function(errorRecoverySet, stmts, sourceElms, noLeadingCase, allowedElements, parentModifiers) {
            var directivePrologue = sourceElms; 
            stmts.minChar = this.scanner.startPos; 
            var limChar = this.scanner.pos; 
            var innerStmts = (allowedElements & Tools.AllowedElements.ModuleDecls) == Tools.AllowedElements.None; 
            var classNope = (allowedElements & Tools.AllowedElements.ClassDecls) == Tools.AllowedElements.None; 
            errorRecoverySet |= Tools.ErrorRecoverySet.StradaS; 
            this.state = ParseState.StartStmtList; 
            var oldStrictMode = this.strictMode; 
            this.nestingLevel++; 
            for(; ; ) {
                if((this.tok.tokenId == Tools.TokenID.RCurly) || (noLeadingCase && ((this.tok.tokenId == Tools.TokenID.CASE) || (this.tok.tokenId == Tools.TokenID.DEFAULT))) || (innerStmts && (this.tok.tokenId == Tools.TokenID.EXPORT)) || (classNope && (this.tok.tokenId == Tools.TokenID.CLASS)) || (classNope && (this.tok.tokenId == Tools.TokenID.OLDCLASS)) || (this.tok.tokenId == Tools.TokenID.EOF)) {
                    this.state = ParseState.EndStmtList; 
                    stmts.limChar = limChar; 
                    if(stmts.members.length == 0) {
                        stmts.preComments = this.parseComments(); 
                    } else  {
                        stmts.postComments = this.parseComments(); 
                    }
                    this.strictMode = oldStrictMode; 
                    this.nestingLevel--; 
                    return;
                }
                var stmt = this.parseStatement(errorRecoverySet & (~(Tools.ErrorRecoverySet.Else | Tools.ErrorRecoverySet.RParen | Tools.ErrorRecoverySet.Catch | Tools.ErrorRecoverySet.Colon)), allowedElements, parentModifiers); 
                if(stmt != null) {
                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine)); 
                    stmts.append(stmt); 
                    limChar = stmt.limChar; 
                    if(directivePrologue) {
                        if(stmt.nodeType == Tools.NodeType.QString) {
                            var qstring = stmt; 
                            if(qstring.text == "use strict") {
                                stmts.flags |= Tools.ASTFlags.StrictMode; 
                                this.strictMode = true; 
                            } else  {
                                directivePrologue = false; 
                            }
                        } else  {
                            directivePrologue = false; 
                        }
                    }
                }
            }
        };
        Parser.prototype.quickParse = function(sourceText, filename, unitIndex) {
            var svGenTarget = Tools.moduleGenTarget; 
            try  {
                Tools.moduleGenTarget = Tools.ModuleGenTarget.Local; 
                var script = this.parse(sourceText, filename, unitIndex, Tools.AllowedElements.QuickParse); 
                return new QuickParseResult(script, this.scanner.lexState); 
            }finally {
                Tools.moduleGenTarget = svGenTarget; 
            }
        };
        Parser.prototype.parse = function(sourceText, filename, unitIndex, allowedElements) {
            if (typeof allowedElements === "undefined") {allowedElements = Tools.AllowedElements.Global; }
            this.ambientModule = false; 
            this.topLevel = true; 
            this.parseError = false; 
            this.hasTopLevelImportOrExport = false; 
            this.fname = filename; 
            this.currentUnitIndex = unitIndex; 
            this.scanner.resetComments(); 
            this.scanner.setSourceText(sourceText, Tools.LexMode.File); 
            var leftCurlyCount = this.scanner.leftCurlyCount; 
            var rightCurlyCount = this.scanner.rightCurlyCount; 
            var minChar = this.scanner.pos; 
            this.tok = this.scanner.scan(); 
            this.pushDeclLists(); 
            var bod = new Tools.ASTList(); 
            bod.minChar = minChar; 
            this.state = ParseState.StartScript; 
            this.parsingDeclareFile = filename.length > 6 && filename.substring(filename.length - 6, filename.length) == ".d.str"; 
            this.parseStmtList(Tools.ErrorRecoverySet.EOF | Tools.ErrorRecoverySet.Func, bod, true, false, allowedElements, Tools.Modifiers.None); 
            if(this.tok.tokenId != Tools.TokenID.EOF) {
                var badToken = Tools.tokenTable[this.tok.tokenId]; 
                this.reportParseError(("Unexpected statement block terminator '" + badToken.text) + "'"); 
            }
            this.state = ParseState.EndScript; 
            bod.limChar = this.scanner.pos; 
            var topLevelMod = null; 
            if(Tools.moduleGenTarget != Tools.ModuleGenTarget.Local && this.hasTopLevelImportOrExport) {
                var correctedFileName = Tools.switchToForwardSlashes(filename); 
                var id = new Tools.Identifier(correctedFileName); 
                topLevelMod = new Tools.ModuleDecl(id, bod, this.topVarList(), this.topScopeList()); 
                topLevelMod.modFlags |= Tools.ModuleFlags.IsDynamic; 
                topLevelMod.modFlags |= Tools.ModuleFlags.IsWholeFile; 
                topLevelMod.modFlags |= Tools.ModuleFlags.Exported; 
                if(this.parsingDeclareFile) {
                    topLevelMod.modFlags |= Tools.ModuleFlags.Ambient; 
                }
                topLevelMod.minChar = minChar; 
                topLevelMod.limChar = this.scanner.pos; 
                topLevelMod.prettyName = Tools.getPrettyName(correctedFileName); 
                topLevelMod.amdDependencies = this.amdDependencies; 
                bod = new Tools.ASTList(); 
                bod.minChar = topLevelMod.minChar; 
                bod.limChar = topLevelMod.limChar; 
                bod.append(topLevelMod); 
            }
            var script = new Tools.Script(this.topVarList(), this.topScopeList()); 
            script.bod = bod; 
            this.popDeclLists(); 
            script.minChar = minChar; 
            script.limChar = this.scanner.pos; 
            script.locationInfo = new Tools.LocationInfo(filename, this.scanner.lineMap, unitIndex); 
            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount; 
            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount; 
            script.isDeclareFile = this.parsingDeclareFile; 
            script.topLevelMod = topLevelMod; 
            return script; 
        };
        return Parser;
    })();
    Tools.Parser = Parser;
    
    function quickParse(logger, scopeStartAST, sourceText, minChar, limChar, errorCapture) {
        var fragment = sourceText.getText(minChar, limChar); 
        logger.log(((((("Quick parse range (" + minChar) + ",") + limChar) + "): \"") + Tools.stringToLiteral(fragment, 100)) + "\""); 
        var quickParser = new Parser(); 
        quickParser.setErrorRecovery(null, -1, -1); 
        quickParser.errorCallback = errorCapture; 
        var quickClassDecl = new Tools.TypeDecl(Tools.NodeType.Class, null, null, null, null, null); 
        quickParser.currentClassDecl = quickClassDecl; 
        var result = quickParser.quickParse(new Tools.StringSourceText(fragment), "", 0); 
        return result; 
    }
    Tools.quickParse = quickParse;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var PrintContext = (function () {
        _inheritsFrom(PrintContext, Tools.BaseWalkContext);
        function PrintContext(outfile, parser) {
            this.outfile = outfile;
            this.parser = parser;
            PrintContext._super.constructor.call(this);
            this.builder = ""; 
            this.indent1 = "  "; 
            this.indentStrings = []; 
            this.indentAmt = 0; 
        }
        PrintContext.prototype.increaseIndent = function() {
            this.indentAmt++; 
        };
        PrintContext.prototype.decreaseIndent = function() {
            this.indentAmt--; 
        };
        PrintContext.prototype.startLine = function() {
            if(this.builder.length > 0) {
                Tools.CompilerDiagnostics.Alert(this.builder); 
            }
            var indentString = this.indentStrings[this.indentAmt]; 
            if(indentString === undefined) {
                indentString = ""; 
                for(var i = 0; i < this.indentAmt; i++) {
                    indentString += this.indent1; 
                }
                this.indentStrings[this.indentAmt] = indentString; 
            }
            this.builder += indentString; 
        };
        PrintContext.prototype.write = function(s) {
            this.builder += s; 
        };
        PrintContext.prototype.writeLine = function(s) {
            this.builder += s; 
            this.outfile.WriteLine(this.builder); 
            this.builder = ""; 
        };
        return PrintContext;
    })();
    Tools.PrintContext = PrintContext;
    
    function prePrintAST(ast, parent, context) {
        var pc = context; 
        ast.print(pc); 
        pc.increaseIndent(); 
        return ast; 
    }
    Tools.prePrintAST = prePrintAST;
    function postPrintAST(ast, parent, context) {
        var pc = context; 
        pc.decreaseIndent(); 
        return ast; 
    }
    Tools.postPrintAST = postPrintAST;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    Tools.LexEOF = (-1); 
    Tools.LexCodeNWL = 10; 
    Tools.LexCodeRET = 13; 
    Tools.LexCodeTAB = 9; 
    Tools.LexCodeVTAB = 11; 
    Tools.LexCode_e = 'e'.charCodeAt(0); 
    Tools.LexCode_E = 'E'.charCodeAt(0); 
    Tools.LexCode_x = 'x'.charCodeAt(0); 
    Tools.LexCode_X = 'X'.charCodeAt(0); 
    Tools.LexCode_a = 'a'.charCodeAt(0); 
    Tools.LexCode_A = 'A'.charCodeAt(0); 
    Tools.LexCode_f = 'f'.charCodeAt(0); 
    Tools.LexCode_F = 'F'.charCodeAt(0); 
    Tools.LexCode_g = 'g'.charCodeAt(0); 
    Tools.LexCode_m = 'm'.charCodeAt(0); 
    Tools.LexCode_i = 'i'.charCodeAt(0); 
    Tools.LexCode_0 = '0'.charCodeAt(0); 
    Tools.LexCode_9 = '9'.charCodeAt(0); 
    Tools.LexCode_8 = '8'.charCodeAt(0); 
    Tools.LexCode_7 = '7'.charCodeAt(0); 
    Tools.LexCodeBSL = '\\'.charCodeAt(0); 
    Tools.LexCodeSHP = '#'.charCodeAt(0); 
    Tools.LexCodeBNG = '!'.charCodeAt(0); 
    Tools.LexCodeQUO = '"'.charCodeAt(0); 
    Tools.LexCodeAPO = '\''.charCodeAt(0); 
    Tools.LexCodePCT = '%'.charCodeAt(0); 
    Tools.LexCodeAMP = '&'.charCodeAt(0); 
    Tools.LexCodeLPR = '('.charCodeAt(0); 
    Tools.LexCodeRPR = ')'.charCodeAt(0); 
    Tools.LexCodePLS = '+'.charCodeAt(0); 
    Tools.LexCodeMIN = '-'.charCodeAt(0); 
    Tools.LexCodeMUL = '*'.charCodeAt(0); 
    Tools.LexCodeSLH = '/'.charCodeAt(0); 
    Tools.LexCodeXOR = '^'.charCodeAt(0); 
    Tools.LexCodeCMA = ','.charCodeAt(0); 
    Tools.LexCodeDOT = '.'.charCodeAt(0); 
    Tools.LexCodeLT = '<'.charCodeAt(0); 
    Tools.LexCodeEQ = '='.charCodeAt(0); 
    Tools.LexCodeGT = '>'.charCodeAt(0); 
    Tools.LexCodeQUE = '?'.charCodeAt(0); 
    Tools.LexCodeLBR = '['.charCodeAt(0); 
    Tools.LexCodeRBR = ']'.charCodeAt(0); 
    Tools.LexCodeUSC = '_'.charCodeAt(0); 
    Tools.LexCodeLC = '{'.charCodeAt(0); 
    Tools.LexCodeRC = '}'.charCodeAt(0); 
    Tools.LexCodeBAR = '|'.charCodeAt(0); 
    Tools.LexCodeTIL = '~'.charCodeAt(0); 
    Tools.LexCodeCOL = ':'.charCodeAt(0); 
    Tools.LexCodeSMC = ';'.charCodeAt(0); 
    Tools.LexCodeUnderscore = '_'.charCodeAt(0); 
    Tools.LexCodeDollar = '$'.charCodeAt(0); 
    Tools.LexCodeSpace = 32; 
    Tools.LexKeywordTable = undefined; 
    var autoToken = new Array(128); 
    var lexIdStartTable = new Array(128); 
    function LexInitialize() {
        Tools.initializeStaticTokens(); 
        autoToken[Tools.LexCodeLPR] = Tools.staticTokens[Tools.TokenID.LParen]; 
        autoToken[Tools.LexCodeRPR] = Tools.staticTokens[Tools.TokenID.RParen]; 
        autoToken[Tools.LexCodeCMA] = Tools.staticTokens[Tools.TokenID.Comma]; 
        autoToken[Tools.LexCodeSMC] = Tools.staticTokens[Tools.TokenID.SColon]; 
        autoToken[Tools.LexCodeLBR] = Tools.staticTokens[Tools.TokenID.LBrack]; 
        autoToken[Tools.LexCodeRBR] = Tools.staticTokens[Tools.TokenID.RBrack]; 
        autoToken[Tools.LexCodeTIL] = Tools.staticTokens[Tools.TokenID.Tilde]; 
        autoToken[Tools.LexCodeQUE] = Tools.staticTokens[Tools.TokenID.QMark]; 
        autoToken[Tools.LexCodeLC] = Tools.staticTokens[Tools.TokenID.LCurly]; 
        autoToken[Tools.LexCodeRC] = Tools.staticTokens[Tools.TokenID.RCurly]; 
        autoToken[Tools.LexCodeCOL] = Tools.staticTokens[Tools.TokenID.Colon]; 
        Tools.LexKeywordTable = new Tools.StringHashTable(); 
        for(var i in (Tools.TokenID)._map) {
            if(i <= Tools.TokenID.LimKeyword) {
                Tools.LexKeywordTable.add((Tools.TokenID)._map[i].toLowerCase(), i); 
            }
        }
        for(var j = 0; j < 128; j++) {
            if(LexIsIdentifierStartChar(j)) {
                lexIdStartTable[j] = true; 
            } else  {
                lexIdStartTable[j] = false; 
            }
        }
    }
    Tools.LexInitialize = LexInitialize;
    function LexAdjustIndent(code, indentAmt) {
        if((code == Tools.LexCodeLBR) || (code == Tools.LexCodeLC) || (code == Tools.LexCodeLPR)) {
            return indentAmt + 1; 
        } else  {
            if((code == Tools.LexCodeRBR) || (code == Tools.LexCodeRC) || (code == Tools.LexCodeRPR)) {
                return indentAmt - 1; 
            } else  {
                return indentAmt; 
            }
        }
    }
    Tools.LexAdjustIndent = LexAdjustIndent;
    function LexIsIdentifierStartChar(code) {
        return (((code >= 97) && (code <= 122)) || ((code >= 65) && (code <= 90)) || (code == Tools.LexCodeDollar) || (code == Tools.LexCodeUnderscore)); 
    }
    Tools.LexIsIdentifierStartChar = LexIsIdentifierStartChar;
    function LexIsDigit(code) {
        return ((code >= 48) && (code <= 57)); 
    }
    Tools.LexIsDigit = LexIsDigit;
    function LexIsIdentifierChar(code) {
        return lexIdStartTable[code] || LexIsDigit(code); 
    }
    Tools.LexIsIdentifierChar = LexIsIdentifierChar;
    function LexMatchingOpen(code) {
        if(code == Tools.LexCodeRBR) {
            return Tools.LexCodeLBR; 
        } else  {
            if(code == Tools.LexCodeRC) {
                return Tools.LexCodeLC; 
            } else  {
                if(code == Tools.LexCodeRPR) {
                    return Tools.LexCodeLPR; 
                } else  {
                    return 0; 
                }
            }
        }
    }
    Tools.LexMatchingOpen = LexMatchingOpen;
    (function(NumberScanState) {
        NumberScanState._map = []; 
        NumberScanState._map[0] = "Start"; 
        NumberScanState.Start = 0; 
        NumberScanState._map[1] = "InFraction"; 
        NumberScanState.InFraction = 1; 
        NumberScanState._map[2] = "InExponent"; 
        NumberScanState.InExponent = 2; 
    })(Tools.NumberScanState||(Tools.NumberScanState={}));
    var NumberScanState = Tools.NumberScanState;

    (function(LexState) {
        LexState._map = []; 
        LexState._map[0] = "Start"; 
        LexState.Start = 0; 
        LexState._map[1] = "InMultilineComment"; 
        LexState.InMultilineComment = 1; 
    })(Tools.LexState||(Tools.LexState={}));
    var LexState = Tools.LexState;

    (function(LexMode) {
        LexMode._map = []; 
        LexMode._map[0] = "Line"; 
        LexMode.Line = 0; 
        LexMode._map[1] = "File"; 
        LexMode.File = 1; 
    })(Tools.LexMode||(Tools.LexMode={}));
    var LexMode = Tools.LexMode;

    (function(CommentStyle) {
        CommentStyle._map = []; 
        CommentStyle._map[0] = "Line"; 
        CommentStyle.Line = 0; 
        CommentStyle._map[1] = "Block"; 
        CommentStyle.Block = 1; 
    })(Tools.CommentStyle||(Tools.CommentStyle={}));
    var CommentStyle = Tools.CommentStyle;

    var StringSourceText = (function () {
        function StringSourceText(text) {
            this.text = text;
        }
        StringSourceText.prototype.getText = function(start, end) {
            return this.text.substring(start, end); 
        };
        StringSourceText.prototype.getLength = function() {
            return this.text.length; 
        };
        return StringSourceText;
    })();
    Tools.StringSourceText = StringSourceText;
    
    var SourceTextSegment = (function () {
        function SourceTextSegment(segmentStart, segmentEnd, segment) {
            this.segmentStart = segmentStart;
            this.segmentEnd = segmentEnd;
            this.segment = segment;

        }
        SourceTextSegment.prototype.charCodeAt = function(index) {
            return this.segment.charCodeAt(index - this.segmentStart); 
        };
        SourceTextSegment.prototype.substring = function(start, end) {
            return this.segment.substring(start - this.segmentStart, end - this.segmentStart); 
        };
        return SourceTextSegment;
    })();
    Tools.SourceTextSegment = SourceTextSegment;
    
    var AggerateSourceTextSegment = (function () {
        function AggerateSourceTextSegment(seg1, seg2) {
            this.seg1 = seg1;
            this.seg2 = seg2;
        }
        AggerateSourceTextSegment.prototype.charCodeAt = function(index) {
            if(this.seg1.segmentStart <= index && index < this.seg1.segmentEnd) {
                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart); 
            }
            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart); 
        };
        AggerateSourceTextSegment.prototype.substring = function(start, end) {
            if(this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd) {
                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart); 
            }
            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substring(0, end - this.seg1.segmentStart); 
        };
        return AggerateSourceTextSegment;
    })();
    Tools.AggerateSourceTextSegment = AggerateSourceTextSegment;
    
    var ScannerTextStream = (function () {
        function ScannerTextStream(sourceText) {
            this.sourceText = sourceText;
            this.agg = new AggerateSourceTextSegment(ScannerTextStream.emptySegment, ScannerTextStream.emptySegment); 
            this.len = this.sourceText.getLength(); 
        }
        ScannerTextStream.emptySegment = new SourceTextSegment(0, 0, ""); 
        ScannerTextStream.prototype.max = function(a, b) {
            return a >= b ? a : b; 
        };
        ScannerTextStream.prototype.min = function(a, b) {
            return a <= b ? a : b; 
        };
        ScannerTextStream.prototype.fetchSegment = function(start, end) {
            if(this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd) {
                return this.agg.seg1; 
            }
            if(this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd) {
                return this.agg; 
            }
            var prev = this.agg.seg1; 
            var s = prev.segmentEnd; 
            var e = Tools.max(s + 512, end); 
            e = Tools.min(e, this.len); 
            var src = this.sourceText.getText(s, e); 
            var newSeg = new SourceTextSegment(s, e, src); 
            this.agg.seg2 = prev; 
            this.agg.seg1 = newSeg; 
            return this.agg; 
        };
        ScannerTextStream.prototype.charCodeAt = function(index) {
            return this.fetchSegment(index, index + 1).charCodeAt(index); 
        };
        ScannerTextStream.prototype.substring = function(start, end) {
            return this.fetchSegment(start, end).substring(start, end); 
        };
        return ScannerTextStream;
    })();
    Tools.ScannerTextStream = ScannerTextStream;
    
    var SavedTokens = (function () {
        function SavedTokens() {
            this.prevToken = null; 
            this.curSavedToken = null; 
            this.prevSavedToken = null; 
            this.currentTokenIndex = 0; 
            this.currentTokens = null; 
            this.tokensByLine = null; 
            this.lexStateByLine = null; 
            this.prevToken = null; 
            this.currentToken = 0; 
            this.tokens = new Array(); 
            this.startPos = 0; 
            this.pos = 0; 
            this.startLine = 0; 
            this.prevLine = 1; 
            this.line = 1; 
            this.col = 0; 
            this.leftCurlyCount = 0; 
            this.rightCurlyCount = 0; 
            this.lexState = LexState.Start; 
            this.commentStack = new Array(); 
            this.lineMap = null; 
        }
        SavedTokens.prototype.previousToken = function() {
            return this.prevToken; 
        };
        SavedTokens.prototype.close = function() {
            this.currentToken = 0; 
        };
        SavedTokens.prototype.addToken = function(tok, scanner) {
            this.tokens[this.currentToken++] = new Tools.SavedToken(tok, scanner.startPos, scanner.pos); 
        };
        SavedTokens.prototype.scan = function() {
            this.startLine = this.line; 
            this.startPos = this.col; 
            if(this.currentTokenIndex == this.currentTokens.length) {
                if(this.line < this.lineMap.length) {
                    this.line++; 
                    this.col = 0; 
                    this.currentTokenIndex = 0; 
                    this.currentTokens = this.tokensByLine[this.line]; 
                } else  {
                    return Tools.staticTokens[Tools.TokenID.EOF]; 
                }
            }
            if(this.currentTokenIndex < this.currentTokens.length) {
                this.prevToken = this.curSavedToken.tok; 
                this.prevSavedToken = this.curSavedToken; 
                this.curSavedToken = this.currentTokens[this.currentTokenIndex++]; 
                var curToken = this.curSavedToken.tok; 
                this.pos = this.curSavedToken.limChar; 
                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar); 
                this.startPos = this.curSavedToken.minChar; 
                this.prevLine = this.line; 
                return curToken; 
            } else  {
                return Tools.staticTokens[Tools.TokenID.EOF]; 
            }
        };
        SavedTokens.prototype.syncToTok = function(offset) {
            this.line = getLineNumberFromPosition(this.lineMap, offset); 
            this.currentTokenIndex = 0; 
            var tmpCol = offset - this.lineMap[this.line]; 
            while((this.lexStateByLine[this.line] == LexState.InMultilineComment) && (this.line > 0)) {
                this.line--; 
                tmpCol = 0; 
            }
            var lenMin1 = this.lineMap.length - 1; 
            this.currentTokens = this.tokensByLine[this.line]; 
            while((this.currentTokens.length == 0) && (this.line < lenMin1)) {
                this.line++; 
                this.currentTokens = this.tokensByLine[this.line]; 
                tmpCol = 0; 
            }
            if(this.line <= lenMin1) {
                while((this.currentTokenIndex < this.currentTokens.length) && (tmpCol > this.currentTokens[this.currentTokenIndex].limChar)) {
                    this.currentTokenIndex++; 
                }
                if(this.currentTokenIndex < this.currentTokens.length) {
                    this.col = this.currentTokens[this.currentTokenIndex].minChar; 
                    return this.col + this.lineMap[this.line]; 
                }
            }
            return -1; 
        };
        SavedTokens.prototype.lastTokenLimChar = function() {
            if(this.prevSavedToken !== null) {
                return this.prevSavedToken.limChar; 
            } else  {
                return 0; 
            }
        };
        SavedTokens.prototype.lastTokenHadNewline = function() {
            return this.prevLine != this.startLine; 
        };
        SavedTokens.prototype.pushComment = function(comment) {
            this.commentStack.push(comment); 
        };
        SavedTokens.prototype.getComments = function() {
            var stack = this.commentStack; 
            this.commentStack = []; 
            return stack; 
        };
        SavedTokens.prototype.getCommentsForLine = function(line) {
            var comments = null; 
            while((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {
                if(comments == null) {
                    comments = [                        this.commentStack.shift()
]; 
                } else  {
                    comments = comments.concat([                        this.commentStack.shift()
]); 
                }
            }
            return comments; 
        };
        SavedTokens.prototype.resetComments = function() {
            this.commentStack = []; 
        };
        SavedTokens.prototype.setSourceText = function(newSrc, textMode) {
        };
        return SavedTokens;
    })();
    Tools.SavedTokens = SavedTokens;
    
    var Scanner = (function () {
        function Scanner() {
            this.prevLine = 1; 
            this.line = 1; 
            this.col = 0; 
            this.pos = 0; 
            this.startPos = 0; 
            this.startCol = this.col; 
            this.startLine = this.line; 
            this.src = ""; 
            this.len = 0; 
            this.lineMap = []; 
            this.lineMap[1] = 0; 
            this.ch = Tools.LexEOF; 
            this.lexState = LexState.Start; 
            this.mode = LexMode.File; 
            this.scanComments = true; 
            this.interveningWhitespace = false; 
            this.interveningWhitespacePos = 0; 
            this.leftCurlyCount = 0; 
            this.rightCurlyCount = 0; 
            this.commentStack = new Array(); 
            this.saveScan = null; 
            if(!Tools.LexKeywordTable) {
                LexInitialize(); 
            }
            this.prevTok = Tools.staticTokens[Tools.TokenID.EOF]; 
        }
        Scanner.prototype.previousToken = function() {
            return this.prevTok; 
        };
        Scanner.prototype.setSourceText = function(newSrc, textMode) {
            this.mode = textMode; 
            this.scanComments = (this.mode === LexMode.Line); 
            this.pos = 0; 
            this.interveningWhitespacePos = 0; 
            this.startPos = 0; 
            this.line = 1; 
            this.col = 0; 
            this.startCol = this.col; 
            this.startLine = this.line; 
            this.len = 0; 
            this.src = newSrc.getText(0, newSrc.getLength()); 
            this.len = this.src.length; 
            this.lineMap = []; 
            this.lineMap[1] = 0; 
            this.commentStack = []; 
            this.leftCurlyCount = 0; 
            this.rightCurlyCount = 0; 
        };
        Scanner.prototype.setSaveScan = function(savedTokens) {
            this.saveScan = savedTokens; 
        };
        Scanner.prototype.setText = function(newSrc, textMode) {
            this.setSourceText(new StringSourceText(newSrc), textMode); 
        };
        Scanner.prototype.setScanComments = function(value) {
            this.scanComments = value; 
        };
        Scanner.prototype.getLexState = function() {
            return this.lexState; 
        };
        Scanner.prototype.scanLine = function(line, initialState) {
            this.lexState = initialState; 
            var result = new Array(); 
            this.setText(line, LexMode.Line); 
            var t = this.scan(); 
            while(t.tokenId != Tools.TokenID.EOF) {
                result[result.length] = t; 
                t = this.scan(); 
            }
            return result; 
        };
        Scanner.prototype.tokenStart = function() {
            this.startPos = this.pos; 
            this.startLine = this.line; 
            this.startCol = this.col; 
            this.interveningWhitespace = false; 
        };
        Scanner.prototype.peekChar = function() {
            if(this.pos < this.len) {
                return this.src.charCodeAt(this.pos); 
            } else  {
                return Tools.LexEOF; 
            }
        };
        Scanner.prototype.peekCharAt = function(index) {
            if(index < this.len) {
                return this.src.charCodeAt(index); 
            } else  {
                return Tools.LexEOF; 
            }
        };
        Scanner.prototype.IsHexDigit = function(c) {
            return ((c >= Tools.LexCode_0) && (c <= Tools.LexCode_9)) || ((c >= Tools.LexCode_A) && (c <= Tools.LexCode_F)) || ((c >= Tools.LexCode_a) && (c <= Tools.LexCode_f)); 
        };
        Scanner.prototype.IsOctalDigit = function(c) {
            return ((c >= Tools.LexCode_0) && (c <= Tools.LexCode_7)) || ((c >= Tools.LexCode_a) && (c <= Tools.LexCode_f)); 
        };
        Scanner.prototype.scanHexDigits = function() {
            var atLeastOneDigit = false; 
            for(; ; ) {
                if(this.IsHexDigit(this.ch)) {
                    this.nextChar(); 
                    atLeastOneDigit = true; 
                } else  {
                    if(atLeastOneDigit) {
                        return new Tools.NumberToken(parseInt(this.src.substring(this.startPos, this.pos))); 
                    } else  {
                        return null; 
                    }
                }
            }
        };
        Scanner.prototype.scanOctalDigits = function() {
            var atLeastOneDigit = false; 
            for(; ; ) {
                if(this.IsOctalDigit(this.ch)) {
                    this.nextChar(); 
                    atLeastOneDigit = true; 
                } else  {
                    if(atLeastOneDigit) {
                        return new Tools.NumberToken(parseInt(this.src.substring(this.startPos, this.pos))); 
                    } else  {
                        return null; 
                    }
                }
            }
        };
        Scanner.prototype.scanDecimalNumber = function(state) {
            var atLeastOneDigit = false; 
            var svPos = this.pos; 
            var svCol = this.col; 
            for(; ; ) {
                if(LexIsDigit(this.ch)) {
                    atLeastOneDigit = true; 
                    this.nextChar(); 
                } else  {
                    if(this.ch == Tools.LexCodeDOT) {
                        if(state == NumberScanState.Start) {
                            this.nextChar(); 
                            state = NumberScanState.InFraction; 
                        } else  {
                            if(atLeastOneDigit) {
                                return new Tools.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos))); 
                            } else  {
                                this.pos = svPos; 
                                this.col = svCol; 
                                return null; 
                            }
                        }
                    } else  {
                        if((this.ch == Tools.LexCode_e) || (this.ch == Tools.LexCode_E)) {
                            if(state == NumberScanState.Start) {
                                if(atLeastOneDigit) {
                                    atLeastOneDigit = false; 
                                    this.nextChar(); 
                                    state = NumberScanState.InExponent; 
                                } else  {
                                    this.pos = svPos; 
                                    this.col = svCol; 
                                    return null; 
                                }
                            } else  {
                                if(state == NumberScanState.InFraction) {
                                    this.nextChar(); 
                                    state = NumberScanState.InExponent; 
                                    atLeastOneDigit = false; 
                                } else  {
                                    if(atLeastOneDigit) {
                                        return new Tools.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos))); 
                                    } else  {
                                        this.pos = svPos; 
                                        this.col = svCol; 
                                        return null; 
                                    }
                                }
                            }
                        } else  {
                            if((this.ch == Tools.LexCodePLS) || (this.ch == Tools.LexCodeMIN)) {
                                if(state == NumberScanState.InExponent) {
                                    if(!atLeastOneDigit) {
                                        this.nextChar(); 
                                    } else  {
                                        this.pos = svPos; 
                                        this.col = svCol; 
                                        return null; 
                                    }
                                } else  {
                                    if(state == NumberScanState.InFraction) {
                                        return new Tools.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos))); 
                                    } else  {
                                        if(!atLeastOneDigit) {
                                            this.pos = svPos; 
                                            this.col = svCol; 
                                            return null; 
                                        } else  {
                                            return new Tools.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos))); 
                                        }
                                    }
                                }
                            } else  {
                                if(!atLeastOneDigit) {
                                    this.pos = svPos; 
                                    this.col = svCol; 
                                    return null; 
                                } else  {
                                    return new Tools.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos))); 
                                }
                            }
                        }
                    }
                }
            }
        };
        Scanner.prototype.scanNumber = function() {
            if(this.peekChar() == Tools.LexCode_0) {
                switch(this.peekCharAt(this.pos + 1)) {
                    case Tools.LexCode_x: {

                    }
                    case Tools.LexCode_X: {
                        this.advanceChar(2); 
                        return this.scanHexDigits(); 

                    }
                    case Tools.LexCode_8: {

                    }
                    case Tools.LexCode_9: {

                    }
                    case Tools.LexCodeDOT: {
                        return this.scanDecimalNumber(NumberScanState.Start); 

                    }
                    default: {
                        return this.scanOctalDigits(); 

                    }
                }
            } else  {
                return this.scanDecimalNumber(NumberScanState.Start); 
            }
        };
        Scanner.prototype.scanFraction = function() {
            return this.scanDecimalNumber(NumberScanState.InFraction); 
        };
        Scanner.prototype.newLine = function() {
            this.col = 0; 
            if(this.mode == LexMode.File) {
                this.line++; 
                this.lineMap[this.line] = this.pos + 1; 
            }
        };
        Scanner.prototype.finishMultilineComment = function() {
            var ch2; 
            this.lexState = LexState.InMultilineComment; 
            while(this.pos < this.len) {
                if(this.ch == Tools.LexCodeMUL) {
                    ch2 = this.peekCharAt(this.pos + 1); 
                    if(ch2 == Tools.LexCodeSLH) {
                        this.advanceChar(2); 
                        if(this.mode == LexMode.File) {
                            this.tokenStart(); 
                        }
                        this.lexState = LexState.Start; 
                        return true; 
                    }
                } else  {
                    if(this.ch == Tools.LexCodeNWL) {
                        this.newLine(); 
                        if(this.mode == LexMode.Line) {
                            this.nextChar(); 
                            return false; 
                        }
                    }
                }
                this.nextChar(); 
            }
            return false; 
        };
        Scanner.prototype.pushComment = function(comment) {
            this.commentStack.push(comment); 
        };
        Scanner.prototype.getComments = function() {
            var stack = this.commentStack; 
            this.commentStack = []; 
            return stack; 
        };
        Scanner.prototype.getCommentsForLine = function(line) {
            var comments = null; 
            while((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {
                if(comments == null) {
                    comments = [                        this.commentStack.shift()
]; 
                } else  {
                    comments = comments.concat([                        this.commentStack.shift()
]); 
                }
            }
            return comments; 
        };
        Scanner.prototype.resetComments = function() {
            this.commentStack = []; 
        };
        Scanner.prototype.endsLine = function(c) {
            return (c == Tools.LexCodeNWL) || (c == Tools.LexCodeRET) || (c == 8232) || (c == 8233); 
        };
        Scanner.prototype.finishSinglelineComment = function() {
            while(this.pos < this.len) {
                if(this.endsLine(this.ch)) {
                    break;
                }
                this.nextChar(); 
            }
            if(this.mode == LexMode.File) {
                this.tokenStart(); 
            }
        };
        Scanner.prototype.tokenText = function() {
            return this.src.substring(this.startPos, this.pos); 
        };
        Scanner.prototype.findClosingSLH = function() {
            var index = this.pos; 
            var ch2 = this.src.charCodeAt(index); 
            var prevCh = 0; 
            var liveEsc = false; 
            while(!this.endsLine(ch2) && (index < this.len)) {
                if((ch2 == Tools.LexCodeSLH) && (!liveEsc)) {
                    return index; 
                }
                prevCh = ch2; 
                index++; 
                if(liveEsc) {
                    liveEsc = false; 
                } else  {
                    liveEsc = (prevCh == Tools.LexCodeBSL); 
                }
                ch2 = this.src.charCodeAt(index); 
            }
            return -1; 
        };
        Scanner.prototype.speculateRegex = function() {
            if(Tools.noRegexTable[this.prevTok.tokenId] != undefined) {
                return null; 
            }
            var svPos = this.pos; 
            var svCol = this.col; 
            var index = this.findClosingSLH(); 
            if(index > 0) {
                var pattern = this.src.substring(svPos, index); 
                var flags = ""; 
                this.pos = index + 1; 
                this.ch = this.peekChar(); 
                var flagsStart = this.pos; 
                while((this.ch == Tools.LexCode_i) || (this.ch == Tools.LexCode_g) || (this.ch == Tools.LexCode_m)) {
                    this.nextChar(); 
                }
                if((this.pos - flagsStart) > 3) {
                    return null; 
                } else  {
                    flags = this.src.substring(flagsStart, this.pos); 
                }
                var regex = undefined; 
                try  {
                    regex = new RegExp(pattern, flags); 
                } catch (regexException) {
                }
                if(regex) {
                    this.col = svCol + (this.pos - this.startPos); 
                    return new Tools.RegexToken(regex); 
                }
            }
            this.pos = svPos; 
            this.col = svCol; 
            return null; 
        };
        Scanner.prototype.lastTokenHadNewline = function() {
            return this.prevLine != this.startLine; 
        };
        Scanner.prototype.lastTokenLimChar = function() {
            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos; 
        };
        Scanner.prototype.advanceChar = function(amt) {
            this.pos += amt; 
            this.col += amt; 
            this.ch = this.peekChar(); 
        };
        Scanner.prototype.nextChar = function() {
            this.pos++; 
            this.col++; 
            this.ch = this.peekChar(); 
        };
        Scanner.prototype.scan = function() {
            if((this.lexState == LexState.InMultilineComment) && (this.scanComments)) {
                this.ch = this.peekChar(); 
                var commentLine = this.line; 
                this.finishMultilineComment(); 
                if(this.startPos < this.pos) {
                    var commentText = this.src.substring(this.startPos, this.pos); 
                    this.tokenStart(); 
                    return new Tools.CommentToken(Tools.TokenID.Comment, commentText, true, this.startPos, commentLine, true); 
                } else  {
                    return Tools.staticTokens[Tools.TokenID.EOF]; 
                }
            }
            this.prevLine = this.line; 
            this.prevTok = this.innerScan(); 
            if(this.saveScan != null) {
                this.saveScan.addToken(this.prevTok, this); 
            }
            return this.prevTok; 
        };
        Scanner.prototype.innerScan = function() {
            var rtok; 
            this.tokenStart(); 
            this.ch = this.peekChar(); 
            while(this.pos < this.len) {
                if(lexIdStartTable[this.ch]) {
                    do {
                        this.nextChar(); 
                    }while(lexIdStartTable[this.ch] || LexIsDigit(this.ch))
                    var idText = this.src.substring(this.startPos, this.pos); 
                    var id; 
                    if((id = Tools.LexKeywordTable.lookup(idText)) != null) {
                        return Tools.staticTokens[id]; 
                    } else  {
                        return new Tools.StringToken(Tools.TokenID.ID, idText); 
                    }
                } else  {
                    if(this.ch == Tools.LexCodeSpace) {
                        if(!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos; 
                        }
                        do {
                            this.nextChar(); 
                        }while(this.ch == Tools.LexCodeSpace)
                        if(this.mode == LexMode.Line) {
                            var whitespaceText = this.src.substring(this.startPos, this.pos); 
                            return new Tools.WhitespaceToken(Tools.TokenID.Whitespace, whitespaceText); 
                        } else  {
                            this.tokenStart(); 
                            this.interveningWhitespace = true; 
                        }
                    } else  {
                        if(this.ch == Tools.LexCodeSLH) {
                            this.nextChar(); 
                            var commentText; 
                            if(this.ch == Tools.LexCodeSLH) {
                                if(!this.interveningWhitespace) {
                                    this.interveningWhitespacePos = this.pos - 1; 
                                }
                                var commentStartPos = this.pos - 1; 
                                var commentStartLine = this.line; 
                                this.finishSinglelineComment(); 
                                var commentText = this.src.substring(commentStartPos, this.pos); 
                                var commentToken = new Tools.CommentToken(Tools.TokenID.Comment, commentText, false, commentStartPos, commentStartLine, false); 
                                if(this.scanComments) {
                                    this.startPos = commentStartPos; 
                                    return commentToken; 
                                } else  {
                                    this.pushComment(commentToken); 
                                }
                                this.interveningWhitespace = true; 
                            } else  {
                                if(this.ch == Tools.LexCodeMUL) {
                                    if(!this.interveningWhitespace) {
                                        this.interveningWhitespacePos = this.pos - 1; 
                                    }
                                    var commentStartPos = this.pos - 1; 
                                    var commentStartLine = this.line; 
                                    this.nextChar(); 
                                    this.finishMultilineComment(); 
                                    var commentText = this.src.substring(commentStartPos, this.pos); 
                                    var endsLine = this.peekChar() == Tools.LexCodeNWL || this.peekChar() == Tools.LexCodeRET; 
                                    var commentToken = new Tools.CommentToken(Tools.TokenID.Comment, commentText, true, commentStartPos, commentStartLine, endsLine); 
                                    if(this.scanComments) {
                                        this.startPos = commentStartPos; 
                                        return commentToken; 
                                    } else  {
                                        this.pushComment(commentToken); 
                                    }
                                    this.interveningWhitespace = true; 
                                } else  {
                                    var regexTok = this.speculateRegex(); 
                                    if(regexTok != null) {
                                        return regexTok; 
                                    } else  {
                                        if(this.peekCharAt(this.pos) == Tools.LexCodeEQ) {
                                            this.nextChar(); 
                                            return Tools.staticTokens[Tools.TokenID.AsgDiv]; 
                                        } else  {
                                            return Tools.staticTokens[Tools.TokenID.Div]; 
                                        }
                                    }
                                }
                            }
                        } else  {
                            if(this.ch == Tools.LexCodeSMC) {
                                this.nextChar(); 
                                return Tools.staticTokens[Tools.TokenID.SColon]; 
                            } else  {
                                if((this.ch == Tools.LexCodeAPO) || (this.ch == Tools.LexCodeQUO)) {
                                    var endCode = this.ch; 
                                    var prevCh = 0; 
                                    var liveEsc = false; 
                                    do {
                                        prevCh = this.ch; 
                                        if(liveEsc) {
                                            liveEsc = false; 
                                        } else  {
                                            liveEsc = (prevCh == Tools.LexCodeBSL); 
                                        }
                                        this.nextChar(); 
                                    }while((this.ch != Tools.LexEOF) && (liveEsc || (this.ch != endCode)))
                                    if(this.ch != Tools.LexEOF) {
                                        this.nextChar(); 
                                    }
                                    return new Tools.StringToken(Tools.TokenID.QString, this.src.substring(this.startPos, this.pos)); 
                                } else  {
                                    if(autoToken[this.ch]) {
                                        var atok = autoToken[this.ch]; 
                                        if(atok.tokenId == Tools.TokenID.LCurly) {
                                            this.leftCurlyCount++; 
                                        } else  {
                                            if(atok.tokenId == Tools.TokenID.RCurly) {
                                                this.rightCurlyCount++; 
                                            }
                                        }
                                        this.nextChar(); 
                                        return atok; 
                                    } else  {
                                        if((this.ch >= Tools.LexCode_0) && (this.ch <= Tools.LexCode_9)) {
                                            rtok = this.scanNumber(); 
                                            if(rtok != null) {
                                                return rtok; 
                                            } else  {
                                                this.nextChar(); 
                                                return Tools.staticTokens[Tools.TokenID.Error]; 
                                            }
                                        } else  {
                                            switch(this.ch) {
                                                case Tools.LexCodeTAB: {

                                                }
                                                case Tools.LexCodeVTAB: {
                                                    if(!this.interveningWhitespace) {
                                                        this.interveningWhitespacePos = this.pos; 
                                                    }
                                                    if(this.mode == LexMode.Line) {
                                                        do {
                                                            this.nextChar(); 
                                                        }while((this.ch == Tools.LexCodeSpace) || (this.ch == 9))
                                                        var wsText = this.src.substring(this.startPos, this.pos); 
                                                        return new Tools.WhitespaceToken(Tools.TokenID.Whitespace, wsText); 
                                                    } else  {
                                                        this.interveningWhitespace = true; 
                                                    }

                                                }
                                                case 255: {

                                                }
                                                case 254: {

                                                }
                                                case 239: {

                                                }
                                                case 187: {

                                                }
                                                case 191: {

                                                }
                                                case 8232: {

                                                }
                                                case 8233: {

                                                }
                                                case Tools.LexCodeNWL: {

                                                }
                                                case Tools.LexCodeRET: {
                                                    if(this.ch == Tools.LexCodeNWL) {
                                                        this.newLine(); 
                                                        if(this.mode == LexMode.Line) {
                                                            return Tools.staticTokens[Tools.TokenID.EOF]; 
                                                        }
                                                    }
                                                    if(!this.interveningWhitespace) {
                                                        this.interveningWhitespacePos = this.pos; 
                                                    }
                                                    this.nextChar(); 
                                                    this.tokenStart(); 
                                                    this.interveningWhitespace = true; 
                                                    break;

                                                }
                                                case Tools.LexCodeDOT: {
 {
                                                        if(this.peekCharAt(this.pos + 1) == Tools.LexCodeDOT) {
                                                            if(this.peekCharAt(this.pos + 2) == Tools.LexCodeDOT) {
                                                                this.advanceChar(3); 
                                                                return Tools.staticTokens[Tools.TokenID.Ellipsis]; 
                                                            } else  {
                                                                this.nextChar(); 
                                                                return Tools.staticTokens[Tools.TokenID.Dot]; 
                                                            }
                                                        } else  {
                                                            this.nextChar(); 
                                                            rtok = this.scanFraction(); 
                                                            if(rtok != null) {
                                                                return rtok; 
                                                            } else  {
                                                                return Tools.staticTokens[Tools.TokenID.Dot]; 
                                                            }
                                                        }
                                                    }

                                                }
                                                case Tools.LexCodeEQ: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        if(this.peekCharAt(this.pos + 2) == Tools.LexCodeEQ) {
                                                            this.advanceChar(3); 
                                                            return Tools.staticTokens[Tools.TokenID.Eqv]; 
                                                        } else  {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.EQ]; 
                                                        }
                                                    } else  {
                                                        if(this.peekCharAt(this.pos + 1) == Tools.LexCodeGT) {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.Arrow]; 
                                                        } else  {
                                                            this.nextChar(); 
                                                            return Tools.staticTokens[Tools.TokenID.Asg]; 
                                                        }
                                                    }

                                                }
                                                case Tools.LexCodeBNG: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        if(this.peekCharAt(this.pos + 2) == Tools.LexCodeEQ) {
                                                            this.advanceChar(3); 
                                                            return Tools.staticTokens[Tools.TokenID.NEqv]; 
                                                        } else  {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.NE]; 
                                                        }
                                                    } else  {
                                                        this.nextChar(); 
                                                        return Tools.staticTokens[Tools.TokenID.Bang]; 
                                                    }

                                                }
                                                case Tools.LexCodePLS: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        this.advanceChar(2); 
                                                        return Tools.staticTokens[Tools.TokenID.AsgAdd]; 
                                                    } else  {
                                                        if(this.peekCharAt(this.pos + 1) == Tools.LexCodePLS) {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.Inc]; 
                                                        } else  {
                                                            this.nextChar(); 
                                                            return Tools.staticTokens[Tools.TokenID.Add]; 
                                                        }
                                                    }

                                                }
                                                case Tools.LexCodeMIN: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        this.advanceChar(2); 
                                                        return Tools.staticTokens[Tools.TokenID.AsgSub]; 
                                                    } else  {
                                                        if(this.peekCharAt(this.pos + 1) == Tools.LexCodeMIN) {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.Dec]; 
                                                        } else  {
                                                            this.nextChar(); 
                                                            return Tools.staticTokens[Tools.TokenID.Sub]; 
                                                        }
                                                    }

                                                }
                                                case Tools.LexCodeMUL: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        this.advanceChar(2); 
                                                        return Tools.staticTokens[Tools.TokenID.AsgMul]; 
                                                    } else  {
                                                        this.nextChar(); 
                                                        return Tools.staticTokens[Tools.TokenID.Mult]; 
                                                    }

                                                }
                                                case Tools.LexCodePCT: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        this.advanceChar(2); 
                                                        return Tools.staticTokens[Tools.TokenID.AsgMod]; 
                                                    } else  {
                                                        this.nextChar(); 
                                                        return Tools.staticTokens[Tools.TokenID.Pct]; 
                                                    }

                                                }
                                                case Tools.LexCodeLT: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeLT) {
                                                        if(this.peekCharAt(this.pos + 2) == Tools.LexCodeEQ) {
                                                            this.advanceChar(3); 
                                                            return Tools.staticTokens[Tools.TokenID.AsgLsh]; 
                                                        } else  {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.Lsh]; 
                                                        }
                                                    } else  {
                                                        if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.LE]; 
                                                        } else  {
                                                            this.nextChar(); 
                                                            return Tools.staticTokens[Tools.TokenID.LT]; 
                                                        }
                                                    }

                                                }
                                                case Tools.LexCodeGT: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeGT) {
                                                        if(this.peekCharAt(this.pos + 2) == Tools.LexCodeEQ) {
                                                            this.advanceChar(3); 
                                                            return Tools.staticTokens[Tools.TokenID.AsgRsh]; 
                                                        } else  {
                                                            if(this.peekCharAt(this.pos + 2) == Tools.LexCodeGT) {
                                                                if(this.peekCharAt(this.pos + 3) == Tools.LexCodeEQ) {
                                                                    this.advanceChar(4); 
                                                                    return Tools.staticTokens[Tools.TokenID.AsgRs2]; 
                                                                } else  {
                                                                    this.advanceChar(3); 
                                                                    return Tools.staticTokens[Tools.TokenID.Rs2]; 
                                                                }
                                                            } else  {
                                                                this.advanceChar(2); 
                                                                return Tools.staticTokens[Tools.TokenID.Rsh]; 
                                                            }
                                                        }
                                                    } else  {
                                                        if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.GE]; 
                                                        } else  {
                                                            this.nextChar(); 
                                                            return Tools.staticTokens[Tools.TokenID.GT]; 
                                                        }
                                                    }

                                                }
                                                case Tools.LexCodeXOR: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        this.advanceChar(2); 
                                                        return Tools.staticTokens[Tools.TokenID.AsgXor]; 
                                                    } else  {
                                                        this.nextChar(); 
                                                        return Tools.staticTokens[Tools.TokenID.Xor]; 
                                                    }

                                                }
                                                case Tools.LexCodeBAR: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        this.advanceChar(2); 
                                                        return Tools.staticTokens[Tools.TokenID.AsgOr]; 
                                                    } else  {
                                                        if(this.peekCharAt(this.pos + 1) == Tools.LexCodeBAR) {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.LogOr]; 
                                                        } else  {
                                                            this.nextChar(); 
                                                            return Tools.staticTokens[Tools.TokenID.Or]; 
                                                        }
                                                    }

                                                }
                                                case Tools.LexCodeAMP: {
                                                    if(this.peekCharAt(this.pos + 1) == Tools.LexCodeEQ) {
                                                        this.advanceChar(2); 
                                                        return Tools.staticTokens[Tools.TokenID.AsgAnd]; 
                                                    } else  {
                                                        if(this.peekCharAt(this.pos + 1) == Tools.LexCodeAMP) {
                                                            this.advanceChar(2); 
                                                            return Tools.staticTokens[Tools.TokenID.LogAnd]; 
                                                        } else  {
                                                            this.nextChar(); 
                                                            return Tools.staticTokens[Tools.TokenID.And]; 
                                                        }
                                                    }

                                                }
                                                default: {
                                                    return Tools.staticTokens[Tools.TokenID.EOF]; 

                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return Tools.staticTokens[Tools.TokenID.EOF]; 
        };
        return Scanner;
    })();
    Tools.Scanner = Scanner;
    
    function convertTokToIDName(tok) {
        return convertTokToIDBase(tok, true, false); 
    }
    Tools.convertTokToIDName = convertTokToIDName;
    function convertTokToID(tok, strictMode) {
        return convertTokToIDBase(tok, false, strictMode); 
    }
    Tools.convertTokToID = convertTokToID;
    function convertTokToIDBase(tok, identifierName, strictMode) {
        if(tok.tokenId <= Tools.TokenID.LimKeyword) {
            var tokInfo = Tools.lookupToken(tok.tokenId); 
            if(tokInfo != undefined) {
                var resFlags = Tools.Reservation.Javascript | Tools.Reservation.JavascriptFuture; 
                if(strictMode) {
                    resFlags |= Tools.Reservation.JavascriptFutureStrict; 
                }
                if(identifierName || !Tools.hasFlag(tokInfo.reservation, resFlags)) {
                    return true; 
                }
            } else  {
                return false; 
            }
        } else  {
            return false; 
        }
    }
    function getLineNumberFromPosition(lineMap, position) {
        if(position === -1) {
            return 0; 
        }
        var min = 0; 
        var max = lineMap.length - 1; 
        while(min < max) {
            var med = (min + max) >> 1; 
            if(position < lineMap[med]) {
                max = med - 1; 
            } else  {
                if(position < lineMap[med + 1]) {
                    min = max = med; 
                } else  {
                    min = med + 1; 
                }
            }
        }
        return min; 
    }
    Tools.getLineNumberFromPosition = getLineNumberFromPosition;
    function getSourceLineColFromMap(lineCol, minChar, lineMap) {
        var line = getLineNumberFromPosition(lineMap, minChar); 
        if(line > 0) {
            lineCol.line = line; 
            lineCol.col = (minChar - lineMap[line]); 
        }
    }
    Tools.getSourceLineColFromMap = getSourceLineColFromMap;
    function getLineColumnFromPosition(script, position) {
        var result = {
            line: -1,
            col: -1
        }; 
        getSourceLineColFromMap(result, position, script.locationInfo.lineMap); 
        if(result.col >= 0) {
            result.col++; 
        }
        return result; 
    }
    Tools.getLineColumnFromPosition = getLineColumnFromPosition;
    function getPositionFromLineColumn(script, line, column) {
        return script.locationInfo.lineMap[line] + (column - 1); 
    }
    Tools.getPositionFromLineColumn = getPositionFromLineColumn;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var AssignScopeContext = (function () {
        _inheritsFrom(AssignScopeContext, Tools.BaseWalkContext);
        function AssignScopeContext(scopeChain, typeFlow, modDeclChain) {
            this.scopeChain = scopeChain;
            this.typeFlow = typeFlow;
            this.modDeclChain = modDeclChain;
            AssignScopeContext._super.constructor.call(this);
        }
        return AssignScopeContext;
    })();
    Tools.AssignScopeContext = AssignScopeContext;
    
    function pushAssignScope(scope, context, type, classType, fnc) {
        var chain = new Tools.ScopeChain(null, context.scopeChain, scope); 
        chain.thisType = type; 
        chain.classType = classType; 
        chain.fnc = fnc; 
        context.scopeChain = chain; 
    }
    Tools.pushAssignScope = pushAssignScope;
    function popAssignScope(context) {
        context.scopeChain = context.scopeChain.previous; 
    }
    Tools.popAssignScope = popAssignScope;
    function instanceCompare(a, b) {
        if(((a == null) || (!a.isInstanceProperty()))) {
            return b; 
        } else  {
            return a; 
        }
    }
    Tools.instanceCompare = instanceCompare;
    function instanceFilterStop(s) {
        return s.isInstanceProperty(); 
    }
    Tools.instanceFilterStop = instanceFilterStop;
    var ScopeSearchFilter = (function () {
        function ScopeSearchFilter(select, stop) {
            this.select = select;
            this.stop = stop;
            this.result = null; 
        }
        ScopeSearchFilter.prototype.reset = function() {
            this.result = null; 
        };
        ScopeSearchFilter.prototype.update = function(b) {
            this.result = this.select(this.result, b); 
            if(this.result != null) {
                return this.stop(this.result); 
            } else  {
                return false; 
            }
        };
        return ScopeSearchFilter;
    })();
    Tools.ScopeSearchFilter = ScopeSearchFilter;
    
    Tools.instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop); 
    function preAssignModuleScopes(ast, context) {
        var moduleDecl = ast; 
        var memberScope = null; 
        var aggScope = null; 
        if(moduleDecl.name != null && moduleDecl.mod != null) {
            moduleDecl.name.sym = moduleDecl.mod.symbol; 
        }
        var mod = moduleDecl.mod; 
        memberScope = new Tools.SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol); 
        mod.memberScope = memberScope; 
        if(moduleDecl.isAnonInnerMod && context.modDeclChain.length > 0) {
            moduleDecl.anonParentMod = context.typeFlow.checker.currentModDecl; 
            moduleDecl.anonExportedSymbols = []; 
        }
        context.modDeclChain.push(moduleDecl); 
        context.typeFlow.checker.currentModDecl = moduleDecl; 
        aggScope = new Tools.SymbolAggregateScope(mod.symbol); 
        aggScope.addParentScope(memberScope); 
        aggScope.addParentScope(context.scopeChain.scope); 
        pushAssignScope(aggScope, context, null, null, null); 
        mod.containedScope = aggScope; 
        if(mod.symbol != null) {
            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true); 
        }
    }
    Tools.preAssignModuleScopes = preAssignModuleScopes;
    function preAssignClassScopes(ast, context) {
        var classDecl = ast; 
        var memberScope = null; 
        var aggScope = null; 
        if(classDecl.isOverload) {
            return;
        }
        if(classDecl.name != null && classDecl.type != null) {
            classDecl.name.sym = classDecl.type.symbol; 
        }
        var classType = ast.type; 
        if(classType != null) {
            var classSym = classType.symbol; 
            memberScope = context.typeFlow.checker.scopeOf(classType); 
            aggScope = new Tools.SymbolAggregateScope(classType.symbol); 
            aggScope.addParentScope(memberScope); 
            aggScope.addParentScope(context.scopeChain.scope); 
            classType.containedScope = aggScope; 
            classType.memberScope = memberScope; 
            var instanceType = classType.instanceType; 
            memberScope = context.typeFlow.checker.scopeOf(instanceType); 
            instanceType.memberScope = memberScope; 
            aggScope = new Tools.SymbolAggregateScope(instanceType.symbol); 
            if(context.typeFlow.checker.addMembersToClassScope) {
                aggScope.addParentScope(memberScope); 
            }
            aggScope.addParentScope(classType.containedScope); 
            pushAssignScope(aggScope, context, instanceType, classType, null); 
            instanceType.containedScope = aggScope; 
            if(context.typeFlow.checker.currentModDecl != null && context.typeFlow.checker.currentModDecl.isAnonInnerMod && Tools.hasFlag((ast).varFlags, Tools.VarFlags.Exported)) {
                context.typeFlow.checker.currentModDecl.anonExportedSymbols.push(classSym); 
            }
        } else  {
            ast.type = context.typeFlow.anyType; 
        }
    }
    Tools.preAssignClassScopes = preAssignClassScopes;
    function preAssignES6ClassScopes(ast, context) {
        var classDecl = ast; 
        var memberScope = null; 
        var aggScope = null; 
        if(classDecl.name != null && classDecl.type != null) {
            classDecl.name.sym = classDecl.type.symbol; 
        }
        var classType = ast.type; 
        if(classType != null) {
            var classSym = classType.symbol; 
            memberScope = context.typeFlow.checker.scopeOf(classType); 
            aggScope = new Tools.SymbolAggregateScope(classType.symbol); 
            aggScope.addParentScope(memberScope); 
            aggScope.addParentScope(context.scopeChain.scope); 
            classType.containedScope = aggScope; 
            classType.memberScope = memberScope; 
            var instanceType = classType.instanceType; 
            memberScope = context.typeFlow.checker.scopeOf(instanceType); 
            instanceType.memberScope = memberScope; 
            aggScope = new Tools.SymbolAggregateScope(instanceType.symbol); 
            aggScope.addParentScope(context.scopeChain.scope); 
            if(context.typeFlow.checker.addMembersToClassScope) {
                aggScope.addParentScope(memberScope); 
            }
            pushAssignScope(aggScope, context, instanceType, classType, null); 
            instanceType.containedScope = aggScope; 
            if(context.typeFlow.checker.currentModDecl != null && context.typeFlow.checker.currentModDecl.isAnonInnerMod && Tools.hasFlag((ast).varFlags, Tools.VarFlags.Exported)) {
                context.typeFlow.checker.currentModDecl.anonExportedSymbols.push(classSym); 
            }
        } else  {
            ast.type = context.typeFlow.anyType; 
        }
    }
    Tools.preAssignES6ClassScopes = preAssignES6ClassScopes;
    function preAssignInterfaceScopes(ast, context) {
        var interfaceDecl = ast; 
        var memberScope = null; 
        var aggScope = null; 
        if(interfaceDecl.name != null && interfaceDecl.type != null) {
            interfaceDecl.name.sym = interfaceDecl.type.symbol; 
        }
        var interfaceType = ast.type; 
        memberScope = context.typeFlow.checker.scopeOf(interfaceType); 
        interfaceType.memberScope = memberScope; 
        aggScope = new Tools.SymbolAggregateScope(interfaceType.symbol); 
        aggScope.addParentScope(memberScope); 
        aggScope.addParentScope(context.scopeChain.scope); 
        pushAssignScope(aggScope, context, null, null, null); 
        interfaceType.containedScope = aggScope; 
    }
    Tools.preAssignInterfaceScopes = preAssignInterfaceScopes;
    function preAssignWithScopes(ast, context) {
        var withStmt = ast; 
        var withType = withStmt.type; 
        var members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
        var ambientMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
        var withType = new Tools.Type(); 
        var withSymbol = new Tools.WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType); 
        withType.members = members; 
        withType.ambientMembers = ambientMembers; 
        withType.symbol = withSymbol; 
        withType.setHasImplementation(); 
        withStmt.type = withType; 
        var withScope = new Tools.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol); 
        pushAssignScope(withScope, context, null, null, null); 
        withType.containedScope = withScope; 
    }
    Tools.preAssignWithScopes = preAssignWithScopes;
    function preAssignFuncDeclScopes(ast, context) {
        var funcDecl = ast; 
        var container = null; 
        var localContainer = null; 
        if(funcDecl.type != null) {
            localContainer = ast.type.symbol; 
        }
        var isStatic = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Static); 
        var isInnerStatic = isStatic && context.scopeChain.fnc != null; 
        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope; 
        if((context.scopeChain.thisType != null) && (!funcDecl.isConstructor || Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod))) {
            var instType = context.scopeChain.thisType; 
            if(!instType.isES6Class && !Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod)) {
                if(!funcDecl.isMethod() || isStatic) {
                    parentScope = instType.constructorScope; 
                } else  {
                    parentScope = instType.containedScope; 
                }
            } else  {
                if(context.scopeChain.previous.scope.container && context.scopeChain.previous.scope.container.declAST && context.scopeChain.previous.scope.container.declAST.nodeType == Tools.NodeType.FuncDecl && (context.scopeChain.previous.scope.container.declAST).isConstructor) {
                    parentScope = instType.constructorScope; 
                } else  {
                    if(isStatic && context.scopeChain.classType) {
                        parentScope = context.scopeChain.classType.containedScope; 
                    } else  {
                        parentScope = instType.containedScope; 
                    }
                }
            }
            container = instType.symbol; 
        } else  {
            if(funcDecl.isConstructor && (context.scopeChain.thisType != null)) {
                container = context.scopeChain.thisType.symbol; 
            }
        }
        if(funcDecl.type == null || Tools.hasFlag(funcDecl.type.symbol.flags, Tools.SymbolFlags.TypeSetDuringScopeAssignment)) {
            if(context.scopeChain.fnc != null) {
                container = context.scopeChain.fnc.type.symbol; 
            }
            var funcScope = null; 
            var outerFnc = context.scopeChain.fnc; 
            var nameText = funcDecl.name != null ? funcDecl.name.text : null; 
            var fgSym = null; 
            if(isStatic) {
                if(outerFnc.type.members == null) {
                    outerFnc.type.members = ((container).type.memberScope).valueMembers; 
                }
                funcScope = context.scopeChain.fnc.type.memberScope; 
                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl; 
            } else  {
                if(!funcDecl.isConstructor && container != null && container.declAST != null && container.declAST.nodeType == Tools.NodeType.FuncDecl && (container.declAST).isConstructor && !funcDecl.isMethod()) {
                    funcScope = context.scopeChain.thisType.constructorScope; 
                } else  {
                    funcScope = context.scopeChain.scope; 
                }
            }
            if(nameText != null && nameText != "__missing") {
                if(isStatic) {
                    fgSym = funcScope.findLocal(nameText, false, false); 
                } else  {
                    fgSym = funcScope.findLocal(nameText, false, false); 
                }
            }
            context.typeFlow.checker.createFunctionSignature(funcDecl, container, funcScope, fgSym, fgSym == null); 
            funcDecl.type.symbol.flags |= Tools.SymbolFlags.TypeSetDuringScopeAssignment; 
        }
        if(funcDecl.name != null && funcDecl.type != null) {
            funcDecl.name.sym = funcDecl.type.symbol; 
        }
        if(funcDecl.isOverload) {
            return;
        }
        var funcTable = new Tools.StringHashTable(); 
        var funcMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(funcTable, new Tools.StringHashTable())); 
        var ambientFuncTable = new Tools.StringHashTable(); 
        var ambientFuncMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(ambientFuncTable, new Tools.StringHashTable())); 
        var funcStaticTable = new Tools.StringHashTable(); 
        var funcStaticMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(funcStaticTable, new Tools.StringHashTable())); 
        var ambientFuncStaticTable = new Tools.StringHashTable(); 
        var ambientFuncStaticMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(ambientFuncStaticTable, new Tools.StringHashTable())); 
        funcDecl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex; 
        var locals = new Tools.SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer); 
        var statics = new Tools.SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null); 
        if(funcDecl.isConstructor && context.scopeChain.thisType != null) {
            context.scopeChain.thisType.constructorScope = locals; 
        }
        funcDecl.symbols = funcTable; 
        if(!funcDecl.isSpecialFn()) {
            var group = funcDecl.type; 
            var signature = funcDecl.signature; 
            if(!funcDecl.isConstructor) {
                group.containedScope = locals; 
                locals.container = group.symbol; 
                group.memberScope = statics; 
                statics.container = group.symbol; 
            }
            funcDecl.enclosingFnc = context.scopeChain.fnc; 
            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType; 
            var fgSym = ast.type.symbol; 
            if(((funcDecl.fncFlags & Tools.FncFlags.Signature) == Tools.FncFlags.None) && (funcDecl.vars != null)) {
                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars, funcTable, false); 
                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics, funcStaticTable, false); 
            }
            if(signature.parameters) {
                var len = signature.parameters.length; 
                for(var i = 0; i < len; i++) {
                    var paramSym = signature.parameters[i]; 
                    context.typeFlow.checker.resolveTypeLink(locals, paramSym.parameter.typeLink, true); 
                }
            }
            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType, funcDecl.isSignature()); 
        }
        if(context.typeFlow.checker.currentModDecl != null && context.typeFlow.checker.currentModDecl.isAnonInnerMod && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Exported)) {
            context.typeFlow.checker.currentModDecl.anonExportedSymbols.push(funcDecl.type.symbol); 
        }
        if(!funcDecl.isConstructor || Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod)) {
            var thisType = (funcDecl.isConstructor && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod)) ? context.scopeChain.thisType : null; 
            pushAssignScope(locals, context, thisType, null, funcDecl); 
        }
    }
    Tools.preAssignFuncDeclScopes = preAssignFuncDeclScopes;
    function preAssignCatchScopes(ast, context) {
        var catchBlock = ast; 
        if(catchBlock.param != null) {
            var catchTable = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            var catchLocals = new Tools.SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope, context.scopeChain.scope.container); 
            catchBlock.containedScope = catchLocals; 
            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc); 
        }
    }
    Tools.preAssignCatchScopes = preAssignCatchScopes;
    function preAssignVarDeclScopes(ast, context) {
        if(context.typeFlow.checker.currentModDecl != null && context.typeFlow.checker.currentModDecl.isAnonInnerMod && Tools.hasFlag((ast).varFlags, Tools.VarFlags.Exported) && (ast).sym != null) {
            context.typeFlow.checker.currentModDecl.anonExportedSymbols.push((ast).sym); 
        }
    }
    Tools.preAssignVarDeclScopes = preAssignVarDeclScopes;
    function preAssignScopes(ast, parent, iwContext) {
        var go = true; 
        var context = iwContext; 
        if(ast != null) {
            if(ast.nodeType == Tools.NodeType.List) {
                var list = ast; 
                list.enclosingScope = context.scopeChain.scope; 
            } else  {
                if(ast.nodeType == Tools.NodeType.Module) {
                    preAssignModuleScopes(ast, context); 
                } else  {
                    if(ast.nodeType == Tools.NodeType.Class) {
                        preAssignClassScopes(ast, context); 
                    } else  {
                        if(ast.nodeType == Tools.NodeType.ES6Class) {
                            preAssignES6ClassScopes(ast, context); 
                        } else  {
                            if(ast.nodeType == Tools.NodeType.Interface) {
                                preAssignInterfaceScopes(ast, context); 
                            } else  {
                                if(ast.nodeType == Tools.NodeType.With) {
                                    preAssignWithScopes(ast, context); 
                                } else  {
                                    if(ast.nodeType == Tools.NodeType.FuncDecl) {
                                        preAssignFuncDeclScopes(ast, context); 
                                    } else  {
                                        if(ast.nodeType == Tools.NodeType.Catch) {
                                            preAssignCatchScopes(ast, context); 
                                        } else  {
                                            if(ast.nodeType == Tools.NodeType.TypeRef) {
                                                go = false; 
                                            } else  {
                                                if(ast.nodeType == Tools.NodeType.VarDecl) {
                                                    preAssignVarDeclScopes(ast, context); 
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        context.goChildren = go; 
        return ast; 
    }
    Tools.preAssignScopes = preAssignScopes;
    function postAssignScopes(ast, parent, iwContext) {
        var context = iwContext; 
        var go = true; 
        if(ast != null) {
            if(ast.nodeType == Tools.NodeType.Module) {
                var prevModDecl = ast; 
                popAssignScope(context); 
                context.modDeclChain.pop(); 
                if(context.modDeclChain.length >= 1) {
                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1]; 
                }
                if(prevModDecl.isAnonInnerMod) {
                    var nExports = prevModDecl.anonExportedSymbols.length; 
                    var sym = null; 
                    for(var i = 0; i < nExports; i++) {
                        sym = prevModDecl.anonExportedSymbols[i]; 
                        if(null != context.typeFlow.checker.currentModDecl.mod.members.allMembers.lookup(sym.name)) {
                            context.typeFlow.checker.errorReporter.simpleError(sym.declAST, ("Anonymous module export '" + sym.name) + "' conflicts with a symbol in the parent module"); 
                        } else  {
                            context.typeFlow.checker.currentModDecl.mod.members.publicMembers.add(sym.name, sym); 
                        }
                        if(sym.isType() && null != context.typeFlow.checker.currentModDecl.mod.enclosedTypes.allMembers.lookup(sym.name)) {
                            context.typeFlow.checker.errorReporter.simpleError(sym.declAST, ("Anonymous module export '" + sym.name) + "' conflicts with a symbol in the parent module"); 
                        } else  {
                            context.typeFlow.checker.currentModDecl.mod.enclosedTypes.publicMembers.add(sym.name, sym); 
                        }
                    }
                }
            } else  {
                if(ast.nodeType == Tools.NodeType.Class) {
                    if(!(ast).isOverload) {
                        popAssignScope(context); 
                    }
                } else  {
                    if(ast.nodeType == Tools.NodeType.ES6Class) {
                        popAssignScope(context); 
                    } else  {
                        if(ast.nodeType == Tools.NodeType.Interface) {
                            popAssignScope(context); 
                        } else  {
                            if(ast.nodeType == Tools.NodeType.With) {
                                popAssignScope(context); 
                            } else  {
                                if(ast.nodeType == Tools.NodeType.FuncDecl) {
                                    var funcDecl = ast; 
                                    if((!funcDecl.isConstructor || Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod)) && !funcDecl.isOverload) {
                                        popAssignScope(context); 
                                    }
                                } else  {
                                    if(ast.nodeType == Tools.NodeType.Catch) {
                                        var catchBlock = ast; 
                                        if(catchBlock.param != null) {
                                            popAssignScope(context); 
                                        }
                                    } else  {
                                        go = false; 
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        context.goChildren = go; 
        return ast; 
    }
    Tools.postAssignScopes = postAssignScopes;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var TypeCollectionContext = (function () {
        _inheritsFrom(TypeCollectionContext, Tools.BaseWalkContext);
        function TypeCollectionContext(scopeChain, checker) {
            this.scopeChain = scopeChain;
            this.checker = checker;
            TypeCollectionContext._super.constructor.call(this);
            this.script = null; 
        }
        return TypeCollectionContext;
    })();
    Tools.TypeCollectionContext = TypeCollectionContext;
    
    var MemberScopeContext = (function () {
        _inheritsFrom(MemberScopeContext, Tools.BaseWalkContext);
        function MemberScopeContext(flow, pos, matchFlag) {
            this.flow = flow;
            this.pos = pos;
            this.matchFlag = matchFlag;
            MemberScopeContext._super.constructor.call(this);
            this.type = null; 
            this.ast = null; 
            this.scope = null; 
        }
        return MemberScopeContext;
    })();
    Tools.MemberScopeContext = MemberScopeContext;
    
    var EnclosingScopeContext = (function () {
        _inheritsFrom(EnclosingScopeContext, Tools.BaseWalkContext);
        function EnclosingScopeContext(logger, script, text, pos, isMemberCompletion) {
            this.logger = logger;
            this.script = script;
            this.text = text;
            this.pos = pos;
            this.isMemberCompletion = isMemberCompletion;
            EnclosingScopeContext._super.constructor.call(this);
            this.scopeGetter = null; 
            this.scopeStartAST = null; 
            this.skipNextFuncDeclForClass = false; 
            this.deepestModuleDecl = null; 
            this.enclosingClassDecl = null; 
            this.publicsOnly = true; 
            this.scriptFragment = null; 
        }
        EnclosingScopeContext.prototype.getScope = function() {
            return this.scopeGetter(); 
        };
        EnclosingScopeContext.prototype.getScopePosition = function() {
            return this.scopeStartAST.minChar; 
        };
        EnclosingScopeContext.prototype.getScriptFragment = function() {
            if(this.scriptFragment == null) {
                var minChar = this.getScopePosition(); 
                var limChar = (this.isMemberCompletion ? this.pos : this.pos + 1); 
                this.scriptFragment = Tools.quickParse(this.logger, this.scopeStartAST, this.text, minChar, limChar, null).Script; 
            }
            return this.scriptFragment; 
        };
        return EnclosingScopeContext;
    })();
    Tools.EnclosingScopeContext = EnclosingScopeContext;
    
    function preFindMemberScope(ast, parent, context) {
        var memScope = context; 
        if(Tools.hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {
            memScope.ast = ast; 
            if((ast.type == null) && (memScope.pos >= 0)) {
                memScope.flow.inScopeTypeCheck(ast, memScope.scope); 
            }
            memScope.type = ast.type; 
            memScope.goChildren = false; 
            memScope.goNextSibling = false; 
        }
        return ast; 
    }
    Tools.preFindMemberScope = preFindMemberScope;
    function pushTypeCollectionScope(container, valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, context, thisType, classType, moduleDecl) {
        var builder = new Tools.SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container); 
        var chain = new Tools.ScopeChain(container, context.scopeChain, builder); 
        chain.thisType = thisType; 
        chain.classType = classType; 
        chain.moduleDecl = moduleDecl; 
        context.scopeChain = chain; 
    }
    Tools.pushTypeCollectionScope = pushTypeCollectionScope;
    function popTypeCollectionScope(context) {
        context.scopeChain = context.scopeChain.previous; 
    }
    Tools.popTypeCollectionScope = popTypeCollectionScope;
    function preFindEnclosingScope(ast, parent, iwContext) {
        var context = iwContext; 
        var minChar = ast.minChar; 
        var limChar = ast.limChar; 
        if(ast.nodeType == Tools.NodeType.Script && context.pos > limChar) {
            limChar = context.pos; 
        }
        if((minChar <= context.pos) && (limChar >= context.pos)) {
            switch(ast.nodeType) {
                case Tools.NodeType.Script: {
                    var script = ast; 
                    context.scopeGetter = function() {
                        return script.bod === null ? null : script.bod.enclosingScope; 
                    }; 
                    context.scopeStartAST = script; 
                    break;

                }
                case Tools.NodeType.ES6Class: {
                    context.scopeGetter = function() {
                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope; 
                    }; 
                    context.scopeStartAST = ast; 
                    context.enclosingClassDecl = ast; 
                    break;

                }
                case Tools.NodeType.Class: {
                    context.scopeGetter = function() {
                        return (ast.type === null || ast.type.instanceType.constructorScope === null) ? null : ast.type.instanceType.constructorScope; 
                    }; 
                    context.scopeStartAST = ast; 
                    context.enclosingClassDecl = ast; 
                    context.skipNextFuncDeclForClass = true; 
                    break;

                }
                case Tools.NodeType.ObjectLit: {
                    if(ast.type != null && (ast).acceptTargetType) {
                    } else  {
                        break;
                    }

                }
                case Tools.NodeType.Module: {
                    context.deepestModuleDecl = ast; 

                }
                case Tools.NodeType.Interface: {

                }
                case Tools.NodeType.FuncDecl: {
                    if(context.skipNextFuncDeclForClass) {
                        context.skipNextFuncDeclForClass = false; 
                        break;
                    }
                    context.scopeGetter = function() {
                        return ast.type === null ? null : ast.type.containedScope; 
                    }; 
                    context.scopeStartAST = ast; 
                    break;

                }
            }
            context.goChildren = true; 
        } else  {
            context.goChildren = false; 
        }
        return ast; 
    }
    Tools.preFindEnclosingScope = preFindEnclosingScope;
    function findEnclosingScopeAt(logger, script, text, pos, isMemberCompletion) {
        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion); 
        script.walk(preFindEnclosingScope, null, null, context); 
        if(context.scopeStartAST === null) {
            return null; 
        }
        return context; 
    }
    Tools.findEnclosingScopeAt = findEnclosingScopeAt;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var Signature = (function () {
        function Signature() {
            this.hasVariableArgList = false; 
            this.returnType = null; 
            this.parameters = null; 
            this.declAST = null; 
            this.typeCheckStatus = Tools.TypeCheckStatus.NotStarted; 
            this.nonOptionalParameterCount = 0; 
        }
        Signature.prototype.specializeType = function(pattern, replacement, checker) {
            var result = new Signature(); 
            if(this.hasVariableArgList) {
                result.hasVariableArgList = true; 
            }
            result.returnType = new Tools.TypeLink(); 
            if(this.returnType.type != null) {
                result.returnType.type = this.returnType.type.specializeType(pattern, replacement, checker, false); 
            } else  {
                result.returnType.type = checker.anyType; 
            }
            if(this.parameters != null) {
                result.parameters = []; 
                for(var i = 0, len = this.parameters.length; i < len; i++) {
                    var oldSym = this.parameters[i]; 
                    var paramDef = new Tools.ValueLocation(); 
                    var paramSym = new Tools.ParameterSymbol(oldSym.name, oldSym.location, checker.locationInfo.unitIndex, paramDef); 
                    paramSym.declAST = this.declAST; 
                    paramDef.symbol = paramSym; 
                    paramDef.typeLink = new Tools.TypeLink(); 
                    result.parameters[i] = paramSym; 
                    var oldType = oldSym.getType(); 
                    if(oldType != null) {
                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false); 
                        paramSym.declAST.type = paramDef.typeLink.type; 
                    } else  {
                        paramDef.typeLink.type = checker.anyType; 
                    }
                }
            }
            return result; 
        };
        Signature.prototype.matchSingleArg = function(argType, checker) {
            if(this.parameters.length == 1) {
                return checker.contravariantMatches(this.parameters[0].parameter.typeLink.type, argType); 
            }
            return false; 
        };
        Signature.prototype.matchParams = function(b, checker) {
            var len = this.parameters.length; 
            if(b.parameters.length == len) {
                for(var i = 0; i < len; i++) {
                    var paramA = this.parameters[i].parameter; 
                    var paramB = b.parameters[i].parameter; 
                    if(!checker.invariantMatches(paramA.typeLink.type, paramB.typeLink.type)) {
                        return false; 
                    }
                }
            } else  {
                return false; 
            }
            return true; 
        };
        Signature.prototype.toString = function() {
            return this.toStringHelper(false, false, null); 
        };
        Signature.prototype.toStringHelper = function(shortform, brackets, scope) {
            var builder; 
            if(brackets) {
                builder = "["; 
            } else  {
                builder = "("; 
            }
            var len = this.parameters.length; 
            for(var i = 0; i < len; i++) {
                builder += (this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "")) + ": "; 
                builder += this.parameters[i].getType().getScopedTypeName(scope); 
                if(i < len - 1) {
                    builder += ","; 
                }
            }
            if(shortform) {
                if(brackets) {
                    builder += "] => "; 
                } else  {
                    builder += ") => "; 
                }
            } else  {
                if(brackets) {
                    builder += "]: "; 
                } else  {
                    builder += "): "; 
                }
            }
            if(this.returnType.type != null) {
                builder += this.returnType.type.getScopedTypeName(scope); 
            } else  {
                builder += "any"; 
            }
            return builder; 
        };
        return Signature;
    })();
    Tools.Signature = Signature;
    
    var SignatureGroup = (function () {
        function SignatureGroup() {
            this.isMethod = true; 
            this.isIndexer = false; 
            this.signatures = []; 
            this.hasImplementation = true; 
            this.definitionSignature = null; 
            this.hasBeenTypechecked = false; 
        }
        SignatureGroup.prototype.addSignature = function(signature) {
            if(this.signatures == null) {
                this.signatures = new Array(); 
            }
            this.signatures[this.signatures.length] = signature; 
            if(signature.declAST && !signature.declAST.isOverload && !signature.declAST.isSignature() && !Tools.hasFlag(signature.declAST.fncFlags, Tools.FncFlags.Ambient) && Tools.hasFlag(signature.declAST.fncFlags, Tools.FncFlags.Definition)) {
                this.definitionSignature = signature; 
            }
        };
        SignatureGroup.prototype.toString = function() {
            return this.signatures.toString(); 
        };
        SignatureGroup.prototype.toStrings = function(prefix, shortform, scope) {
            var result = []; 
            var len = this.signatures.length; 
            if(len > 1) {
                shortform = false; 
            }
            for(var i = 0; i < len; i++) {
                if(len > 1 && this.signatures[i] == this.definitionSignature) {
                    continue;
                }
                if(this.isIndexer) {
                    result[i] = this.signatures[i].toStringHelper(shortform, true, scope); 
                } else  {
                    result[i] = prefix + this.signatures[i].toStringHelper(shortform, false, scope); 
                }
            }
            return result; 
        };
        SignatureGroup.prototype.specializeType = function(pattern, replacement, checker) {
            var result = new SignatureGroup(); 
            if(this.signatures != null) {
                for(var i = 0, len = this.signatures.length; i < len; i++) {
                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker)); 
                }
            }
            return result; 
        };
        SignatureGroup.prototype.typeCheck = function(checker, ast, hasConstruct) {
            if(this.hasBeenTypechecked) {
                return;
            }
            this.hasBeenTypechecked = true; 
            var len = 0; 
            if((this.signatures != null) && ((len = this.signatures.length) > 0)) {
                for(var i = 0; i < len; i++) {
                    if(!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !Tools.hasFlag(this.signatures[i].declAST.fncFlags, Tools.FncFlags.Ambient)) {
                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition"); 
                    }
                    if(this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == Tools.TypeCheckStatus.NotStarted) {
                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl); 
                    }
                    checker.typeFlow.typeCheck(this.signatures[i].declAST); 
                }
                for(i = 0; i < len; i++) {
                    for(var j = i + 1; j < len; j++) {
                        if(this.signatures[i].declAST && this.signatures[j].declAST && (!Tools.hasFlag(this.signatures[i].declAST.fncFlags, Tools.FncFlags.Definition) && !Tools.hasFlag(this.signatures[j].declAST.fncFlags, Tools.FncFlags.Definition)) && this.signatures[i].matchParams(this.signatures[j], checker) && checker.invariantMatches(this.signatures[i].returnType.type, this.signatures[j].returnType.type)) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Signature is duplicated"); 
                        }
                    }
                    if(this.definitionSignature) {
                        if(!checker.signatureAssignable(this.signatures[i], this.definitionSignature)) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition"); 
                        }
                    }
                }
            }
        };
        return SignatureGroup;
    })();
    Tools.SignatureGroup = SignatureGroup;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    (function(TypeCheckStatus) {
        TypeCheckStatus._map = []; 
        TypeCheckStatus._map[0] = "NotStarted"; 
        TypeCheckStatus.NotStarted = 0; 
        TypeCheckStatus._map[1] = "Started"; 
        TypeCheckStatus.Started = 1; 
        TypeCheckStatus._map[2] = "Finished"; 
        TypeCheckStatus.Finished = 2; 
    })(Tools.TypeCheckStatus||(Tools.TypeCheckStatus={}));
    var TypeCheckStatus = Tools.TypeCheckStatus;

    function uniqueSymbols(dup) {
        var a = new Array(); 
        var l = dup.length; 
        var prevName = "@"; 
        for(var i = 0; i < l; i++) {
            if(prevName != dup[i].name) {
                a[a.length] = dup[i]; 
                prevName = dup[i].name; 
            }
        }
        return a; 
    }
    Tools.uniqueSymbols = uniqueSymbols;
    function symbolCompareByName(a, b) {
        if(a.name < b.name) {
            return -1; 
        } else  {
            if(a.name == b.name) {
                return 0; 
            } else  {
                return 1; 
            }
        }
    }
    Tools.symbolCompareByName = symbolCompareByName;
    function aLexicallyEnclosesB(a, b) {
        if(a.declAST != null && b != null && b.declAST != null && a.declAST.nodeType == Tools.NodeType.FuncDecl) {
            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar; 
        } else  {
            return false; 
        }
    }
    Tools.aLexicallyEnclosesB = aLexicallyEnclosesB;
    function aEnclosesB(a, b) {
        while(a.container != null) {
            if(a == b || aLexicallyEnclosesB(a.container, b)) {
                return true; 
            }
            a = a.container; 
        }
        return false; 
    }
    Tools.aEnclosesB = aEnclosesB;
    var Symbol = (function () {
        function Symbol(name, location, unitIndex) {
            this.name = name;
            this.location = location;
            this.unitIndex = unitIndex;
            this.bound = false; 
            this.container = null; 
            this.flags = Tools.SymbolFlags.None; 
            this.refs = null; 
            this.isObjectLitField = false; 
            this.declAST = null; 
            this.declModule = null; 
            this.passSymbolCreated = Tools.CompilerDiagnostics.analysisPass; 
        }
        Symbol.prototype.instanceScope = function() {
            return null; 
        };
        Symbol.prototype.isVariable = function() {
            return false; 
        };
        Symbol.prototype.isMember = function() {
            return false; 
        };
        Symbol.prototype.isInferenceSymbol = function() {
            return false; 
        };
        Symbol.prototype.isWith = function() {
            return false; 
        };
        Symbol.prototype.writeable = function() {
            return false; 
        };
        Symbol.prototype.isType = function() {
            return false; 
        };
        Symbol.prototype.getType = function() {
            return null; 
        };
        Symbol.prototype.isAccessor = function() {
            return false; 
        };
        Symbol.prototype.isInstanceProperty = function() {
            return Tools.hasFlag(this.flags, Tools.SymbolFlags.Property) && (!Tools.hasFlag(this.flags, Tools.SymbolFlags.ModuleMember)); 
        };
        Symbol.prototype.getTypeName = function(scope) {
            return this.toString(); 
        };
        Symbol.prototype.pathToRoot = function() {
            var path = new Array(); 
            var node = this; 
            while((node != null) && (node.name != Tools.globalId)) {
                path[path.length] = node; 
                node = node.container; 
            }
            return path; 
        };
        Symbol.prototype.findCommonAncestorPath = function(b) {
            if(this.container == null) {
                return new Array(); 
            }
            var aPath = this.container.pathToRoot(); 
            var bPath; 
            if(b != null) {
                bPath = b.pathToRoot(); 
            } else  {
                bPath = new Array(); 
            }
            var commonNodeIndex = -1; 
            for(var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i]; 
                for(var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j]; 
                    if(aNode == bNode) {
                        commonNodeIndex = i; 
                        break;
                    }
                }
                if(commonNodeIndex >= 0) {
                    break;
                }
            }
            if(commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex); 
            } else  {
                return aPath; 
            }
        };
        Symbol.prototype.scopeRelativeName = function(scope) {
            if(scope == null) {
                return this.name; 
            }
            var lca = this.findCommonAncestorPath(scope.container); 
            var builder = ""; 
            for(var i = 0, len = lca.length; i < len; i++) {
                builder = (lca[i].name + ".") + builder; 
            }
            builder += this.name; 
            return builder; 
        };
        Symbol.prototype.fullName = function() {
            var builder = this.name; 
            var ancestor = this.container; 
            while((ancestor != null) && (ancestor.name != Tools.globalId)) {
                builder = (ancestor.name + ".") + builder; 
                ancestor = ancestor.container; 
            }
            return builder; 
        };
        Symbol.prototype.visible = function(scope, checker) {
            if(checker == null || this.container == checker.gloMod) {
                return true; 
            }
            if(Tools.hasFlag(this.flags, Tools.SymbolFlags.ModuleMember)) {
                if(Tools.hasFlag(this.flags, Tools.SymbolFlags.Exported)) {
                    if(!Tools.hasFlag(this.flags, Tools.SymbolFlags.Private)) {
                        return true; 
                    } else  {
                        return aEnclosesB(this, scope.container); 
                    }
                } else  {
                    return checker != null && (checker.currentModDecl == this.declModule) || (checker.currentModDecl != null && checker.currentModDecl.mod != null && checker.currentModDecl.mod.symbol != null && this.declModule != null && this.declModule.mod != null && this.declModule.mod.symbol != null && aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol)); 
                }
            } else  {
                var isFunction = this.declAST != null && this.declAST.nodeType == Tools.NodeType.FuncDecl; 
                var isMethod = isFunction && (this.declAST).isMethod(); 
                var isStaticFunction = isFunction && Tools.hasFlag((this.declAST).fncFlags, Tools.FncFlags.Static); 
                var isPrivateMethod = isMethod && Tools.hasFlag((this.declAST).fncFlags, Tools.FncFlags.Private); 
                var isAlias = this.isType() && (this).isAlias; 
                if(this.isMember() || isMethod || isStaticFunction || isAlias) {
                    if(Tools.hasFlag(this.flags, Tools.SymbolFlags.Private) || isPrivateMethod) {
                        if(scope.container == null && this.container != scope.container) {
                            return false; 
                        } else  {
                            return this.container == null ? true : aEnclosesB(scope.container, this.container); 
                        }
                    } else  {
                        return true; 
                    }
                } else  {
                    if(this.container != null) {
                        return aEnclosesB(this, scope.container); 
                    } else  {
                        return true; 
                    }
                }
            }
        };
        Symbol.prototype.addRef = function(identifier) {
            if(this.refs == null) {
                this.refs = []; 
            }
            this.refs[this.refs.length] = identifier; 
        };
        Symbol.prototype.toString = function() {
            if(this.name != null) {
                return this.name; 
            } else  {
                return "_anonymous"; 
            }
        };
        Symbol.prototype.print = function(outfile) {
            outfile.Write(this.toString()); 
        };
        Symbol.prototype.specializeType = function(pattern, replacement, checker) {
            throw new Error("please implement in derived class");
        };
        Symbol.prototype.setType = function(type) {
            throw new Error("please implement in derived class");
        };
        Symbol.prototype.kind = function() {
            throw new Error("please implement in derived class");
        };
        return Symbol;
    })();
    Tools.Symbol = Symbol;
    
    var ValueLocation = (function () {
        function ValueLocation() {
            this.symbol = null; 
            this.typeLink = null; 
        }
        return ValueLocation;
    })();
    Tools.ValueLocation = ValueLocation;
    
    var InferenceSymbol = (function () {
        _inheritsFrom(InferenceSymbol, Symbol);
        function InferenceSymbol(name, location, unitIndex) {
            InferenceSymbol._super.constructor.call(this, name, location, unitIndex);
            this.typeCheckStatus = TypeCheckStatus.NotStarted; 
        }
        InferenceSymbol.prototype.isInferenceSymbol = function() {
            return true; 
        };
        InferenceSymbol.prototype.transferVarFlags = function(varFlags) {
            if(Tools.hasFlag(varFlags, Tools.VarFlags.Ambient)) {
                this.flags |= Tools.SymbolFlags.Ambient; 
            }
            if(Tools.hasFlag(varFlags, Tools.VarFlags.Constant)) {
                this.flags |= Tools.SymbolFlags.Constant; 
            }
            if(Tools.hasFlag(varFlags, Tools.VarFlags.Static)) {
                this.flags |= Tools.SymbolFlags.Static; 
            }
            if(Tools.hasFlag(varFlags, Tools.VarFlags.Property)) {
                this.flags |= Tools.SymbolFlags.Property; 
            }
            if(Tools.hasFlag(varFlags, Tools.VarFlags.Private)) {
                this.flags |= Tools.SymbolFlags.Private; 
            }
            if(Tools.hasFlag(varFlags, Tools.VarFlags.Public)) {
                this.flags |= Tools.SymbolFlags.Public; 
            }
            if(Tools.hasFlag(varFlags, Tools.VarFlags.Readonly)) {
                this.flags |= Tools.SymbolFlags.Readonly; 
            }
            if(Tools.hasFlag(varFlags, Tools.VarFlags.Exported)) {
                this.flags |= Tools.SymbolFlags.Exported; 
            }
        };
        return InferenceSymbol;
    })();
    Tools.InferenceSymbol = InferenceSymbol;
    
    var TypeSymbol = (function () {
        _inheritsFrom(TypeSymbol, InferenceSymbol);
        function TypeSymbol(locName, location, unitIndex, type) {
            this.type = type;
            TypeSymbol._super.constructor.call(this, locName, location, unitIndex);
            this.additionalLocations = null; 
            this.expansions = []; 
            this.isMethod = false; 
            this.isAlias = false; 
            this.prettyName = this.name; 
            this.onlyReferencedAsTypeRef = Tools.optimizeModuleCodeGen; 
            this.instanceType = null; 
        }
        TypeSymbol.prototype.addLocation = function(loc) {
            if(this.additionalLocations == null) {
                this.additionalLocations = []; 
            }
            this.additionalLocations[this.additionalLocations.length] = loc; 
        };
        TypeSymbol.prototype.kind = function() {
            return Tools.SymbolKind.Type; 
        };
        TypeSymbol.prototype.isType = function() {
            return true; 
        };
        TypeSymbol.prototype.getType = function() {
            return this.type; 
        };
        TypeSymbol.prototype.getTypeName = function(scope) {
            return this.type.getMemberTypeName((this.name != null) ? this.name : "", false, false, scope); 
        };
        TypeSymbol.prototype.instanceScope = function() {
            if(!this.type.isES6Class && this.type.isClass()) {
                return this.type.instanceType.constructorScope; 
            } else  {
                return this.type.containedScope; 
            }
        };
        TypeSymbol.prototype.toString = function() {
            var result = this.type.getTypeName(); 
            if(this.name != null) {
                result = (this.name + ":") + result; 
            }
            return result; 
        };
        TypeSymbol.prototype.isClass = function() {
            return this.instanceType != null; 
        };
        TypeSymbol.prototype.specializeType = function(pattern, replacement, checker) {
            if(this.type == pattern) {
                return replacement.symbol; 
            } else  {
                var replType = this.type.specializeType(pattern, replacement, checker, false); 
                if(replType != this.type) {
                    var result = new TypeSymbol(this.name, 0, -1, replType); 
                    return result; 
                } else  {
                    return this; 
                }
            }
        };
        TypeSymbol.prototype.scopeRelativeName = function(scope) {
            if(scope == null) {
                return this.prettyName; 
            }
            var lca = this.findCommonAncestorPath(scope.container); 
            var builder = ""; 
            for(var i = 0, len = lca.length; i < len; i++) {
                builder = (lca[i].name + ".") + builder; 
            }
            builder += this.prettyName; 
            return builder; 
        };
        return TypeSymbol;
    })();
    Tools.TypeSymbol = TypeSymbol;
    
    var WithSymbol = (function () {
        _inheritsFrom(WithSymbol, TypeSymbol);
        function WithSymbol(location, unitIndex, withType) {
            WithSymbol._super.constructor.call(this, "with", location, unitIndex, withType);
        }
        WithSymbol.prototype.isWith = function() {
            return true; 
        };
        return WithSymbol;
    })();
    Tools.WithSymbol = WithSymbol;
    
    var FieldSymbol = (function () {
        _inheritsFrom(FieldSymbol, InferenceSymbol);
        function FieldSymbol(name, location, unitIndex, canWrite, field) {
            this.name = name;
            this.location = location;
            this.canWrite = canWrite;
            this.field = field;
            FieldSymbol._super.constructor.call(this, this.name, this.location, unitIndex);
            this.getter = null; 
            this.setter = null; 
            this.hasBeenEmitted = false; 
        }
        FieldSymbol.prototype.kind = function() {
            return Tools.SymbolKind.Field; 
        };
        FieldSymbol.prototype.writeable = function() {
            return this.isAccessor() ? this.setter != null : this.canWrite; 
        };
        FieldSymbol.prototype.getType = function() {
            return this.field.typeLink.type; 
        };
        FieldSymbol.prototype.getTypeName = function(scope) {
            return (this.name + ": ") + this.field.typeLink.type.getMemberTypeName("", true, false, scope); 
        };
        FieldSymbol.prototype.isMember = function() {
            return true; 
        };
        FieldSymbol.prototype.setType = function(type) {
            this.field.typeLink.type = type; 
        };
        FieldSymbol.prototype.isAccessor = function() {
            return this.getter != null || this.setter != null; 
        };
        FieldSymbol.prototype.isVariable = function() {
            return true; 
        };
        FieldSymbol.prototype.toString = function() {
            return (this.name + ":") + this.field.typeLink.type.getTypeName(); 
        };
        FieldSymbol.prototype.specializeType = function(pattern, replacement, checker) {
            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false); 
            if(rType != this.field.typeLink.type) {
                var fieldDef = new ValueLocation(); 
                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex, this.canWrite, fieldDef); 
                result.flags = this.flags; 
                fieldDef.symbol = result; 
                fieldDef.typeLink = new Tools.TypeLink(); 
                result.setType(rType); 
                result.typeCheckStatus = TypeCheckStatus.Finished; 
                return result; 
            } else  {
                return this; 
            }
        };
        return FieldSymbol;
    })();
    Tools.FieldSymbol = FieldSymbol;
    
    var ParameterSymbol = (function () {
        _inheritsFrom(ParameterSymbol, InferenceSymbol);
        function ParameterSymbol(name, location, unitIndex, parameter) {
            this.name = name;
            this.location = location;
            this.parameter = parameter;
            ParameterSymbol._super.constructor.call(this, this.name, this.location, unitIndex);
            this.argsOffset = (-1); 
        }
        ParameterSymbol.prototype.kind = function() {
            return Tools.SymbolKind.Parameter; 
        };
        ParameterSymbol.prototype.writeable = function() {
            return true; 
        };
        ParameterSymbol.prototype.getType = function() {
            return this.parameter.typeLink.type; 
        };
        ParameterSymbol.prototype.setType = function(type) {
            this.parameter.typeLink.type = type; 
        };
        ParameterSymbol.prototype.isVariable = function() {
            return true; 
        };
        ParameterSymbol.prototype.isOptional = function() {
            if(this.parameter != null && this.parameter.symbol != null && this.parameter.symbol.declAST != null) {
                return (this.parameter.symbol.declAST).isOptional; 
            } else  {
                return false; 
            }
        };
        ParameterSymbol.prototype.getTypeName = function(scope) {
            return ((this.name + (this.isOptional() ? "?" : "")) + ":") + this.getType().getMemberTypeName("", false, false, scope); 
        };
        ParameterSymbol.prototype.toString = function() {
            return ((this.name + (this.isOptional() ? "?" : "")) + ":") + this.getType().getTypeName(); 
        };
        ParameterSymbol.prototype.specializeType = function(pattern, replacement, checker) {
            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false); 
            if(this.parameter.typeLink.type != rType) {
                var paramDef = new ValueLocation(); 
                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex, paramDef); 
                paramDef.symbol = result; 
                result.setType(rType); 
                return result; 
            } else  {
                return this; 
            }
        };
        return ParameterSymbol;
    })();
    Tools.ParameterSymbol = ParameterSymbol;
    
    var VariableSymbol = (function () {
        _inheritsFrom(VariableSymbol, InferenceSymbol);
        function VariableSymbol(name, location, unitIndex, variable) {
            this.variable = variable;
            VariableSymbol._super.constructor.call(this, name, location, unitIndex);
        }
        VariableSymbol.prototype.kind = function() {
            return Tools.SymbolKind.Variable; 
        };
        VariableSymbol.prototype.writeable = function() {
            return true; 
        };
        VariableSymbol.prototype.getType = function() {
            return this.variable.typeLink.type; 
        };
        VariableSymbol.prototype.getTypeName = function(scope) {
            return (this.name + ":") + this.getType().getMemberTypeName("", false, false, scope); 
        };
        VariableSymbol.prototype.setType = function(type) {
            this.variable.typeLink.type = type; 
        };
        VariableSymbol.prototype.isVariable = function() {
            return true; 
        };
        return VariableSymbol;
    })();
    Tools.VariableSymbol = VariableSymbol;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var ScopedMembers = (function () {
        function ScopedMembers(dualMembers) {
            this.dualMembers = dualMembers;
            this.allMembers = this.dualMembers; 
            this.publicMembers = this.dualMembers.primaryTable; 
            this.privateMembers = this.dualMembers.secondaryTable; 
        }
        ScopedMembers.prototype.addPublicMember = function(key, data) {
            return this.dualMembers.primaryTable.add(key, data); 
        };
        ScopedMembers.prototype.addPrivateMember = function(key, data) {
            return this.dualMembers.secondaryTable.add(key, data); 
        };
        return ScopedMembers;
    })();
    Tools.ScopedMembers = ScopedMembers;
    
    (function(SymbolKind) {
        SymbolKind._map = []; 
        SymbolKind._map[0] = "None"; 
        SymbolKind.None = 0; 
        SymbolKind._map[1] = "Type"; 
        SymbolKind.Type = 1; 
        SymbolKind._map[2] = "Field"; 
        SymbolKind.Field = 2; 
        SymbolKind._map[3] = "Parameter"; 
        SymbolKind.Parameter = 3; 
        SymbolKind._map[4] = "Variable"; 
        SymbolKind.Variable = 4; 
    })(Tools.SymbolKind||(Tools.SymbolKind={}));
    var SymbolKind = Tools.SymbolKind;

    var SymbolScope = (function () {
        function SymbolScope(container) {
            this.container = container;
        }
        SymbolScope.prototype.printLabel = function() {
            return "base"; 
        };
        SymbolScope.prototype.getAllSymbolNames = function(members) {
            return [                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
]; 
        };
        SymbolScope.prototype.getAllTypeSymbolNames = function(members) {
            return [                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
]; 
        };
        SymbolScope.prototype.getAllValueSymbolNames = function(members) {
            return [                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
]; 
        };
        SymbolScope.prototype.search = function(filter, name, publicOnly, typespace) {
            return null; 
        };
        SymbolScope.prototype.findLocal = function(name, publicOnly, typespace) {
            return null; 
        };
        SymbolScope.prototype.find = function(name, publicOnly, typespace) {
            return null; 
        };
        SymbolScope.prototype.findImplementation = function(name, publicOnly, typespace) {
            return null; 
        };
        SymbolScope.prototype.findAmbient = function(name, publicOnly, typespace) {
            return null; 
        };
        SymbolScope.prototype.print = function(outfile) {
            if(this.container != null) {
                outfile.WriteLine(((this.printLabel() + " scope with container: ") + this.container.name) + "..."); 
            } else  {
                outfile.WriteLine(this.printLabel() + " scope..."); 
            }
        };
        SymbolScope.prototype.enter = function(container, ast, symbol, errorReporter, publicOnly, typespace, ambient) {
            throw new Error("please implement in derived class");
        };
        SymbolScope.prototype.getTable = function() {
            throw new Error("please implement in derived class");
        };
        return SymbolScope;
    })();
    Tools.SymbolScope = SymbolScope;
    
    function symbolCanBeUsed(sym, publicOnly) {
        return publicOnly ? !(Tools.hasFlag(sym.flags, Tools.SymbolFlags.Private) || (sym.declAST != null && sym.declAST.nodeType == Tools.NodeType.FuncDecl && Tools.hasFlag((sym.declAST).fncFlags, Tools.FncFlags.Private))) : true; 
    }
    var SymbolAggregateScope = (function () {
        _inheritsFrom(SymbolAggregateScope, SymbolScope);
        function SymbolAggregateScope(container) {
            this.container = container;
            SymbolAggregateScope._super.constructor.call(this, this.container);
            this.valueCache = null; 
            this.valueImplCache = null; 
            this.valueAmbientCache = null; 
            this.typeCache = null; 
            this.typeImplCache = null; 
            this.typeAmbientCache = null; 
            this.parents = null; 
        }
        SymbolAggregateScope.prototype.printLabel = function() {
            return "agg"; 
        };
        SymbolAggregateScope.prototype.search = function(filter, name, publicOnly, typespace) {
            if(this.parents != null) {
                for(var i = 0; i < this.parents.length; i++) {
                    var sym = this.parents[i].search(filter, name, publicOnly, typespace); 
                    if(sym != null) {
                        if(filter.update(sym)) {
                            return sym; 
                        }
                    }
                }
            }
            return filter.result; 
        };
        SymbolAggregateScope.prototype.getAllSymbolNames = function(members) {
            var result = []; 
            if(this.parents != null) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllSymbolNames(members); 
                    if(parentResult != null) {
                        result = result.concat(parentResult); 
                    }
                }
            }
            return result; 
        };
        SymbolAggregateScope.prototype.getAllTypeSymbolNames = function(members) {
            var result = []; 
            if(this.parents != null) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllTypeSymbolNames(members); 
                    if(parentResult != null) {
                        result = result.concat(parentResult); 
                    }
                }
            }
            return result; 
        };
        SymbolAggregateScope.prototype.getAllValueSymbolNames = function(members) {
            var result = []; 
            if(this.parents != null) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllValueSymbolNames(members); 
                    if(parentResult != null) {
                        result = result.concat(parentResult); 
                    }
                }
            }
            return result; 
        };
        SymbolAggregateScope.prototype.print = function(outfile) {
            SymbolAggregateScope._super.print.call(this, outfile); 
            if(this.parents != null) {
                for(var i = 0; i < this.parents.length; i++) {
                    this.parents[i].print(outfile); 
                }
            }
        };
        SymbolAggregateScope.prototype.findImplementation = function(name, publicOnly, typespace) {
            var sym = null; 
            var i = 0; 
            var implCache = this.valueImplCache; 
            if(typespace) {
                implCache = this.typeImplCache; 
            }
            if((implCache != null) && ((sym = implCache.lookup(name)) != null) && (publicOnly ? !(Tools.hasFlag(sym.flags, Tools.SymbolFlags.Private) || (sym.declAST != null && sym.declAST.nodeType == Tools.NodeType.FuncDecl && Tools.hasFlag((sym.declAST).fncFlags, Tools.FncFlags.Private))) : true)) {
                return sym; 
            }
            if(this.parents != null) {
                for(i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findImplementation(name, publicOnly, typespace); 
                    if(sym != null) {
                        break;
                    }
                }
            }
            if(implCache == null) {
                if(typespace) {
                    this.typeImplCache = new Tools.StringHashTable(); 
                    implCache = this.typeImplCache; 
                } else  {
                    this.valueImplCache = new Tools.StringHashTable(); 
                    implCache = this.valueImplCache; 
                }
            }
            implCache.add(name, sym); 
            return sym; 
        };
        SymbolAggregateScope.prototype.find = function(name, publicOnly, typespace) {
            var sym = null; 
            var i = 0; 
            var cache = this.valueCache; 
            if(typespace) {
                cache = this.typeCache; 
            }
            if((cache != null) && ((sym = cache.lookup(name)) != null) && (publicOnly ? !(Tools.hasFlag(sym.flags, Tools.SymbolFlags.Private) || (sym.declAST != null && sym.declAST.nodeType == Tools.NodeType.FuncDecl && Tools.hasFlag((sym.declAST).fncFlags, Tools.FncFlags.Private))) : true)) {
                return sym; 
            }
            if(this.parents != null) {
                for(i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].find(name, publicOnly, typespace); 
                    if(sym != null) {
                        break;
                    }
                }
            }
            if(cache == null) {
                if(typespace) {
                    this.typeCache = new Tools.StringHashTable(); 
                    cache = this.typeCache; 
                } else  {
                    this.valueCache = new Tools.StringHashTable(); 
                    cache = this.valueCache; 
                }
            }
            cache.add(name, sym); 
            return sym; 
        };
        SymbolAggregateScope.prototype.findAmbient = function(name, publicOnly, typespace) {
            var sym = null; 
            var i = 0; 
            var cache = this.valueAmbientCache; 
            if(typespace) {
                cache = this.typeAmbientCache; 
            }
            if((cache != null) && ((sym = cache.lookup(name)) != null)) {
                return sym; 
            }
            if(this.parents != null) {
                for(i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findAmbient(name, publicOnly, typespace); 
                    if(sym != null) {
                        break;
                    }
                }
            }
            if(cache == null) {
                if(typespace) {
                    this.typeAmbientCache = new Tools.StringHashTable(); 
                    cache = this.typeAmbientCache; 
                } else  {
                    this.valueAmbientCache = new Tools.StringHashTable(); 
                    cache = this.valueAmbientCache; 
                }
            }
            cache.add(name, sym); 
            return sym; 
        };
        SymbolAggregateScope.prototype.addParentScope = function(parent) {
            if(this.parents == null) {
                this.parents = new Array(); 
            }
            this.parents[this.parents.length] = parent; 
        };
        return SymbolAggregateScope;
    })();
    Tools.SymbolAggregateScope = SymbolAggregateScope;
    
    var SymbolTableScope = (function () {
        _inheritsFrom(SymbolTableScope, SymbolScope);
        function SymbolTableScope(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, container) {
            this.valueMembers = valueMembers;
            this.ambientValueMembers = ambientValueMembers;
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            this.container = container;
            SymbolTableScope._super.constructor.call(this, this.container);
        }
        SymbolTableScope.prototype.printLabel = function() {
            return "table"; 
        };
        SymbolTableScope.prototype.getAllSymbolNames = function(members) {
            var result = this.getAllTypeSymbolNames(members); 
            return result.concat(this.getAllValueSymbolNames(members)); 
        };
        SymbolTableScope.prototype.getAllTypeSymbolNames = function(members) {
            var result = []; 
            if(this.ambientEnclosedTypes != null) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys()); 
            }
            if(this.enclosedTypes != null) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys()); 
            }
            return result; 
        };
        SymbolTableScope.prototype.getAllValueSymbolNames = function(members) {
            var result = []; 
            if(this.ambientValueMembers != null) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys()); 
            }
            if(this.valueMembers != null) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys()); 
            }
            return result; 
        };
        SymbolTableScope.prototype.search = function(filter, name, publicOnly, typespace) {
            var sym = this.find(name, publicOnly, typespace); 
            filter.update(sym); 
            return filter.result; 
        };
        SymbolTableScope.prototype.find = function(name, publicOnly, typespace) {
            var table = null; 
            var ambientTable = null; 
            if(typespace) {
                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers; 
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers; 
            } else  {
                table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers; 
                ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers; 
            }
            if(ambientTable != null) {
                var s = ambientTable.lookup(name); 
                if(s != null) {
                    return s; 
                }
            }
            if(table != null) {
                var s = table.lookup(name); 
                if(s != null) {
                    return s; 
                }
            }
            return null; 
        };
        SymbolTableScope.prototype.findAmbient = function(name, publicOnly, typespace) {
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers; 
            if(typespace) {
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers; 
            }
            if(ambientTable != null) {
                var s = ambientTable.lookup(name); 
                if(s != null) {
                    return s; 
                }
            }
            return null; 
        };
        SymbolTableScope.prototype.print = function(outfile) {
            SymbolTableScope._super.print.call(this, outfile); 
            if(this.ambientValueMembers != null) {
                this.ambientValueMembers.allMembers.map(function(key, sym, context) {
                    outfile.WriteLine("  " + key); 
                }, null); 
            }
            if(this.valueMembers != null) {
                this.valueMembers.allMembers.map(function(key, sym, context) {
                    outfile.WriteLine("  " + key); 
                }, null); 
            }
            if(this.ambientEnclosedTypes != null) {
                this.ambientEnclosedTypes.allMembers.map(function(key, sym, context) {
                    outfile.WriteLine("  " + key); 
                }, null); 
            }
            if(this.enclosedTypes != null) {
                this.enclosedTypes.allMembers.map(function(key, sym, context) {
                    outfile.WriteLine("  " + key); 
                }, null); 
            }
        };
        SymbolTableScope.prototype.findImplementation = function(name, publicOnly, typespace) {
            var sym = this.find(name, publicOnly, typespace); 
            if(sym != null) {
                if(sym.kind() == SymbolKind.Type) {
                    var typeSym = sym; 
                    if(!typeSym.type.hasImplementation()) {
                        sym = null; 
                    }
                } else  {
                    if(sym.container != null) {
                        if(sym.container.kind() == SymbolKind.Type) {
                            var ctypeSym = sym.container; 
                            if(!ctypeSym.type.hasImplementation()) {
                                sym = null; 
                            }
                        }
                    }
                }
            }
            return sym; 
        };
        SymbolTableScope.prototype.getTable = function() {
            return this.valueMembers.allMembers; 
        };
        return SymbolTableScope;
    })();
    Tools.SymbolTableScope = SymbolTableScope;
    
    var SymbolScopeBuilder = (function () {
        _inheritsFrom(SymbolScopeBuilder, SymbolScope);
        function SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, parent, container) {
            this.valueMembers = valueMembers;
            this.ambientValueMembers = ambientValueMembers;
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            this.parent = parent;
            SymbolScopeBuilder._super.constructor.call(this, this.container);
        }
        SymbolScopeBuilder.prototype.printLabel = function() {
            return "builder"; 
        };
        SymbolScopeBuilder.prototype.getAllSymbolNames = function(members) {
            var result = this.getAllTypeSymbolNames(members); 
            return result.concat(this.getAllValueSymbolNames(members)); 
        };
        SymbolScopeBuilder.prototype.getAllTypeSymbolNames = function(members) {
            var result = []; 
            if(this.ambientEnclosedTypes != null) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys()); 
            }
            if(this.enclosedTypes != null) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys()); 
            }
            if(!members && this.parent != null) {
                var parentResult = this.parent.getAllTypeSymbolNames(members); 
                if(parentResult != null) {
                    result = result.concat(parentResult); 
                }
            }
            return result; 
        };
        SymbolScopeBuilder.prototype.getAllValueSymbolNames = function(members) {
            var result = []; 
            if(this.ambientValueMembers != null) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys()); 
            }
            if(this.valueMembers != null) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys()); 
            }
            if(!members && this.parent != null) {
                var parentResult = this.parent.getAllValueSymbolNames(members); 
                if(parentResult != null) {
                    result = result.concat(parentResult); 
                }
            }
            return result; 
        };
        SymbolScopeBuilder.prototype.search = function(filter, name, publicOnly, typespace) {
            var sym = null; 
            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers; 
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers; 
            if(typespace) {
                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers; 
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers; 
            }
            if(ambientTable != null) {
                if((sym = ambientTable.lookup(name)) != null) {
                    if(filter.update(sym)) {
                        return sym; 
                    }
                }
            }
            if(table != null) {
                if((sym = table.lookup(name)) != null) {
                    if(filter.update(sym)) {
                        return sym; 
                    }
                }
            }
            if(this.parent != null) {
                sym = this.parent.search(filter, name, publicOnly, typespace); 
                if(sym != null) {
                    if(filter.update(sym)) {
                        return sym; 
                    }
                }
            }
            return filter.result; 
        };
        SymbolScopeBuilder.prototype.print = function(outfile) {
            SymbolScopeBuilder._super.print.call(this, outfile); 
            if(this.ambientValueMembers != null) {
                this.ambientValueMembers.allMembers.map(function(key, s, context) {
                    var sym = s; 
                    outfile.WriteLine("  " + key); 
                }, null); 
            }
            if(this.valueMembers != null) {
                this.valueMembers.allMembers.map(function(key, s, context) {
                    var sym = s; 
                    outfile.WriteLine("  " + key); 
                }, null); 
            }
            if(this.ambientEnclosedTypes != null) {
                this.ambientEnclosedTypes.allMembers.map(function(key, s, context) {
                    var sym = s; 
                    outfile.WriteLine("  " + key); 
                }, null); 
            }
            if(this.enclosedTypes != null) {
                this.enclosedTypes.allMembers.map(function(key, s, context) {
                    var sym = s; 
                    outfile.WriteLine("  " + key); 
                }, null); 
            }
            if(this.parent != null) {
                this.parent.print(outfile); 
            }
        };
        SymbolScopeBuilder.prototype.find = function(name, publicOnly, typespace) {
            var sym = null; 
            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers; 
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers; 
            if(typespace) {
                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers; 
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers; 
            }
            if((ambientTable != null) && ((sym = ambientTable.lookup(name)) != null)) {
                return sym; 
            }
            if((table != null) && ((sym = table.lookup(name)) != null)) {
                return sym; 
            }
            if(this.parent != null) {
                return this.parent.find(name, publicOnly, typespace); 
            }
            return null; 
        };
        SymbolScopeBuilder.prototype.findAmbient = function(name, publicOnly, typespace) {
            var sym = null; 
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers; 
            if(typespace) {
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers; 
            }
            if((ambientTable != null) && ((sym = ambientTable.lookup(name)) != null)) {
                return sym; 
            }
            if(this.parent != null) {
                return this.parent.findAmbient(name, publicOnly, typespace); 
            }
            return null; 
        };
        SymbolScopeBuilder.prototype.findLocal = function(name, publicOnly, typespace) {
            var sym = null; 
            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers; 
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers; 
            if(typespace) {
                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers; 
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers; 
            }
            if(table != null) {
                if((sym = table.lookup(name)) != null) {
                    if(sym != null) {
                        return sym; 
                    }
                }
            }
            if(ambientTable != null) {
                if((sym = ambientTable.lookup(name)) != null) {
                    if(sym != null) {
                        return sym; 
                    }
                }
            }
            return null; 
        };
        SymbolScopeBuilder.prototype.enter = function(container, ast, symbol, errorReporter, insertAsPublic, typespace, ambient) {
            var table = null; 
            if(ambient) {
                if(typespace) {
                    table = (this.ambientEnclosedTypes == null) ? null : insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers; 
                } else  {
                    table = (this.ambientValueMembers == null) ? null : insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers; 
                }
            } else  {
                if(typespace) {
                    table = (this.enclosedTypes == null) ? null : insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers; 
                } else  {
                    table = (this.valueMembers == null) ? null : insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers; 
                }
            }
            if(table != null) {
                if(!table.add(symbol.name, symbol)) {
                    errorReporter.duplicateIdentifier(ast, symbol.name); 
                }
            } else  {
                Tools.CompilerDiagnostics.Alert("YYYYY"); 
            }
            symbol.container = container; 
        };
        SymbolScopeBuilder.prototype.getTable = function() {
            return this.valueMembers.allMembers; 
        };
        return SymbolScopeBuilder;
    })();
    Tools.SymbolScopeBuilder = SymbolScopeBuilder;
    
    var FilteredSymbolScope = (function () {
        _inheritsFrom(FilteredSymbolScope, SymbolScope);
        function FilteredSymbolScope(scope, container, filter) {
            this.scope = scope;
            this.filter = filter;
            FilteredSymbolScope._super.constructor.call(this, container);
        }
        FilteredSymbolScope.prototype.print = function(outfile) {
            this.scope.print(outfile); 
        };
        FilteredSymbolScope.prototype.find = function(name, publicOnly, typespace) {
            this.filter.reset(); 
            return this.scope.search(this.filter, name, publicOnly, typespace); 
        };
        FilteredSymbolScope.prototype.findLocal = function(name, publicOnly, typespace) {
            return this.scope.findLocal(name, publicOnly, typespace); 
        };
        return FilteredSymbolScope;
    })();
    Tools.FilteredSymbolScope = FilteredSymbolScope;
    
    var FilteredSymbolScopeBuilder = (function () {
        _inheritsFrom(FilteredSymbolScopeBuilder, SymbolScopeBuilder);
        function FilteredSymbolScopeBuilder(valueMembers, parent, container, filter) {
            this.filter = filter;
            FilteredSymbolScopeBuilder._super.constructor.call(this, valueMembers, null, null, null, parent, container);
        }
        FilteredSymbolScopeBuilder.prototype.findLocal = function(name, publicOnly, typespace) {
            var sym = FilteredSymbolScopeBuilder._super.findLocal.call(this, name, publicOnly, typespace); 
            if(sym != null) {
                if(!this.filter(sym)) {
                    return null; 
                }
            }
            return sym; 
        };
        FilteredSymbolScopeBuilder.prototype.search = function(filter, name, publicOnly, typespace) {
            throw new Error("please implement");
        };
        FilteredSymbolScopeBuilder.prototype.find = function(name, publicOnly, typespace) {
            var sym = FilteredSymbolScopeBuilder._super.findLocal.call(this, name, publicOnly, typespace); 
            if(sym != null) {
                if(!this.filter(sym)) {
                    return null; 
                }
            }
            return FilteredSymbolScopeBuilder._super.find.call(this, name, publicOnly, typespace); 
        };
        return FilteredSymbolScopeBuilder;
    })();
    Tools.FilteredSymbolScopeBuilder = FilteredSymbolScopeBuilder;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    (function(TokenID) {
        TokenID._map = []; 
        TokenID._map[0] = "ANY"; 
        TokenID.ANY = 0; 
        TokenID._map[1] = "BOOL"; 
        TokenID.BOOL = 1; 
        TokenID._map[2] = "BREAK"; 
        TokenID.BREAK = 2; 
        TokenID._map[3] = "CASE"; 
        TokenID.CASE = 3; 
        TokenID._map[4] = "CATCH"; 
        TokenID.CATCH = 4; 
        TokenID._map[5] = "CLASS"; 
        TokenID.CLASS = 5; 
        TokenID._map[6] = "OLDCLASS"; 
        TokenID.OLDCLASS = 6; 
        TokenID._map[7] = "CONST"; 
        TokenID.CONST = 7; 
        TokenID._map[8] = "CONTINUE"; 
        TokenID.CONTINUE = 8; 
        TokenID._map[9] = "DEFAULT"; 
        TokenID.DEFAULT = 9; 
        TokenID._map[10] = "DELETE"; 
        TokenID.DELETE = 10; 
        TokenID._map[11] = "DO"; 
        TokenID.DO = 11; 
        TokenID._map[12] = "ELSE"; 
        TokenID.ELSE = 12; 
        TokenID._map[13] = "ENUM"; 
        TokenID.ENUM = 13; 
        TokenID._map[14] = "EXPORT"; 
        TokenID.EXPORT = 14; 
        TokenID._map[15] = "EXTENDS"; 
        TokenID.EXTENDS = 15; 
        TokenID._map[16] = "DECLARE"; 
        TokenID.DECLARE = 16; 
        TokenID._map[17] = "FALSE"; 
        TokenID.FALSE = 17; 
        TokenID._map[18] = "FINALLY"; 
        TokenID.FINALLY = 18; 
        TokenID._map[19] = "FOR"; 
        TokenID.FOR = 19; 
        TokenID._map[20] = "FUNCTION"; 
        TokenID.FUNCTION = 20; 
        TokenID._map[21] = "CONSTRUCTOR"; 
        TokenID.CONSTRUCTOR = 21; 
        TokenID._map[22] = "GET"; 
        TokenID.GET = 22; 
        TokenID._map[23] = "IF"; 
        TokenID.IF = 23; 
        TokenID._map[24] = "IMPLEMENTS"; 
        TokenID.IMPLEMENTS = 24; 
        TokenID._map[25] = "IMPORT"; 
        TokenID.IMPORT = 25; 
        TokenID._map[26] = "IN"; 
        TokenID.IN = 26; 
        TokenID._map[27] = "INSTANCEOF"; 
        TokenID.INSTANCEOF = 27; 
        TokenID._map[28] = "INTERFACE"; 
        TokenID.INTERFACE = 28; 
        TokenID._map[29] = "LET"; 
        TokenID.LET = 29; 
        TokenID._map[30] = "MODULE"; 
        TokenID.MODULE = 30; 
        TokenID._map[31] = "NEW"; 
        TokenID.NEW = 31; 
        TokenID._map[32] = "NUMBER"; 
        TokenID.NUMBER = 32; 
        TokenID._map[33] = "NULL"; 
        TokenID.NULL = 33; 
        TokenID._map[34] = "PACKAGE"; 
        TokenID.PACKAGE = 34; 
        TokenID._map[35] = "PRIVATE"; 
        TokenID.PRIVATE = 35; 
        TokenID._map[36] = "PROPERTY"; 
        TokenID.PROPERTY = 36; 
        TokenID._map[37] = "PROTECTED"; 
        TokenID.PROTECTED = 37; 
        TokenID._map[38] = "PUBLIC"; 
        TokenID.PUBLIC = 38; 
        TokenID._map[39] = "RETURN"; 
        TokenID.RETURN = 39; 
        TokenID._map[40] = "SET"; 
        TokenID.SET = 40; 
        TokenID._map[41] = "STATIC"; 
        TokenID.STATIC = 41; 
        TokenID._map[42] = "STRING"; 
        TokenID.STRING = 42; 
        TokenID._map[43] = "SUPER"; 
        TokenID.SUPER = 43; 
        TokenID._map[44] = "SWITCH"; 
        TokenID.SWITCH = 44; 
        TokenID._map[45] = "THIS"; 
        TokenID.THIS = 45; 
        TokenID._map[46] = "THROW"; 
        TokenID.THROW = 46; 
        TokenID._map[47] = "TRUE"; 
        TokenID.TRUE = 47; 
        TokenID._map[48] = "TRY"; 
        TokenID.TRY = 48; 
        TokenID._map[49] = "TYPEOF"; 
        TokenID.TYPEOF = 49; 
        TokenID._map[50] = "VAR"; 
        TokenID.VAR = 50; 
        TokenID._map[51] = "VOID"; 
        TokenID.VOID = 51; 
        TokenID._map[52] = "WITH"; 
        TokenID.WITH = 52; 
        TokenID._map[53] = "WHILE"; 
        TokenID.WHILE = 53; 
        TokenID._map[54] = "YIELD"; 
        TokenID.YIELD = 54; 
        TokenID._map[55] = "SColon"; 
        TokenID.SColon = 55; 
        TokenID._map[56] = "LParen"; 
        TokenID.LParen = 56; 
        TokenID._map[57] = "RParen"; 
        TokenID.RParen = 57; 
        TokenID._map[58] = "LBrack"; 
        TokenID.LBrack = 58; 
        TokenID._map[59] = "RBrack"; 
        TokenID.RBrack = 59; 
        TokenID._map[60] = "LCurly"; 
        TokenID.LCurly = 60; 
        TokenID._map[61] = "RCurly"; 
        TokenID.RCurly = 61; 
        TokenID._map[62] = "Comma"; 
        TokenID.Comma = 62; 
        TokenID._map[63] = "Asg"; 
        TokenID.Asg = 63; 
        TokenID._map[64] = "AsgAdd"; 
        TokenID.AsgAdd = 64; 
        TokenID._map[65] = "AsgSub"; 
        TokenID.AsgSub = 65; 
        TokenID._map[66] = "AsgMul"; 
        TokenID.AsgMul = 66; 
        TokenID._map[67] = "AsgDiv"; 
        TokenID.AsgDiv = 67; 
        TokenID._map[68] = "AsgMod"; 
        TokenID.AsgMod = 68; 
        TokenID._map[69] = "AsgAnd"; 
        TokenID.AsgAnd = 69; 
        TokenID._map[70] = "AsgXor"; 
        TokenID.AsgXor = 70; 
        TokenID._map[71] = "AsgOr"; 
        TokenID.AsgOr = 71; 
        TokenID._map[72] = "AsgLsh"; 
        TokenID.AsgLsh = 72; 
        TokenID._map[73] = "AsgRsh"; 
        TokenID.AsgRsh = 73; 
        TokenID._map[74] = "AsgRs2"; 
        TokenID.AsgRs2 = 74; 
        TokenID._map[75] = "QMark"; 
        TokenID.QMark = 75; 
        TokenID._map[76] = "Colon"; 
        TokenID.Colon = 76; 
        TokenID._map[77] = "LogOr"; 
        TokenID.LogOr = 77; 
        TokenID._map[78] = "LogAnd"; 
        TokenID.LogAnd = 78; 
        TokenID._map[79] = "Or"; 
        TokenID.Or = 79; 
        TokenID._map[80] = "Xor"; 
        TokenID.Xor = 80; 
        TokenID._map[81] = "And"; 
        TokenID.And = 81; 
        TokenID._map[82] = "EQ"; 
        TokenID.EQ = 82; 
        TokenID._map[83] = "NE"; 
        TokenID.NE = 83; 
        TokenID._map[84] = "Eqv"; 
        TokenID.Eqv = 84; 
        TokenID._map[85] = "NEqv"; 
        TokenID.NEqv = 85; 
        TokenID._map[86] = "LT"; 
        TokenID.LT = 86; 
        TokenID._map[87] = "LE"; 
        TokenID.LE = 87; 
        TokenID._map[88] = "GT"; 
        TokenID.GT = 88; 
        TokenID._map[89] = "GE"; 
        TokenID.GE = 89; 
        TokenID._map[90] = "Lsh"; 
        TokenID.Lsh = 90; 
        TokenID._map[91] = "Rsh"; 
        TokenID.Rsh = 91; 
        TokenID._map[92] = "Rs2"; 
        TokenID.Rs2 = 92; 
        TokenID._map[93] = "Add"; 
        TokenID.Add = 93; 
        TokenID._map[94] = "Sub"; 
        TokenID.Sub = 94; 
        TokenID._map[95] = "Mult"; 
        TokenID.Mult = 95; 
        TokenID._map[96] = "Div"; 
        TokenID.Div = 96; 
        TokenID._map[97] = "Pct"; 
        TokenID.Pct = 97; 
        TokenID._map[98] = "Tilde"; 
        TokenID.Tilde = 98; 
        TokenID._map[99] = "Bang"; 
        TokenID.Bang = 99; 
        TokenID._map[100] = "Inc"; 
        TokenID.Inc = 100; 
        TokenID._map[101] = "Dec"; 
        TokenID.Dec = 101; 
        TokenID._map[102] = "Dot"; 
        TokenID.Dot = 102; 
        TokenID._map[103] = "Ellipsis"; 
        TokenID.Ellipsis = 103; 
        TokenID._map[104] = "Error"; 
        TokenID.Error = 104; 
        TokenID._map[105] = "EOF"; 
        TokenID.EOF = 105; 
        TokenID._map[106] = "Arrow"; 
        TokenID.Arrow = 106; 
        TokenID._map[107] = "ID"; 
        TokenID.ID = 107; 
        TokenID._map[108] = "QString"; 
        TokenID.QString = 108; 
        TokenID._map[109] = "Regex"; 
        TokenID.Regex = 109; 
        TokenID._map[110] = "NumberLit"; 
        TokenID.NumberLit = 110; 
        TokenID._map[111] = "Whitespace"; 
        TokenID.Whitespace = 111; 
        TokenID._map[112] = "Comment"; 
        TokenID.Comment = 112; 
        TokenID._map[113] = "Lim"; 
        TokenID.Lim = 113; 
        TokenID.LimFixed = TokenID.Arrow; 
        TokenID.LimKeyword = TokenID.YIELD; 
    })(Tools.TokenID||(Tools.TokenID={}));
    var TokenID = Tools.TokenID;

    Tools.tokenTable = new Array(); 
    Tools.nodeTypeTable = new Array(); 
    Tools.nodeTypeToTokTable = new Array(); 
    Tools.noRegexTable = new Array(); 
    Tools.noRegexTable[TokenID.ID] = true; 
    Tools.noRegexTable[TokenID.QString] = true; 
    Tools.noRegexTable[TokenID.NumberLit] = true; 
    Tools.noRegexTable[TokenID.Regex] = true; 
    Tools.noRegexTable[TokenID.THIS] = true; 
    Tools.noRegexTable[TokenID.Inc] = true; 
    Tools.noRegexTable[TokenID.Dec] = true; 
    Tools.noRegexTable[TokenID.RParen] = true; 
    Tools.noRegexTable[TokenID.RBrack] = true; 
    Tools.noRegexTable[TokenID.RCurly] = true; 
    Tools.noRegexTable[TokenID.TRUE] = true; 
    Tools.noRegexTable[TokenID.FALSE] = true; 
    (function(OperatorPrecedence) {
        OperatorPrecedence._map = []; 
        OperatorPrecedence._map[0] = "No"; 
        OperatorPrecedence.No = 0; 
        OperatorPrecedence._map[1] = "Cma"; 
        OperatorPrecedence.Cma = 1; 
        OperatorPrecedence._map[2] = "Asg"; 
        OperatorPrecedence.Asg = 2; 
        OperatorPrecedence._map[3] = "Que"; 
        OperatorPrecedence.Que = 3; 
        OperatorPrecedence._map[4] = "Lor"; 
        OperatorPrecedence.Lor = 4; 
        OperatorPrecedence._map[5] = "Lan"; 
        OperatorPrecedence.Lan = 5; 
        OperatorPrecedence._map[6] = "Bor"; 
        OperatorPrecedence.Bor = 6; 
        OperatorPrecedence._map[7] = "Xor"; 
        OperatorPrecedence.Xor = 7; 
        OperatorPrecedence._map[8] = "Ban"; 
        OperatorPrecedence.Ban = 8; 
        OperatorPrecedence._map[9] = "Equ"; 
        OperatorPrecedence.Equ = 9; 
        OperatorPrecedence._map[10] = "Cmp"; 
        OperatorPrecedence.Cmp = 10; 
        OperatorPrecedence._map[11] = "Shf"; 
        OperatorPrecedence.Shf = 11; 
        OperatorPrecedence._map[12] = "Add"; 
        OperatorPrecedence.Add = 12; 
        OperatorPrecedence._map[13] = "Mul"; 
        OperatorPrecedence.Mul = 13; 
        OperatorPrecedence._map[14] = "Uni"; 
        OperatorPrecedence.Uni = 14; 
        OperatorPrecedence._map[15] = "Lim"; 
        OperatorPrecedence.Lim = 15; 
    })(Tools.OperatorPrecedence||(Tools.OperatorPrecedence={}));
    var OperatorPrecedence = Tools.OperatorPrecedence;

    (function(Reservation) {
        Reservation._map = []; 
        Reservation.None = 0; 
        Reservation.Javascript = 1; 
        Reservation.JavascriptFuture = 2; 
        Reservation.Strada = 4; 
        Reservation.JavascriptFutureStrict = 8; 
        Reservation.StradaAndJS = Reservation.Javascript | Reservation.Strada; 
        Reservation.StradaAndJSFuture = Reservation.JavascriptFuture | Reservation.Strada; 
        Reservation.StradaAndJSFutureStrict = Reservation.JavascriptFutureStrict | Reservation.Strada; 
    })(Tools.Reservation||(Tools.Reservation={}));
    var Reservation = Tools.Reservation;

    var TokenInfo = (function () {
        function TokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers) {
            this.tokenId = tokenId;
            this.reservation = reservation;
            this.binopPrecedence = binopPrecedence;
            this.binopNodeType = binopNodeType;
            this.unopPrecedence = unopPrecedence;
            this.unopNodeType = unopNodeType;
            this.text = text;
            this.ers = ers;
        }
        return TokenInfo;
    })();
    Tools.TokenInfo = TokenInfo;
    
    function setTokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers) {
        if(tokenId !== undefined) {
            Tools.tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers); 
            if(binopNodeType != Tools.NodeType.None) {
                Tools.nodeTypeTable[binopNodeType] = text; 
                Tools.nodeTypeToTokTable[binopNodeType] = tokenId; 
            }
            if(unopNodeType != Tools.NodeType.None) {
                Tools.nodeTypeTable[unopNodeType] = text; 
            }
        }
    }
    setTokenInfo(TokenID.ANY, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "any", Tools.ErrorRecoverySet.PrimType); 
    setTokenInfo(TokenID.BOOL, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "bool", Tools.ErrorRecoverySet.PrimType); 
    setTokenInfo(TokenID.BREAK, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "break", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.CASE, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "case", Tools.ErrorRecoverySet.SCase); 
    setTokenInfo(TokenID.CATCH, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "catch", Tools.ErrorRecoverySet.Catch); 
    setTokenInfo(TokenID.CLASS, Reservation.StradaAndJSFuture, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "class", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.OLDCLASS, Reservation.StradaAndJSFuture, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "oldclass", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.CONST, Reservation.StradaAndJSFuture, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "const", Tools.ErrorRecoverySet.Var); 
    setTokenInfo(TokenID.CONTINUE, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "continue", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.DEFAULT, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "default", Tools.ErrorRecoverySet.SCase); 
    setTokenInfo(TokenID.DELETE, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.Uni, Tools.NodeType.Delete, "delete", Tools.ErrorRecoverySet.Prefix); 
    setTokenInfo(TokenID.DO, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "do", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.ELSE, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "else", Tools.ErrorRecoverySet.Else); 
    setTokenInfo(TokenID.ENUM, Reservation.StradaAndJSFuture, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "enum", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.EXPORT, Reservation.StradaAndJSFuture, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "export", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.EXTENDS, Reservation.StradaAndJSFuture, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "extends", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.DECLARE, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "declare", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.FALSE, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "false", Tools.ErrorRecoverySet.RLit); 
    setTokenInfo(TokenID.FINALLY, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "finally", Tools.ErrorRecoverySet.Catch); 
    setTokenInfo(TokenID.FOR, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "for", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.FUNCTION, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "function", Tools.ErrorRecoverySet.Func); 
    setTokenInfo(TokenID.CONSTRUCTOR, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "constructor", Tools.ErrorRecoverySet.Func); 
    setTokenInfo(TokenID.GET, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "get", Tools.ErrorRecoverySet.Func); 
    setTokenInfo(TokenID.SET, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "set", Tools.ErrorRecoverySet.Func); 
    setTokenInfo(TokenID.IF, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "if", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.IMPLEMENTS, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "implements", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.IMPORT, Reservation.StradaAndJSFuture, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "import", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.IN, Reservation.StradaAndJS, OperatorPrecedence.Cmp, Tools.NodeType.In, OperatorPrecedence.No, Tools.NodeType.None, "in", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.INSTANCEOF, Reservation.StradaAndJS, OperatorPrecedence.Cmp, Tools.NodeType.InstOf, OperatorPrecedence.No, Tools.NodeType.None, "instanceof", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.INTERFACE, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "interface", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.LET, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "let", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.MODULE, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "module", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.NEW, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "new", Tools.ErrorRecoverySet.PreOp); 
    setTokenInfo(TokenID.NUMBER, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "number", Tools.ErrorRecoverySet.PrimType); 
    setTokenInfo(TokenID.NULL, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "null", Tools.ErrorRecoverySet.RLit); 
    setTokenInfo(TokenID.PACKAGE, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "package", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.PRIVATE, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "private", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.PROPERTY, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "property", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.PROTECTED, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "protected", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.PUBLIC, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "public", Tools.ErrorRecoverySet.StradaS); 
    setTokenInfo(TokenID.RETURN, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "return", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.STATIC, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "static", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.STRING, Reservation.Strada, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "string", Tools.ErrorRecoverySet.PrimType); 
    setTokenInfo(TokenID.SUPER, Reservation.StradaAndJSFuture, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "super", Tools.ErrorRecoverySet.RLit); 
    setTokenInfo(TokenID.SWITCH, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "switch", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.THIS, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "this", Tools.ErrorRecoverySet.RLit); 
    setTokenInfo(TokenID.THROW, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "throw", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.TRUE, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "true", Tools.ErrorRecoverySet.RLit); 
    setTokenInfo(TokenID.TRY, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "try", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.TYPEOF, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.Uni, Tools.NodeType.Typeof, "typeof", Tools.ErrorRecoverySet.Prefix); 
    setTokenInfo(TokenID.VAR, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "var", Tools.ErrorRecoverySet.Var); 
    setTokenInfo(TokenID.VOID, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.Uni, Tools.NodeType.Void, "void", Tools.ErrorRecoverySet.Prefix); 
    setTokenInfo(TokenID.WITH, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.With, "with", Tools.ErrorRecoverySet.Stmt); 
    setTokenInfo(TokenID.WHILE, Reservation.StradaAndJS, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "while", Tools.ErrorRecoverySet.While); 
    setTokenInfo(TokenID.YIELD, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "yield", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.ID, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "identifier", Tools.ErrorRecoverySet.ID); 
    setTokenInfo(TokenID.NumberLit, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "numberLiteral", Tools.ErrorRecoverySet.Literal); 
    setTokenInfo(TokenID.Regex, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "regex", Tools.ErrorRecoverySet.RegExp); 
    setTokenInfo(TokenID.QString, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "qstring", Tools.ErrorRecoverySet.Literal); 
    setTokenInfo(TokenID.SColon, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, ";", Tools.ErrorRecoverySet.SColon); 
    setTokenInfo(TokenID.RParen, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, ")", Tools.ErrorRecoverySet.RParen); 
    setTokenInfo(TokenID.RBrack, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "]", Tools.ErrorRecoverySet.RBrack); 
    setTokenInfo(TokenID.LCurly, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "{", Tools.ErrorRecoverySet.LCurly); 
    setTokenInfo(TokenID.RCurly, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "}", Tools.ErrorRecoverySet.RCurly); 
    setTokenInfo(TokenID.Ellipsis, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "...", Tools.ErrorRecoverySet.None); 
    setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Cma, Tools.NodeType.Comma, OperatorPrecedence.No, Tools.NodeType.None, ",", Tools.ErrorRecoverySet.Comma); 
    setTokenInfo(TokenID.Asg, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.Asg, OperatorPrecedence.No, Tools.NodeType.None, "=", Tools.ErrorRecoverySet.Asg); 
    setTokenInfo(TokenID.AsgAdd, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgAdd, OperatorPrecedence.No, Tools.NodeType.None, "+=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgSub, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgSub, OperatorPrecedence.No, Tools.NodeType.None, "-=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgMul, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgMul, OperatorPrecedence.No, Tools.NodeType.None, "*=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgDiv, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgDiv, OperatorPrecedence.No, Tools.NodeType.None, "/=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgMod, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgMod, OperatorPrecedence.No, Tools.NodeType.None, "%=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgAnd, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgAnd, OperatorPrecedence.No, Tools.NodeType.None, "&=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgXor, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgXor, OperatorPrecedence.No, Tools.NodeType.None, "^=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgOr, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgOr, OperatorPrecedence.No, Tools.NodeType.None, "|=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgLsh, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgLsh, OperatorPrecedence.No, Tools.NodeType.None, "<<=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgRsh, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgRsh, OperatorPrecedence.No, Tools.NodeType.None, ">>=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.AsgRs2, Reservation.None, OperatorPrecedence.Asg, Tools.NodeType.AsgRs2, OperatorPrecedence.No, Tools.NodeType.None, ">>>=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.QMark, Reservation.None, OperatorPrecedence.Que, Tools.NodeType.QMark, OperatorPrecedence.No, Tools.NodeType.None, "?", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, ":", Tools.ErrorRecoverySet.Colon); 
    setTokenInfo(TokenID.LogOr, Reservation.None, OperatorPrecedence.Lor, Tools.NodeType.LogOr, OperatorPrecedence.No, Tools.NodeType.None, "||", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.LogAnd, Reservation.None, OperatorPrecedence.Lan, Tools.NodeType.LogAnd, OperatorPrecedence.No, Tools.NodeType.None, "&&", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Or, Reservation.None, OperatorPrecedence.Bor, Tools.NodeType.Or, OperatorPrecedence.No, Tools.NodeType.None, "|", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Xor, Reservation.None, OperatorPrecedence.Xor, Tools.NodeType.Xor, OperatorPrecedence.No, Tools.NodeType.None, "^", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.Ban, Tools.NodeType.And, OperatorPrecedence.No, Tools.NodeType.None, "&", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.EQ, Reservation.None, OperatorPrecedence.Equ, Tools.NodeType.Eq, OperatorPrecedence.No, Tools.NodeType.None, "==", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.NE, Reservation.None, OperatorPrecedence.Equ, Tools.NodeType.Ne, OperatorPrecedence.No, Tools.NodeType.None, "!=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Eqv, Reservation.None, OperatorPrecedence.Equ, Tools.NodeType.Eqv, OperatorPrecedence.No, Tools.NodeType.None, "===", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.NEqv, Reservation.None, OperatorPrecedence.Equ, Tools.NodeType.NEqv, OperatorPrecedence.No, Tools.NodeType.None, "!==", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.LT, Reservation.None, OperatorPrecedence.Cmp, Tools.NodeType.Lt, OperatorPrecedence.No, Tools.NodeType.None, "<", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.LE, Reservation.None, OperatorPrecedence.Cmp, Tools.NodeType.Le, OperatorPrecedence.No, Tools.NodeType.None, "<=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.GT, Reservation.None, OperatorPrecedence.Cmp, Tools.NodeType.Gt, OperatorPrecedence.No, Tools.NodeType.None, ">", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.GE, Reservation.None, OperatorPrecedence.Cmp, Tools.NodeType.Ge, OperatorPrecedence.No, Tools.NodeType.None, ">=", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Lsh, Reservation.None, OperatorPrecedence.Shf, Tools.NodeType.Lsh, OperatorPrecedence.No, Tools.NodeType.None, "<<", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Rsh, Reservation.None, OperatorPrecedence.Shf, Tools.NodeType.Rsh, OperatorPrecedence.No, Tools.NodeType.None, ">>", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Rs2, Reservation.None, OperatorPrecedence.Shf, Tools.NodeType.Rs2, OperatorPrecedence.No, Tools.NodeType.None, ">>>", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Add, Reservation.None, OperatorPrecedence.Add, Tools.NodeType.Add, OperatorPrecedence.Uni, Tools.NodeType.Pos, "+", Tools.ErrorRecoverySet.AddOp); 
    setTokenInfo(TokenID.Sub, Reservation.None, OperatorPrecedence.Add, Tools.NodeType.Sub, OperatorPrecedence.Uni, Tools.NodeType.Neg, "-", Tools.ErrorRecoverySet.AddOp); 
    setTokenInfo(TokenID.Mult, Reservation.None, OperatorPrecedence.Mul, Tools.NodeType.Mul, OperatorPrecedence.No, Tools.NodeType.None, "*", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Div, Reservation.None, OperatorPrecedence.Mul, Tools.NodeType.Div, OperatorPrecedence.No, Tools.NodeType.None, "/", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Pct, Reservation.None, OperatorPrecedence.Mul, Tools.NodeType.Mod, OperatorPrecedence.No, Tools.NodeType.None, "%", Tools.ErrorRecoverySet.BinOp); 
    setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.Uni, Tools.NodeType.Not, "~", Tools.ErrorRecoverySet.PreOp); 
    setTokenInfo(TokenID.Bang, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.Uni, Tools.NodeType.LogNot, "!", Tools.ErrorRecoverySet.PreOp); 
    setTokenInfo(TokenID.Inc, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.Uni, Tools.NodeType.IncPre, "++", Tools.ErrorRecoverySet.PreOp); 
    setTokenInfo(TokenID.Dec, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.Uni, Tools.NodeType.DecPre, "--", Tools.ErrorRecoverySet.PreOp); 
    setTokenInfo(TokenID.LParen, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "(", Tools.ErrorRecoverySet.LParen); 
    setTokenInfo(TokenID.LBrack, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "[", Tools.ErrorRecoverySet.LBrack); 
    setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Uni, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, ".", Tools.ErrorRecoverySet.Dot); 
    setTokenInfo(TokenID.EOF, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "<EOF>", Tools.ErrorRecoverySet.EOF); 
    setTokenInfo(TokenID.Arrow, Reservation.None, OperatorPrecedence.No, Tools.NodeType.None, OperatorPrecedence.No, Tools.NodeType.None, "=>", Tools.ErrorRecoverySet.None); 
    function lookupToken(tokenId) {
        return Tools.tokenTable[tokenId]; 
    }
    Tools.lookupToken = lookupToken;
    (function(TokenClass) {
        TokenClass._map = []; 
        TokenClass._map[0] = "Punctuation"; 
        TokenClass.Punctuation = 0; 
        TokenClass._map[1] = "Keyword"; 
        TokenClass.Keyword = 1; 
        TokenClass._map[2] = "Operator"; 
        TokenClass.Operator = 2; 
        TokenClass._map[3] = "Comment"; 
        TokenClass.Comment = 3; 
        TokenClass._map[4] = "Whitespace"; 
        TokenClass.Whitespace = 4; 
        TokenClass._map[5] = "Identifier"; 
        TokenClass.Identifier = 5; 
        TokenClass._map[6] = "Literal"; 
        TokenClass.Literal = 6; 
    })(Tools.TokenClass||(Tools.TokenClass={}));
    var TokenClass = Tools.TokenClass;

    var SavedToken = (function () {
        function SavedToken(tok, minChar, limChar) {
            this.tok = tok;
            this.minChar = minChar;
            this.limChar = limChar;
        }
        return SavedToken;
    })();
    Tools.SavedToken = SavedToken;
    
    var Token = (function () {
        function Token(tokenId) {
            this.tokenId = tokenId;
        }
        Token.prototype.toString = function() {
            return ((((("token: " + this.tokenId) + " ") + this.getText()) + " (") + (TokenID)._map[this.tokenId]) + ")"; 
        };
        Token.prototype.print = function(line, outfile) {
            outfile.WriteLine((this.toString() + ",on line") + line); 
        };
        Token.prototype.getText = function() {
            return Tools.tokenTable[this.tokenId].text; 
        };
        Token.prototype.classification = function() {
            if(this.tokenId <= TokenID.LimKeyword) {
                return TokenClass.Keyword; 
            } else  {
                var tokenInfo = lookupToken(this.tokenId); 
                if(tokenInfo != undefined) {
                    if((tokenInfo.unopNodeType != Tools.NodeType.None) || (tokenInfo.binopNodeType != Tools.NodeType.None)) {
                        return TokenClass.Operator; 
                    }
                }
            }
            return TokenClass.Punctuation; 
        };
        return Token;
    })();
    Tools.Token = Token;
    
    var NumberToken = (function () {
        _inheritsFrom(NumberToken, Token);
        function NumberToken(value) {
            this.value = value;
            NumberToken._super.constructor.call(this, TokenID.NumberLit);
        }
        NumberToken.prototype.getText = function() {
            return this.value.toString(); 
        };
        NumberToken.prototype.classification = function() {
            return TokenClass.Literal; 
        };
        return NumberToken;
    })();
    Tools.NumberToken = NumberToken;
    
    var StringToken = (function () {
        _inheritsFrom(StringToken, Token);
        function StringToken(tokenId, value) {
            this.tokenId = tokenId;
            this.value = value;
            StringToken._super.constructor.call(this, this.tokenId);
        }
        StringToken.prototype.getText = function() {
            return this.value; 
        };
        StringToken.prototype.classification = function() {
            if(this.tokenId == TokenID.ID) {
                return TokenClass.Identifier; 
            } else  {
                return TokenClass.Literal; 
            }
        };
        return StringToken;
    })();
    Tools.StringToken = StringToken;
    
    var WhitespaceToken = (function () {
        _inheritsFrom(WhitespaceToken, Token);
        function WhitespaceToken(tokenId, value) {
            this.tokenId = tokenId;
            this.value = value;
            WhitespaceToken._super.constructor.call(this, this.tokenId);
        }
        WhitespaceToken.prototype.getText = function() {
            return this.value; 
        };
        WhitespaceToken.prototype.classification = function() {
            return TokenClass.Whitespace; 
        };
        return WhitespaceToken;
    })();
    Tools.WhitespaceToken = WhitespaceToken;
    
    var CommentToken = (function () {
        _inheritsFrom(CommentToken, Token);
        function CommentToken(tokenID, value, isBlock, startPos, line, endsLine) {
            this.tokenID = tokenID;
            this.value = value;
            this.isBlock = isBlock;
            this.startPos = startPos;
            this.line = line;
            this.endsLine = endsLine;
            CommentToken._super.constructor.call(this, this.tokenID);
        }
        CommentToken.prototype.getText = function() {
            return this.value; 
        };
        CommentToken.prototype.classification = function() {
            return TokenClass.Comment; 
        };
        return CommentToken;
    })();
    Tools.CommentToken = CommentToken;
    
    var RegexToken = (function () {
        _inheritsFrom(RegexToken, Token);
        function RegexToken(regex) {
            this.regex = regex;
            RegexToken._super.constructor.call(this, TokenID.Regex);
        }
        RegexToken.prototype.getText = function() {
            return this.regex.toString(); 
        };
        RegexToken.prototype.classification = function() {
            return TokenClass.Literal; 
        };
        return RegexToken;
    })();
    Tools.RegexToken = RegexToken;
    
    Tools.staticTokens = new Array(); 
    function initializeStaticTokens() {
        for(var i = 0; i <= TokenID.LimFixed; i++) {
            Tools.staticTokens[i] = new Token(i); 
        }
    }
    Tools.initializeStaticTokens = initializeStaticTokens;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var ArrayCache = (function () {
        function ArrayCache() {
            this.arrayType = null; 
            this.arrayBase = null; 
        }
        ArrayCache.prototype.specialize = function(arrInstType, checker) {
            if(this.arrayBase == null) {
                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType, checker, true); 
            }
            return this.arrayBase; 
        };
        return ArrayCache;
    })();
    Tools.ArrayCache = ArrayCache;
    
    (function(TraceFlags) {
        TraceFlags._map = []; 
        TraceFlags.None = 0; 
        TraceFlags.Symbols = 1; 
    })(Tools.TraceFlags||(Tools.TraceFlags={}));
    var TraceFlags = Tools.TraceFlags;

    var TypePair = (function () {
        function TypePair(a, b) {
            this.a = a;
            this.b = b;
        }
        return TypePair;
    })();
    Tools.TypePair = TypePair;
    
    function hashTypePair(tp) {
        var typePair = tp; 
        var result = typePair.a.primitives ^ (typePair.b.primitives << 4); 
        if(typePair.a.members != null) {
            result = result ^ ((typePair.a.members.allMembers.count()) << 7); 
        } else  {
            if(typePair.a.construct != null) {
                result = (result + 3) << 2; 
            } else  {
                if(typePair.a.call != null) {
                    result = (result + 7) << 5; 
                } else  {
                    if(typePair.a.extendsList != null) {
                        result = (result + 11) << 9; 
                    }
                }
            }
        }
        if(typePair.b.members != null) {
            result = result ^ ((typePair.b.members.allMembers.count()) << 7); 
        } else  {
            if(typePair.b.construct != null) {
                result = (result + 3) << 2; 
            } else  {
                if(typePair.b.call != null) {
                    result = (result + 7) << 5; 
                } else  {
                    if(typePair.b.extendsList != null) {
                        result = (result + 11) << 9; 
                    }
                }
            }
        }
        return result; 
    }
    Tools.hashTypePair = hashTypePair;
    function equalsTypePair(a, b) {
        var pairA = a; 
        var pairB = b; 
        return (pairA.a == pairB.a) && (pairA.b == pairB.b); 
    }
    Tools.equalsTypePair = equalsTypePair;
    (function(TypeCheckCollectionMode) {
        TypeCheckCollectionMode._map = []; 
        TypeCheckCollectionMode._map[0] = "Resident"; 
        TypeCheckCollectionMode.Resident = 0; 
        TypeCheckCollectionMode._map[1] = "Transient"; 
        TypeCheckCollectionMode.Transient = 1; 
    })(Tools.TypeCheckCollectionMode||(Tools.TypeCheckCollectionMode={}));
    var TypeCheckCollectionMode = Tools.TypeCheckCollectionMode;

    var PersistentGlobalTypeState = (function () {
        function PersistentGlobalTypeState(errorReporter) {
            this.errorReporter = errorReporter;
            this.importedGlobalsTable = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            this.importedGlobalsTypeTable = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            this.importedGlobals = new Tools.SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null); 
            this.globals = null; 
            this.globalTypes = null; 
            this.ambientGlobals = null; 
            this.ambientGlobalTypes = null; 
            this.residentGlobalValues = new Tools.StringHashTable(); 
            this.residentGlobalTypes = new Tools.StringHashTable(); 
            this.residentGlobalAmbientValues = new Tools.StringHashTable(); 
            this.residentGlobalAmbientTypes = new Tools.StringHashTable(); 
            this.dualGlobalValues = new Tools.DualStringHashTable(this.residentGlobalValues, new Tools.StringHashTable()); 
            this.dualGlobalTypes = new Tools.DualStringHashTable(this.residentGlobalTypes, new Tools.StringHashTable()); 
            this.dualAmbientGlobalValues = new Tools.DualStringHashTable(this.residentGlobalAmbientValues, new Tools.StringHashTable()); 
            this.dualAmbientGlobalTypes = new Tools.DualStringHashTable(this.residentGlobalAmbientTypes, new Tools.StringHashTable()); 
            var dualGlobalScopedMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(this.dualGlobalValues, new Tools.StringHashTable())); 
            var dualGlobalScopedAmbientMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(this.dualAmbientGlobalValues, new Tools.StringHashTable())); 
            var dualGlobalScopedEnclosedTypes = new Tools.ScopedMembers(new Tools.DualStringHashTable(this.dualGlobalTypes, new Tools.StringHashTable())); 
            var dualGlobalScopedAmbientEnclosedTypes = new Tools.ScopedMembers(new Tools.DualStringHashTable(this.dualAmbientGlobalTypes, new Tools.StringHashTable())); 
            this.globalScope = new Tools.SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null); 
            this.voidType = this.enterPrimitive(Tools.Primitive.Void, "void"); 
            this.booleanType = this.enterPrimitive(Tools.Primitive.Boolean, "bool"); 
            this.doubleType = this.enterPrimitive(Tools.Primitive.Double, "number"); 
            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol); 
            this.stringType = this.enterPrimitive(Tools.Primitive.String, "string"); 
            this.anyType = this.enterPrimitive(Tools.Primitive.Any, "any"); 
            this.nullType = this.enterPrimitive(Tools.Primitive.Null, "null"); 
            this.undefinedType = this.enterPrimitive(Tools.Primitive.Undefined, "undefined"); 
            this.residentTypeCheck = true; 
            this.mod = null; 
            this.gloMod = null; 
            this.wildElm = null; 
            this.setCollectionMode(TypeCheckCollectionMode.Resident); 
            this.wildElm = new Tools.TypeSymbol("_element", 0, -1, new Tools.Type()); 
            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm); 
            this.mod = new Tools.ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes); 
            this.mod.members = dualGlobalScopedMembers; 
            this.mod.ambientMembers = dualGlobalScopedAmbientMembers; 
            this.mod.containedScope = this.globalScope; 
            this.gloMod = new Tools.TypeSymbol(Tools.globalId, 0, -1, this.mod); 
            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod); 
            this.defineGlobalValue("undefined", this.undefinedType); 
        }
        PersistentGlobalTypeState.prototype.enterPrimitive = function(flags, name) {
            var primitive = new Tools.Type(); 
            primitive.primitives = flags; 
            var symbol = new Tools.TypeSymbol(name, 0, -1, primitive); 
            symbol.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
            primitive.symbol = symbol; 
            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true); 
            return primitive; 
        };
        PersistentGlobalTypeState.prototype.setCollectionMode = function(mode) {
            this.residentTypeCheck = this.dualGlobalValues.insertPrimary = this.dualGlobalTypes.insertPrimary = this.dualAmbientGlobalValues.insertPrimary = this.dualAmbientGlobalTypes.insertPrimary = mode == TypeCheckCollectionMode.Resident; 
        };
        PersistentGlobalTypeState.prototype.refreshPersistentState = function() {
            this.globals = new Tools.StringHashTable(); 
            this.globalTypes = new Tools.StringHashTable(); 
            this.ambientGlobals = new Tools.StringHashTable(); 
            this.ambientGlobalTypes = new Tools.StringHashTable(); 
            this.dualGlobalValues.secondaryTable = this.globals; 
            this.dualGlobalTypes.secondaryTable = this.globalTypes; 
            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals; 
            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes; 
        };
        PersistentGlobalTypeState.prototype.defineGlobalValue = function(name, type) {
            var valueLocation = new Tools.ValueLocation(); 
            valueLocation.typeLink = new Tools.TypeLink(); 
            var sym = new Tools.VariableSymbol(name, 0, -1, valueLocation); 
            sym.setType(type); 
            sym.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
            sym.container = this.gloMod; 
            this.importedGlobalsTable.addPublicMember(name, sym); 
        };
        return PersistentGlobalTypeState;
    })();
    Tools.PersistentGlobalTypeState = PersistentGlobalTypeState;
    
    var ContextualTypeContext = (function () {
        function ContextualTypeContext(targetType) {
            this.targetType = targetType;
            this.targetSig = null; 
            this.targetThis = null; 
            this.targetAccessorType = null; 
        }
        return ContextualTypeContext;
    })();
    Tools.ContextualTypeContext = ContextualTypeContext;
    
    var ContextualTypingContext = (function () {
        function ContextualTypingContext() {
            this.contextStack = []; 
        }
        ContextualTypingContext.prototype.pushTargetType = function(type) {
            this.contextStack.push(new ContextualTypeContext(type)); 
        };
        ContextualTypingContext.prototype.popTargetType = function() {
            return this.contextStack.pop(); 
        };
        ContextualTypingContext.prototype.targetType = function() {
            return (this.contextStack == [] ? null : this.contextStack[this.contextStack.length - 1]); 
        };
        return ContextualTypingContext;
    })();
    Tools.ContextualTypingContext = ContextualTypingContext;
    
    var TypeChecker = (function () {
        function TypeChecker(persistentState) {
            this.persistentState = persistentState;
            this.errorReporter = null; 
            this.checkControlFlow = false; 
            this.printControlFlowGraph = false; 
            this.checkControlFlowUseDef = false; 
            this.styleSettings = null; 
            this.units = null; 
            this.voidType = this.persistentState.voidType; 
            this.booleanType = this.persistentState.booleanType; 
            this.doubleType = this.persistentState.doubleType; 
            this.stringType = this.persistentState.stringType; 
            this.anyType = this.persistentState.anyType; 
            this.nullType = this.persistentState.nullType; 
            this.undefinedType = this.persistentState.undefinedType; 
            this.anon = "_anonymous"; 
            this.globals = this.persistentState.dualGlobalValues; 
            this.globalTypes = this.persistentState.dualGlobalTypes; 
            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues; 
            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes; 
            this.mod = this.persistentState.mod; 
            this.gloMod = this.persistentState.gloMod; 
            this.wildElm = this.persistentState.wildElm; 
            this.symTrack = false; 
            this.traceFlags = TraceFlags.None; 
            this.locationInfo = null; 
            this.typeFlow = null; 
            this.typeMatches = new Tools.HashTable(Tools.HashMediumSize, hashTypePair, equalsTypePair); 
            this.currentCompareA = null; 
            this.currentCompareB = null; 
            this.currentModDecl = null; 
            this.globalScope = this.persistentState.globalScope; 
            this.inBind = false; 
            this.inWith = false; 
            this.errorsOnWith = true; 
            this.addMembersToClassScope = true; 
            this.typingContext = new ContextualTypingContext(); 
            this.targetTypeContext = null; 
            this.resolvingBases = false; 
        }
        TypeChecker.prototype.setTargetType = function(type) {
            this.typingContext.pushTargetType(type); 
            this.targetTypeContext = this.typingContext.targetType(); 
        };
        TypeChecker.prototype.unsetTargetType = function() {
            this.typingContext.popTargetType(); 
            this.targetTypeContext = this.typingContext.targetType(); 
        };
        TypeChecker.prototype.typeCheckWithTargetType = function(contextType, condition, ast) {
            if(condition) {
                this.setTargetType(contextType); 
            }
            this.typeFlow.typeCheck(ast); 
            if(condition) {
                this.unsetTargetType(); 
            }
        };
        TypeChecker.prototype.setStyleOptions = function(style) {
            this.styleSettings = style; 
        };
        TypeChecker.prototype.resetTargetType = function() {
            this.targetTypeContext = this.typingContext.targetType(); 
        };
        TypeChecker.prototype.killTargetType = function() {
            return this.targetTypeContext = null; 
        };
        TypeChecker.prototype.hasTargetType = function() {
            return this.targetTypeContext != null && this.targetTypeContext.targetType != null; 
        };
        TypeChecker.prototype.getTargetTypeContext = function() {
            return this.targetTypeContext; 
        };
        TypeChecker.prototype.collectTypes = function(ast) {
            if(ast.nodeType == Tools.NodeType.Script) {
                var script = ast; 
                this.locationInfo = script.locationInfo; 
            }
            var globalChain = new Tools.ScopeChain(this.gloMod, null, this.globalScope); 
            var context = new Tools.TypeCollectionContext(globalChain, this); 
            ast.walk(Tools.preCollectTypes, Tools.postCollectTypes, null, context); 
        };
        TypeChecker.prototype.makeArrayType = function(type) {
            if(type.arrayCache == null) {
                type.arrayCache = new ArrayCache(); 
                type.arrayCache.arrayType = new Tools.Type(); 
                type.arrayCache.arrayType.elementType = type; 
                type.arrayCache.arrayType.symbol = type.symbol; 
            }
            return type.arrayCache.arrayType; 
        };
        TypeChecker.prototype.tryStartTypeMatch = function(a, b) {
            a.checkDecl(this); 
            b.checkDecl(this); 
            var pair = new TypePair(a, b); 
            return this.typeMatches.add(pair, pair); 
        };
        TypeChecker.prototype.endTypeMatch = function(a, b) {
            var pair = new TypePair(a, b); 
            this.typeMatches.remove(pair); 
        };
        TypeChecker.prototype.getParameterList = function(args, container) {
            var parameterTable = null; 
            var parameterBuilder = null; 
            var len = args.members.length; 
            var nonOptionalParams = 0; 
            var result = []; 
            if(len > 0) {
                parameterTable = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                parameterBuilder = new Tools.SymbolScopeBuilder(parameterTable, null, null, null, null, container); 
                for(var i = 0; i < len; i++) {
                    var parameter = args.members[i]; 
                    var paramDef = new Tools.ValueLocation(); 
                    var parameterSymbol = new Tools.ParameterSymbol(parameter.id.text, parameter.minChar, this.locationInfo.unitIndex, paramDef); 
                    parameterSymbol.declAST = parameter; 
                    parameter.id.sym = parameterSymbol; 
                    parameter.sym = parameterSymbol; 
                    paramDef.symbol = parameterSymbol; 
                    paramDef.typeLink = Tools.getTypeLink(parameter.typeExpr, this, false); 
                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false); 
                    result[result.length] = parameterSymbol; 
                    if(!parameter.isOptionalArg()) {
                        nonOptionalParams++; 
                    }
                }
            }
            return {
                parameters: result,
                nonOptionalParameterCount: nonOptionalParams
            }; 
        };
        TypeChecker.prototype.createNewConstructGroupForType = function(type) {
            var signature = new Tools.Signature(); 
            signature.returnType = new Tools.TypeLink(); 
            signature.returnType.type = type.instanceType; 
            signature.parameters = []; 
            type.construct = new Tools.SignatureGroup(); 
            type.construct.addSignature(signature); 
        };
        TypeChecker.prototype.cloneParentConstructGroupForChildType = function(child, parent) {
            child.construct = new Tools.SignatureGroup(); 
            var sig = null; 
            if(!parent.construct) {
                this.createNewConstructGroupForType(parent); 
            }
            for(var i = 0; i < parent.construct.signatures.length; i++) {
                sig = new Tools.Signature(); 
                sig.parameters = parent.construct.signatures[i].parameters; 
                sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount; 
                sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus; 
                sig.declAST = parent.construct.signatures[i].declAST; 
                sig.returnType = new Tools.TypeLink(); 
                sig.returnType.type = child.instanceType; 
                child.construct.addSignature(sig); 
            }
        };
        TypeChecker.prototype.createFunctionSignature = function(funcDecl, container, scope, overloadGroupSym, addToScope) {
            var isExported = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Exported) || container == this.gloMod; 
            var isStatic = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Static); 
            var isPrivate = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Private); 
            var isDefinition = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Definition); 
            var isAmbient = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Ambient); 
            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor; 
            var isGlobal = container == this.gloMod; 
            var signature = new Tools.Signature(); 
            if(funcDecl.returnTypeAnnotation != null || isDefinition) {
                signature.returnType = Tools.getTypeLink(funcDecl.returnTypeAnnotation, this, false); 
            } else  {
                signature.returnType = new Tools.TypeLink(); 
                signature.returnType.type = this.anyType; 
            }
            signature.hasVariableArgList = funcDecl.variableArgList; 
            var sigData = this.getParameterList(funcDecl.args, container); 
            signature.parameters = sigData.parameters; 
            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount; 
            funcDecl.signature = signature; 
            signature.declAST = funcDecl; 
            var useOverloadGroupSym = overloadGroupSym != null && overloadGroupSym.getType() != null && !overloadGroupSym.isAccessor() && (funcDecl.isSignature() || (isAmbient == Tools.hasFlag(overloadGroupSym.flags, Tools.SymbolFlags.Ambient))); 
            if(useOverloadGroupSym && isPrivate != Tools.hasFlag(overloadGroupSym.flags, Tools.SymbolFlags.Private)) {
                this.errorReporter.simpleError(funcDecl, "Public/Private visibility of overloads does not agree"); 
            }
            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new Tools.Type(); 
            if(isConstructor) {
                if(groupType.construct == null) {
                    groupType.construct = new Tools.SignatureGroup(); 
                }
                groupType.construct.addSignature(signature); 
                groupType.construct.hasImplementation = !(funcDecl.isSignature()); 
                if(groupType.construct.hasImplementation) {
                    groupType.setHasImplementation(); 
                }
            } else  {
                if(funcDecl.isIndexerMember()) {
                    if(groupType.index == null) {
                        groupType.index = new Tools.SignatureGroup(); 
                        groupType.index.isIndexer = true; 
                    }
                    groupType.index.addSignature(signature); 
                    groupType.index.hasImplementation = !(funcDecl.isSignature()); 
                    if(groupType.index.hasImplementation) {
                        groupType.setHasImplementation(); 
                    }
                } else  {
                    if(groupType.call == null) {
                        groupType.call = new Tools.SignatureGroup(); 
                    }
                    groupType.call.addSignature(signature); 
                    groupType.call.hasImplementation = !(funcDecl.isSignature()); 
                    if(groupType.call.hasImplementation) {
                        groupType.setHasImplementation(); 
                    }
                }
            }
            var instanceType = groupType.instanceType; 
            if(instanceType != null) {
                if(instanceType.call == null) {
                    instanceType.call = groupType.call; 
                } else  {
                    if(groupType.call != null) {
                        instanceType.call.signatures.concat(groupType.call.signatures); 
                    }
                }
            }
            var funcName = null; 
            var usedHint = false; 
            if(funcDecl.name != null && !funcDecl.name.isMissing()) {
                funcName = funcDecl.name.text; 
            } else  {
                if(funcDecl.hint != null) {
                    funcName = funcDecl.hint; 
                    usedHint = true; 
                }
            }
            if(groupType.symbol == null) {
                groupType.symbol = new Tools.TypeSymbol((funcName != null) ? funcName : this.anon, funcDecl.minChar, this.locationInfo.unitIndex, groupType); 
                if(!useOverloadGroupSym) {
                    groupType.symbol.declAST = funcDecl; 
                }
            }
            if(isStatic) {
                groupType.symbol.flags |= Tools.SymbolFlags.Static; 
            }
            if(isAmbient) {
                groupType.symbol.flags |= Tools.SymbolFlags.Ambient; 
            }
            if(isPrivate) {
                groupType.symbol.flags |= Tools.SymbolFlags.Private; 
            }
            groupType.symbol.isMethod = funcDecl.isMethod(); 
            if(groupType.symbol.isMethod) {
                groupType.symbol.flags |= Tools.SymbolFlags.Property; 
            }
            funcDecl.type = groupType; 
            if(!isConstructor) {
                if(funcName != null && !funcDecl.isAccessor() && !usedHint) {
                    if(addToScope) {
                        if(funcDecl.isMethod() && isStatic) {
                            if(!(container).type.members.publicMembers.add(funcName, groupType.symbol)) {
                                this.errorReporter.duplicateIdentifier(funcDecl, funcName); 
                            }
                            groupType.symbol.container = container; 
                        } else  {
                            if(overloadGroupSym == null || (overloadGroupSym.declAST != null && !(overloadGroupSym.declAST).isOverload && (container.isType()))) {
                                scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient); 
                            }
                        }
                    } else  {
                        if(!funcDecl.isSpecialFn()) {
                            groupType.symbol.container = container; 
                        }
                    }
                } else  {
                    if(!funcDecl.isSpecialFn()) {
                        groupType.symbol.container = container; 
                    }
                }
            }
            if(useOverloadGroupSym) {
                var overloadGroupType = overloadGroupSym != null ? overloadGroupSym.getType() : null; 
                var classType = groupType; 
                if(classType != overloadGroupType) {
                    if(classType.construct == null) {
                        if(overloadGroupType != null && overloadGroupType.construct != null) {
                            classType.construct = overloadGroupType.construct; 
                        } else  {
                            classType.construct = new Tools.SignatureGroup(); 
                        }
                    } else  {
                        if(overloadGroupType != null) {
                            if(overloadGroupType.construct != null) {
                                classType.construct.signatures.concat(overloadGroupType.construct.signatures); 
                            }
                        }
                    }
                    if(overloadGroupType != null) {
                        if(classType.call == null) {
                            classType.call = overloadGroupType.call; 
                        } else  {
                            if(overloadGroupType.call != null) {
                                classType.call.signatures.concat(overloadGroupType.call.signatures); 
                            }
                        }
                        if(!isStatic) {
                            if(classType.instanceType == null) {
                                classType.instanceType = overloadGroupType.instanceType; 
                            }
                            var instanceType = classType.instanceType; 
                            if(instanceType != null) {
                                if(instanceType.call == null) {
                                    instanceType.call = overloadGroupType.call; 
                                } else  {
                                    if(overloadGroupType.call != null) {
                                        instanceType.call.signatures.concat(overloadGroupType.call.signatures); 
                                    }
                                }
                            }
                        }
                        if(classType.index == null) {
                            classType.index = overloadGroupType.index; 
                        } else  {
                            if(overloadGroupType.index != null) {
                                classType.index.signatures.concat(overloadGroupType.index.signatures); 
                            }
                        }
                    }
                }
            }
            return signature; 
        };
        TypeChecker.prototype.createAccessorSymbol = function(funcDecl, fgSym, enclosingClass, addToMembers, isClassProperty, scope, container) {
            var accessorSym = null; 
            var sig = funcDecl.signature; 
            var nameText = funcDecl.name.text; 
            var isStatic = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Static); 
            var isPrivate = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Private); 
            if(fgSym == null) {
                var field = new Tools.ValueLocation(); 
                accessorSym = new Tools.FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field); 
                field.symbol = accessorSym; 
                accessorSym.declAST = funcDecl; 
                if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.GetAccessor)) {
                    if(accessorSym.getter != null) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter"); 
                    }
                    accessorSym.getter = sig.declAST.type.symbol; 
                } else  {
                    if(accessorSym.setter != null) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter"); 
                    }
                    accessorSym.setter = sig.declAST.type.symbol; 
                }
                field.typeLink = Tools.getTypeLink(null, this, false); 
                if(addToMembers) {
                    if(enclosingClass) {
                        if(!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {
                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name); 
                        }
                        accessorSym.container = enclosingClass.symbol; 
                    } else  {
                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context"); 
                    }
                } else  {
                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false); 
                }
                accessorSym.flags |= Tools.SymbolFlags.Exported; 
                if(isClassProperty) {
                    accessorSym.flags |= Tools.SymbolFlags.Property; 
                }
                if(isPrivate) {
                    accessorSym.flags |= Tools.SymbolFlags.Private; 
                } else  {
                    accessorSym.flags |= Tools.SymbolFlags.Public; 
                }
            } else  {
                accessorSym = (fgSym); 
                if(isPrivate != Tools.hasFlag(accessorSym.flags, Tools.SymbolFlags.Private)) {
                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility"); 
                }
                if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.GetAccessor)) {
                    if(accessorSym.getter != null) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter"); 
                    }
                    accessorSym.getter = funcDecl.type.symbol; 
                } else  {
                    if(accessorSym.setter != null) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter"); 
                    }
                    accessorSym.setter = funcDecl.type.symbol; 
                }
            }
            return accessorSym; 
        };
        TypeChecker.prototype.addBases = function(resultScope, type) {
            resultScope.addParentScope(new Tools.SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol)); 
            var i = 0; 
            var base; 
            if(type.extendsList != null) {
                for(var len = type.extendsList.length; i < len; i++) {
                    base = type.extendsList[i]; 
                    this.addBases(resultScope, base); 
                }
            }
        };
        TypeChecker.prototype.scopeOf = function(type) {
            var resultScope = new Tools.SymbolAggregateScope(type.symbol); 
            this.addBases(resultScope, type); 
            return resultScope; 
        };
        TypeChecker.prototype.lookupMemberType = function(containingType, name) {
            var symbol = null; 
            if(containingType.containedScope != null) {
                symbol = containingType.containedScope.find(name, false, true); 
            } else  {
                if(containingType.members != null) {
                    symbol = containingType.members.allMembers.lookup(name); 
                    if(symbol == null && containingType.ambientMembers != null) {
                        symbol = containingType.ambientMembers.allMembers.lookup(name); 
                    }
                }
            }
            if(symbol == null) {
                var typeMembers = containingType.getAllEnclosedTypes(); 
                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes(); 
                if(typeMembers != null) {
                    symbol = typeMembers.allMembers.lookup(name); 
                    if(symbol == null && ambientTypeMembers != null) {
                        symbol = ambientTypeMembers.allMembers.lookup(name); 
                    }
                }
            }
            if((symbol != null) && (symbol.isType())) {
                return symbol.getType(); 
            } else  {
                return null; 
            }
        };
        TypeChecker.prototype.resolveTypeMember = function(scope, dotNode) {
            var lhs = dotNode.operand1; 
            var rhs = dotNode.operand2; 
            var resultType = this.anyType; 
            var lhsType = this.anyType; 
            if((lhs != null) && (rhs != null) && (rhs.nodeType == Tools.NodeType.Name)) {
                if(lhs.nodeType == Tools.NodeType.Dot) {
                    lhsType = this.resolveTypeMember(scope, lhs); 
                } else  {
                    if(lhs.nodeType == Tools.NodeType.Name) {
                        var identifier = lhs; 
                        var symbol = scope.find(identifier.text, false, true); 
                        if(symbol == null) {
                            this.errorReporter.unresolvedSymbol(identifier, identifier.text); 
                        } else  {
                            if(symbol.isType()) {
                                if(Tools.optimizeModuleCodeGen && symbol != null) {
                                    var symType = symbol.getType(); 
                                    if(symType != null && (symbol).isAlias && (symbol).onlyReferencedAsTypeRef) {
                                        var modDecl = symType.symbol.declAST; 
                                        if(modDecl != null && Tools.hasFlag(modDecl.modFlags, Tools.ModuleFlags.IsDynamic)) {
                                            (symbol).onlyReferencedAsTypeRef = !this.resolvingBases; 
                                        }
                                    }
                                }
                                if(!symbol.visible(scope, this)) {
                                    this.errorReporter.simpleError(lhs, ("symbol '" + identifier.text) + "' not visible at this point"); 
                                }
                                lhsType = symbol.getType(); 
                                identifier.sym = symbol; 
                            } else  {
                                this.errorReporter.simpleError(lhs, "expected type"); 
                            }
                        }
                    }
                }
                if(!lhsType) {
                    lhsType = this.anyType; 
                }
                if(lhsType != this.anyType) {
                    var rhsIdentifier = rhs; 
                    resultType = this.lookupMemberType(lhsType, rhsIdentifier.text); 
                    if(resultType == null) {
                        resultType = this.anyType; 
                        this.errorReporter.simpleError(dotNode, "expected type"); 
                    } else  {
                        if(!resultType.symbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, ("symbol '" + (rhs).text) + "' not visible at this point"); 
                        }
                    }
                    rhsIdentifier.sym = resultType.symbol; 
                }
            }
            if(resultType.isClass()) {
                resultType = resultType.instanceType; 
            }
            return resultType; 
        };
        TypeChecker.prototype.resolveFuncDecl = function(funcDecl, scope, fgSym) {
            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol; 
            var signatures; 
            if(funcDecl.isConstructMember()) {
                signatures = functionGroupSymbol.type.construct.signatures; 
            } else  {
                if(funcDecl.isIndexerMember()) {
                    signatures = functionGroupSymbol.type.getInstanceType().index.signatures; 
                } else  {
                    signatures = functionGroupSymbol.type.call.signatures; 
                }
            }
            var signature = signatures[signatures.length - 1]; 
            var len = signature.parameters.length; 
            for(var i = 0; i < len; i++) {
                var paramSym = signature.parameters[i]; 
                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true); 
            }
            this.resolveTypeLink(scope, signature.returnType, funcDecl.isSignature()); 
            return functionGroupSymbol; 
        };
        TypeChecker.prototype.resolveVarDecl = function(varDecl, scope) {
            var field = new Tools.ValueLocation(); 
            var fieldSymbol = new Tools.FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex, (varDecl.varFlags & Tools.VarFlags.Readonly) == Tools.VarFlags.None, field); 
            fieldSymbol.transferVarFlags(varDecl.varFlags); 
            field.symbol = fieldSymbol; 
            fieldSymbol.declAST = varDecl; 
            field.typeLink = Tools.getTypeLink(varDecl.typeExpr, this, varDecl.init == null); 
            this.resolveTypeLink(scope, field.typeLink, true); 
            varDecl.sym = fieldSymbol; 
            varDecl.type = field.typeLink.type; 
            return fieldSymbol; 
        };
        TypeChecker.prototype.resolveTypeLink = function(scope, typeLink, supplyVar) {
            var arrayCount = 0; 
            if(typeLink.type == null) {
                var ast = typeLink.ast; 
                if(ast != null) {
                    while(typeLink.type == null) {
                        switch(ast.nodeType) {
                            case Tools.NodeType.Name: {
                                var identifier = ast; 
                                var symbol = scope.find(identifier.text, false, true); 
                                if(symbol == null) {
                                    typeLink.type = this.anyType; 
                                    this.errorReporter.unresolvedSymbol(identifier, identifier.text); 
                                } else  {
                                    if(symbol.isType()) {
                                        if(!symbol.visible(scope, this)) {
                                            this.errorReporter.simpleError(ast, ("symbol '" + identifier.text) + "' not visible at this point"); 
                                        }
                                        identifier.sym = symbol; 
                                        typeLink.type = symbol.getType(); 
                                        if(typeLink.type) {
                                            if(typeLink.type.isClass()) {
                                                typeLink.type = typeLink.type.instanceType; 
                                            }
                                        } else  {
                                            typeLink.type = this.anyType; 
                                        }
                                    } else  {
                                        typeLink.type = this.anyType; 
                                        this.errorReporter.simpleError(ast, "expected type"); 
                                    }
                                }
                                break;

                            }
                            case Tools.NodeType.Dot: {
                                typeLink.type = this.resolveTypeMember(scope, ast); 
                                break;

                            }
                            case Tools.NodeType.TypeRef: {
                                var typeRef = ast; 
                                arrayCount = typeRef.arrayCount; 
                                ast = typeRef.term; 
                                if(ast == null) {
                                    typeLink.type = this.anyType; 
                                }
                                break;

                            }
                            case Tools.NodeType.Interface: {
                                var interfaceDecl = ast; 
                                var _interface = new Tools.Type(); 
                                var interfaceSymbol = new Tools.TypeSymbol((interfaceDecl.name).text, ast.minChar, this.locationInfo.unitIndex, _interface); 
                                _interface.symbol = interfaceSymbol; 
                                _interface.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                                _interface.containedScope = new Tools.SymbolTableScope(_interface.members, null, null, null, interfaceSymbol); 
                                _interface.containedScope.container = interfaceSymbol; 
                                _interface.memberScope = _interface.containedScope; 
                                var memberList = interfaceDecl.members; 
                                var props = memberList.members; 
                                var propsLen = props.length; 
                                for(var j = 0; j < propsLen; j++) {
                                    var propDecl = props[j]; 
                                    var propSym = null; 
                                    var addMember = true; 
                                    if(propDecl.nodeType == Tools.NodeType.FuncDecl) {
                                        var funcDecl = propDecl; 
                                        propSym = _interface.members.allMembers.lookup(funcDecl.getNameText()); 
                                        addMember = (propSym == null); 
                                        if(funcDecl.isSpecialFn()) {
                                            addMember = false; 
                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol); 
                                        } else  {
                                            propSym = this.resolveFuncDecl(funcDecl, scope, propSym); 
                                        }
                                        funcDecl.type = (propSym).type; 
                                    } else  {
                                        propSym = this.resolveVarDecl(propDecl, scope); 
                                    }
                                    if(addMember) {
                                        if(!_interface.members.allMembers.add(propSym.name, propSym)) {
                                            this.errorReporter.duplicateIdentifier(ast, propSym.name); 
                                        }
                                    }
                                }
                                ast.type = _interface; 
                                typeLink.type = _interface; 
                                break;

                            }
                            case Tools.NodeType.FuncDecl: {
                                var tsym = this.resolveFuncDecl(ast, scope, null); 
                                typeLink.type = tsym.type; 
                                break;

                            }
                            default: {
                                typeLink.type = this.anyType; 
                                this.errorReporter.simpleError(ast, "expected type"); 
                                break;

                            }
                        }
                    }
                }
                for(var count = arrayCount; count > 0; count--) {
                    typeLink.type = this.makeArrayType(typeLink.type); 
                }
                if(supplyVar && (typeLink.type == null)) {
                    typeLink.type = this.anyType; 
                }
                if(typeLink.ast != null) {
                    typeLink.ast.type = typeLink.type; 
                }
            }
        };
        TypeChecker.prototype.invariantMatches = function(a, b) {
            return (a == null) || (b == null) || (a == b); 
        };
        TypeChecker.prototype.covariantMatches = function(a, b) {
            if(a != null) {
                return a.subtype(b, this); 
            } else  {
                return true; 
            }
        };
        TypeChecker.prototype.contravariantMatches = function(a, b) {
            if(b != null) {
                return b.subtype(a, this); 
            } else  {
                return true; 
            }
        };
        TypeChecker.prototype.currentSymbolCompareError = function(msg, left) {
            if((this.currentCompareA != null) && (this.currentCompareB != null)) {
                var builder = ((("Comparing " + this.currentCompareA.fullName()) + " and ") + this.currentCompareB.fullName()) + ", "; 
                var offendingSym = this.currentCompareA; 
                if(left) {
                    builder += this.currentCompareA.fullName(); 
                } else  {
                    offendingSym = this.currentCompareB; 
                    builder += this.currentCompareB.fullName(); 
                }
                builder += " "; 
                builder += msg; 
                this.errorReporter.simpleErrorFromSym(offendingSym, builder); 
            }
        };
        TypeChecker.prototype.signatureSubtype = function(a, b) {
            if((a.parameters != null) && (b.parameters == null)) {
                return false; 
            }
            if((a.parameters == null) && (b.parameters != null)) {
                return false; 
            }
            if(a.parameters.length > b.parameters.length) {
                return false; 
            }
            var art = a.returnType.type; 
            var brt = b.returnType.type; 
            if(art == null) {
                this.currentSymbolCompareError("return type unknown", true); 
                art = this.anyType; 
            }
            if(brt == null) {
                this.currentSymbolCompareError("return type unknown", false); 
                brt = this.anyType; 
            }
            if((art != this.voidType) && (brt != this.voidType)) {
                if(!(art.subtype(brt, this))) {
                    return false; 
                }
            }
            var len = a.parameters.length; 
            for(var i = 0; i < len; i++) {
                var paramA = (a.parameters[i]).parameter; 
                var paramB = (b.parameters[i]).parameter; 
                if(!(paramB.typeLink.type.subtype(paramA.typeLink.type, this))) {
                    return false; 
                }
            }
            return true; 
        };
        TypeChecker.prototype.signatureGroupSubtype = function(a, b) {
            if(a == null) {
                return (b == null); 
            } else  {
                var sva = null; 
                if(b != null) {
                    for(var i = 0, len = b.signatures.length; i < len; i++) {
                        var sb = b.signatures[i]; 
                        var ok = false; 
                        for(var j = 0, aLen = a.signatures.length; j < aLen; j++) {
                            var sa = a.signatures[j]; 
                            sva = sa; 
                            if(this.signatureSubtype(sa, sb)) {
                                ok = true; 
                                break;
                            }
                        }
                        if(!ok) {
                            return false; 
                        }
                    }
                } else  {
                    return false; 
                }
            }
            return true; 
        };
        TypeChecker.prototype.signatureAssignable = function(a, b) {
            if((a.parameters != null) && (b.parameters == null)) {
                return false; 
            }
            if((a.parameters == null) && (b.parameters != null)) {
                return false; 
            }
            if(a.parameters.length > b.parameters.length) {
                return false; 
            }
            var art = a.returnType.type; 
            var brt = b.returnType.type; 
            if(art == null) {
                this.currentSymbolCompareError("return type unknown", true); 
                art = this.anyType; 
            }
            if(brt == null) {
                this.currentSymbolCompareError("return type unknown", false); 
                brt = this.anyType; 
            }
            if(!(art == this.voidType && b.declAST != null && (b.declAST.isConstructor || Tools.hasFlag(b.declAST.fncFlags, Tools.FncFlags.ConstructMember)))) {
                if((art != this.voidType) && (brt != this.voidType)) {
                    if(!(art.assignable(brt, this))) {
                        return false; 
                    }
                } else  {
                    if(art != brt && (art != this.voidType && brt != this.voidType)) {
                        return false; 
                    }
                }
            }
            var len = a.parameters.length; 
            for(var i = 0; i < len; i++) {
                var paramA = (a.parameters[i]).parameter; 
                var paramB = (b.parameters[i]).parameter; 
                if(!(paramB.typeLink.type.assignable(paramA.typeLink.type, this))) {
                    return false; 
                }
            }
            return true; 
        };
        TypeChecker.prototype.signatureGroupAssignable = function(a, b) {
            if(a == null) {
                return (b == null); 
            } else  {
                var sva = null; 
                if(b != null) {
                    for(var i = 0, len = b.signatures.length; i < len; i++) {
                        var sb = b.signatures[i]; 
                        var ok = false; 
                        for(var j = 0, aLen = a.signatures.length; j < aLen; j++) {
                            var sa = a.signatures[j]; 
                            sva = sa; 
                            if(this.signatureAssignable(sa, sb)) {
                                ok = true; 
                                break;
                            }
                        }
                        if(!ok) {
                            return false; 
                        }
                    }
                } else  {
                    return false; 
                }
            }
            return true; 
        };
        TypeChecker.prototype.symbolSubtype = function(a, b) {
            if((a == null) || (b == null)) {
                return false; 
            }
            if(a == b) {
                return true; 
            }
            if(a.name != b.name) {
                return false; 
            }
            var inf = null; 
            if(a.isInferenceSymbol()) {
                inf = a; 
                if(inf.typeCheckStatus == Tools.TypeCheckStatus.NotStarted) {
                    this.typeFlow.typeCheck(a.declAST); 
                }
            }
            if(b.isInferenceSymbol()) {
                inf = b; 
                if(inf.typeCheckStatus != Tools.TypeCheckStatus.NotStarted) {
                    this.typeFlow.typeCheck(b.declAST); 
                }
            }
            var svCompareA = this.currentCompareA; 
            var svCompareB = this.currentCompareB; 
            this.currentCompareA = a; 
            this.currentCompareB = b; 
            var result = a.getType().subtype(b.getType(), this); 
            this.currentCompareA = svCompareA; 
            this.currentCompareB = svCompareB; 
            return result; 
        };
        TypeChecker.prototype.symbolAssignable = function(a, b) {
            if((a == null) || (b == null)) {
                return false; 
            }
            if(a == b) {
                return true; 
            }
            var inf = null; 
            if(a.isInferenceSymbol()) {
                inf = a; 
                if(inf.typeCheckStatus == Tools.TypeCheckStatus.NotStarted) {
                    this.typeFlow.typeCheck(a.declAST); 
                }
            }
            if(b.isInferenceSymbol()) {
                inf = b; 
                if(inf.typeCheckStatus != Tools.TypeCheckStatus.NotStarted) {
                    this.typeFlow.typeCheck(b.declAST); 
                }
            }
            var result = a.name == b.name && (a.getType().assignable(b.getType(), this) || b.getType().assignable(a.getType(), this)); 
            return result; 
        };
        TypeChecker.prototype.assignableTo = function(from, to) {
            if(from == to) {
                return true; 
            }
            if(from == this.voidType) {
                return false; 
            }
            if((from == null) || (to == null)) {
                return true; 
            }
            if((from == this.undefinedType) || (to == this.undefinedType)) {
                return true; 
            }
            to = to.getInstanceType(); 
            if(to.assignable(from, this) || from.assignable(to, this)) {
                return true; 
            }
            return false; 
        };
        TypeChecker.prototype.getApplicableSignatures = function(signatures, args) {
            var applicableSigs = []; 
            var memberType = null; 
            for(var i = 0; i < signatures.length; i++) {
                for(var j = 0; j < args.members.length; j++) {
                    if(j >= signatures[i].parameters.length) {
                        continue;
                    }
                    memberType = signatures[i].parameters[j].getType(); 
                    if((j >= signatures[i].nonOptionalParameterCount || (signatures[i].declAST.variableArgList && j >= signatures[i].nonOptionalParameterCount - 1)) && memberType.isArray()) {
                        memberType = memberType.elementType; 
                    }
                    if(memberType == this.anyType) {
                        continue;
                    } else  {
                        if(args.members[j].nodeType == Tools.NodeType.FuncDecl) {
                            if(!this.canContextuallyTypeFunction(memberType, args.members[j], true)) {
                                if(this.canContextuallyTypeFunction(memberType, args.members[j], false)) {
                                    this.typeFlow.typeCheck(args.members[j]); 
                                } else  {
                                    break;
                                }
                            }
                        } else  {
                            if(args.members[j].nodeType == Tools.NodeType.ObjectLit) {
                                if(!this.canContextuallyTypeObjectLiteral(memberType, args.members[j])) {
                                    if(this.objectLiteralIsSupersetOfContextualType(memberType, args.members[j])) {
                                        this.typeFlow.typeCheck(args.members[j]); 
                                    } else  {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                if(j == args.members.length) {
                    applicableSigs[applicableSigs.length] = signatures[i]; 
                }
            }
            return applicableSigs; 
        };
        TypeChecker.prototype.getBetterConversion = function(sig1, sig2, args) {
            return null; 
        };
        TypeChecker.prototype.canContextuallyTypeFunction = function(candidateType, funcDecl, beStringent) {
            if(funcDecl.isParenthesized || funcDecl.isMethod() || (beStringent && funcDecl.returnTypeAnnotation != null) || funcDecl.isInlineCallLiteral) {
                return false; 
            }
            if(!beStringent) {
                return true; 
            }
            var signature = funcDecl.signature; 
            var paramLen = signature.parameters.length; 
            for(var i = 0; i < paramLen; i++) {
                var param = signature.parameters[i]; 
                var symbol = param; 
                var argDecl = symbol.declAST; 
                if(beStringent && (argDecl.init != null || argDecl.typeExpr != null)) {
                    return false; 
                }
            }
            if(candidateType.construct != null && candidateType.call != null) {
                return false; 
            }
            var candidateSigs = candidateType.construct != null ? candidateType.construct : candidateType.call; 
            if(candidateSigs == null || candidateSigs.signatures.length > 1) {
                return false; 
            }
            var candidateParams = candidateSigs.signatures[0].parameters; 
            if(candidateParams.length < funcDecl.args.members.length) {
                return false; 
            }
            return true; 
        };
        TypeChecker.prototype.canContextuallyTypeObjectLiteral = function(targetType, objectLit) {
            var memberDecls = objectLit.operand; 
            if(!(memberDecls && targetType.memberScope)) {
                return false; 
            }
            var id = null; 
            var targetMember = null; 
            var text = ""; 
            for(var i = 0; i < memberDecls.members.length; i++) {
                id = (memberDecls.members[i]).operand1; 
                if(id.nodeType == Tools.NodeType.Name) {
                    text = (id).text; 
                } else  {
                    if(id.nodeType == Tools.NodeType.QString) {
                        var idText = (id).text; 
                        text = idText.substring(1, idText.length - 1); 
                    } else  {
                        return false; 
                    }
                }
                targetMember = targetType.memberScope.find(text, false, false); 
                if(!targetMember) {
                    return false; 
                }
            }
            return true; 
        };
        TypeChecker.prototype.objectLiteralIsSupersetOfContextualType = function(targetType, objectLit) {
            var memberDecls = objectLit.operand; 
            if(!(memberDecls && targetType.memberScope)) {
                return false; 
            }
            var id = null; 
            var targetMember = null; 
            var text = ""; 
            var members = targetType.members.publicMembers.getAllKeys(); 
            for(var i = 0; i < members.length; i++) {
                for(var j = 0; j < memberDecls.members.length; j++) {
                    id = (memberDecls.members[j]).operand1; 
                    if(id.nodeType == Tools.NodeType.Name) {
                        text = (id).text; 
                    } else  {
                        if(id.nodeType == Tools.NodeType.QString) {
                            var idText = (id).text; 
                            text = idText.substring(1, idText.length - 1); 
                        } else  {
                            return false; 
                        }
                    }
                    if(text == members[i]) {
                        break;
                    }
                }
                if(j == memberDecls.members.length) {
                    return false; 
                }
            }
            return true; 
        };
        return TypeChecker;
    })();
    Tools.TypeChecker = TypeChecker;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var Continuation = (function () {
        function Continuation(normalBlock) {
            this.normalBlock = normalBlock;
            this.exceptionBlock = -1; 
        }
        return Continuation;
    })();
    Tools.Continuation = Continuation;
    
    function getBaseTypeLinks(bases, baseTypeLinks) {
        if(bases != null) {
            var len = bases.members.length; 
            if(baseTypeLinks == null) {
                baseTypeLinks = new Array(); 
            }
            for(var i = 0; i < len; i++) {
                var baseExpr = bases.members[i]; 
                var name = baseExpr; 
                if(name.nodeType == Tools.NodeType.Call) {
                    name = (name).target; 
                }
                var typeLink = new Tools.TypeLink(); 
                typeLink.ast = name; 
                baseTypeLinks[baseTypeLinks.length] = typeLink; 
            }
        }
        return baseTypeLinks; 
    }
    function getBases(type, typeDecl) {
        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks); 
        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks); 
    }
    function addPrototypeField(classType, ast, context) {
        var field = new Tools.ValueLocation(); 
        field.typeLink = new Tools.TypeLink(); 
        field.typeLink.ast = ast; 
        field.typeLink.type = classType.instanceType; 
        var fieldSymbol = new Tools.FieldSymbol("prototype", ast.minChar, context.checker.locationInfo.unitIndex, true, field); 
        fieldSymbol.flags |= (Tools.SymbolFlags.Property | Tools.SymbolFlags.BuiltIn); 
        field.symbol = fieldSymbol; 
        fieldSymbol.declAST = ast; 
        classType.members.addPublicMember("prototype", fieldSymbol); 
    }
    Tools.globalId = "__GLO"; 
    function findTypeSymbolInScopeChain(name, scopeChain) {
        var symbol = scopeChain.scope.find(name, false, true); 
        if(symbol == null && scopeChain.previous != null) {
            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous); 
        }
        return symbol; 
    }
    function findSymbolFromAlias(alias, context) {
        var symbol = null; 
        switch(alias.nodeType) {
            case Tools.NodeType.Name: {
                var name = (alias).text; 
                var isDynamic = Tools.isQuoted(name); 
                if(isDynamic) {
                    var path = Tools.getRootFilePath(context.tcContext.script.locationInfo.filename); 
                    var modName = Tools.switchToForwardSlashes(Tools.stripQuotes(name)); 
                    name = Tools.normalizePath((path + modName) + ".str"); 
                }
                if(context.members != null) {
                    symbol = context.members.lookup(name); 
                } else  {
                    symbol = findTypeSymbolInScopeChain(name, context.topLevelScope); 
                }
                break;

            }
            case Tools.NodeType.Dot: {
                var dottedExpr = alias; 
                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context); 
                if(op1Sym != null && op1Sym.getType() != null) {
                    symbol = findSymbolFromAlias(dottedExpr.operand2, context); 
                }
                break;

            }
            default: {
                break;

            }
        }
        if(symbol != null) {
            var symType = symbol.getType(); 
            if(symType) {
                var members = symType.members; 
                if(members != null) {
                    context.members = members.publicMembers; 
                }
            } else  {
                context.tcContext.checker.errorReporter.simpleError(alias, "Potentially circular alias reference - could not obtain type of alias"); 
            }
        }
        return symbol; 
    }
    function preCollectImportTypes(ast, parent, context) {
        var scopeChain = context.scopeChain; 
        var typeSymbol = null; 
        var modType = null; 
        var importDecl = ast; 
        var isExported = Tools.hasFlag(importDecl.varFlags, Tools.VarFlags.Exported); 
        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, {
            topLevelScope: scopeChain,
            members: null,
            tcContext: context
        }); 
        var isGlobal = context.scopeChain.container == context.checker.gloMod; 
        modType = null; 
        if(aliasedModSymbol != null) {
            var aliasedModType = aliasedModSymbol.getType(); 
            if(aliasedModType != null) {
                modType = aliasedModType; 
            }
        }
        typeSymbol = new Tools.TypeSymbol(importDecl.id.text, importDecl.minChar, context.checker.locationInfo.unitIndex, modType); 
        typeSymbol.isAlias = true; 
        if(context.scopeChain.moduleDecl != null) {
            typeSymbol.declModule = context.scopeChain.moduleDecl; 
        }
        typeSymbol.declAST = importDecl; 
        importDecl.id.sym = typeSymbol; 
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, false); 
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, false); 
        return true; 
    }
    Tools.preCollectImportTypes = preCollectImportTypes;
    function preCollectModuleTypes(ast, parent, context) {
        var scopeChain = context.scopeChain; 
        var moduleDecl = ast; 
        var isAmbient = Tools.hasFlag(moduleDecl.modFlags, Tools.ModuleFlags.Ambient); 
        var isEnum = Tools.hasFlag(moduleDecl.modFlags, Tools.ModuleFlags.IsEnum); 
        var isGlobal = context.scopeChain.container == context.checker.gloMod; 
        var isExported = Tools.hasFlag(moduleDecl.modFlags, Tools.ModuleFlags.Exported); 
        var modName = (moduleDecl.name).text; 
        var isDynamic = Tools.isQuoted(modName); 
        var symbol = scopeChain.scope.findLocal(modName, false, false); 
        var typeSymbol = null; 
        var modType = null; 
        if((symbol == null) || (symbol.kind() != Tools.SymbolKind.Type)) {
            if(modType == null) {
                var enclosedTypes = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                var ambientEnclosedTypes = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                modType = new Tools.ModuleType(enclosedTypes, ambientEnclosedTypes); 
                if(isEnum) {
                    modType.typeFlags |= Tools.TypeFlags.IsEnum; 
                }
                modType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                modType.ambientMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                modType.setHasImplementation(); 
            }
            typeSymbol = new Tools.TypeSymbol(modName, moduleDecl.minChar, context.checker.locationInfo.unitIndex, modType); 
            if(context.scopeChain.moduleDecl != null) {
                typeSymbol.declModule = context.scopeChain.moduleDecl; 
            }
            typeSymbol.declAST = moduleDecl; 
            typeSymbol.prettyName = moduleDecl.prettyName; 
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient); 
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient); 
            modType.symbol = typeSymbol; 
        } else  {
            if(symbol != null && symbol.declAST != null && symbol.declAST.nodeType != Tools.NodeType.Module) {
                context.checker.errorReporter.simpleError(moduleDecl, ("Conflicting symbol name for module '" + modName) + "'"); 
            }
            typeSymbol = symbol; 
            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers; 
            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new Tools.StringHashTable() : publicEnclosedTypes; 
            var enclosedTypes = new Tools.ScopedMembers(new Tools.DualStringHashTable(publicEnclosedTypesTable, new Tools.StringHashTable())); 
            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers; 
            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new Tools.StringHashTable() : publicEnclosedAmbientTypes; 
            var ambientEnclosedTypes = new Tools.ScopedMembers(new Tools.DualStringHashTable(publicAmbientEnclosedTypesTable, new Tools.StringHashTable())); 
            var publicMembers = typeSymbol.type.members.publicMembers; 
            var publicMembersTable = (publicMembers == null) ? new Tools.StringHashTable() : publicMembers; 
            var members = new Tools.ScopedMembers(new Tools.DualStringHashTable(publicMembersTable, new Tools.StringHashTable())); 
            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers; 
            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new Tools.StringHashTable() : publicAmbientMembers; 
            var ambientMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(publicAmbientMembersTable, new Tools.StringHashTable())); 
            modType = new Tools.ModuleType(enclosedTypes, ambientEnclosedTypes); 
            if(isEnum) {
                modType.typeFlags |= Tools.TypeFlags.IsEnum; 
            }
            modType.members = members; 
            modType.ambientMembers = ambientMembers; 
            modType.setHasImplementation(); 
            modType.symbol = typeSymbol; 
            typeSymbol.addLocation(moduleDecl.minChar); 
            typeSymbol.expansions.push(modType); 
        }
        if(context.scopeChain.moduleDecl != null) {
            context.scopeChain.moduleDecl.recordNonInterface(); 
        }
        if(isExported) {
            typeSymbol.flags |= Tools.SymbolFlags.Exported; 
        }
        if((context.scopeChain.moduleDecl != null) || (context.scopeChain.container == context.checker.gloMod)) {
            typeSymbol.flags |= Tools.SymbolFlags.ModuleMember; 
        }
        moduleDecl.mod = modType; 
        Tools.pushTypeCollectionScope(typeSymbol, modType.members, modType.ambientMembers, modType.enclosedTypes, modType.ambientEnclosedTypes, context, null, null, moduleDecl); 
        return true; 
    }
    Tools.preCollectModuleTypes = preCollectModuleTypes;
    function preCollectClassTypes(ast, parent, context) {
        var scopeChain = context.scopeChain; 
        var classDecl = ast; 
        var classType; 
        var instanceType; 
        var typeSymbol = null; 
        var className = (classDecl.name).text; 
        var alreadyInScope = false; 
        var isAmbient = Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Ambient); 
        var isExported = Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Exported); 
        var isGlobal = context.scopeChain.container == context.checker.gloMod; 
        var containerMod = scopeChain.container; 
        var foundValSymbol = false; 
        typeSymbol = scopeChain.scope.findLocal(className, false, true); 
        if(typeSymbol == null) {
            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false); 
            if(valTypeSymbol != null && valTypeSymbol.isType() && valTypeSymbol.declAST != null && valTypeSymbol.declAST.nodeType == Tools.NodeType.FuncDecl && (valTypeSymbol.declAST).isSignature()) {
                typeSymbol = valTypeSymbol; 
                foundValSymbol = true; 
                if(isExported) {
                    typeSymbol.flags |= Tools.SymbolFlags.Exported; 
                }
                if(isAmbient) {
                    typeSymbol.flags |= Tools.SymbolFlags.Ambient; 
                }
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient); 
            }
        }
        if(typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl) && !(typeSymbol.declAST).isOverload && !classDecl.isOverload) {
            typeSymbol = null; 
        }
        if(typeSymbol == null) {
            var valueSymbol = scopeChain.scope.findLocal(className, false, false); 
            classType = new Tools.Type(); 
            classType.setHasImplementation(); 
            instanceType = new Tools.Type(); 
            instanceType.setHasImplementation(); 
            classType.instanceType = instanceType; 
            classType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            addPrototypeField(classType, classDecl, context); 
            instanceType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            typeSymbol = new Tools.TypeSymbol(className, classDecl.minChar, context.checker.locationInfo.unitIndex, classType); 
            typeSymbol.declAST = classDecl; 
            typeSymbol.instanceType = instanceType; 
            classType.symbol = typeSymbol; 
            instanceType.symbol = typeSymbol; 
            if(context.scopeChain.moduleDecl != null) {
                context.scopeChain.moduleDecl.recordNonInterface(); 
                typeSymbol.declModule = context.scopeChain.moduleDecl; 
                typeSymbol.flags |= Tools.SymbolFlags.ModuleMember; 
            }
            if(isExported) {
                typeSymbol.flags |= Tools.SymbolFlags.Exported; 
            }
            if(isAmbient) {
                typeSymbol.flags |= Tools.SymbolFlags.Ambient; 
            }
            ast.type = classType; 
            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient); 
            if(valueSymbol == null) {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient); 
            }
        } else  {
            classType = typeSymbol.type; 
            if(classType.instanceType == null) {
                classType.instanceType = new Tools.Type(); 
                classType.instanceType.setHasImplementation(); 
                classType.instanceType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                classType.instanceType.symbol = classType.symbol; 
            }
            instanceType = classType.instanceType; 
            ast.type = classType; 
        }
        if(!classDecl.isOverload) {
            getBases(instanceType, classDecl); 
            Tools.pushTypeCollectionScope(typeSymbol, instanceType.members, null, null, null, context, instanceType, classType, null); 
        }
        return true; 
    }
    Tools.preCollectClassTypes = preCollectClassTypes;
    function preCollectES6ClassTypes(ast, parent, context) {
        var scopeChain = context.scopeChain; 
        var classDecl = ast; 
        var classType; 
        var instanceType; 
        var typeSymbol = null; 
        var className = (classDecl.name).text; 
        var alreadyInScope = false; 
        var isAmbient = Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Ambient); 
        var isExported = Tools.hasFlag(classDecl.varFlags, Tools.VarFlags.Exported); 
        var isGlobal = context.scopeChain.container == context.checker.gloMod; 
        var containerMod = scopeChain.container; 
        var foundValSymbol = false; 
        typeSymbol = scopeChain.scope.findLocal(className, false, true); 
        if(typeSymbol == null) {
            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false); 
            if(valTypeSymbol != null && valTypeSymbol.isType() && valTypeSymbol.declAST != null && valTypeSymbol.declAST.nodeType == Tools.NodeType.FuncDecl && (valTypeSymbol.declAST).isSignature()) {
                typeSymbol = valTypeSymbol; 
                foundValSymbol = true; 
                if(isExported) {
                    typeSymbol.flags |= Tools.SymbolFlags.Exported; 
                }
                if(isAmbient) {
                    typeSymbol.flags |= Tools.SymbolFlags.Ambient; 
                }
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient); 
            }
        }
        if(typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl) && !(typeSymbol.declAST).isOverload) {
            typeSymbol = null; 
        }
        if(typeSymbol == null) {
            var valueSymbol = scopeChain.scope.findLocal(className, false, false); 
            classType = new Tools.Type(); 
            classType.setHasImplementation(); 
            instanceType = new Tools.Type(); 
            instanceType.setHasImplementation(); 
            classType.instanceType = instanceType; 
            classType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            classType.ambientMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            addPrototypeField(classType, classDecl, context); 
            instanceType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            instanceType.ambientMembers = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            typeSymbol = new Tools.TypeSymbol(className, classDecl.minChar, context.checker.locationInfo.unitIndex, classType); 
            typeSymbol.declAST = classDecl; 
            typeSymbol.instanceType = instanceType; 
            classType.symbol = typeSymbol; 
            instanceType.symbol = typeSymbol; 
            if(context.scopeChain.moduleDecl != null) {
                context.scopeChain.moduleDecl.recordNonInterface(); 
                typeSymbol.declModule = context.scopeChain.moduleDecl; 
                typeSymbol.flags |= Tools.SymbolFlags.ModuleMember; 
            }
            if(isExported) {
                typeSymbol.flags |= Tools.SymbolFlags.Exported; 
            }
            if(isAmbient) {
                typeSymbol.flags |= Tools.SymbolFlags.Ambient; 
            }
            ast.type = classType; 
            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient); 
            if(valueSymbol == null) {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient); 
            }
        } else  {
            classType = typeSymbol.type; 
            if(classType.instanceType == null) {
                classType.instanceType = new Tools.Type(); 
                classType.instanceType.setHasImplementation(); 
                classType.instanceType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                classType.instanceType.symbol = classType.symbol; 
            }
            instanceType = classType.instanceType; 
            ast.type = classType; 
        }
        classType.isES6Class = true; 
        instanceType.isES6Class = true; 
        getBases(instanceType, classDecl); 
        Tools.pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null, context, instanceType, classType, null); 
        return true; 
    }
    Tools.preCollectES6ClassTypes = preCollectES6ClassTypes;
    function preCollectInterfaceTypes(ast, parent, context) {
        var scopeChain = context.scopeChain; 
        var interfaceDecl = ast; 
        var interfaceSymbol = null; 
        var interfaceType = null; 
        var isExported = Tools.hasFlag(interfaceDecl.varFlags, Tools.VarFlags.Exported); 
        var isGlobal = context.scopeChain.container == context.checker.gloMod; 
        var alreadyInScope = true; 
        alreadyInScope = false; 
        var interfaceName = (interfaceDecl.name).text; 
        interfaceSymbol = scopeChain.scope.findLocal(interfaceName, false, true); 
        if(interfaceSymbol == null) {
            interfaceType = new Tools.Type(); 
            interfaceSymbol = new Tools.TypeSymbol(interfaceName, ast.minChar, context.checker.locationInfo.unitIndex, interfaceType); 
            interfaceType.symbol = interfaceSymbol; 
            interfaceType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            interfaceSymbol.declAST = interfaceDecl; 
            interfaceSymbol.declModule = context.scopeChain.moduleDecl; 
        } else  {
            alreadyInScope = true; 
            interfaceType = interfaceSymbol.type; 
        }
        ast.type = interfaceType; 
        getBases(interfaceType, interfaceDecl); 
        if(isExported) {
            interfaceSymbol.flags |= Tools.SymbolFlags.Exported; 
        }
        if(context.scopeChain.moduleDecl != null) {
            interfaceSymbol.flags |= Tools.SymbolFlags.ModuleMember; 
        }
        if(!alreadyInScope) {
            context.scopeChain.scope.enter(context.scopeChain.container, ast, interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false); 
        }
        Tools.pushTypeCollectionScope(interfaceSymbol, interfaceType.members, null, null, null, context, interfaceType, null, null); 
        return true; 
    }
    Tools.preCollectInterfaceTypes = preCollectInterfaceTypes;
    function preCollectArgDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain; 
        var argDecl = ast; 
        if(Tools.hasFlag(argDecl.varFlags, Tools.VarFlags.Public | Tools.VarFlags.Private)) {
            var field = new Tools.ValueLocation(); 
            var isPrivate = Tools.hasFlag(argDecl.varFlags, Tools.VarFlags.Private); 
            var fieldSymbol = new Tools.FieldSymbol(argDecl.id.text, argDecl.minChar, context.checker.locationInfo.unitIndex, !Tools.hasFlag(argDecl.varFlags, Tools.VarFlags.Readonly), field); 
            fieldSymbol.transferVarFlags(argDecl.varFlags); 
            field.symbol = fieldSymbol; 
            fieldSymbol.declAST = ast; 
            context.scopeChain.scope.enter(context.scopeChain.container, ast, fieldSymbol, context.checker.errorReporter, !isPrivate, false, false); 
            field.typeLink = Tools.getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null); 
            argDecl.sym = fieldSymbol; 
        }
        return false; 
    }
    Tools.preCollectArgDeclTypes = preCollectArgDeclTypes;
    function preCollectVarDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain; 
        var varDecl = ast; 
        var isAmbient = Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Ambient); 
        var isExported = Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Exported); 
        var isGlobal = context.scopeChain.container == context.checker.gloMod; 
        var isProperty = Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Property); 
        var isStatic = Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Static); 
        var isPrivate = Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Private); 
        if(context.scopeChain.moduleDecl != null) {
            context.scopeChain.moduleDecl.recordNonInterface(); 
        }
        if(isProperty || isExported || (context.scopeChain.container == context.checker.gloMod) || (context.scopeChain.moduleDecl != null)) {
            if(isAmbient) {
                var existingSym = scopeChain.scope.findLocal(varDecl.id.text, false, false); 
                if(existingSym != null) {
                    varDecl.sym = existingSym; 
                    return false; 
                }
            }
            if(varDecl.id == null) {
                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location"); 
                return false; 
            }
            var field = new Tools.ValueLocation(); 
            var fieldSymbol = new Tools.FieldSymbol(varDecl.id.text, varDecl.minChar, context.checker.locationInfo.unitIndex, (varDecl.varFlags & Tools.VarFlags.Readonly) == Tools.VarFlags.None, field); 
            fieldSymbol.transferVarFlags(varDecl.varFlags); 
            field.symbol = fieldSymbol; 
            fieldSymbol.declAST = ast; 
            if((context.scopeChain.moduleDecl != null) || (context.scopeChain.container == context.checker.gloMod)) {
                fieldSymbol.flags |= Tools.SymbolFlags.ModuleMember; 
                fieldSymbol.declModule = context.scopeChain.moduleDecl; 
            }
            if(Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Property) && isStatic) {
                if(!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {
                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name); 
                }
                fieldSymbol.container = context.scopeChain.classType.symbol; 
            } else  {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, fieldSymbol, context.checker.errorReporter, !isPrivate && (isProperty || isExported || isGlobal || isStatic), false, isAmbient); 
            }
            if(Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Exported)) {
                fieldSymbol.flags |= Tools.SymbolFlags.Exported; 
            }
            field.typeLink = Tools.getTypeLink(varDecl.typeExpr, context.checker, varDecl.init == null); 
            varDecl.sym = fieldSymbol; 
        }
        return false; 
    }
    Tools.preCollectVarDeclTypes = preCollectVarDeclTypes;
    function preCollectFuncDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain; 
        if(context.scopeChain.moduleDecl != null) {
            context.scopeChain.moduleDecl.recordNonInterface(); 
        }
        var funcDecl = ast; 
        var fgSym = null; 
        var nameText = funcDecl.getNameText(); 
        var isExported = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Exported); 
        var isStatic = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Static); 
        var isPrivate = Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Private); 
        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor; 
        var containerSym = ((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor() ? context.scopeChain.classType.symbol : context.scopeChain.container); 
        var containerScope = context.scopeChain.scope; 
        var isGlobal = containerSym == context.checker.gloMod; 
        var go = false; 
        var foundSymbol = false; 
        if(isConstructor && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod)) {
            containerSym = containerSym.container; 
            containerScope = scopeChain.previous.scope; 
        }
        funcDecl.unitIndex = context.checker.locationInfo.unitIndex; 
        if(!funcDecl.isConstructor && containerSym != null && containerSym.declAST != null && containerSym.declAST.nodeType == Tools.NodeType.FuncDecl && (containerSym.declAST).isConstructor && !funcDecl.isMethod()) {
            return go; 
        }
        if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Signature)) {
            var instType = context.scopeChain.thisType; 
            if(nameText != null && nameText != "__missing") {
                if(isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText); 
                } else  {
                    fgSym = containerScope.findLocal(nameText, false, false); 
                    if(fgSym == null) {
                        fgSym = containerScope.findLocal(nameText, false, true); 
                    }
                }
                if(fgSym != null) {
                    foundSymbol = true; 
                    if(!funcDecl.isSignature() && (Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Ambient) != Tools.hasFlag(fgSym.flags, Tools.SymbolFlags.Ambient))) {
                        fgSym = null; 
                    }
                }
            }
            if(fgSym == null) {
                if(!(funcDecl.isSpecialFn())) {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol; 
                } else  {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol; 
                }
                fgSym.declAST = ast; 
            } else  {
                if((fgSym.kind() == Tools.SymbolKind.Type)) {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol; 
                } else  {
                    context.checker.errorReporter.simpleError(funcDecl, ("Function or method '" + funcDecl.name) + "' already declared as a property"); 
                }
            }
            if(funcDecl.isSpecialFn()) {
                funcDecl.type = instType != null ? instType : fgSym.type; 
            } else  {
                funcDecl.type = fgSym.type; 
            }
        } else  {
            if(nameText != null) {
                if(isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText); 
                } else  {
                    if(funcDecl.isConstructor && context.scopeChain.previous != null) {
                        fgSym = context.scopeChain.previous.scope.findLocal(nameText, false, false); 
                    }
                    if(fgSym == null) {
                        fgSym = containerScope.findLocal(nameText, false, false); 
                    }
                }
                if(fgSym != null) {
                    foundSymbol = true; 
                    if(!isConstructor && fgSym.declAST.nodeType == Tools.NodeType.FuncDecl && !(fgSym.declAST).isAccessor() && !(fgSym.declAST).isSignature()) {
                        fgSym = null; 
                        foundSymbol = false; 
                    }
                }
            }
            if(fgSym != null && !fgSym.isAccessor() && fgSym.type != null && fgSym.type.construct != null && fgSym.type.construct.signatures != [] && (fgSym.type.construct.signatures[0].declAST == null || !Tools.hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, Tools.FncFlags.Ambient)) && !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Functions may not have class overloads"); 
            }
            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol); 
            if(((fgSym == null || fgSym.declAST.nodeType != Tools.NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym != null && fgSym.isAccessor())) {
                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym); 
            }
            funcDecl.type.symbol.declAST = ast; 
            if(funcDecl.isConstructor) {
                go = true; 
            }
            ;; 
        }
        if(isExported) {
            if(funcDecl.type.call != null) {
                funcDecl.type.symbol.flags |= Tools.SymbolFlags.Exported; 
            }
            if(fgSym != null && !fgSym.isAccessor() && fgSym.type.call != null) {
                fgSym.flags |= Tools.SymbolFlags.Exported; 
            }
        }
        if((context.scopeChain.moduleDecl != null) && (!funcDecl.isSpecialFn())) {
            funcDecl.type.symbol.flags |= Tools.SymbolFlags.ModuleMember; 
            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl; 
        }
        return go; 
    }
    Tools.preCollectFuncDeclTypes = preCollectFuncDeclTypes;
    function preCollectTypes(ast, parent, context) {
        var go = false; 
        var scopeChain = context.scopeChain; 
        if(ast.nodeType == Tools.NodeType.Script) {
            var script = ast; 
            context.script = script; 
            go = true; 
        } else  {
            if(ast.nodeType == Tools.NodeType.List) {
                go = true; 
            } else  {
                if(ast.nodeType == Tools.NodeType.Import) {
                    go = preCollectImportTypes(ast, parent, context); 
                } else  {
                    if(ast.nodeType == Tools.NodeType.With) {
                        go = false; 
                    } else  {
                        if(ast.nodeType == Tools.NodeType.Module) {
                            go = preCollectModuleTypes(ast, parent, context); 
                        } else  {
                            if(ast.nodeType == Tools.NodeType.Class) {
                                go = preCollectClassTypes(ast, parent, context); 
                            } else  {
                                if(ast.nodeType == Tools.NodeType.ES6Class) {
                                    go = preCollectES6ClassTypes(ast, parent, context); 
                                } else  {
                                    if(ast.nodeType == Tools.NodeType.Block) {
                                        go = true; 
                                    } else  {
                                        if(ast.nodeType == Tools.NodeType.Interface) {
                                            go = preCollectInterfaceTypes(ast, parent, context); 
                                        } else  {
                                            if(ast.nodeType == Tools.NodeType.ArgDecl) {
                                                go = preCollectArgDeclTypes(ast, parent, context); 
                                            } else  {
                                                if(ast.nodeType == Tools.NodeType.VarDecl) {
                                                    go = preCollectVarDeclTypes(ast, parent, context); 
                                                } else  {
                                                    if(ast.nodeType == Tools.NodeType.FuncDecl) {
                                                        go = preCollectFuncDeclTypes(ast, parent, context); 
                                                    } else  {
                                                        if(ast.isStatementOrExpression() && context.scopeChain.moduleDecl != null) {
                                                            context.scopeChain.moduleDecl.recordNonInterface(); 
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        context.goChildren = go; 
        return ast; 
    }
    Tools.preCollectTypes = preCollectTypes;
    function postCollectTypes(ast, parent, iwContext) {
        var context = iwContext; 
        if(ast.nodeType == Tools.NodeType.Module) {
            Tools.popTypeCollectionScope(context); 
        } else  {
            if(ast.nodeType == Tools.NodeType.Class) {
                if(!(ast).isOverload) {
                    Tools.popTypeCollectionScope(context); 
                }
            } else  {
                if(ast.nodeType == Tools.NodeType.ES6Class) {
                    Tools.popTypeCollectionScope(context); 
                } else  {
                    if(ast.nodeType == Tools.NodeType.Interface) {
                        Tools.popTypeCollectionScope(context); 
                    }
                }
            }
        }
        return ast; 
    }
    Tools.postCollectTypes = postCollectTypes;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var ScopeChain = (function () {
        function ScopeChain(container, previous, scope) {
            this.container = container;
            this.previous = previous;
            this.scope = scope;
            this.thisType = null; 
            this.classType = null; 
            this.fnc = null; 
            this.moduleDecl = null; 
        }
        return ScopeChain;
    })();
    Tools.ScopeChain = ScopeChain;
    
    var BBUseDefInfo = (function () {
        function BBUseDefInfo(bb) {
            this.bb = bb;
            this.defsBySymbol = new Array(); 
            this.gen = null; 
            this.kill = null; 
            this.top = null; 
            this.useIndexBySymbol = new Array(); 
        }
        BBUseDefInfo.prototype.updateTop = function() {
            var temp = new BitVector(this.top.bitCount); 
            for(var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {
                var succ = this.bb.successors[i]; 
                if(succ.useDef) {
                    temp.union(succ.useDef.top); 
                }
            }
            temp.difference(this.kill); 
            temp.union(this.gen); 
            var changed = temp.notEq(this.top); 
            this.top = temp; 
            return changed; 
        };
        BBUseDefInfo.prototype.initialize = function(useDefContext) {
            var _self = this;
            var defSym = function(sym, context) {
                if(context.isLocalSym(sym)) {
                    var index = context.getSymbolIndex(sym); 
                    _self.useIndexBySymbol[index] = new Array(); 
                    _self.defsBySymbol[index] = true; 
                }
            }; 
            var useSym = function(sym, context, ast) {
                if(context.isLocalSym(sym)) {
                    var symIndex = context.getSymbolIndex(sym); 
                    if(_self.useIndexBySymbol[symIndex] == undefined) {
                        _self.useIndexBySymbol[symIndex] = new Array(); 
                    }
                    var symUses = _self.useIndexBySymbol[symIndex]; 
                    var astIndex = context.getUseIndex(ast); 
                    context.addUse(symIndex, astIndex); 
                    symUses.push(astIndex); 
                }
            }; 
            function initUseDefPre(cur, parent, context) {
                if(cur.nodeType == Tools.NodeType.VarDecl) {
                    var varDecl = cur; 
                    if((varDecl.init != null) || (Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.AutoInit))) {
                        defSym(varDecl.sym, context); 
                    }
                } else  {
                    if(cur.nodeType == Tools.NodeType.Name) {
                        if(parent != null) {
                            if(parent.nodeType == Tools.NodeType.Asg) {
                                var asg = parent; 
                                if(asg.operand1 == cur) {
                                    return;
                                }
                            } else  {
                                if(parent.nodeType == Tools.NodeType.VarDecl) {
                                    var parentDecl = parent; 
                                    if(parentDecl.id == cur) {
                                        return;
                                    }
                                }
                            }
                        }
                        var id = cur; 
                        useSym(id.sym, context, cur); 
                    } else  {
                        if((cur.nodeType >= Tools.NodeType.Asg) && (cur.nodeType <= Tools.NodeType.LastAsg)) {
                            var asg = cur; 
                            if((asg.operand1 != null) && (asg.operand1.nodeType == Tools.NodeType.Name)) {
                                var id = asg.operand1; 
                                defSym(id.sym, context); 
                            }
                        } else  {
                            if(cur.nodeType == Tools.NodeType.FuncDecl) {
                                context.goChildren = false; 
                            }
                        }
                    }
                }
            }
            this.bb.content.walk(initUseDefPre, null, null, useDefContext); 
        };
        BBUseDefInfo.prototype.initializeGen = function(useDefContext) {
            var symbolLen = this.useIndexBySymbol.length; 
            var bitCount = useDefContext.uses.length; 
            this.gen = new BitVector(bitCount); 
            for(var s = 0; s < symbolLen; s++) {
                var symUses = this.useIndexBySymbol[s]; 
                if((symUses != undefined) && (symUses.length > 0)) {
                    for(var u = 0, uLen = symUses.length; u < uLen; u++) {
                        this.gen.set(symUses[u], true); 
                    }
                }
            }
            this.top = this.gen; 
        };
        BBUseDefInfo.prototype.initializeKill = function(useDefContext) {
            this.kill = new BitVector(this.gen.bitCount); 
            for(var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {
                if(this.defsBySymbol[s]) {
                    var globalSymUses = useDefContext.useIndexBySymbol[s]; 
                    if(globalSymUses) {
                        for(var u = 0, useLen = globalSymUses.length; u < useLen; u++) {
                            this.kill.set(globalSymUses[u], true); 
                        }
                    }
                }
            }
        };
        return BBUseDefInfo;
    })();
    Tools.BBUseDefInfo = BBUseDefInfo;
    
    var UseDefContext = (function () {
        _inheritsFrom(UseDefContext, Tools.BaseWalkContext);
        function UseDefContext() {
            UseDefContext._super.constructor.call(this);
            this.useIndexBySymbol = new Array(); 
            this.uses = new Array(); 
            this.symbols = new Array(); 
            this.symbolMap = new Tools.StringHashTable(); 
            this.symbolCount = 0; 
            this.func = null; 
            this.reverseSiblings = true; 
        }
        UseDefContext.prototype.getSymbolIndex = function(sym) {
            var name = sym.name; 
            var index = (this.symbolMap.lookup(name)); 
            if(index == null) {
                index = this.symbolCount++; 
                this.symbols[index] = sym; 
                this.symbolMap.add(name, index); 
            }
            return index; 
        };
        UseDefContext.prototype.addUse = function(symIndex, astIndex) {
            var useBySym = this.useIndexBySymbol[symIndex]; 
            if(useBySym == undefined) {
                useBySym = new Array(); 
                this.useIndexBySymbol[symIndex] = useBySym; 
            }
            useBySym[useBySym.length] = astIndex; 
        };
        UseDefContext.prototype.getUseIndex = function(ast) {
            this.uses[this.uses.length] = ast; 
            return this.uses.length - 1; 
        };
        UseDefContext.prototype.isLocalSym = function(sym) {
            return ((sym != null) && (sym.container == this.func) && (sym.kind() == Tools.SymbolKind.Variable)); 
        };
        UseDefContext.prototype.killSymbol = function(sym, bbUses) {
            var index = this.symbolMap.lookup(sym.name); 
            var usesOfSym = this.useIndexBySymbol[index]; 
            for(var k = 0, len = usesOfSym.length; k < len; k++) {
                bbUses.set(usesOfSym[k], true); 
            }
        };
        return UseDefContext;
    })();
    Tools.UseDefContext = UseDefContext;
    
    var BitVector = (function () {
        function BitVector(bitCount) {
            this.bitCount = bitCount;
            this.firstBits = 0; 
            this.restOfBits = null; 
            if(this.bitCount > BitVector.packBits) {
                this.restOfBits = new Array(); 
                var len = Math.floor(this.bitCount / BitVector.packBits); 
                for(var i = 0; i < len; i++) {
                    this.restOfBits[i] = 0; 
                }
            }
        }
        BitVector.packBits = 30; 
        BitVector.prototype.set = function(bitIndex, value) {
            if(bitIndex < BitVector.packBits) {
                if(value) {
                    this.firstBits |= (1 << bitIndex); 
                } else  {
                    this.firstBits &= (~(1 << bitIndex)); 
                }
            } else  {
                var offset = Math.floor(bitIndex / BitVector.packBits) - 1; 
                var localIndex = bitIndex % BitVector.packBits; 
                if(value) {
                    this.restOfBits[offset] |= (1 << localIndex); 
                } else  {
                    this.restOfBits[offset] &= (~(1 << localIndex)); 
                }
            }
        };
        BitVector.prototype.map = function(fn) {
            var k; 
            for(k = 0; k < BitVector.packBits; k++) {
                if(k == this.bitCount) {
                    return;
                }
                if(((1 << k) & this.firstBits) != 0) {
                    fn(k); 
                }
            }
            if(this.restOfBits != null) {
                var len; 
                var cumu = BitVector.packBits; 
                for(k = 0 , len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k]; 
                    for(var j = 0; j < BitVector.packBits; j++) {
                        if(((1 << j) & myBits) != 0) {
                            fn(cumu); 
                        }
                        cumu++; 
                        if(cumu == this.bitCount) {
                            return;
                        }
                    }
                }
            }
        };
        BitVector.prototype.union = function(b) {
            this.firstBits |= b.firstBits; 
            if(this.restOfBits != null) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k]; 
                    var bBits = b.restOfBits[k]; 
                    this.restOfBits[k] = myBits | bBits; 
                }
            }
        };
        BitVector.prototype.intersection = function(b) {
            this.firstBits &= b.firstBits; 
            if(this.restOfBits != null) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k]; 
                    var bBits = b.restOfBits[k]; 
                    this.restOfBits[k] = myBits & bBits; 
                }
            }
        };
        BitVector.prototype.notEq = function(b) {
            if(this.firstBits != b.firstBits) {
                return true; 
            }
            if(this.restOfBits != null) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k]; 
                    var bBits = b.restOfBits[k]; 
                    if(myBits != bBits) {
                        return true; 
                    }
                }
            }
            return false; 
        };
        BitVector.prototype.difference = function(b) {
            var oldFirstBits = this.firstBits; 
            this.firstBits &= (~b.firstBits); 
            if(this.restOfBits != null) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k]; 
                    var bBits = b.restOfBits[k]; 
                    this.restOfBits[k] &= (~bBits); 
                }
            }
        };
        return BitVector;
    })();
    Tools.BitVector = BitVector;
    
    var BasicBlock = (function () {
        function BasicBlock() {
            this.predecessors = new Array(); 
            this.index = -1; 
            this.markValue = 0; 
            this.successors = new Array(); 
            this.useDef = null; 
            this.content = new Tools.ASTList(); 
        }
        BasicBlock.prototype.marked = function(markBase) {
            return this.markValue > markBase; 
        };
        BasicBlock.prototype.mark = function() {
            this.markValue++; 
        };
        BasicBlock.prototype.addSuccessor = function(successor) {
            this.successors[this.successors.length] = successor; 
            successor.predecessors[successor.predecessors.length] = this; 
        };
        return BasicBlock;
    })();
    Tools.BasicBlock = BasicBlock;
    
    var ControlFlowContext = (function () {
        _inheritsFrom(ControlFlowContext, Tools.BaseWalkContext);
        function ControlFlowContext(current, exit, pre) {
            this.current = current;
            this.exit = exit;
            this.pre = pre;
            ControlFlowContext._super.constructor.call(this);
            this.entry = this.current; 
            this.unreachable = null; 
            this.noContinuation = false; 
            this.statementStack = new Array(); 
            this.currentSwitch = new Array(); 
            this.markBase = 0; 
            this.linearBBs = new Array(); 
        }
        ControlFlowContext.prototype.pushSwitch = function(bb) {
            this.currentSwitch.push(bb); 
        };
        ControlFlowContext.prototype.popSwitch = function() {
            return this.currentSwitch.pop(); 
        };
        ControlFlowContext.prototype.reportUnreachable = function(er) {
            if((this.unreachable != null) && (this.unreachable.length > 0)) {
                var len = this.unreachable.length; 
                for(var i = 0; i < len; i++) {
                    var unreachableAST = this.unreachable[i]; 
                    if(unreachableAST.nodeType != Tools.NodeType.EndCode) {
                        er.simpleError(unreachableAST, "unreachable code"); 
                    }
                }
            }
        };
        ControlFlowContext.prototype.printAST = function(ast, outfile) {
            var printContext = new Tools.PrintContext(outfile, null); 
            printContext.increaseIndent(); 
            ast.walk(Tools.prePrintAST, Tools.postPrintAST, null, printContext); 
            printContext.decreaseIndent(); 
        };
        ControlFlowContext.prototype.printBlockContent = function(bb, outfile) {
            var content = bb.content; 
            for(var i = 0, len = content.members.length; i < len; i++) {
                var ast = content.members[i]; 
                this.printAST(ast, outfile); 
            }
        };
        ControlFlowContext.prototype.bfs = function(nodeFunc, edgeFunc, preEdges, postEdges) {
            var markValue = this.markBase++; 
            var q = new Array(); 
            q[q.length] = this.entry; 
            while(q.length > 0) {
                var bb = q.pop(); 
                if(!(bb.marked(markValue))) {
                    bb.mark(); 
                    if(nodeFunc != null) {
                        nodeFunc(bb); 
                    }
                    var succLen = bb.successors.length; 
                    if(succLen > 0) {
                        if(preEdges != null) {
                            preEdges(); 
                        }
                        for(var j = succLen - 1; j >= 0; j--) {
                            var successor = bb.successors[j]; 
                            if(!(successor.marked(this.markBase))) {
                                if(edgeFunc != null) {
                                    edgeFunc(bb, successor); 
                                }
                                q[q.length] = successor; 
                            }
                        }
                        if(postEdges != null) {
                            postEdges(); 
                        }
                    }
                }
            }
        };
        ControlFlowContext.prototype.useDef = function(er, funcSym) {
            var _self = this;
            var useDefContext = new UseDefContext(); 
            useDefContext.func = funcSym; 
            var useDefInit = function(bb) {
                bb.useDef = new BBUseDefInfo(bb); 
                bb.useDef.initialize(useDefContext); 
                _self.linearBBs[_self.linearBBs.length] = bb; 
            }; 
            this.bfs(useDefInit, null, null, null); 
            var i; 
            var bbLen; 

            for(i = 0 , bbLen = this.linearBBs.length; i < bbLen; i++) {
                this.linearBBs[i].useDef.initializeGen(useDefContext); 
                this.linearBBs[i].useDef.initializeKill(useDefContext); 
            }
            var changed = true; 
            while(changed) {
                changed = false; 
                for(i = 0; i < bbLen; i++) {
                    changed = this.linearBBs[i].useDef.updateTop() || changed; 
                }
            }
            var top = this.entry.useDef.top; 
            top.map(function(index) {
                var ast = useDefContext.uses[index]; 
                er.simpleError(ast, ("use of variable '" + ast.text) + "' that is not definitely assigned"); 
            }); 
        };
        ControlFlowContext.prototype.print = function(outfile) {
            var _self = this;
            var index = 0; 
            var node = function(bb) {
                if(bb.index < 0) {
                    bb.index = index++; 
                }
                if(bb == _self.exit) {
                    outfile.WriteLine("Exit block with index " + bb.index); 
                } else  {
                    outfile.WriteLine("Basic block with index " + bb.index); 
                    _self.printBlockContent(bb, outfile); 
                }
            }; 
            function preEdges() {
                outfile.Write("  Branches to "); 
            }
            function postEdges() {
                outfile.WriteLine(""); 
            }
            function edge(node1, node2) {
                if(node2.index < 0) {
                    node2.index = index++; 
                }
                outfile.Write(node2.index + " "); 
            }
            this.bfs(node, edge, preEdges, postEdges); 
            if(this.unreachable != null) {
                for(var i = 0, len = this.unreachable.length; i < len; i++) {
                    outfile.WriteLine("Unreachable basic block ..."); 
                    this.printAST(this.unreachable[i], outfile); 
                }
            }
        };
        ControlFlowContext.prototype.pushStatement = function(stmt, continueBB, breakBB) {
            this.statementStack.push({
                stmt: stmt,
                continueBB: continueBB,
                breakBB: breakBB
            }); 
        };
        ControlFlowContext.prototype.popStatement = function() {
            return this.statementStack.pop(); 
        };
        ControlFlowContext.prototype.returnStmt = function() {
            this.current.addSuccessor(this.exit); 
            this.setUnreachable(); 
        };
        ControlFlowContext.prototype.setUnreachable = function() {
            this.current = null; 
            this.noContinuation = true; 
        };
        ControlFlowContext.prototype.addUnreachable = function(ast) {
            if(this.unreachable === null) {
                this.unreachable = new Array(); 
            }
            this.unreachable[this.unreachable.length] = ast; 
        };
        ControlFlowContext.prototype.unconditionalBranch = function(target, isContinue) {
            var targetBB = null; 
            for(var i = 0, len = this.statementStack.length; i < len; i++) {
                var targetInfo = this.statementStack[i]; 
                if(targetInfo.stmt == target) {
                    if(isContinue) {
                        targetBB = targetInfo.continueBB; 
                    } else  {
                        targetBB = targetInfo.breakBB; 
                    }
                    break;
                }
            }
            if(targetBB != null) {
                this.current.addSuccessor(targetBB); 
            }
            this.setUnreachable(); 
        };
        ControlFlowContext.prototype.addContent = function(ast) {
            if(this.current != null) {
                this.current.content.append(ast); 
            }
        };
        return ControlFlowContext;
    })();
    Tools.ControlFlowContext = ControlFlowContext;
    
    var ResolutionDataCache = (function () {
        function ResolutionDataCache() {
            this.cacheSize = 16; 
            this.rdCache = []; 
            this.nextUp = 0; 
            for(var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: new Array(),
                    exactCandidates: new Array(),
                    conversionCandidates: new Array(),
                    id: i
                }; 
            }
        }
        ResolutionDataCache.prototype.getResolutionData = function() {
            var rd = null; 
            if(this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp]; 
            }
            if(rd == null) {
                this.cacheSize++; 
                rd = {
                    actuals: new Array(),
                    exactCandidates: new Array(),
                    conversionCandidates: new Array(),
                    id: this.cacheSize
                }; 
                this.rdCache[this.cacheSize] = rd; 
            }
            this.nextUp++; 
            return rd; 
        };
        ResolutionDataCache.prototype.returnResolutionData = function(rd) {
            rd.actuals.length = 0; 
            rd.exactCandidates.length = 0; 
            rd.conversionCandidates.length = 0; 
            this.nextUp = rd.id; 
        };
        return ResolutionDataCache;
    })();
    
    var TypeFlow = (function () {
        function TypeFlow(logger, initScope, parser, checker) {
            this.logger = logger;
            this.initScope = initScope;
            this.parser = parser;
            this.checker = checker;
            this.scope = this.initScope; 
            this.globalScope = this.initScope; 
            this.thisType = null; 
            this.thisFnc = null; 
            this.thisClassNode = null; 
            this.enclosingFncIsMethod = false; 
            this.doubleType = this.checker.doubleType; 
            this.booleanType = this.checker.booleanType; 
            this.stringType = this.checker.stringType; 
            this.anyType = this.checker.anyType; 
            this.regexType = this.anyType; 
            this.nullType = this.checker.nullType; 
            this.voidType = this.checker.voidType; 
            this.arrayAnyType = this.checker.makeArrayType(this.anyType); 
            this._toString = new Tools.Identifier("_toString"); 
            this.coreModule = null; 
            this.coreScope = null; 
            this.arrayInstanceType = null; 
            this.stringInstanceType = null; 
            this.objectInstanceType = null; 
            this.functionInstanceType = null; 
            this.currentScript = null; 
            this.inNewTargetTypeCheck = false; 
            this.inImportTypeCheck = false; 
            this.inTypeRefTypeCheck = false; 
            this.inArrayElementTypeCheck = false; 
            this.resolutionDataCache = new ResolutionDataCache(); 
            this.nestingLevel = 0; 
            this.checker.typeFlow = this; 
        }
        TypeFlow.prototype.initLibs = function() {
            if(this.coreModule == null) {
                this.coreModule = this.globalScope.find("_Core", false, true); 
                if(this.coreModule != null) {
                    this.coreScope = this.coreModule.instanceScope(); 
                    if(this.coreScope != null) {
                        this.arrayInstanceType = (this.coreScope.find("Array", false, true)).type; 
                    }
                }
            }
            var stringSym = this.globalScope.find("String", false, true); 
            if((stringSym != null) && (stringSym.kind() == Tools.SymbolKind.Type)) {
                this.stringInstanceType = (stringSym).type.instanceType; 
            }
            var objectSym = this.globalScope.find("Object", false, true); 
            if((objectSym != null) && (objectSym.kind() == Tools.SymbolKind.Type)) {
                this.objectInstanceType = (objectSym).type.instanceType; 
            }
            var fnSym = this.globalScope.find("Function", false, true); 
            if((fnSym != null) && (fnSym.kind() == Tools.SymbolKind.Type)) {
                this.functionInstanceType = (fnSym).type.instanceType; 
            }
        };
        TypeFlow.prototype.checkAssignableTo = function(ast, type, op) {
            if(!this.checker.assignableTo(ast.type, type)) {
                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, op, this.scope); 
            }
        };
        TypeFlow.prototype.cast = function(ast, type) {
            return this.castWithCoercion(ast, type, true); 
        };
        TypeFlow.prototype.castWithCoercion = function(ast, type, applyCoercion) {
            if(this.checker.assignableTo(ast.type, type)) {
                if(applyCoercion) {
                    if(type == null) {
                        ast.type = this.anyType; 
                    } else  {
                        if(type.isClass()) {
                            ast.type = type.instanceType; 
                        } else  {
                            ast.type = type; 
                        }
                    }
                }
                return ast; 
            } else  {
                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, "cast", this.scope); 
                return ast; 
            }
        };
        TypeFlow.prototype.inScopeTypeCheck = function(ast, enclosingScope) {
            var prevScope = this.scope; 
            this.scope = enclosingScope; 
            var svThisFnc = this.thisFnc; 
            var svThisType = this.thisType; 
            var svCurrentModDecl = this.checker.currentModDecl; 
            var prevMethodStatus = this.enclosingFncIsMethod; 
            var container = this.scope.container; 
            var fnc = null; 
            while(container != null) {
                if(container.kind() == Tools.SymbolKind.Type) {
                    var typeSym = container; 
                    var type = typeSym.type; 
                    if(type.call != null) {
                        if(fnc == null) {
                            this.enclosingFncIsMethod = typeSym.isMethod; 
                            fnc = container.declAST; 
                        }
                    }
                    if(type.isClass()) {
                        this.thisType = type.instanceType; 
                        break;
                    }
                    if(type.isModuleType()) {
                        this.checker.currentModDecl = typeSym.declAST; 
                        break;
                    }
                }
                container = container.container; 
            }
            this.thisFnc = fnc; 
            var updated = this.typeCheck(ast); 
            this.thisFnc = svThisFnc; 
            this.thisType = svThisType; 
            this.checker.currentModDecl = svCurrentModDecl; 
            this.enclosingFncIsMethod = prevMethodStatus; 
            this.scope = prevScope; 
            return updated; 
        };
        TypeFlow.prototype.typeCheck = function(ast) {
            if(ast != null) {
                return ast.typeCheck(this); 
            } else  {
                return null; 
            }
        };
        TypeFlow.prototype.inScopeTypeCheckDecl = function(ast) {
            if(ast.nodeType == Tools.NodeType.VarDecl || ast.nodeType == Tools.NodeType.ArgDecl) {
                this.inScopeTypeCheckBoundDecl(ast); 
            } else  {
                if(ast.nodeType == Tools.NodeType.FuncDecl) {
                    var funcDecl = ast; 
                    if(funcDecl.isAccessor()) {
                        this.typeCheckFunction(funcDecl); 
                    } else  {
                        if((funcDecl.type.symbol.declModule == null) || (!(funcDecl.type.symbol.declModule.modFlags & Tools.ModuleFlags.Ambient))) {
                            this.typeCheckClass(funcDecl.classDecl); 
                        }
                    }
                }
            }
        };
        TypeFlow.prototype.inScopeTypeCheckBoundDecl = function(varDecl) {
            var sym = varDecl.sym; 
            var svThisFnc = this.thisFnc; 
            var svThisType = this.thisType; 
            var prevMethodStatus = this.enclosingFncIsMethod; 
            var prevLocationInfo = this.checker.locationInfo; 
            if((sym != null) && (sym.container != null)) {
                var instanceScope = Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.ES6ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope(); 
                if(Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Property)) {
                    this.thisFnc = sym.container.declAST; 
                }
                if(instanceScope != null) {
                    var prevScope = this.scope; 
                    this.scope = instanceScope; 
                    var container = sym.container; 
                    if((this.checker.units != null) && (sym.unitIndex >= 0) && (sym.unitIndex < this.checker.units.length)) {
                        this.checker.locationInfo = this.checker.units[sym.unitIndex]; 
                    } else  {
                        this.checker.locationInfo = Tools.unknownLocationInfo; 
                    }
                    while(container != null) {
                        if(container.kind() == Tools.SymbolKind.Type) {
                            var typeSym = container; 
                            var type = typeSym.type; 
                            if(type.call != null) {
                                this.enclosingFncIsMethod = typeSym.isMethod; 
                            }
                            if(type.isClass()) {
                                this.thisType = type.instanceType; 
                                break;
                            }
                        }
                        container = container.container; 
                    }
                    this.typeCheckBoundDecl(varDecl); 
                    this.scope = prevScope; 
                }
            }
            this.thisFnc = svThisFnc; 
            this.thisType = svThisType; 
            this.checker.locationInfo = prevLocationInfo; 
            this.enclosingFncIsMethod = prevMethodStatus; 
        };
        TypeFlow.prototype.resolveBoundDecl = function(varDecl) {
            if(varDecl.typeExpr != null) {
                if(varDecl.typeExpr.type == null || (varDecl.typeExpr.type != null && varDecl.typeExpr.type == this.anyType && this.scope != null) || varDecl.typeExpr.type.symbol == null || varDecl.typeExpr.type.symbol.typeCheckStatus != Tools.TypeCheckStatus.Finished) {
                    this.typeCheck(varDecl.typeExpr); 
                }
                varDecl.type = varDecl.typeExpr.type; 
                if(varDecl.sym != null) {
                    varDecl.sym.setType(varDecl.type); 
                }
            } else  {
                if(varDecl.init == null) {
                    if(this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'"); 
                    }
                    varDecl.type = this.anyType; 
                    if(varDecl.sym != null) {
                        if(varDecl.sym.isType()) {
                            var tsym = varDecl.sym; 
                            if(tsym.isMethod) {
                                this.checker.errorReporter.simpleError(varDecl, "Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)"); 
                                return;
                            } else  {
                                this.checker.errorReporter.simpleError(varDecl, "Cannot bind type to variable"); 
                                return;
                            }
                        }
                        varDecl.sym.setType(varDecl.type); 
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckBoundDecl = function(varDecl) {
            var infSym = varDecl.sym; 
            if(infSym == null) {
                if(varDecl.init != null) {
                    varDecl.init = this.typeCheck(varDecl.init); 
                    varDecl.type = varDecl.init.type; 
                } else  {
                    if(this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'"); 
                    }
                    varDecl.type = this.anyType; 
                }
            } else  {
                if(infSym.typeCheckStatus == Tools.TypeCheckStatus.Started) {
                    if(this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'"); 
                    }
                    varDecl.type = this.anyType; 
                    infSym.setType(this.anyType); 
                } else  {
                    if(infSym.typeCheckStatus == Tools.TypeCheckStatus.NotStarted) {
                        infSym.typeCheckStatus = Tools.TypeCheckStatus.Started; 
                        var resolved = false; 
                        if(varDecl.type == null) {
                            if(varDecl.typeExpr != null) {
                                this.resolveBoundDecl(varDecl); 
                                resolved = true; 
                                varDecl.type = varDecl.typeExpr.type; 
                                infSym.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
                            }
                        }
                        if(varDecl.init != null) {
                            if(Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.Ambient)) {
                                this.checker.errorReporter.simpleError(varDecl, "ambient variable can not have an initializer"); 
                            }
                            var isLocalStatic = Tools.hasFlag(varDecl.varFlags, Tools.VarFlags.LocalStatic); 
                            var prevScope = this.scope; 
                            var applyTargetType = !varDecl.init.isParenthesized; 
                            if(isLocalStatic) {
                                this.scope = varDecl.sym.container.getType().memberScope; 
                            }
                            this.checker.typeCheckWithTargetType(varDecl.type, applyTargetType, varDecl.init); 
                            this.scope = prevScope; 
                            if(varDecl.type != null) {
                                var preserveScope = false; 
                                var preservedContainedScope = null; 
                                if(varDecl.init.type != null) {
                                    preservedContainedScope = varDecl.init.type.containedScope; 
                                    preserveScope = true; 
                                }
                                varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType); 
                                if(preserveScope && varDecl.init.type.containedScope == null) {
                                    varDecl.init.type.containedScope = preservedContainedScope; 
                                }
                            } else  {
                                varDecl.type = varDecl.init.type == this.checker.undefinedType ? this.anyType : varDecl.init.type; 
                                if(varDecl.type == this.voidType) {
                                    this.checker.errorReporter.simpleError(varDecl, ("can not assign to variable " + varDecl.id.text) + " a value of type void"); 
                                    varDecl.type = this.anyType; 
                                } else  {
                                    if(varDecl.type == this.nullType) {
                                        varDecl.type = this.anyType; 
                                    }
                                }
                            }
                            infSym.setType(varDecl.type); 
                        } else  {
                            if(!resolved) {
                                this.resolveBoundDecl(varDecl); 
                            }
                        }
                        infSym.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
                    } else  {
                        if((infSym.typeCheckStatus == Tools.TypeCheckStatus.Finished) && (infSym.declAST != varDecl)) {
                            if(varDecl.init != null) {
                                varDecl.init = this.typeCheck(varDecl.init); 
                                varDecl.type = infSym.getType(); 
                                varDecl.init = this.cast(varDecl.init, varDecl.type); 
                            }
                        }
                    }
                }
            }
            if(varDecl.id != null && varDecl.sym != null) {
                varDecl.id.sym = varDecl.sym; 
            }
            return varDecl; 
        };
        TypeFlow.prototype.typeCheckSuper = function(ast) {
            if((this.thisType != null) && (this.enclosingFncIsMethod) && (this.thisType.baseClass() != null)) {
                ast.type = this.thisType.baseClass(); 
            } else  {
                ast.type = this.anyType; 
                this.checker.errorReporter.invalidSuperReference(ast); 
            }
            return ast; 
        };
        TypeFlow.prototype.typeCheckThis = function(ast) {
            if(this.thisFnc == null) {
                if(this.thisType != null) {
                    if(this.thisClassNode && this.thisClassNode.nty == Tools.NodeType.ES6Class) {
                        this.checker.errorReporter.simpleError(ast, "Uses of 'this' are illegal within the outer class body"); 
                        ast.type = this.anyType; 
                    } else  {
                        ast.type = this.thisType; 
                    }
                } else  {
                    ast.type = this.anyType; 
                }
            } else  {
                if(this.thisFnc.isMethod() || this.thisFnc.isConstructor || this.thisFnc.isTargetTypedAsMethod) {
                    if(this.thisType != null) {
                        ast.type = this.thisType; 
                    } else  {
                        ast.type = this.anyType; 
                    }
                } else  {
                    ast.type = this.anyType; 
                }
            }
            if(!this.enclosingFncIsMethod && this.thisFnc != null && Tools.hasFlag(this.thisFnc.fncFlags, Tools.FncFlags.IsFatArrowFunction)) {
                if(this.thisFnc.boundToProperty != null) {
                    var container = this.thisFnc.boundToProperty.sym.container; 
                    if(container.declAST.nodeType == Tools.NodeType.FuncDecl) {
                        (container.declAST).setHasSelfReference(); 
                    }
                } else  {
                    var encFnc = this.thisFnc.enclosingFnc; 
                    var firstEncFnc = encFnc; 
                    var foundMeth = false; 
                    while(encFnc != null) {
                        if(encFnc.isMethod()) {
                            encFnc.setHasSelfReference(); 
                            foundMeth = true; 
                            break;
                        }
                        encFnc = encFnc.enclosingFnc; 
                    }
                    if(!foundMeth && firstEncFnc) {
                        firstEncFnc.setHasSelfReference(); 
                    }
                    if(foundMeth && this.thisType) {
                        ast.type = this.thisType; 
                    }
                }
            }
            return ast; 
        };
        TypeFlow.prototype.typeCheckSelf = function(ast) {
            if(this.thisType == null) {
                ast.type = this.anyType; 
                this.checker.errorReporter.simpleError(ast, "reference to 'self' outside of class scope"); 
            } else  {
                ast.type = this.thisType; 
                if(!this.enclosingFncIsMethod) {
                    if(this.thisFnc != null) {
                        if(this.thisFnc.isConstructor || this.thisFnc.isMethod()) {
                            this.thisFnc.setHasSelfReference(); 
                        } else  {
                            if(this.thisFnc.boundToProperty != null) {
                                var container = this.thisFnc.boundToProperty.sym.container; 
                                if(container.declAST.nodeType == Tools.NodeType.FuncDecl) {
                                    (container.declAST).setHasSelfReference(); 
                                }
                            } else  {
                                var encFnc = this.thisFnc.enclosingFnc; 
                                while(encFnc != null) {
                                    if(encFnc.isMethod()) {
                                        encFnc.setHasSelfReference(); 
                                        break;
                                    }
                                    encFnc = encFnc.enclosingFnc; 
                                }
                            }
                        }
                    }
                }
            }
            return ast; 
        };
        TypeFlow.prototype.setTypeFromSymbol = function(ast, symbol) {
            if(symbol.isVariable()) {
                if(symbol.isInferenceSymbol()) {
                    var infSym = symbol; 
                    if((infSym.declAST != null) && (infSym.typeCheckStatus != Tools.TypeCheckStatus.Finished)) {
                        this.inScopeTypeCheckDecl(infSym.declAST); 
                    }
                    if(!this.checker.styleSettings.innerScopeDeclEscape) {
                        if((infSym.declAST != null) && (infSym.declAST.nodeType == Tools.NodeType.VarDecl)) {
                            if(this.nestingLevel < (infSym.declAST).nestingLevel) {
                                this.checker.errorReporter.styleError(ast, "reference to variable defined in more nested scope"); 
                            }
                        }
                    }
                }
                ast.type = symbol.getType(); 
                if(!symbol.writeable()) {
                    ast.flags = ast.flags & (~(Tools.ASTFlags.Writeable)); 
                }
            } else  {
                if(symbol.isType()) {
                    ast.type = symbol.getType(); 
                    ast.flags = ast.flags & (~(Tools.ASTFlags.Writeable)); 
                } else  {
                    ast.type = this.anyType; 
                    this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name); 
                }
            }
        };
        TypeFlow.prototype.typeCheckName = function(ast) {
            var identifier = ast; 
            if(this.checker.inWith) {
                identifier.type = this.anyType; 
            } else  {
                var typespace = false; 
                var idText = identifier.text; 
                var originalIdText = idText; 
                var isDynamicModuleName = Tools.isQuoted(identifier.text); 
                var symbol = this.scope.find(idText, false, typespace); 
                if(symbol == null && isDynamicModuleName) {
                    if(!symbol) {
                        idText = Tools.swapQuotes(originalIdText); 
                        symbol = this.scope.find(idText, false, typespace); 
                    }
                    if(!symbol) {
                        idText = Tools.stripQuotes(originalIdText) + ".str"; 
                        symbol = this.scope.find(idText, false, typespace); 
                    }
                    if(!symbol) {
                        idText = Tools.stripQuotes(originalIdText) + ".d.str"; 
                        symbol = this.scope.find(idText, false, typespace); 
                    }
                    if(!symbol && !Tools.isRelative(originalIdText)) {
                        idText = originalIdText; 
                        var strippedIdText = Tools.stripQuotes(idText); 
                        var path = Tools.getRootFilePath(this.currentScript.locationInfo.filename); 
                        while(symbol == null && path != "" && path != "/") {
                            idText = Tools.normalizePath((path + strippedIdText) + ".str"); 
                            symbol = this.scope.find(idText, false, typespace); 
                            if(symbol == null) {
                                idText = Tools.changePathToDSTR(idText); 
                                symbol = this.scope.find(idText, false, typespace); 
                            }
                            if(symbol == null) {
                                path = Tools.normalizePath(path + ".."); 
                                path = path ? path + "/" : path; 
                            }
                        }
                    }
                }
                if(symbol == null) {
                    if(!identifier.isMissing()) {
                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text); 
                    }
                    identifier.type = this.anyType; 
                } else  {
                    if(this.inNewTargetTypeCheck && symbol.isInferenceSymbol() && (symbol).typeCheckStatus != Tools.TypeCheckStatus.Finished) {
                        this.checker.errorReporter.simpleError(ast, ("Symbol '" + identifier.text) + "' is referenced before its declaration"); 
                    }
                    if(Tools.optimizeModuleCodeGen && symbol != null && symbol.isType()) {
                        var symType = symbol.getType(); 
                        if(symType != null && (symbol).isAlias && (symbol).onlyReferencedAsTypeRef) {
                            var modDecl = symType.symbol.declAST; 
                            if(modDecl != null && Tools.hasFlag(modDecl.modFlags, Tools.ModuleFlags.IsDynamic)) {
                                (symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck; 
                            }
                        }
                    }
                    this.setTypeFromSymbol(ast, symbol); 
                    identifier.sym = symbol; 
                    if(this.thisFnc != null) {
                        if(this.thisFnc.type != null && symbol.container != this.thisFnc.type.symbol) {
                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol; 
                        }
                    }
                    if(this.checker.symTrack) {
                        if(this.thisFnc != null) {
                            if(((symbol.kind() == Tools.SymbolKind.Variable) || (symbol.kind() == Tools.SymbolKind.Parameter)) && (symbol.container != this.thisFnc.type.symbol) && (symbol.container != this.checker.gloMod)) {
                                if(Tools.hasFlag(this.checker.traceFlags, Tools.TraceFlags.Symbols)) {
                                    this.checker.errorReporter.simpleError(identifier, "clo ref " + symbol.name); 
                                }
                                identifier.cloId = this.thisFnc.addCloRef(identifier, symbol); 
                            }
                        }
                        if(Tools.hasFlag(this.checker.traceFlags, Tools.TraceFlags.Symbols)) {
                            this.checker.errorReporter.showRef(identifier, identifier.text, identifier.sym); 
                        }
                        symbol.addRef(ast); 
                    }
                }
            }
            return ast; 
        };
        TypeFlow.prototype.typeCheckScript = function(script) {
            this.checker.locationInfo = script.locationInfo; 
            this.scope = this.checker.globalScope; 
            if(!script.topLevelMod) {
                this.addLocalsFromScope(this.scope, this.checker.gloMod, script.vars, this.checker.globals, true); 
            }
            this.currentScript = script; 
            script.bod = this.typeCheck(script.bod); 
            this.currentScript = null; 
            return script; 
        };
        TypeFlow.prototype.typeCheckBitNot = function(ast) {
            var unex = ast; 
            unex.operand = this.typeCheck(unex.operand); 
            unex.type = this.doubleType; 
            return unex; 
        };
        TypeFlow.prototype.typeCheckUnaryNumberOperator = function(ast) {
            var unex = ast; 
            unex.operand = this.typeCheck(unex.operand); 
            unex.type = this.doubleType; 
            return ast; 
        };
        TypeFlow.prototype.typeCheckLogNot = function(ast) {
            var unex = ast; 
            unex.operand = this.typeCheck(unex.operand); 
            unex.type = this.booleanType; 
            return unex; 
        };
        TypeFlow.prototype.astIsWriteable = function(ast) {
            return Tools.hasFlag(ast.flags, Tools.ASTFlags.Writeable); 
        };
        TypeFlow.prototype.typeCheckIncOrDec = function(ast) {
            var unex = ast; 
            var lval = unex.operand; 
            if(!this.astIsWriteable(unex)) {
                this.checker.errorReporter.valueCannotBeModified(unex); 
                unex.type = this.doubleType; 
                return unex; 
            } else  {
                return this.typeCheckUnaryNumberOperator(ast); 
            }
        };
        TypeFlow.prototype.typeCheckBitwiseOperator = function(ast, assignment) {
            var binex = ast; 
            var resultType = null; 
            binex.operand1 = this.typeCheck(binex.operand1); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            var leftType = binex.operand1.type; 
            var rightType = binex.operand2.type; 
            if(assignment && (!this.astIsWriteable(binex))) {
                this.checker.errorReporter.valueCannotBeModified(binex); 
            }
            if(this.checker.styleSettings.bitwise) {
                this.checker.errorReporter.styleError(ast, "use of " + Tools.nodeTypeTable[binex.nodeType]); 
            }
            if(leftType.subtype(this.doubleType, this.checker) && (rightType.subtype(this.doubleType, this.checker))) {
                resultType = this.doubleType; 
            } else  {
                if((leftType == this.booleanType) && (rightType == this.booleanType)) {
                    resultType = this.booleanType; 
                } else  {
                    if(leftType == this.anyType) {
                        if((rightType == this.anyType) || (rightType == this.doubleType) || (rightType == this.booleanType)) {
                            resultType = this.anyType; 
                        }
                    } else  {
                        if(rightType == this.anyType) {
                            if((leftType == this.anyType) || (leftType == this.doubleType) || (leftType == this.booleanType)) {
                                resultType = this.anyType; 
                            }
                        }
                    }
                }
            }
            if(resultType == null) {
                resultType = this.anyType; 
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope); 
            }
            binex.type = resultType; 
            return binex; 
        };
        TypeFlow.prototype.typeCheckArithmeticOperator = function(ast, assignment) {
            var binex = ast; 
            binex.operand1 = this.typeCheck(binex.operand1); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            var leftType = binex.operand1.type; 
            var rightType = binex.operand2.type; 
            if(assignment && (!this.astIsWriteable(binex))) {
                this.checker.errorReporter.valueCannotBeModified(binex); 
            }
            if(this.checker.styleSettings.bitwise && ((binex.nodeType == Tools.NodeType.And) || (binex.nodeType == Tools.NodeType.Or) || (binex.nodeType == Tools.NodeType.AsgAnd) || (binex.nodeType == Tools.NodeType.AsgOr))) {
                this.checker.errorReporter.styleError(ast, "use of " + Tools.nodeTypeTable[binex.nodeType]); 
            }
            if(leftType == null || rightType == null) {
                this.checker.errorReporter.simpleError(binex, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?"); 
                binex.type = this.anyType; 
                return binex; 
            }
            var nodeType = binex.nodeType; 
            if(((nodeType == Tools.NodeType.Add) || (nodeType == Tools.NodeType.AsgAdd)) && ((leftType == this.stringType) || (rightType == this.stringType))) {
                binex.type = this.stringType; 
            } else  {
                if(leftType.subtype(this.doubleType, this.checker) && rightType.subtype(this.doubleType, this.checker)) {
                    binex.type = this.doubleType; 
                } else  {
                    if(((leftType == this.anyType) && ((rightType == this.anyType) || (rightType.subtype(this.doubleType, this.checker)))) || ((rightType == this.anyType) && ((leftType == this.anyType) || (leftType.subtype(this.doubleType, this.checker))))) {
                        binex.type = this.anyType; 
                    } else  {
                        binex.type = this.anyType; 
                        this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope); 
                    }
                }
            }
            return binex; 
        };
        TypeFlow.prototype.typeCheckDotOperator = function(ast) {
            var binex = ast; 
            var leftIsFnc = false; 
            binex.operand1 = this.typeCheck(binex.operand1); 
            var leftType = binex.operand1.type; 
            var leftScope = null; 
            if(leftType != null) {
                if((leftType == this.anyType) || leftType.isDouble()) {
                    binex.type = this.anyType; 
                    return binex; 
                } else  {
                    if(leftType == this.stringType) {
                        if(this.stringInstanceType != null) {
                            leftScope = this.stringInstanceType.memberScope; 
                        } else  {
                            binex.type = this.anyType; 
                            return binex; 
                        }
                    } else  {
                        if(((leftType.call != null) || (leftType.construct != null)) && (leftType.members == null)) {
                            if(this.functionInstanceType != null) {
                                leftScope = this.functionInstanceType.memberScope; 
                            } else  {
                                binex.type = this.anyType; 
                                return binex; 
                            }
                        } else  {
                            if(leftType.elementType != null) {
                                if(this.arrayInstanceType != null) {
                                    var arrInstType = leftType.elementType.getArrayBase(this.arrayInstanceType, this.checker); 
                                    leftScope = arrInstType.memberScope; 
                                } else  {
                                    binex.type = this.anyType; 
                                    return binex; 
                                }
                            } else  {
                                leftScope = leftType.memberScope; 
                            }
                        }
                    }
                }
            }
            if(leftScope == null) {
                if(leftType != this.nullType) {
                    this.checker.errorReporter.expectedClassOrInterface(binex); 
                }
                binex.type = this.anyType; 
            } else  {
                var propertyName = binex.operand2; 
                var lhsIsEnclosingType = this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType; 
                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, false); 
                if((symbol == null) && (leftType != null)) {
                    if(((leftType.call != null) || (leftType.construct != null)) && (this.functionInstanceType != null)) {
                        leftScope = this.functionInstanceType.memberScope; 
                    } else  {
                        if(leftType.isReferenceType()) {
                            if(this.objectInstanceType != null) {
                                leftScope = this.objectInstanceType.memberScope; 
                                symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, false); 
                            }
                        }
                    }
                }
                if((symbol == null) || (!symbol.visible(leftScope, this.checker))) {
                    binex.type = this.anyType; 
                    if((leftType.call != null) && (!leftType.call.isMethod)) {
                    } else  {
                        if(symbol == null) {
                            this.checker.errorReporter.unresolvedSymbol(propertyName, propertyName.text); 
                        } else  {
                            this.checker.errorReporter.simpleError(binex, propertyName.text + " not visible"); 
                        }
                    }
                } else  {
                    if(symbol.isVariable()) {
                        if(symbol.isInferenceSymbol()) {
                            var infSym = symbol; 
                            if(infSym.declAST != null && infSym.typeCheckStatus != Tools.TypeCheckStatus.Finished) {
                                this.inScopeTypeCheckDecl(infSym.declAST); 
                            }
                        }
                    }
                    propertyName.sym = symbol; 
                    binex.type = symbol.getType(); 
                }
            }
            if(binex.type == null) {
                binex.type = this.anyType; 
            }
            return binex; 
        };
        TypeFlow.prototype.typeCheckBooleanOperator = function(ast) {
            var binex = ast; 
            binex.operand1 = this.typeCheck(binex.operand1); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            var leftType = binex.operand1.type; 
            var rightType = binex.operand2.type; 
            if((!(this.checker.assignableTo(leftType, rightType))) && (!(this.checker.assignableTo(rightType, leftType)))) {
                this.checker.errorReporter.valuesCannotBeCompared(binex, leftType, rightType); 
            }
            binex.type = this.booleanType; 
            return binex; 
        };
        TypeFlow.prototype.typeCheckAsgOperator = function(ast) {
            var binex = ast; 
            var applyTargetType = !binex.operand2.isParenthesized; 
            binex.operand1 = this.typeCheck(binex.operand1); 
            this.checker.typeCheckWithTargetType(binex.operand1.type, applyTargetType, binex.operand2); 
            var leftType = binex.operand1.type; 
            var rightType = binex.operand2.type; 
            if(!(this.astIsWriteable(binex.operand1))) {
                this.checker.errorReporter.valueCannotBeModified(binex); 
            }
            if(binex.operand1.nodeType == Tools.NodeType.Call) {
                var callEx = binex.operand1; 
            }
            var preserveScope = false; 
            var preservedContainedScope = null; 
            if(binex.operand2.type != null) {
                preservedContainedScope = binex.operand2.type.containedScope; 
                preserveScope = true; 
            }
            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType); 
            if(preserveScope && binex.operand2.type.containedScope == null) {
                binex.operand2.type.containedScope = preservedContainedScope; 
            }
            binex.type = rightType; 
            return binex; 
        };
        TypeFlow.prototype.typeCheckIndex = function(ast) {
            var binex = ast; 
            binex.operand1 = this.typeCheck(binex.operand1); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            if(!this.checker.styleSettings.literalSubscript) {
                if(binex.operand2.nodeType == Tools.NodeType.QString) {
                    this.checker.errorReporter.styleError(ast, "literal subscript (use '.' instead)"); 
                }
            }
            var collectionType = binex.operand1.type; 
            if(collectionType == this.anyType) {
                binex.type = this.anyType; 
            } else  {
                if(collectionType == this.stringType) {
                    binex.type = this.stringType; 
                } else  {
                    if(collectionType == null) {
                        binex.type = this.anyType; 
                    } else  {
                        if(collectionType.elementType != null) {
                            binex.type = collectionType.elementType; 
                        } else  {
                            var itemType = collectionType.getItemType(binex.operand2.type, this.checker, binex.operand2); 
                            if(itemType != null) {
                                binex.type = itemType; 
                            } else  {
                                binex.type = this.anyType; 
                                this.checker.errorReporter.indexLHS(binex); 
                            }
                        }
                    }
                }
            }
            return binex; 
        };
        TypeFlow.prototype.typeCheckInOperator = function(binex) {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            binex.type = this.booleanType; 
            return binex; 
        };
        TypeFlow.prototype.typeCheckShift = function(binex, assignment) {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType); 
            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType); 
            if(assignment && (!(this.astIsWriteable(binex.operand1)))) {
                this.checker.errorReporter.valueCannotBeModified(binex); 
            }
            binex.type = this.doubleType; 
            return binex; 
        };
        TypeFlow.prototype.typeCheckQMark = function(trinex) {
            trinex.operand1 = this.typeCheck(trinex.operand1); 
            trinex.operand2 = this.typeCheck(trinex.operand2); 
            trinex.operand3 = this.typeCheck(trinex.operand3); 
            var leftType = trinex.operand2.type; 
            var rightType = trinex.operand3.type; 
            if(leftType == rightType) {
                trinex.type = leftType; 
            } else  {
                if(this.checker.assignableTo(rightType, leftType)) {
                    trinex.operand3 = this.cast(trinex.operand3, leftType); 
                } else  {
                    if(this.checker.assignableTo(leftType, rightType)) {
                        trinex.operand2 = this.cast(trinex.operand2, rightType); 
                    } else  {
                        trinex.type = this.anyType; 
                        this.checker.errorReporter.qMarkIncompatibleTypes(trinex, leftType, rightType, this.scope); 
                    }
                }
            }
            if(trinex.type == null) {
                trinex.type = this.anyType; 
            }
            return trinex; 
        };
        TypeFlow.prototype.addFormals = function(container, signature, table) {
            var len = signature.parameters.length; 
            for(var i = 0; i < len; i++) {
                var symbol = signature.parameters[i]; 
                symbol.container = container; 
                table.add(symbol.name, symbol); 
            }
        };
        TypeFlow.prototype.addLocalsFromScope = function(scope, container, vars, table, isModContainer) {
            var len = vars.members.length; 
            var hasArgsDef = false; 
            for(var i = 0; i < len; i++) {
                var local = vars.members[i]; 
                if(((local.sym == null) || (local.sym.kind() != Tools.SymbolKind.Field))) {
                    var result = null; 
                    if((result = table.lookup(local.id.text)) == null) {
                        var localVar = new Tools.ValueLocation(); 
                        localVar.typeLink = new Tools.TypeLink(); 
                        var varSym = null; 
                        if(Tools.hasFlag(local.varFlags, Tools.VarFlags.Static)) {
                            local.varFlags |= Tools.VarFlags.LocalStatic; 
                            varSym = new Tools.FieldSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, true, localVar); 
                        } else  {
                            varSym = new Tools.VariableSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, localVar); 
                        }
                        varSym.transferVarFlags(local.varFlags); 
                        localVar.symbol = varSym; 
                        varSym.declAST = local; 
                        localVar.typeLink.ast = local.typeExpr; 
                        this.checker.resolveTypeLink(scope, localVar.typeLink, false); 
                        if((local.type == null) && (local.init == null)) {
                            local.type = this.anyType; 
                        }
                        localVar.typeLink.type = local.type; 
                        localVar.symbol.container = container; 
                        local.sym = localVar.symbol; 
                        table.add(local.id.text, varSym); 
                        if(local.id.text == "arguments") {
                            hasArgsDef = true; 
                        }
                    } else  {
                        local.type = result.getType(); 
                        local.sym = result; 
                    }
                }
            }
            if(!isModContainer) {
                if(!hasArgsDef) {
                    var argLoc = new Tools.ValueLocation(); 
                    argLoc.typeLink = new Tools.TypeLink(); 
                    var theArgSym = new Tools.VariableSymbol("arguments", vars.minChar, this.checker.locationInfo.unitIndex, argLoc); 
                    argLoc.typeLink.ast = new Tools.Identifier("IArguments"); 
                    this.checker.resolveTypeLink(scope, argLoc.typeLink, false); 
                    table.add("arguments", theArgSym); 
                }
            }
        };
        TypeFlow.prototype.addConstructorLocalArgs = function(container, args, table) {
            if(args != null) {
                var len = args.members.length; 
                for(var i = 0; i < len; i++) {
                    var local = args.members[i]; 
                    if((local.sym == null) || (local.sym.kind() != Tools.SymbolKind.Field)) {
                        var result = null; 
                        if((result = table.lookup(local.id.text)) == null) {
                            this.resolveBoundDecl(local); 
                            var localVar = new Tools.ValueLocation(); 
                            localVar.typeLink = new Tools.TypeLink(); 
                            var varSym = new Tools.ParameterSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, localVar); 
                            varSym.declAST = local; 
                            localVar.symbol = varSym; 
                            localVar.typeLink.type = local.type; 
                            localVar.symbol.container = container; 
                            local.sym = localVar.symbol; 
                            table.add(local.id.text, varSym); 
                        } else  {
                            local.type = result.getType(); 
                            local.sym = result; 
                        }
                    }
                }
            }
        };
        TypeFlow.prototype.checkInitSelf = function(funcDecl) {
            if(!funcDecl.isMethod()) {
                var freeVars = funcDecl.freeVariables; 
                for(var k = 0, len = freeVars.length; k < len; k++) {
                    var sym = freeVars[k]; 
                    if(sym.isInstanceProperty()) {
                        return true; 
                    }
                }
            }
            var fns = funcDecl.scopes; 
            var fnsLen = fns.members.length; 
            for(var j = 0; j < fnsLen; j++) {
                var fn = fns.members[j]; 
                if(this.checkInitSelf(fn)) {
                    return true; 
                }
            }
            return false; 
        };
        TypeFlow.prototype.checkPromoteFreeVars = function(funcDecl, constructorSym) {
            var freeVars = funcDecl.freeVariables; 
            for(var k = 0, len = freeVars.length; k < len; k++) {
                var sym = freeVars[k]; 
                if((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {
                    Tools.instanceFilter.reset(); 
                    if(this.scope.search(Tools.instanceFilter, sym.name, false, false) != null) {
                        this.checker.errorReporter.simpleError(funcDecl, ((("Constructor-local variable shadows class property '" + sym.name) + "'. To access the class property, use 'self.") + sym.name) + "'"); 
                    }
                    this.checker.errorReporter.simpleError(funcDecl, ("Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '" + sym.name) + "' to a class property"); 
                }
            }
        };
        TypeFlow.prototype.allReturnsAreVoid = function(funcDecl) {
            var allReturnsAreVoid = true; 
            if(funcDecl.signature.returnType.type == null) {
                var context = {
                    goChildren: true,
                    goNextSibling: true
                }; 
                var preFindReturnExpressionTypes = function(ast, parent, context) {
                    var go = true; 
                    switch(ast.nodeType) {
                        case Tools.NodeType.FuncDecl: {
                            go = false; 
                            break;

                        }
                        case Tools.NodeType.Return: {
                            var returnStmt = ast; 
                            if(returnStmt.returnExpression != null) {
                                allReturnsAreVoid = false; 
                                go = false; 
                            }

                        }
                        default: {
                            break;

                        }
                    }
                    context.goChildren = go; 
                    context.goNextSibling = go; 
                    return ast; 
                }; 
                funcDecl.bod.walk(preFindReturnExpressionTypes, null, funcDecl, context); 
            }
            return allReturnsAreVoid; 
        };
        TypeFlow.prototype.es6ConstructorHasSuperCall = function(funcDecl) {
            var foundSuper = false; 
            var context = {
                goChildren: true,
                goNextSibling: true
            }; 
            var preFindSuperCall = function(ast, parent, context) {
                var go = true; 
                switch(ast.nodeType) {
                    case Tools.NodeType.FuncDecl: {
                        go = false; 
                        break;

                    }
                    case Tools.NodeType.Call: {
                        var call = ast; 
                        if(call.target.nodeType == Tools.NodeType.Super) {
                            go = false; 
                            foundSuper = true; 
                            break;
                        }
                        break;

                    }
                    default: {
                        break;

                    }
                }
                return ast; 
            }; 
            funcDecl.bod.walk(preFindSuperCall, null, funcDecl, context); 
            return foundSuper; 
        };
        TypeFlow.prototype.typeCheckFunction = function(funcDecl) {
            this.nestingLevel = 0; 
            var fnType = funcDecl.type; 
            var fgSym = fnType.symbol; 
            var signature = funcDecl.signature; 
            if(signature.typeCheckStatus == Tools.TypeCheckStatus.Finished) {
                return funcDecl; 
            } else  {
                if(signature.typeCheckStatus == Tools.TypeCheckStatus.Started) {
                    if(funcDecl.bod != null && !funcDecl.isSignature() && !(funcDecl.isConstructor) && this.allReturnsAreVoid(funcDecl)) {
                        signature.returnType.type = this.voidType; 
                        return funcDecl; 
                    } else  {
                        if(funcDecl.returnTypeAnnotation == null) {
                            if(this.checker.styleSettings.implicitAny) {
                                this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'"); 
                            }
                            signature.returnType.type = this.anyType; 
                        }
                        return funcDecl; 
                    }
                }
            }
            signature.typeCheckStatus = Tools.TypeCheckStatus.Started; 
            var prevScope = this.scope; 
            var prevFnc = this.thisFnc; 
            var prevMethodStatus = this.enclosingFncIsMethod; 
            var prevClassNode = this.thisClassNode; 
            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor; 
            this.thisFnc = funcDecl; 
            var container = funcDecl.type.symbol; 
            var prevThisType = this.thisType; 
            var prevLocationInfo = this.checker.locationInfo; 
            var funcTable = null; 
            var setNewTargetType = false; 
            var targetParams = null; 
            var accessorType = null; 
            var isGetter = funcDecl.isAccessor() && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.GetAccessor); 
            var isSetter = funcDecl.isAccessor() && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.SetAccessor); 
            var prevModDecl = this.checker.currentModDecl; 
            if(funcDecl.isConstructor && !funcDecl.isOverload) {
                if(fnType.instanceType == null) {
                    this.checker.errorReporter.simpleError(funcDecl, "Malformed function body"); 
                    return funcDecl; 
                }
                this.scope = fnType.instanceType.constructorScope; 
                var ssb = this.scope; 
                funcTable = ssb.valueMembers.allMembers; 
            } else  {
                if(funcDecl.isSpecialFn() || funcDecl.isOverload) {
                    funcTable = funcDecl.symbols; 
                    if(!Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.Static)) {
                        this.scope = fnType.containedScope; 
                    }
                } else  {
                    if(funcDecl.bod) {
                        this.scope = fnType.containedScope; 
                    }
                    var ssb = this.scope; 
                    if(ssb != null && ssb.valueMembers != null) {
                        funcTable = ssb.valueMembers.allMembers; 
                    }
                }
            }
            if(funcDecl.isConstructor && funcDecl.bod && Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod)) {
                var hasBaseType = Tools.hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, Tools.TypeFlags.HasBaseType); 
                var noSuperCallAllowed = !hasBaseType || Tools.hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, Tools.TypeFlags.HasBaseTypeOfObject); 
                var superCallMustBeFirst = Tools.hasFlag((funcDecl.classDecl).varFlags, Tools.VarFlags.ES6ClassSuperMustBeFirstCallInConstructor); 
                if(noSuperCallAllowed && this.es6ConstructorHasSuperCall(funcDecl)) {
                    this.checker.errorReporter.simpleError(funcDecl, "Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class"); 
                } else  {
                    if(hasBaseType) {
                        if(superCallMustBeFirst) {
                            if(!funcDecl.bod || !funcDecl.bod.members.length || !(funcDecl.bod.members[0].nodeType == Tools.NodeType.Call && (funcDecl.bod.members[0]).target.nodeType == Tools.NodeType.Super)) {
                                this.checker.errorReporter.simpleError(funcDecl, "If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor"); 
                            }
                        } else  {
                            if(!this.es6ConstructorHasSuperCall(funcDecl)) {
                                this.checker.errorReporter.simpleError(funcDecl, "Constructors for derived classes must contain a call to the class's 'super' constructor"); 
                            }
                        }
                    }
                }
            }
            if(funcDecl.isMethod() && funcDecl.type.enclosingType) {
                var enclosingClassNode = null; 
                if(funcDecl.type.enclosingType.symbol.declAST.nodeType == Tools.NodeType.FuncDecl) {
                    enclosingClassNode = (funcDecl.type.enclosingType.symbol.declAST).classDecl; 
                } else  {
                    if(funcDecl.type.enclosingType.symbol.declAST.nodeType == Tools.NodeType.ES6Class) {
                        enclosingClassNode = funcDecl.type.enclosingType.symbol.declAST; 
                    }
                }
                if(enclosingClassNode) {
                    this.thisClassNode = enclosingClassNode; 
                }
            }
            if(fnType.enclosingType != null) {
                ;; 
                var enclosingSym = fnType.symbol.container; 
                if(enclosingSym != null && enclosingSym.isType() && enclosingSym.getType().isClass()) {
                    enclosingSym = enclosingSym.container; 
                }
                if(enclosingSym != null && enclosingSym.declAST != null && enclosingSym.declAST.nodeType == Tools.NodeType.Module) {
                    this.checker.currentModDecl = enclosingSym.declAST; 
                }
            }
            if((this.checker.units != null) && (funcDecl.unitIndex >= 0) && (funcDecl.unitIndex < this.checker.units.length)) {
                this.checker.locationInfo = this.checker.units[funcDecl.unitIndex]; 
            } else  {
                this.checker.locationInfo = Tools.unknownLocationInfo; 
            }
            if(fnType.enclosingType != null) {
                this.thisType = fnType.enclosingType; 
            } else  {
                this.thisType = prevThisType; 
            }
            var paramLen = signature.parameters.length; 
            if((!funcDecl.isConstructor) && (funcDecl.bod != null) && (!funcDecl.isSignature())) {
                var tmpParamScope = this.scope; 
                var ssb = this.scope; 
                if(!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {
                    if(prevScope != null && funcDecl.name != null && !funcDecl.name.isMissing()) {
                        var considerSym = prevScope.findAmbient(funcDecl.name.text, false, false); 
                        if(considerSym != null && considerSym.declAST != null && considerSym.declAST.type != null) {
                            this.checker.setTargetType(considerSym.declAST.type); 
                            setNewTargetType = true; 
                        }
                    }
                    if(this.checker.hasTargetType()) {
                        var candidateTypeContext = this.checker.getTargetTypeContext(); 
                        var candidateType = candidateTypeContext.targetType; 
                        if(this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {
                            var candidateSigs = candidateType.construct != null ? candidateType.construct : candidateType.call; 
                            candidateTypeContext.targetSig = candidateSigs.signatures[0]; 
                            var candidateParams = candidateTypeContext.targetSig.parameters; 
                            targetParams = candidateParams; 
                            if(candidateTypeContext.targetSig.declAST != null) {
                                if(candidateTypeContext.targetSig.declAST.isConstructor) {
                                    this.thisType = candidateType.instanceType; 
                                    funcDecl.isTargetTypedAsMethod = true; 
                                } else  {
                                    if(candidateTypeContext.targetSig.declAST.isMethod()) {
                                        this.thisType = candidateTypeContext.targetSig.declAST.type.enclosingType; 
                                        funcDecl.isTargetTypedAsMethod = true; 
                                    }
                                }
                            }
                            fgSym.type = candidateTypeContext.targetType; 
                        } else  {
                            if(candidateType != null && funcDecl.isAccessor()) {
                                accessorType = candidateType; 
                                candidateTypeContext.targetAccessorType = accessorType; 
                            } else  {
                                this.checker.killTargetType(); 
                            }
                        }
                    }
                }
                var paramTable = ssb.valueMembers; 
                this.scope = new Tools.SymbolScopeBuilder(paramTable, null, null, null, prevScope, container); 
                for(var p = 0; p < paramLen; p++) {
                    var param = signature.parameters[p]; 
                    var symbol = param; 
                    var ast = symbol.declAST; 
                    if(this.checker.hasTargetType() && (targetParams != null || (isSetter && accessorType != null))) {
                        ast.type = (isSetter && accessorType != null) ? accessorType : targetParams[p].getType(); 
                        ast.sym.setType(ast.type); 
                        (ast.sym).typeCheckStatus = Tools.TypeCheckStatus.Finished; 
                    } else  {
                        this.typeCheck(ast); 
                    }
                    symbol.container = container; 
                    paramTable.publicMembers.add(symbol.name, symbol); 
                }
                this.scope = tmpParamScope; 
            } else  {
                this.typeCheck(funcDecl.args); 
                for(var p = 0; p < paramLen; p++) {
                    signature.parameters[p].parameter.typeLink.type = funcDecl.args.members[p].type; 
                }
            }
            if((funcDecl.bod != null) && (!funcDecl.isSignature())) {
                if(!(funcDecl.isConstructor)) {
                    this.addFormals(container, signature, funcTable); 
                } else  {
                    if(!Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.ES6ClassMethod)) {
                        this.addConstructorLocalArgs(funcDecl.type.symbol, funcDecl.args, funcTable); 
                    }
                    if((this.thisClassNode != null) && (this.thisClassNode.extendsList != null)) {
                        var tmpScope = this.scope; 
                        var funcMembers = new Tools.ScopedMembers(funcTable); 
                        this.scope = new Tools.FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol, function(sym) {
                            return sym.kind() == Tools.SymbolKind.Parameter; 
                        }); 
                        this.typeCheckBaseCalls(this.thisClassNode.extendsList); 
                        this.scope = tmpScope; 
                    }
                }
                var prevMod = this.checker.currentModDecl; 
                if(funcDecl.type != null && funcDecl.type.symbol != null && !funcDecl.isMethod() && funcDecl.type.symbol.declModule != null) {
                    this.checker.currentModDecl = funcDecl.type.symbol.declModule; 
                }
                this.typeCheck(funcDecl.bod); 
                this.checker.currentModDecl = prevMod; 
                if(this.checker.checkControlFlow) {
                    var cfg = funcDecl.buildControlFlow(); 
                    if(this.checker.printControlFlowGraph) {
                        cfg.print(this.checker.errorReporter.outfile); 
                    }
                    cfg.reportUnreachable(this.checker.errorReporter); 
                    if(this.checker.checkControlFlowUseDef) {
                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol); 
                    }
                }
                if(funcDecl.isConstructor) {
                    var fns = funcDecl.scopes; 
                    var fnsLen = fns.members.length; 
                    var freeVars; 
                    var sym; 
                    var j = 0; 
                    for(; j < fnsLen; j++) {
                        var fn = fns.members[j]; 
                        if(!fn.isSignature()) {
                            if(Tools.hasFlag(fn.fncFlags, Tools.FncFlags.Method) && (!Tools.hasFlag(fn.fncFlags, Tools.FncFlags.Static))) {
                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol); 
                            }
                        }
                    }
                    if(this.checker.addMembersToClassScope) {
                        var initSelf = false; 
                        for(j = 0; j < fnsLen; j++) {
                            var fn = fns.members[j]; 
                            if(!fn.isSignature()) {
                                if(Tools.hasFlag(fn.fncFlags, Tools.FncFlags.Method)) {
                                    if(this.checkInitSelf(fn)) {
                                        fn.setHasSelfReference(); 
                                    }
                                } else  {
                                    if(this.checkInitSelf(fn)) {
                                        initSelf = true; 
                                    }
                                }
                            }
                        }
                        if(initSelf) {
                            funcDecl.setHasSelfReference(); 
                        }
                    }
                }
            }
            this.scope = prevScope; 
            this.thisFnc = prevFnc; 
            this.thisClassNode = prevClassNode; 
            this.enclosingFncIsMethod = prevMethodStatus; 
            this.thisType = prevThisType; 
            this.checker.locationInfo = prevLocationInfo; 
            this.checker.currentModDecl = prevModDecl; 
            signature.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
            if(funcDecl.returnTypeAnnotation) {
                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation); 
                if(signature.returnType.type == null) {
                    this.checker.resolveTypeLink(this.scope, signature.returnType, false); 
                }
            }
            if(funcDecl.returnStatements.length > 0) {
                var collection = {
                    getLength: function() {
                        return funcDecl.returnStatements.length; 
                    },
                    setTypeAtIndex: function(index, type) {
                        funcDecl.returnStatements[index].type = type; 
                    },
                    getTypeAtIndex: function(index) {
                        return funcDecl.returnStatements[index].type; 
                    }
                }; 
                var bestCommonReturnType = funcDecl.returnStatements[0].type; 
                bestCommonReturnType = Tools.findBestCommonType(bestCommonReturnType, null, collection, this.checker); 
                if(bestCommonReturnType) {
                    signature.returnType.type = bestCommonReturnType; 
                } else  {
                    for(var i = 0; i < funcDecl.returnStatements.length; i++) {
                        this.checker.errorReporter.simpleError(funcDecl.returnStatements[i], "Incompatible return type"); 
                    }
                    signature.returnType.type = this.anyType; 
                }
            }
            if(signature.returnType.type == null) {
                if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.HasReturnValue)) {
                    if(this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'"); 
                    }
                    signature.returnType.type = this.anyType; 
                } else  {
                    signature.returnType.type = this.voidType; 
                }
            } else  {
                if(signature.returnType.type == this.nullType) {
                    signature.returnType.type = this.anyType; 
                } else  {
                    if(signature.returnType.type != this.voidType && funcDecl.returnTypeAnnotation != null) {
                        if(!funcDecl.isSignature() && !funcDecl.isConstructor && !Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.HasReturnValue) && !Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.IsFatArrowFunction)) {
                            var onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == Tools.NodeType.Throw); 
                            if(!onlyHasThrow) {
                                this.checker.errorReporter.simpleError(funcDecl, "Function declared a non-void return type, but has no return statement"); 
                            }
                        }
                    }
                }
            }
            if(setNewTargetType) {
                this.checker.unsetTargetType(); 
            }
            if(funcDecl.accessorSymbol != null) {
                var accessorType = funcDecl.accessorSymbol.getType(); 
                if(accessorType != null) {
                    if((Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.GetAccessor) && accessorType != signature.returnType.type) || (funcDecl.args.members.length > 0 && accessorType != funcDecl.args.members[0].type)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Getter and Setter types do not agree"); 
                    }
                } else  {
                    if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.GetAccessor)) {
                        funcDecl.accessorSymbol.setType(signature.returnType.type); 
                    } else  {
                        if(funcDecl.args.members.length != 1) {
                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument"); 
                        } else  {
                            funcDecl.accessorSymbol.setType(funcDecl.args.members[0].type); 
                        }
                    }
                }
            }
            this.typeCheckOverloadSignatures(fnType, funcDecl); 
            return funcDecl; 
        };
        TypeFlow.prototype.typeCheckBases = function(type) {
            var seenInterface = false; 
            var bases = type.extendsList; 
            if(bases != null) {
                var len = bases.length; 
                this.inNewTargetTypeCheck = true; 
                if(len > 0) {
                    type.typeFlags |= Tools.TypeFlags.HasBaseType; 
                    if(bases[0] == this.anyType) {
                        for(var e = 0; e < len; e++) {
                            type.extendsTypeLinks[e].type = null; 
                        }
                        var binder = new Tools.Binder(this.checker); 
                        binder.resolveBases(this.scope, type); 
                        bases = type.extendsList; 
                        type.memberScope = this.checker.scopeOf(type); 
                    }
                }
                for(var i = 0; i < len; i++) {
                    var base = bases[i]; 
                    if(base.symbol && base.symbol.name == "Object") {
                        type.typeFlags |= Tools.TypeFlags.HasBaseTypeOfObject; 
                    }
                    if(base.isClassInstance()) {
                        if(type.isClassInstance() && (base.symbol.typeCheckStatus != Tools.TypeCheckStatus.Finished) && (base.symbol.declAST != null)) {
                            this.checker.errorReporter.simpleErrorFromSym(base.symbol, ("Base type '" + base.symbol.name) + "' is referenced before its declaration"); 
                            this.typeCheckClass(base.symbol.declAST); 
                        }
                        if(this.currentScript != null) {
                            this.currentScript.requiresInherits = true; 
                        }
                        if(!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleErrorFromSym(base.symbol, "Interface base type must be interface"); 
                        } else  {
                            if(seenInterface) {
                                this.checker.errorReporter.simpleErrorFromSym(base.symbol, "Class may not follow interface as base type"); 
                            }
                        }
                    } else  {
                        if(base.members != null) {
                            if(!seenInterface) {
                                seenInterface = true; 
                            }
                        } else  {
                            if(!(type.isClassInstance())) {
                                this.checker.errorReporter.simpleErrorFromSym(base.symbol, "Interface base type must be interface"); 
                            } else  {
                                this.checker.errorReporter.simpleErrorFromSym(base.symbol, "Base type must be interface or class"); 
                            }
                            break;
                        }
                    }
                }
                this.inNewTargetTypeCheck = false; 
            }
        };
        TypeFlow.prototype.scopeImplementsInterface = function(scope, interfaceType, useImpl) {
            if(scope == null) {
                return false; 
            }
            if(interfaceType.members == null) {
                return true; 
            }
            return interfaceType.members.publicMembers.every(function(key, s, context) {
                var sym = s; 
                var scopeSymbol = null; 
                if(useImpl) {
                    scopeSymbol = context.scope.findImplementation(sym.name); 
                } else  {
                    scopeSymbol = context.scope.find(sym.name); 
                }
                return (scopeSymbol != null) && !(scopeSymbol.flags & Tools.SymbolFlags.Private) && context.checker.symbolSubtype(scopeSymbol, sym); 
            }, {
                scope: scope,
                checker: this.checker
            }); 
        };
        TypeFlow.prototype.checkMembersImplementInterface = function(instanceType, _interface, classDecl, requireImpl, requiringType) {
            var classScope = instanceType.memberScope; 
            if(!this.scopeImplementsInterface(classScope, _interface, requireImpl)) {
                if(requiringType == null) {
                    this.checker.errorReporter.interfaceDeclNotImpl(_interface, instanceType); 
                } else  {
                    this.checker.errorReporter.simpleError(classDecl, (("mixin " + requiringType.symbol.name) + " requires implementation of ") + _interface.symbol.name); 
                }
            }
        };
        TypeFlow.prototype.checkMembersImplementInterfaces = function(_class, classDecl) {
            var instanceType = _class.instanceType; 
            if(instanceType.implementsList != null) {
                var len = instanceType.implementsList.length; 
                this.inNewTargetTypeCheck = true; 
                for(var i = 0; i < len; i++) {
                    var base = instanceType.implementsList[i]; 
                    var requireImpl = (!Tools.hasFlag((classDecl).varFlags, Tools.VarFlags.Ambient)); 
                    this.checkMembersImplementInterface(instanceType, base, classDecl, requireImpl, null); 
                }
                this.inNewTargetTypeCheck = false; 
            }
        };
        TypeFlow.prototype.typeCheckBaseCalls = function(bases) {
            if(bases == null) {
                return;
            }
            var basesLen = bases.members.length; 
            for(var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i]; 
                var baseSymbol = null; 
                if(baseExpr.nodeType == Tools.NodeType.Call) {
                    this.typeCheckNew(baseExpr); 
                }
            }
        };
        TypeFlow.prototype.checkUniqueAndReq = function(names, type, classDecl, checkUnique) {
            var _self = this;
            if(type != null) {
                if(type.members != null) {
                    type.members.publicMembers.map(function(key, s, c) {
                        var sym = s; 
                        var dup = names.lookup(sym.name); 
                        if(dup != null) {
                            if(checkUnique) {
                                _self.checker.errorReporter.simpleError(classDecl, (((((("duplicate member name in bases for " + classDecl.name.text) + ": ") + type.symbol.name) + " and ") + dup.container.name) + " both contain member with name ") + sym.name); 
                            }
                        } else  {
                            names.add(sym.name, sym); 
                        }
                    }, null); 
                }
                if(type.extendsList != null) {
                    var len = type.extendsList.length; 
                    for(var i = 0; i < len; i++) {
                        this.checkUniqueAndReq(names, type.extendsList[i], classDecl, checkUnique); 
                    }
                }
            }
        };
        TypeFlow.prototype.checkLegalInheritance = function(_class, classDecl) {
            var _self = this;
            var instanceType = _class.instanceType; 
            if(instanceType.extendsList == null) {
                return;
            }
            var len = instanceType.extendsList.length; 
            if(len > 0) {
                var names = new Tools.StringHashTable(); 
                for(var i = 0; i < len; i++) {
                    this.checkUniqueAndReq(names, instanceType.extendsList[i], classDecl, i > 0); 
                }
                if(instanceType.members != null) {
                    instanceType.members.publicMembers.map(function(key, s, c) {
                        var sym = s; 
                        for(var j = 0; j < len; j++) {
                            var base = instanceType.extendsList[j]; 
                            if(base.memberScope == null) {
                                _self.checker.errorReporter.simpleError(classDecl, ("Base class '" + base.symbol.name) + "' lacks an implementation."); 
                            } else  {
                                var bSym = base.memberScope.find(sym.name, false, false); 
                                if(bSym != null) {
                                    var aType = sym.getType(); 
                                    var bType = bSym.getType(); 
                                    if(!(aType.subtype(bType, _self.checker))) {
                                        _self.checker.errorReporter.simpleError(classDecl, (("type of overridden member " + sym.name) + " is not subtype of original member defined by type ") + bSym.container.name); 
                                    } else  {
                                        if((sym.kind() == Tools.SymbolKind.Type) && (bSym.kind() == Tools.SymbolKind.Field)) {
                                            _self.checker.errorReporter.simpleError(classDecl, ("can not override field (" + sym.name) + ") with method"); 
                                        }
                                    }
                                }
                            }
                        }
                    }, null); 
                }
            }
        };
        TypeFlow.prototype.typeCheckClass = function(classDecl) {
            var typeSymbol = classDecl.type.symbol; 
            if(typeSymbol.typeCheckStatus == Tools.TypeCheckStatus.Finished) {
                return classDecl; 
            } else  {
                if(typeSymbol.typeCheckStatus == Tools.TypeCheckStatus.Started) {
                    return classDecl; 
                } else  {
                    typeSymbol.typeCheckStatus = Tools.TypeCheckStatus.Started; 
                }
            }
            var prevScope = this.scope; 
            var svClassNode = this.thisClassNode; 
            this.thisClassNode = classDecl; 
            var classType = classDecl.type; 
            this.typeCheckBases(classType.instanceType); 
            var prevThisType = this.thisType; 
            this.thisType = classType.instanceType; 
            this.scope = classType.instanceType.containedScope; 
            this.typeCheck(classDecl.members); 
            typeSymbol.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
            this.checkLegalInheritance(classType, classDecl); 
            this.checkMembersImplementInterfaces(classType, classDecl); 
            this.typeCheckOverloadSignatures(classType, classDecl); 
            this.typeCheckOverloadSignatures(classType.instanceType, classDecl); 
            this.thisType = prevThisType; 
            this.thisClassNode = svClassNode; 
            this.scope = prevScope; 
            return classDecl; 
        };
        TypeFlow.prototype.typeCheckES6Class = function(classDecl) {
            var typeSymbol = classDecl.type.symbol; 
            if(typeSymbol.typeCheckStatus == Tools.TypeCheckStatus.Finished) {
                return classDecl; 
            } else  {
                if(typeSymbol.typeCheckStatus == Tools.TypeCheckStatus.Started) {
                    return classDecl; 
                } else  {
                    typeSymbol.typeCheckStatus = Tools.TypeCheckStatus.Started; 
                }
            }
            var prevScope = this.scope; 
            var svClassNode = this.thisClassNode; 
            this.thisClassNode = classDecl; 
            var classType = classDecl.type; 
            this.typeCheckBases(classType.instanceType); 
            var prevThisType = this.thisType; 
            this.thisType = classType.instanceType; 
            this.scope = classType.instanceType.containedScope; 
            if(classDecl.constructorDecl) {
                var fnType = classDecl.constructorDecl.type; 
                this.scope = fnType.instanceType.constructorScope; 
                var ssb = this.scope; 
                var funcTable = ssb.valueMembers.allMembers; 
                this.addConstructorLocalArgs(classDecl.constructorDecl.type.symbol, classDecl.constructorDecl.args, funcTable); 
            }
            this.typeCheck(classDecl.members); 
            typeSymbol.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
            this.checkLegalInheritance(classType, classDecl); 
            this.checkMembersImplementInterfaces(classType, classDecl); 
            this.typeCheckOverloadSignatures(classType, classDecl); 
            this.typeCheckOverloadSignatures(classType.instanceType, classDecl); 
            if(!classDecl.constructorDecl) {
                var funcSym = prevScope.find(classDecl.name.text, true, false); 
                if(funcSym && funcSym.declAST && funcSym.declAST.type && funcSym.declAST.type.call) {
                    this.checker.errorReporter.duplicateIdentifier(funcSym.declAST, funcSym.name); 
                }
                if(classDecl.baseClass && classDecl.baseClass.members.length && classDecl.baseClass.members[0].type.symbol.type.isClass()) {
                    this.checker.cloneParentConstructGroupForChildType(classDecl.type, classDecl.baseClass.members[0].type.symbol.type); 
                } else  {
                    this.checker.createNewConstructGroupForType(classDecl.type); 
                }
            }
            this.thisType = prevThisType; 
            this.thisClassNode = svClassNode; 
            this.scope = prevScope; 
            return classDecl; 
        };
        TypeFlow.prototype.typeCheckOverloadSignatures = function(type, ast) {
            if(type.call != null) {
                type.call.typeCheck(this.checker, ast, type.construct != null); 
            }
            if(type.construct != null) {
                type.construct.typeCheck(this.checker, ast, false); 
            }
            if(type.index != null) {
                type.index.typeCheck(this.checker, ast, false); 
            }
            if(type.members != null) {
                type.members.publicMembers.map(function(key, s, c) {
                    var ch = c; 
                    var sym = s; 
                    if(sym.kind() == Tools.SymbolKind.Type) {
                        var memberType = (sym).type; 
                        if(memberType.call != null) {
                            memberType.call.typeCheck(ch, ast, false); 
                        }
                    }
                }, this.checker); 
            }
        };
        TypeFlow.prototype.typeCheckInterface = function(interfaceDecl) {
            this.typeCheckOverloadSignatures(interfaceDecl.type, interfaceDecl); 
            this.typeCheckBases(interfaceDecl.type); 
            this.typeCheck(interfaceDecl.members); 
            return interfaceDecl; 
        };
        TypeFlow.prototype.typeCheckImportDecl = function(importDecl) {
            var mod = importDecl.alias.type; 
            var sym = null; 
            var prevInImportTC = this.inImportTypeCheck; 
            this.inImportTypeCheck = true; 
            this.typeCheck(importDecl.alias); 
            mod = importDecl.alias.type; 
            if(mod == null) {
                this.checker.errorReporter.simpleError(importDecl.alias, ("Could not resolve module alias '" + importDecl.id.text) + "'"); 
                mod = this.checker.anyType; 
                (importDecl.id.sym).type = mod; 
            }
            importDecl.id.type = mod; 
            sym = mod.symbol; 
            if(!mod.isModuleType()) {
                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type"); 
            } else  {
                sym.type = mod; 
                if(this.checker.currentModDecl != null && this.checker.currentModDecl.mod != null) {
                    this.checker.currentModDecl.mod.importedModules.push(importDecl); 
                }
                (importDecl.id.sym).type = mod; 
                if(mod.symbol && mod.symbol.declAST) {
                    (mod.symbol.declAST).modFlags &= ~Tools.ModuleFlags.ShouldEmitModuleDecl; 
                }
            }
            this.inImportTypeCheck = prevInImportTC; 
            return importDecl; 
        };
        TypeFlow.prototype.typeCheckModule = function(moduleDecl) {
            if(this.currentScript != null) {
                this.currentScript.requiresGlobal = true; 
            }
            var mod = moduleDecl.mod; 
            var sym = null; 
            var prevScope = this.scope; 
            var prevThisType = this.thisType; 
            var prevCurrentModDecl = this.checker.currentModDecl; 
            this.checker.currentModDecl = moduleDecl; 
            if(!this.inImportTypeCheck && (prevCurrentModDecl != null) && Tools.hasFlag(moduleDecl.modFlags, Tools.ModuleFlags.IsDynamic)) {
                this.checker.errorReporter.simpleError(moduleDecl, "Dynamic modules may not be nested within other modules"); 
            }
            this.thisType = null; 
            this.scope = mod.containedScope; 
            this.typeCheck(moduleDecl.members); 
            sym = mod.symbol; 
            this.checker.currentModDecl = prevCurrentModDecl; 
            this.thisType = prevThisType; 
            this.scope = prevScope; 
            moduleDecl.type = mod; 
            if(sym != null) {
                sym.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
            }
            return moduleDecl; 
        };
        TypeFlow.prototype.typeCheckFor = function(forStmt) {
            forStmt.init = this.typeCheck(forStmt.init); 
            this.nestingLevel++; 
            forStmt.cond = this.typeCheck(forStmt.cond); 
            this.typeCheckCondExpr(forStmt.cond); 
            forStmt.incr = this.typeCheck(forStmt.incr); 
            this.nestingLevel--; 
            forStmt.body = this.typeCheck(forStmt.body); 
            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement"); 
            forStmt.type = this.voidType; 
            return forStmt; 
        };
        TypeFlow.prototype.typeCheckWith = function(withStmt) {
            if(this.checker.errorsOnWith) {
                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a 'with' block will be typed as 'any'"); 
            }
            withStmt.expr = this.typeCheck(withStmt.expr); 
            this.checker.inWith = true; 
            withStmt.body = this.typeCheck(withStmt.body); 
            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement"); 
            this.checker.inWith = false; 
            return withStmt; 
        };
        TypeFlow.prototype.typeCheckForIn = function(forInStmt) {
            forInStmt.obj = this.typeCheck(forInStmt.obj); 
            forInStmt.lval = this.typeCheck(forInStmt.lval); 
            forInStmt.body = this.typeCheck(forInStmt.body); 
            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement"); 
            return forInStmt; 
        };
        TypeFlow.prototype.typeCheckWhile = function(whileStmt) {
            whileStmt.cond = this.typeCheck(whileStmt.cond); 
            this.typeCheckCondExpr(whileStmt.cond); 
            whileStmt.body = this.typeCheck(whileStmt.body); 
            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement"); 
            whileStmt.type = this.voidType; 
            return whileStmt; 
        };
        TypeFlow.prototype.typeCheckDoWhile = function(doWhileStmt) {
            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond); 
            this.typeCheckCondExpr(doWhileStmt.cond); 
            doWhileStmt.body = this.typeCheck(doWhileStmt.body); 
            this.typeCheckCompoundStmtBlock(doWhileStmt.body, "do while statement"); 
            doWhileStmt.type = this.voidType; 
            return doWhileStmt; 
        };
        TypeFlow.prototype.typeCheckCondExpr = function(cond) {
            if(this.checker.styleSettings.assignmentInCond) {
                if((cond !== null) && (cond.nodeType >= Tools.NodeType.Asg) && (cond.nodeType <= Tools.NodeType.LastAsg)) {
                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression"); 
                }
            }
        };
        TypeFlow.prototype.typeCheckCompoundStmtBlock = function(stmts, stmtType) {
            if(this.checker.styleSettings.blockInCompoundStmt && (stmts != null)) {
                if(stmts.nodeType != Tools.NodeType.Block) {
                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block"); 
                }
            }
        };
        TypeFlow.prototype.typeCheckIf = function(ifStmt) {
            ifStmt.cond = this.typeCheck(ifStmt.cond); 
            this.typeCheckCondExpr(ifStmt.cond); 
            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod); 
            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod); 
            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement"); 
            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement"); 
            ifStmt.type = this.voidType; 
            return ifStmt; 
        };
        TypeFlow.prototype.typeFromAccessorFuncDecl = function(funcDecl) {
            if(!funcDecl.isAccessor()) {
                return null; 
            }
            if(Tools.hasFlag(funcDecl.fncFlags, Tools.FncFlags.GetAccessor)) {
                return funcDecl.type.call.signatures[0].returnType.type; 
            } else  {
                return funcDecl.type.call.signatures[0].parameters[0].getType(); 
            }
        };
        TypeFlow.prototype.typeCheckObjectLit = function(objectLit) {
            var resultType = new Tools.Type(); 
            resultType.symbol = new Tools.TypeSymbol(this.checker.anon, objectLit.minChar, this.checker.locationInfo.unitIndex, resultType); 
            resultType.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
            var memberDecls = objectLit.operand; 
            var prevThisType = this.thisType; 
            var acceptTargetType = false; 
            var targetType = null; 
            if(this.checker.hasTargetType()) {
                targetType = this.checker.getTargetTypeContext().targetType; 
                if(targetType != null && targetType.symbol != null && targetType.symbol.typeCheckStatus != Tools.TypeCheckStatus.Finished) {
                    if(targetType.symbol.declAST != null) {
                        this.typeCheck(targetType.symbol.declAST); 
                    }
                }
                acceptTargetType = this.checker.canContextuallyTypeObjectLiteral(targetType, objectLit); 
            }
            if(memberDecls != null) {
                for(var i = 0, len = memberDecls.members.length; i < len; i++) {
                    var binex = memberDecls.members[i]; 
                    var id = binex.operand1; 
                    var text; 
                    var targetMember = null; 
                    var fieldSymbol = null; 
                    if(id.nodeType == Tools.NodeType.Name) {
                        text = (id).text; 
                    } else  {
                        if(id.nodeType == Tools.NodeType.QString) {
                            var idText = (id).text; 
                            text = idText.substring(1, idText.length - 1); 
                        } else  {
                            this.checker.errorReporter.simpleError(objectLit, "malformed object literal"); 
                            resultType = this.anyType; 
                            break;
                        }
                    }
                    if(acceptTargetType) {
                        targetMember = targetType.memberScope.find(text, false, false); 
                    }
                    if(binex.operand2.nodeType == Tools.NodeType.FuncDecl && (binex.operand2).isAccessor()) {
                        var funcDecl = binex.operand2; 
                        var accessorSym = resultType.members.publicMembers.lookup(text); 
                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, this.scope, null); 
                        funcDecl.accessorSymbol = accessorSym; 
                        fieldSymbol = accessorSym; 
                        if(id.nodeType == Tools.NodeType.Name) {
                            (id).sym = accessorSym; 
                        }
                    }
                    this.checker.typeCheckWithTargetType(acceptTargetType ? targetMember.getType() : null, acceptTargetType, binex.operand2); 
                    if(acceptTargetType) {
                        if((binex.operand2.type == this.anyType || binex.operand2.type.subtype(targetMember.getType(), this.checker)) || (binex.operand2.nodeType == Tools.NodeType.FuncDecl && (binex.operand2).isAccessor() && this.typeFromAccessorFuncDecl(binex.operand2) == targetMember.getType())) {
                            binex.operand1.type = targetMember.getType(); 
                        } else  {
                            this.checker.errorReporter.simpleError(binex.operand1, "type mismatch - could not apply contextual type"); 
                            acceptTargetType = false; 
                        }
                    } else  {
                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type; 
                    }
                    if(fieldSymbol == null) {
                        var memberType = binex.operand2.type; 
                        var field = new Tools.ValueLocation(); 
                        fieldSymbol = new Tools.FieldSymbol(text, id.minChar, this.checker.locationInfo.unitIndex, true, field); 
                        fieldSymbol.flags |= Tools.SymbolFlags.Property; 
                        field.symbol = fieldSymbol; 
                        fieldSymbol.typeCheckStatus = Tools.TypeCheckStatus.Finished; 
                        field.typeLink = new Tools.TypeLink(); 
                        field.typeLink.type = memberType; 
                        resultType.members.publicMembers.add(text, fieldSymbol); 
                    }
                    fieldSymbol.isObjectLitField = true; 
                }
            }
            resultType.containedScope = new Tools.SymbolTableScope(resultType.members, null, null, null, null); 
            resultType.containedScope.container = resultType.symbol; 
            resultType.memberScope = acceptTargetType ? targetType.containedScope : resultType.containedScope; 
            this.thisType = prevThisType; 
            objectLit.type = acceptTargetType ? targetType : resultType; 
            objectLit.acceptTargetType = acceptTargetType; 
        };
        TypeFlow.prototype.typeCheckArrayLit = function(arrayLit) {
            var elements = arrayLit.operand; 
            var elementType = this.anyType; 
            var targetElementType = null; 
            if(this.checker.hasTargetType()) {
                var targetType = this.checker.getTargetTypeContext().targetType; 
                if(targetType.elementType != null) {
                    targetElementType = targetType.elementType; 
                }
            }
            if(elements != null) {
                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck; 
                this.inArrayElementTypeCheck = true; 
                this.checker.typeCheckWithTargetType(targetElementType, targetElementType != null, elements); 
                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck; 
                elementType = elements.members[0].type; 
                var collection = {
                    getLength: function() {
                        return elements.members.length; 
                    },
                    setTypeAtIndex: function(index, type) {
                        elements.members[index].type = type; 
                    },
                    getTypeAtIndex: function(index) {
                        return elements.members[index].type; 
                    }
                }; 
                elementType = Tools.findBestCommonType(elementType, targetElementType, collection, this.checker); 
                if(elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {
                    elementType = this.anyType; 
                }
            }
            if(!elementType) {
                this.checker.errorReporter.simpleError(arrayLit, "incompatible types in array literal expression"); 
                elementType = this.anyType; 
            } else  {
                if(targetElementType) {
                    elementType = targetElementType; 
                }
            }
            arrayLit.type = this.checker.makeArrayType(elementType); 
        };
        TypeFlow.prototype.checkForVoidConstructor = function(type, ast) {
            if(type != null && type.construct != null && type.construct.signatures.length > 0) {
                for(var i = 0; i < type.construct.signatures.length; i++) {
                    if(type.construct.signatures[i].returnType.type == this.checker.voidType) {
                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of 'void'"); 
                        break;
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckReturn = function(returnStmt) {
            if(this.thisFnc != null) {
                var targetType = null; 
                if(this.checker.hasTargetType()) {
                    var tcContext = this.checker.getTargetTypeContext(); 
                    var accessorType = tcContext.targetAccessorType; 
                    if(accessorType != null) {
                        targetType = accessorType; 
                    } else  {
                        var targetSig = this.checker.getTargetTypeContext().targetSig; 
                        if(targetSig != null && targetSig.returnType.type != this.voidType) {
                            targetType = targetSig.returnType.type; 
                        }
                    }
                }
                if(returnStmt.returnExpression != null) {
                    this.thisFnc.fncFlags |= Tools.FncFlags.HasReturnValue; 
                    if(targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {
                        targetType = this.thisFnc.returnTypeAnnotation.type; 
                    }
                    this.checker.typeCheckWithTargetType(targetType, targetType != null, returnStmt.returnExpression); 
                    var expectedReturnType = (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : targetType; 
                    if(expectedReturnType) {
                        if(expectedReturnType == this.voidType) {
                            this.checker.errorReporter.simpleError(returnStmt, "Return with value expression in void function"); 
                            returnStmt.type = returnStmt.returnExpression.type; 
                        } else  {
                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType); 
                            returnStmt.type = expectedReturnType; 
                        }
                    } else  {
                        if(targetType != null) {
                            if(returnStmt.returnExpression.type != this.voidType) {
                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType); 
                            } else  {
                                returnStmt.returnExpression.type = targetType; 
                            }
                        }
                        returnStmt.type = returnStmt.returnExpression.type; 
                    }
                } else  {
                    returnStmt.type = targetType == null ? this.voidType : targetType; 
                }
                this.thisFnc.returnStatements[this.thisFnc.returnStatements.length] = returnStmt; 
            }
            return returnStmt; 
        };
        TypeFlow.prototype.typeCheckInstOf = function(ast) {
            var binex = ast; 
            binex.operand1 = this.typeCheck(binex.operand1); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            binex.type = this.booleanType; 
            return binex; 
        };
        TypeFlow.prototype.typeCheckCommaOperator = function(ast) {
            var binex = ast; 
            binex.operand1 = this.typeCheck(binex.operand1); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            binex.type = binex.operand2.type; 
            return binex; 
        };
        TypeFlow.prototype.typeCheckLogOr = function(binex) {
            binex.operand1 = this.typeCheck(binex.operand1); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            var leftType = binex.operand1.type; 
            var rightType = binex.operand2.type; 
            if(leftType.subtype(rightType, this.checker)) {
                binex.type = rightType; 
            } else  {
                if(rightType.subtype(leftType, this.checker)) {
                    binex.type = leftType; 
                } else  {
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, "||", this.scope); 
                    binex.type = leftType; 
                }
            }
            return binex; 
        };
        TypeFlow.prototype.typeCheckLogAnd = function(binex) {
            binex.operand1 = this.typeCheck(binex.operand1); 
            binex.operand2 = this.typeCheck(binex.operand2); 
            binex.type = binex.operand2.type; 
            return binex; 
        };
        TypeFlow.prototype.tryAddCandidates = function(signature, actuals, exactCandidates, conversionCandidates) {
            var lowerBound = signature.nonOptionalParameterCount; 
            var upperBound = signature.parameters.length; 
            var formalLen = lowerBound; 
            var acceptable = false; 
            if((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length); 
                acceptable = true; 
            }
            var repeatType = null; 
            if(acceptable || signature.hasVariableArgList) {
                if(signature.hasVariableArgList) {
                    formalLen -= 1; 
                    repeatType = (signature.parameters[formalLen]).parameter.typeLink.type; 
                    repeatType = repeatType.elementType; 
                    acceptable = actuals.length >= formalLen; 
                }
                var len = actuals.length; 
                var exact = acceptable; 
                var convert = acceptable; 
                for(var i = 0; i < len; i++) {
                    var typeA; 
                    if(i < formalLen) {
                        typeA = (signature.parameters[i]).parameter.typeLink.type; 
                    } else  {
                        typeA = repeatType; 
                    }
                    var typeB = actuals[i]; 
                    if(!typeA || !typeB || !(this.checker.invariantMatches(typeA, typeB))) {
                        exact = false; 
                    }
                    if(!this.checker.assignableTo(typeA, typeB)) {
                        convert = false; 
                    }
                    if(!(exact || convert)) {
                        break;
                    }
                }
                if(exact) {
                    exactCandidates[exactCandidates.length] = signature; 
                } else  {
                    if(convert && (exactCandidates.length == 0)) {
                        conversionCandidates[conversionCandidates.length] = signature; 
                    }
                }
            }
        };
        TypeFlow.prototype.resolveOverload = function(callEx, group) {
            var rd = this.resolutionDataCache.getResolutionData(); 
            var actuals = rd.actuals; 
            var exactCandidates = rd.exactCandidates; 
            var conversionCandidates = rd.conversionCandidates; 
            var candidate = null; 
            if(callEx.args != null) {
                var len = callEx.args.members.length; 
                for(var i = 0; i < len; i++) {
                    actuals[i] = callEx.args.members[i].type; 
                }
            }
            for(var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {
                var signature = group.signatures[j]; 
                if((signature.returnType.type == null) && (signature.declAST != null) && (signature.typeCheckStatus != Tools.TypeCheckStatus.Finished)) {
                    this.typeCheckFunction(signature.declAST); 
                }
                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates); 
            }
            if(exactCandidates.length == 0) {
                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, callEx.args); 
                if(applicableCandidates.length > 0) {
                    candidate = applicableCandidates[0]; 
                } else  {
                    this.checker.errorReporter.simpleError(callEx, "supplied parameters do not match any signature of call target"); 
                }
            } else  {
                candidate = exactCandidates[0]; 
            }
            this.resolutionDataCache.returnResolutionData(rd); 
            return candidate; 
        };
        TypeFlow.prototype.typeCheckNew = function(ast) {
            var callEx = ast; 
            callEx.target = this.typeCheck(callEx.target); 
            var target = callEx.target; 
            if(target.type.construct != null || target.type.call != null) {
                this.preTypeCheckCallArgs(callEx.args); 
            } else  {
                callEx.args = this.typeCheck(callEx.args); 
            }
            if(target.type == this.anyType) {
                callEx.type = this.anyType; 
                callEx.args = this.typeCheck(callEx.args); 
            } else  {
                if(target.type.construct != null) {
                    var signature = this.resolveOverload(callEx, target.type.construct); 
                    if(signature == null) {
                        callEx.type = this.anyType; 
                    } else  {
                        if(signature.returnType.type == this.voidType) {
                            callEx.type = this.anyType; 
                            callEx.signature = signature; 
                        } else  {
                            callEx.type = signature.returnType.type; 
                            callEx.signature = signature; 
                        }
                    }
                } else  {
                    if(target.type.call != null) {
                        var signature = this.resolveOverload(callEx, target.type.call); 
                        if(signature == null) {
                            callEx.type = this.anyType; 
                        } else  {
                            if((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {
                                callEx.type = this.anyType; 
                                callEx.signature = signature; 
                            } else  {
                                this.checker.errorReporter.simpleError(callEx.target, "new expression only valid on constructors"); 
                            }
                        }
                    } else  {
                        if(target.type.elementType != null) {
                            callEx.type = target.type; 
                        } else  {
                            this.checker.errorReporter.invalidCall(callEx, callEx.nodeType); 
                            callEx.type = this.anyType; 
                        }
                    }
                }
            }
            this.postTypeCheckCallArgs(callEx); 
            return callEx; 
        };
        TypeFlow.prototype.preTypeCheckCallArgs = function(args) {
            if(!args) {
                return;
            }
            for(var i = 0; i < args.members.length; i++) {
                switch(args.members[i].nodeType) {
                    case Tools.NodeType.FuncDecl: {

                    }
                    case Tools.NodeType.ObjectLit: {

                    }
                    case Tools.NodeType.ArrayLit: {
                        continue;

                    }
                    default: {
                        this.typeCheck(args.members[i]); 
                        break;

                    }
                }
            }
        };
        TypeFlow.prototype.postTypeCheckCallArgs = function(callEx) {
            var acceptedTargetType = false; 
            var i = 0; 
            if(callEx.target && callEx.target.type && callEx.signature && callEx.args) {
                var sig = callEx.signature; 
                if(sig && callEx.args.members.length >= sig.nonOptionalParameterCount) {
                    acceptedTargetType = true; 
                    var targetType = null; 
                    var len = callEx.args.members.length < sig.parameters.length ? callEx.args.members.length : sig.parameters.length; 
                    for(i = 0; i < len; i++) {
                        targetType = sig.parameters[i].getType(); 
                        if(targetType != null && sig.hasVariableArgList && i >= sig.nonOptionalParameterCount) {
                            targetType = targetType.elementType; 
                        }
                        switch(callEx.args.members[i].nodeType) {
                            case Tools.NodeType.FuncDecl: {

                            }
                            case Tools.NodeType.ObjectLit: {

                            }
                            case Tools.NodeType.ArrayLit: {
                                this.checker.typeCheckWithTargetType(targetType, !sig.parameters[i].declAST.isParenthesized, callEx.args.members[i]); 
                                break;

                            }
                            default: {
                                continue;

                            }
                        }
                    }
                }
            }
            if(!acceptedTargetType && callEx.args) {
                this.checker.killTargetType(); 
                for(i = 0; i < callEx.args.members.length; i++) {
                    switch(callEx.args.members[i].nodeType) {
                        case Tools.NodeType.FuncDecl: {

                        }
                        case Tools.NodeType.ObjectLit: {

                        }
                        case Tools.NodeType.ArrayLit: {
                            this.typeCheck(callEx.args.members[i]); 
                            break;

                        }
                        default: {
                            continue;

                        }
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckCall = function(ast) {
            var callEx = ast; 
            if(this.checker.styleSettings.newMustBeUsed && (ast.nodeType == Tools.NodeType.New)) {
                if(Tools.hasFlag(ast.flags, Tools.ASTFlags.IsStatement)) {
                    this.checker.errorReporter.styleError(ast, "use of new expression as a statement"); 
                }
            } else  {
                if((!this.checker.styleSettings.evalOK) && (ast.nodeType == Tools.NodeType.Call)) {
                    if((callEx.target.nodeType == Tools.NodeType.Name) && ((callEx.target).text == "eval")) {
                        this.checker.errorReporter.styleError(callEx, "eval not permitted"); 
                    }
                }
            }
            if(callEx.target.nodeType == Tools.NodeType.FuncDecl) {
                (callEx.target).isInlineCallLiteral = true; 
            }
            callEx.target = this.typeCheck(callEx.target); 
            this.preTypeCheckCallArgs(callEx.args); 
            var target = callEx.target; 
            if((target.type == null) || (target.type == this.anyType)) {
                callEx.type = this.anyType; 
            } else  {
                var fnType = target.type; 
                if(fnType.call != null) {
                    var signature = this.resolveOverload(callEx, fnType.call); 
                    if(signature == null) {
                        callEx.type = this.anyType; 
                    } else  {
                        callEx.type = signature.returnType.type; 
                        callEx.signature = signature; 
                    }
                } else  {
                    if(callEx.target.nodeType == Tools.NodeType.Super && this.thisFnc && this.thisFnc.isConstructor && Tools.hasFlag(this.thisFnc.fncFlags, Tools.FncFlags.ES6ClassMethod)) {
                        var signature = this.resolveOverload(callEx, fnType.symbol.type.construct); 
                        if(signature == null) {
                            callEx.type = this.anyType; 
                        } else  {
                            (this.thisClassNode).baseConstructorCall.members[0] = callEx; 
                            callEx.flags |= Tools.ASTFlags.ES6ClassBaseConstructorCall; 
                            callEx.type = signature.returnType.type; 
                            callEx.signature = signature; 
                        }
                    } else  {
                        callEx.type = this.anyType; 
                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType); 
                    }
                }
            }
            this.postTypeCheckCallArgs(callEx); 
            return callEx; 
        };
        TypeFlow.prototype.assignScopes = function(ast) {
            var script = ast; 
            this.checker.locationInfo = script.locationInfo; 
            var globalChain = new ScopeChain(null, null, this.globalScope); 
            var context = new Tools.AssignScopeContext(globalChain, this, [                this.checker.currentModDecl
]); 
            ast.walk(Tools.preAssignScopes, Tools.postAssignScopes, null, context); 
        };
        TypeFlow.prototype.findMemberScope = function(enclosingScopeContext, matchFlag) {
            var enclosingScope = enclosingScopeContext.getScope(); 
            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScopePosition(); 
            var scriptFragment = enclosingScopeContext.getScriptFragment(); 
            var memContext = new Tools.MemberScopeContext(this, pos, matchFlag); 
            memContext.scope = enclosingScope; 
            if(scriptFragment.nodeType == Tools.NodeType.Name) {
                return scriptFragment.type.getMemberScope(this); 
            } else  {
                scriptFragment.walk(Tools.preFindMemberScope, null, null, memContext); 
                if(memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {
                    enclosingScopeContext.publicsOnly = false; 
                }
                if(memContext.type != null) {
                    return memContext.type.getMemberScope(this); 
                } else  {
                    return null; 
                }
            }
        };
        TypeFlow.prototype.findMemberScopeAt = function(enclosingScopeContext) {
            return this.findMemberScope(enclosingScopeContext, Tools.ASTFlags.DotLHS); 
        };
        return TypeFlow;
    })();
    Tools.TypeFlow = TypeFlow;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    (function(Primitive) {
        Primitive._map = []; 
        Primitive.None = 0; 
        Primitive.Void = 1; 
        Primitive.Double = 2; 
        Primitive.String = 4; 
        Primitive.Boolean = 8; 
        Primitive.Any = 16; 
        Primitive.Null = 32; 
        Primitive.Undefined = 64; 
    })(Tools.Primitive||(Tools.Primitive={}));
    var Primitive = Tools.Primitive;

    function hasNominalSubtypeRelationship(a, b, depth) {
        if(depth > 0) {
            var impls = a.implementsList; 
            var exnds = a.extendsList; 
            var candidates = null; 
            if(impls == null && exnds == null) {
                return false; 
            } else  {
                if(impls != null && exnds != null) {
                    candidates = impls.concat(exnds); 
                } else  {
                    candidates = impls != null ? impls : exnds; 
                }
            }
            var imp = null; 
            var bbase = null; 
            var impbase = null; 
            for(var i = 0; i < candidates.length; i++) {
                imp = candidates[i]; 
                impbase = imp.baseClass(); 
                bbase = b.baseClass(); 
                if(b == impbase || bbase == imp) {
                    return true; 
                }
                if(bbase != null && impbase != null && bbase == impbase) {
                    return true; 
                }
                if(b == imp || hasNominalSubtypeRelationship(imp, b, depth - 1)) {
                    return true; 
                }
            }
        }
        return false; 
    }
    Tools.hasNominalSubtypeRelationship = hasNominalSubtypeRelationship;
    var currentTypeID = -1; 
    var Type = (function () {
        function Type() {
            this.typeID = currentTypeID++; 
            this.members = null; 
            this.ambientMembers = null; 
            this.construct = null; 
            this.call = null; 
            this.index = null; 
            this.extendsList = null; 
            this.extendsTypeLinks = null; 
            this.implementsList = null; 
            this.implementsTypeLinks = null; 
            this.isES6Class = false; 
            this.passTypeCreated = Tools.CompilerDiagnostics.analysisPass; 
            this.elementType = null; 
            this.primitives = Primitive.None; 
            this.constructorScope = null; 
            this.containedScope = null; 
            this.memberScope = null; 
            this.arrayCache = null; 
            this.typeFlags = Tools.TypeFlags.None; 
            this.symbol = null; 
            this.enclosingType = null; 
            this.instanceType = null; 
        }
        Type.prototype.baseClass = function() {
            if((this.extendsList != null) && (this.extendsList.length > 0)) {
                return this.extendsList[0]; 
            } else  {
                return null; 
            }
        };
        Type.prototype.getArrayBase = function(arrInstType, checker) {
            return this.arrayCache.specialize(arrInstType, checker); 
        };
        Type.prototype.isClass = function() {
            return this.instanceType != null; 
        };
        Type.prototype.isArray = function() {
            return this.elementType != null; 
        };
        Type.prototype.isClassInstance = function() {
            return ((this.symbol != null) && (this.elementType == null) && ((this.symbol).type.isClass())); 
        };
        Type.prototype.getInstanceType = function() {
            if(this.isClass()) {
                return this.instanceType; 
            } else  {
                return this; 
            }
        };
        Type.prototype.hasImplementation = function() {
            return Tools.hasFlag(this.typeFlags, Tools.TypeFlags.HasImplementation); 
        };
        Type.prototype.setHasImplementation = function() {
            this.typeFlags |= Tools.TypeFlags.HasImplementation; 
        };
        Type.prototype.isDouble = function() {
            return Tools.hasFlag(this.primitives, Primitive.Double); 
        };
        Type.prototype.isString = function() {
            return Tools.hasFlag(this.primitives, Primitive.String); 
        };
        Type.prototype.isBoolean = function() {
            return Tools.hasFlag(this.primitives, Primitive.Boolean); 
        };
        Type.prototype.isNull = function() {
            return Tools.hasFlag(this.primitives, Primitive.Null); 
        };
        Type.prototype.subtypeMembers = function(b, checker) {
            if(this.isBase(b)) {
                return true; 
            }
            if((b.members != null) && (!b.hasImplementation())) {
                return b.members.publicMembers.every(function(key, s, t) {
                    var sym = s; 
                    var a = t; 
                    var memberScope = a.memberScope; 
                    if(memberScope == null) {
                        return false; 
                    } else  {
                        var aSym = a.memberScope.find(sym.name, true, false); 
                        return checker.symbolSubtype(aSym, sym); 
                    }
                }, this); 
            }
            return true; 
        };
        Type.prototype.assignableMembers = function(b, checker) {
            if(this.isBase(b) || b.isBase(this)) {
                return true; 
            }
            if(this.members == b.members) {
                return true; 
            }
            if(this.members == null || b.members == null) {
                return true; 
            }
            var isAssignable = false; 
            if((this.members != null) && (!this.hasImplementation())) {
                isAssignable = this.members.publicMembers.every(function(key, s, t) {
                    var sym = s; 
                    var bT = t; 
                    if(bT.memberScope == null) {
                        return false; 
                    } else  {
                        var bSym = bT.memberScope.find(sym.name, true, false); 
                        return checker.symbolAssignable(sym, bSym); 
                    }
                }, b); 
            }
            if(!isAssignable) {
                if((b.members != null) && (!b.hasImplementation())) {
                    isAssignable = b.members.publicMembers.every(function(key, s, t) {
                        var sym = s; 
                        var a = t; 
                        var memberScope = a.memberScope; 
                        if(memberScope == null) {
                            return false; 
                        } else  {
                            var aSym = a.memberScope.find(sym.name, true, false); 
                            return checker.symbolAssignable(aSym, sym); 
                        }
                    }, this); 
                }
            }
            return isAssignable; 
        };
        Type.prototype.getItemType = function(indexType, checker, ast) {
            if(this.elementType != null) {
                return this.elementType; 
            }
            if(this.memberScope == null) {
                return null; 
            }
            if(this.index != null) {
                var signatures = this.index.signatures; 
                if(signatures.length > 0) {
                    var signature = signatures[0]; 
                    if(signature.matchSingleArg(indexType, checker) || indexType == checker.anyType) {
                        return signature.returnType.type; 
                    } else  {
                        return null; 
                    }
                }
            } else  {
                if(!checker.contravariantMatches(checker.stringType, indexType)) {
                    checker.errorReporter.simpleError(ast, "Unless explicitly overloaded, index methods may only take string parameters"); 
                } else  {
                    return checker.anyType; 
                }
            }
        };
        Type.prototype.getTypeName = function() {
            return this.getMemberTypeName("", true, false, null); 
        };
        Type.prototype.getScopedTypeName = function(scope) {
            return this.getMemberTypeName("", true, false, scope); 
        };
        Type.prototype.callCount = function() {
            var total = 0; 
            if(this.call != null) {
                total += this.call.signatures.length; 
            }
            if(this.construct != null) {
                total += this.construct.signatures.length; 
            }
            if(this.index != null) {
                total += this.index.signatures.length; 
            }
            return total; 
        };
        Type.prototype.getMemberTypeName = function(prefix, topLevel, isElementType, scope) {
            if(this.elementType != null) {
                return this.elementType.getMemberTypeName(prefix, false, true, scope) + "[]"; 
            } else  {
                if((this.symbol != null) && (this.symbol.name != null) && (this.symbol.name != "_anonymous") && (((this.call == null) && (this.construct == null) && (this.index == null)) || (Tools.hasFlag(this.typeFlags, Tools.TypeFlags.BuildingName)) || ((this.members != null) && (!this.isClass())))) {
                    return this.symbol.scopeRelativeName(scope); 
                } else  {
                    if((this.members != null) || (this.call != null) || (this.construct != null)) {
                        if(Tools.hasFlag(this.typeFlags, Tools.TypeFlags.BuildingName)) {
                            return "this"; 
                        }
                        this.typeFlags |= Tools.TypeFlags.BuildingName; 
                        var builder = ""; 
                        var curlies = isElementType; 
                        var delim = "; "; 
                        var signatureCount = 0; 
                        var memCount = 0; 
                        if(this.members != null) {
                            this.members.allMembers.map(function(key, s, unused) {
                                var sym = s; 
                                if(!Tools.hasFlag(sym.flags, Tools.SymbolFlags.BuiltIn)) {
                                    builder += sym.getTypeName(scope); 
                                    memCount++; 
                                    if(sym.kind() == Tools.SymbolKind.Type) {
                                        var memberType = (sym).type; 
                                        if(memberType.callCount() > 1) {
                                            curlies = true; 
                                        }
                                    } else  {
                                        builder += delim; 
                                        curlies = true; 
                                    }
                                }
                            }, null); 
                        }
                        var signatures; 
                        var j; 
                        var len = 0; 
                        var shortform = (memCount == 0) && (this.callCount() == 1) && topLevel; 
                        if(this.call != null) {
                            signatures = this.call.toStrings(prefix, shortform, scope); 
                            for(j = 0 , len = signatures.length; j < len; j++) {
                                builder += signatures[j]; 
                                signatureCount++; 
                                if(!shortform) {
                                    builder += delim; 
                                }
                            }
                        }
                        if(this.construct != null) {
                            signatures = this.construct.toStrings("new", shortform, scope); 
                            for(j = 0 , len = signatures.length; j < len; j++) {
                                builder += signatures[j]; 
                                signatureCount++; 
                                if(!shortform) {
                                    builder += delim; 
                                }
                            }
                        }
                        if(this.index != null) {
                            signatures = this.index.toStrings("", shortform, scope); 
                            for(j = 0 , len = signatures.length; j < len; j++) {
                                builder += signatures[j]; 
                                signatureCount++; 
                                if(!shortform) {
                                    builder += delim; 
                                }
                            }
                        }
                        if((curlies) || ((signatureCount > 1) && topLevel)) {
                            builder = ("{ " + builder) + "}"; 
                        }
                        this.typeFlags &= (~Tools.TypeFlags.BuildingName); 
                        if((signatureCount == 0) && (memCount == 0)) {
                            return "{}"; 
                        } else  {
                            return builder; 
                        }
                    } else  {
                        return "{}"; 
                    }
                }
            }
        };
        Type.prototype.checkDecl = function(checker) {
            if(this.isClassInstance() || this.isClass()) {
                if(this.symbol.declAST != null) {
                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST); 
                }
            }
        };
        Type.prototype.tryStartMatch = function(b, checker) {
            return checker.tryStartTypeMatch(this, b); 
        };
        Type.prototype.endMatch = function(b, checker) {
            return checker.endTypeMatch(this, b); 
        };
        Type.prototype.getMemberScope = function(flow) {
            if(this == flow.anyType) {
                if(flow.objectInstanceType != null) {
                    return flow.objectInstanceType.memberScope; 
                } else  {
                    return null; 
                }
            } else  {
                if(this.isDouble()) {
                    return null; 
                } else  {
                    if(this == flow.stringType) {
                        if(flow.stringInstanceType != null) {
                            return flow.stringInstanceType.memberScope; 
                        } else  {
                            return null; 
                        }
                    } else  {
                        if(this.elementType != null) {
                            if(flow.arrayInstanceType != null) {
                                var arrInstType = this.elementType.getArrayBase(flow.arrayInstanceType, flow.checker); 
                                return arrInstType.memberScope; 
                            } else  {
                                return null; 
                            }
                        } else  {
                            return this.memberScope; 
                        }
                    }
                }
            }
        };
        Type.prototype.isReferenceType = function() {
            return (this.members != null) || (this.extendsList != null) || (this.construct != null) || (this.call != null) || (this.index != null) || (this.elementType != null); 
        };
        Type.prototype.specializeType = function(pattern, replacement, checker, membersOnly) {
            if(pattern == this) {
                return replacement; 
            }
            var result = this; 
            if(membersOnly) {
                if(this.isReferenceType()) {
                    result = new Type(); 
                    if(this.members != null) {
                        result.members = new Tools.ScopedMembers(new Tools.DualStringHashTable(new Tools.StringHashTable(), new Tools.StringHashTable())); 
                        this.members.publicMembers.map(function(key, s, unused) {
                            var sym = s; 
                            var bSym = sym.specializeType(pattern, replacement, checker); 
                            result.members.addPublicMember(bSym.name, bSym); 
                        }, null); 
                        this.members.privateMembers.map(function(key, s, unused) {
                            var sym = s; 
                            var bSym = sym.specializeType(pattern, replacement, checker); 
                            result.members.addPrivateMember(bSym.name, bSym); 
                        }, null); 
                    }
                    result.containedScope = checker.scopeOf(result); 
                    result.memberScope = result.containedScope; 
                }
            } else  {
                if(this.elementType != null) {
                    if(this.elementType == pattern) {
                        result = checker.makeArrayType(replacement); 
                    } else  {
                        if(this.elementType.elementType == pattern) {
                            result = checker.makeArrayType(checker.makeArrayType(replacement)); 
                        }
                    }
                } else  {
                    if(this.call != null) {
                        result = new Type(); 
                        result.call = this.call.specializeType(pattern, replacement, checker); 
                    }
                }
            }
            return result; 
        };
        Type.prototype.isBase = function(b) {
            if(b == this) {
                return true; 
            } else  {
                if(this.extendsList != null) {
                    for(var i = 0, len = this.extendsList.length; i < len; i++) {
                        if(this.extendsList[i].isBase(b)) {
                            return true; 
                        }
                    }
                }
            }
            return false; 
        };
        Type.prototype.subtype = function(b, checker) {
            if((this == b) || (b == null)) {
                return true; 
            }
            if(this == checker.nullType && b != checker.undefinedType) {
                return true; 
            }
            if(this == checker.undefinedType) {
                return true; 
            }
            if(b == checker.anyType) {
                return true; 
            } else  {
                if(b == checker.nullType) {
                    return false; 
                }
            }
            if(Tools.hasFlag(this.typeFlags, Tools.TypeFlags.IsEnum)) {
                return (b == checker.doubleType); 
            }
            if(Tools.hasFlag(b.typeFlags, Tools.TypeFlags.IsEnum)) {
                return false; 
            }
            if(this.primitives != b.primitives) {
                return false; 
            }
            if(this.isClass() || b.isClass()) {
                return false; 
            }
            if(this.elementType != null) {
                if(b.elementType != null) {
                    if(!this.elementType.subtype(b.elementType, checker)) {
                        return false; 
                    }
                } else  {
                    return false; 
                }
            } else  {
                if(b.elementType != null) {
                    return false; 
                }
            }
            if(this.isClassInstance()) {
                if(b.isClassInstance()) {
                    return this.isBase(b); 
                }
            } else  {
                if(b.isClassInstance()) {
                    return false; 
                }
            }
            if(hasNominalSubtypeRelationship(this, b, 4) || hasNominalSubtypeRelationship(b, this, 4)) {
                return true; 
            }
            if(!this.tryStartMatch(b, checker)) {
                return true; 
            }
            if(this.construct != null) {
                if(b.construct != null) {
                    if(!checker.signatureGroupSubtype(this.construct, b.construct)) {
                        this.endMatch(b, checker); 
                        return false; 
                    }
                } else  {
                    return false; 
                }
            }
            if(this.call != null) {
                if(b.call != null) {
                    if(!checker.signatureGroupSubtype(this.call, b.call)) {
                        this.endMatch(b, checker); 
                        return false; 
                    }
                } else  {
                    return false; 
                }
            }
            if(this.index != null) {
                if(b.index != null) {
                    if(!checker.signatureGroupSubtype(this.index, b.index)) {
                        this.endMatch(b, checker); 
                        return false; 
                    }
                } else  {
                    return false; 
                }
            }
            if(!this.subtypeMembers(b, checker)) {
                this.endMatch(b, checker); 
                return false; 
            }
            this.endMatch(b, checker); 
            return true; 
        };
        Type.prototype.assignable = function(b, checker) {
            if((this == b) || (b == null)) {
                return true; 
            }
            if(this == checker.nullType && b != checker.voidType) {
                return true; 
            }
            if(this == checker.anyType && b != checker.voidType) {
                return true; 
            }
            if(b == checker.anyType && this != checker.voidType) {
                return true; 
            } else  {
                if(b == checker.nullType && this != checker.voidType) {
                    return true; 
                }
            }
            if(Tools.hasFlag(this.typeFlags, Tools.TypeFlags.IsEnum)) {
                return (b == checker.doubleType); 
            }
            if(Tools.hasFlag(b.typeFlags, Tools.TypeFlags.IsEnum)) {
                return false; 
            }
            if(this.primitives != b.primitives) {
                return false; 
            }
            if(this.isClass() || b.isClass()) {
                return false; 
            }
            if(this.elementType != null) {
                if(b.elementType != null) {
                    return this.elementType.assignable(b.elementType, checker); 
                } else  {
                    return false; 
                }
            } else  {
                if(b.elementType != null) {
                    return false; 
                }
            }
            if(this.isClassInstance()) {
                if(b.isClassInstance()) {
                    return this.isBase(b); 
                }
            } else  {
                if(b.isClassInstance()) {
                    return false; 
                }
            }
            if(hasNominalSubtypeRelationship(this, b, 4) || hasNominalSubtypeRelationship(b, this, 4)) {
                return true; 
            }
            if(!this.tryStartMatch(b, checker)) {
                return true; 
            }
            if(this.construct != null) {
                if(b.construct != null) {
                    if(!checker.signatureGroupAssignable(this.construct, b.construct)) {
                        this.endMatch(b, checker); 
                        return false; 
                    }
                } else  {
                    return false; 
                }
            } else  {
                if(b.construct != null) {
                    if(this.call != null) {
                        return checker.signatureGroupAssignable(this.call, b.construct); 
                    } else  {
                        return false; 
                    }
                }
            }
            if(this.call != null) {
                if(b.call != null) {
                    if(!checker.signatureGroupAssignable(this.call, b.call)) {
                        this.endMatch(b, checker); 
                        return false; 
                    }
                } else  {
                    if(b.construct != null) {
                        if(!checker.signatureGroupAssignable(this.call, b.construct)) {
                            this.endMatch(b, checker); 
                            return false; 
                        }
                    } else  {
                        return false; 
                    }
                }
            } else  {
                if(b.call != null) {
                    if(this.construct != null) {
                        return checker.signatureGroupAssignable(this.construct, b.call); 
                    } else  {
                        return false; 
                    }
                }
            }
            if(this.index != null) {
                if(b.index != null) {
                    if(!checker.signatureGroupAssignable(this.index, b.index)) {
                        this.endMatch(b, checker); 
                        return false; 
                    }
                } else  {
                    return false; 
                }
            }
            if(!this.assignableMembers(b, checker)) {
                this.endMatch(b, checker); 
                return false; 
            }
            this.endMatch(b, checker); 
            return true; 
        };
        Type.prototype.mergeOrdered = function(b, checker) {
            if((this == checker.anyType) || (b == checker.anyType)) {
                return checker.anyType; 
            } else  {
                if(this == b) {
                    return this; 
                } else  {
                    if((b == checker.nullType) && this != checker.nullType) {
                        return this; 
                    } else  {
                        if((this == checker.nullType) && (b != checker.nullType)) {
                            return b; 
                        } else  {
                            if((this.elementType != null) && (b.elementType != null)) {
                                if(this.elementType == b.elementType) {
                                    return this; 
                                } else  {
                                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker); 
                                    if(mergedET == null) {
                                        return checker.makeArrayType(checker.anyType); 
                                    } else  {
                                        return checker.makeArrayType(mergedET); 
                                    }
                                }
                            } else  {
                                if(this.subtype(b, checker)) {
                                    return b; 
                                } else  {
                                    if(b.subtype(this, checker)) {
                                        return this; 
                                    } else  {
                                        return null; 
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        Type.prototype.isModuleType = function() {
            return false; 
        };
        Type.prototype.hasMembers = function() {
            return this.members != null; 
        };
        Type.prototype.getAllEnclosedTypes = function() {
            return null; 
        };
        Type.prototype.getAllAmbientEnclosedTypes = function() {
            return null; 
        };
        Type.prototype.getPublicEnclosedTypes = function() {
            return null; 
        };
        Type.prototype.getpublicAmbientEnclosedTypes = function() {
            return null; 
        };
        return Type;
    })();
    Tools.Type = Type;
    
    function findBestCommonType(initialType, targetType, collection, checker) {
        var i = 0; 
        var len = collection.getLength(); 
        var nlastChecked = 0; 
        var bestCommonType = initialType; 
        if(targetType) {
            bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, checker) : targetType; 
        }
        var convergenceType = bestCommonType; 
        while(nlastChecked < len) {
            for(i = 0; i < len; i++) {
                if(i == nlastChecked) {
                    continue;
                }
                if(convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), checker))) {
                    convergenceType = bestCommonType; 
                }
                if(bestCommonType == checker.anyType || bestCommonType == null) {
                    break;
                } else  {
                    if(targetType != null) {
                        collection.setTypeAtIndex(i, targetType); 
                    }
                }
            }
            if(convergenceType != null && bestCommonType != null) {
                break;
            }
            nlastChecked++; 
            if(nlastChecked < len) {
                convergenceType = collection.getTypeAtIndex(nlastChecked); 
            }
        }
        return bestCommonType; 
    }
    Tools.findBestCommonType = findBestCommonType;
    var ModuleType = (function () {
        _inheritsFrom(ModuleType, Type);
        function ModuleType(enclosedTypes, ambientEnclosedTypes) {
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            ModuleType._super.constructor.call(this);
            this.importedModules = []; 
        }
        ModuleType.prototype.isModuleType = function() {
            return true; 
        };
        ModuleType.prototype.hasMembers = function() {
            return (this.members != null) || (this.enclosedTypes != null); 
        };
        ModuleType.prototype.getAllEnclosedTypes = function() {
            return this.enclosedTypes; 
        };
        ModuleType.prototype.getAllAmbientEnclosedTypes = function() {
            return this.ambientEnclosedTypes; 
        };
        ModuleType.prototype.getPublicEnclosedTypes = function() {
            return null; 
        };
        ModuleType.prototype.getpublicAmbientEnclosedTypes = function() {
            return null; 
        };
        return ModuleType;
    })();
    Tools.ModuleType = ModuleType;
    
    var TypeLink = (function () {
        function TypeLink() {
            this.type = null; 
            this.ast = null; 
        }
        return TypeLink;
    })();
    Tools.TypeLink = TypeLink;
    
    function getTypeLink(ast, checker, autoVar) {
        var result = new TypeLink(); 
        result.ast = ast; 
        if((ast == null) && (autoVar)) {
            result.type = checker.anyType; 
        } else  {
            result.type = null; 
        }
        return result; 
    }
    Tools.getTypeLink = getTypeLink;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    function stripQuotes(str) {
        return str.replace("\"", "").replace("'", "").replace("'", "").replace("\"", ""); 
    }
    Tools.stripQuotes = stripQuotes;
    function isQuoted(str) {
        return str.indexOf("\"") != -1 || str.indexOf("'") != -1 || str.indexOf("'") != -1 || str.indexOf("\"") != -1; 
    }
    Tools.isQuoted = isQuoted;
    function quoteStr(str) {
        return ("\"" + str) + "\""; 
    }
    Tools.quoteStr = quoteStr;
    function swapQuotes(str) {
        if(str.indexOf("\"") != -1) {
            str = str.replace("\"", "'"); 
            str = str.replace("\"", "'"); 
        } else  {
            str = str.replace("'", "\""); 
            str = str.replace("'", "\""); 
        }
        return str; 
    }
    Tools.swapQuotes = swapQuotes;
    function switchToForwardSlashes(path) {
        return path.replace(/\\/g, "/"); 
    }
    Tools.switchToForwardSlashes = switchToForwardSlashes;
    function trimModName(modName) {
        if(modName.length > 4 && modName.substring(modName.length - 4, modName.length) == ".str") {
            modName = modName.substring(0, modName.length - 4); 
        }
        if(modName.length > 2 && modName.substring(modName.length - 2, modName.length) == ".d") {
            modName = modName.substring(0, modName.length - 2); 
        }
        return modName; 
    }
    Tools.trimModName = trimModName;
    function getPrettyName(modPath, quote, treatAsFileName) {
        if (typeof quote === "undefined") {quote = true; }
        if (typeof treatAsFileName === "undefined") {treatAsFileName = false; }
        var modName = treatAsFileName ? modPath : trimModName(stripQuotes(modPath)); 
        var components = modName.split("/"); 
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath; 
    }
    Tools.getPrettyName = getPrettyName;
    function quoteBaseName(modPath) {
        var modName = trimModName(stripQuotes(modPath)); 
        var path = getRootFilePath(modName); 
        if(path == "") {
            return modPath; 
        } else  {
            var components = modName.split(path); 
            var fileIndex = components.length > 1 ? 1 : 0; 
            return quoteStr(components[fileIndex]); 
        }
    }
    Tools.quoteBaseName = quoteBaseName;
    function changePathToSTR(modPath) {
        return trimModName(stripQuotes(modPath)) + ".str"; 
    }
    Tools.changePathToSTR = changePathToSTR;
    function changePathToDSTR(modPath) {
        return trimModName(stripQuotes(modPath)) + ".d.str"; 
    }
    Tools.changePathToDSTR = changePathToDSTR;
    function isRelative(path) {
        return path.charAt(0) == "."; 
    }
    Tools.isRelative = isRelative;
    function isRooted(path) {
        return path.charAt(0) == "\\" || path.charAt(0) == "/" || (path.indexOf(":\\") != -1) || (path.indexOf(":/") != -1); 
    }
    Tools.isRooted = isRooted;
    function getRootFilePath(outFname) {
        if(outFname == "") {
            return outFname; 
        } else  {
            var isPath = outFname.indexOf("/") != -1; 
            return isPath ? filePath(outFname) : ""; 
        }
    }
    Tools.getRootFilePath = getRootFilePath;
    function filePath(fullPath) {
        fullPath = switchToForwardSlashes(fullPath); 
        var components = fullPath.split("/"); 
        var path = components.slice(0, components.length - 1); 
        return path.join("/") + "/"; 
    }
    Tools.filePath = filePath;
    function normalizeURL(url) {
        var hostDomainAndPortRegex = /^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i; 
        var matches = hostDomainAndPortRegex.exec(url); 
        if(matches) {
            var hostDomainAndPort = matches[1]; 
            var actualPath = matches[3]; 
            return hostDomainAndPort + normalizePath(actualPath); 
        }
        return normalizePath(url); 
    }
    Tools.normalizeURL = normalizeURL;
    Tools.pathNormalizeRegExp = /\//g; 
    function normalizePath(path) {
        path = switchToForwardSlashes(path); 
        var startedWithSep = path.charAt(0) === "/"; 
        var parts = path.split("/"); 
        for(var i = 0; i < parts.length; i++) {
            if(parts[i] === "." || parts[i] === "") {
                parts.splice(i, 1); 
                i--; 
            }
            if(i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {
                parts.splice(i - 1, 2); 
                i -= 2; 
            }
        }
        return (startedWithSep ? "/" : "") + parts.join("/"); 
    }
    Tools.normalizePath = normalizePath;
    function normalizeImportPath(path) {
        return normalizePath(path); 
    }
    Tools.normalizeImportPath = normalizeImportPath;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var SourceUnit = (function () {
        function SourceUnit(path, content) {
            this.path = path;
            this.content = content;

        }
        SourceUnit.prototype.getText = function(start, end) {
            return this.content.substring(start, end); 
        };
        SourceUnit.prototype.getLength = function() {
            return this.content.length; 
        };
        return SourceUnit;
    })();
    Tools.SourceUnit = SourceUnit;
    
    var CompilationEnvironment = (function () {
        function CompilationEnvironment(compilationSettings, ioHost) {
            this.compilationSettings = compilationSettings;
            this.ioHost = ioHost;
            this.residentCode = []; 
            this.code = []; 
        }
        return CompilationEnvironment;
    })();
    Tools.CompilationEnvironment = CompilationEnvironment;
    
    var CodeResolver = (function () {
        function CodeResolver(environment) {
            this.environment = environment;
            this.visited = {
            }; 
        }
        CodeResolver.prototype.resolveCode = function(referencePath, parentPath, performSearch, resolutionDispatcher) {
            var resolvedFile = {
                content: "",
                path: referencePath
            }; 
            var ioHost = this.environment.ioHost; 
            var isRelativePath = Tools.isRelative(referencePath); 
            var isRootedPath = isRelativePath ? false : Tools.isRooted(referencePath); 
            var normalizedPath = isRelativePath ? ioHost.resolvePath((parentPath + "/") + referencePath) : (isRootedPath || !parentPath || performSearch ? referencePath : (parentPath + "/") + referencePath); 
            if(normalizedPath.substring(normalizedPath.length - 4, normalizedPath.length) != ".str") {
                normalizedPath += ".str"; 
            }
            normalizedPath = Tools.switchToForwardSlashes(Tools.stripQuotes(normalizedPath)); 
            if(!this.visited[normalizedPath]) {
                if(isRelativePath || isRootedPath || !performSearch) {
                    try  {
                        Tools.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath); 
                        try  {
                            resolvedFile.content = ioHost.readFile(normalizedPath); 
                        } catch (err) {
                            normalizedPath = Tools.changePathToDSTR(normalizedPath); 
                            Tools.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath); 
                            resolvedFile.content = ioHost.readFile(normalizedPath); 
                        }
                        Tools.CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath); 
                        resolvedFile.path = normalizedPath; 
                        this.visited[resolvedFile.path] = true; 
                    } catch (err) {
                        Tools.CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath); 
                    }
                } else  {
                    resolvedFile = ioHost.findFile(parentPath, normalizedPath); 
                    if(!resolvedFile) {
                        normalizedPath = Tools.changePathToDSTR(normalizedPath); 
                        resolvedFile = ioHost.findFile(parentPath, normalizedPath); 
                    }
                    if(resolvedFile) {
                        resolvedFile.path = Tools.switchToForwardSlashes(Tools.stripQuotes(resolvedFile.path)); 
                        Tools.CompilerDiagnostics.debugPrint((referencePath + " resolved to: ") + resolvedFile.path); 
                        resolvedFile.content = resolvedFile.content; 
                        this.visited[resolvedFile.path] = true; 
                    } else  {
                        Tools.CompilerDiagnostics.debugPrint("Could not find " + referencePath); 
                    }
                }
                if(resolvedFile && resolvedFile.content) {
                    var rootDir = ioHost.dirName(resolvedFile.path); 
                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content); 
                    var preProcessedFileInfo = Tools.preProcessFile(sourceUnit, this.environment.compilationSettings); 
                    for(var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {
                        var referencedFile = preProcessedFileInfo.referencedFiles[i]; 
                        var normalizedPath = Tools.isRooted(referencedFile.path) ? referencedFile.path : (rootDir + "/") + referencedFile.path; 
                        normalizedPath = ioHost.resolvePath(normalizedPath); 
                        if(referencePath == normalizedPath) {
                            resolutionDispatcher.postResolutionError(normalizedPath, "File contains reference to itself", null); 
                            continue;
                        }
                        this.resolveCode(referencedFile.path, rootDir, false, resolutionDispatcher); 
                    }
                    for(var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {
                        this.resolveCode(preProcessedFileInfo.importedFiles[i].path, rootDir, true, resolutionDispatcher); 
                    }
                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit); 
                }
            }
        };
        return CodeResolver;
    })();
    Tools.CodeResolver = CodeResolver;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var StyleSettings = (function () {
        function StyleSettings() {
            this.bitwise = false; 
            this.blockInCompoundStmt = false; 
            this.eqeqeq = false; 
            this.forin = false; 
            this.emptyBlocks = true; 
            this.newMustBeUsed = false; 
            this.requireSemi = false; 
            this.assignmentInCond = false; 
            this.eqnull = false; 
            this.evalOK = true; 
            this.innerScopeDeclEscape = true; 
            this.funcInLoop = true; 
            this.reDeclareLocal = true; 
            this.literalSubscript = true; 
            this.implicitAny = false; 
        }
        StyleSettings.prototype.setOption = function(opt, val) {
            var optExists = this[opt]; 
            if(optExists !== undefined) {
                this[opt] = val; 
                return true; 
            } else  {
                return false; 
            }
        };
        StyleSettings.prototype.parseOptions = function(str) {
            var opts = str.split(";"); 
            for(var i = 0, len = opts.length; i < len; i++) {
                var opt = opts[i]; 
                var val = true; 
                var colonIndex = opt.lastIndexOf(":"); 
                if(colonIndex >= 0) {
                    var valStr = opt.substring(colonIndex + 1); 
                    opt = opt.substring(0, colonIndex); 
                    if(valStr == "off") {
                        val = false; 
                    }
                }
                if(!this.setOption(opt, val)) {
                    return false; 
                }
            }
            return true; 
        };
        return StyleSettings;
    })();
    Tools.StyleSettings = StyleSettings;
    
    var CompilationSettings = (function () {
        function CompilationSettings() {
            this.styleSettings = new StyleSettings(); 
            this.emitTypes = false; 
            this.propagateConstants = false; 
            this.minWhitespace = false; 
            this.parseOnly = false; 
            this.outputMany = true; 
            this.errorRecovery = false; 
            this.emitComments = false; 
            this.watch = false; 
            this.exec = false; 
            this.resolve = true; 
            this.controlFlow = false; 
            this.printControlFlow = false; 
            this.controlFlowUseDef = false; 
            this.errorOnWith = true; 
            this.preprocess = true; 
            this.propertiesRequireThis = true; 
            this.inferPropertiesFromThisAssignment = false; 
            this.codeGenTarget = Tools.CodeGenTarget.ES5; 
            this.moduleGenTarget = Tools.ModuleGenTarget.Asynchronous; 
            this.outputFileName = ""; 
            this.errorFileName = ""; 
            this.mapSourceFiles = false; 
        }
        CompilationSettings.prototype.setStyleOptions = function(str) {
            this.styleSettings.parseOptions(str); 
        };
        CompilationSettings.prototype.outputOne = function(outFile) {
            this.outputFileName = outFile; 
            this.outputMany = false; 
        };
        return CompilationSettings;
    })();
    Tools.CompilationSettings = CompilationSettings;
    
    function getFileReferenceFromReferencePath(comment) {
        var referencesRegEx = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm; 
        var match = referencesRegEx.exec(comment); 
        if(match != null) {
            var path = Tools.normalizePath(match[3]); 
            var adjustedPath = Tools.normalizePath(path); 
            var isResident = match.length >= 7 && match[6] == "true"; 
            if(isResident) {
                Tools.CompilerDiagnostics.debugPrint(path + " is resident"); 
            }
            return {
                minChar: 0,
                limChar: 0,
                path: Tools.switchToForwardSlashes(adjustedPath),
                isResident: isResident
            }; 
        } else  {
            return null; 
        }
    }
    function getAdditionalDependencyPath(comment) {
        var referencesRegEx = /^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm; 
        var match = referencesRegEx.exec(comment); 
        if(match != null) {
            var path = match[3]; 
            return path; 
        } else  {
            return null; 
        }
    }
    Tools.getAdditionalDependencyPath = getAdditionalDependencyPath;
    function getStyleSettings(comment, styleSettings) {
        var styleRegEx = /^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/igm; 
        var settings = styleRegEx.exec(comment); 
        if(settings) {
            var settingsRegEx = /^([a-zA-Z]+=['"]on['|"])/igm; 
            settings = settingsRegEx.exec(settings[2]); 
            if(settings) {
                for(var i = 0; i < settings.length; i++) {
                    var setting = (settings[i]).split("="); 
                    var on = "\"on\""; 
                    switch(setting[0]) {
                        case "blockInCompoundStmt": {
                            styleSettings.blockInCompoundStmt = setting[1] == on; 
                            break;

                        }
                        case "eqeqeq": {
                            styleSettings.eqeqeq = setting[1] == on; 
                            break;

                        }
                        case "forin": {
                            styleSettings.forin = setting[1] == on; 
                            break;

                        }
                        case "emptyBlocks": {
                            styleSettings.emptyBlocks = setting[1] == on; 
                            break;

                        }
                        case "newMustBeUsed": {
                            styleSettings.newMustBeUsed = setting[1] == on; 
                            break;

                        }
                        case "requireSemi": {
                            styleSettings.requireSemi = setting[1] == on; 
                            break;

                        }
                        case "assignmentInCond": {
                            styleSettings.assignmentInCond = setting[1] == on; 
                            break;

                        }
                        case "eqnull": {
                            styleSettings.eqnull = setting[1] == on; 
                            break;

                        }
                        case "evalOK": {
                            styleSettings.evalOK = setting[1] == on; 
                            break;

                        }
                        case "innerScopeDeclEscape": {
                            styleSettings.innerScopeDeclEscape = setting[1] == on; 
                            break;

                        }
                        case "funcInLoop": {
                            styleSettings.funcInLoop = setting[1] == on; 
                            break;

                        }
                        case "reDeclareLocal": {
                            styleSettings.reDeclareLocal = setting[1] == on; 
                            break;

                        }
                        case "literalSubscript": {
                            styleSettings.literalSubscript = setting[1] == on; 
                            break;

                        }
                        case "implicitAny": {
                            styleSettings.implicitAny = setting[1] == on; 
                            break;

                        }
                    }
                }
            }
        }
    }
    Tools.getStyleSettings = getStyleSettings;
    function preProcessFile(sourceText, options) {
        if (typeof options === "undefined") {options = new CompilationSettings(); }
        var scanner = new Tools.Scanner(); 
        scanner.resetComments(); 
        scanner.setSourceText(sourceText, Tools.LexMode.File); 
        var tok = scanner.scan(); 
        var comments = []; 
        var comment = null; 
        var leftCurlies = []; 
        var settings = options; 
        var referencedFiles = []; 
        var importedFiles = []; 
        var isLibFile = false; 
        while(tok.tokenId != Tools.TokenID.EOF) {
            if(tok.tokenId == Tools.TokenID.IMPORT) {
                tok = scanner.scan(); 
                if(tok.tokenId == Tools.TokenID.ID || Tools.convertTokToID(tok, false)) {
                    tok = scanner.scan(); 
                    if(tok.tokenId == Tools.TokenID.Asg) {
                        tok = scanner.scan(); 
                        if(tok.tokenId == Tools.TokenID.MODULE) {
                            tok = scanner.scan(); 
                            if(tok.tokenId == Tools.TokenID.LParen) {
                                tok = scanner.scan(); 
                                if(tok.tokenId == Tools.TokenID.QString) {
                                    var ref = {
                                        minChar: scanner.startPos,
                                        limChar: scanner.pos,
                                        path: Tools.stripQuotes(Tools.switchToForwardSlashes(tok.getText())),
                                        isResident: false
                                    }; 
                                    importedFiles.push(ref); 
                                }
                            }
                        }
                    }
                }
            }
            if(tok.tokenId == Tools.TokenID.LCurly) {
                leftCurlies.push(tok); 
            }
            if(tok.tokenId == Tools.TokenID.RCurly) {
                leftCurlies.pop(); 
            }
            tok = scanner.scan(); 
        }
        comments = scanner.getComments(); 
        for(var iComment = 0; iComment < comments.length; iComment++) {
            comment = comments[iComment]; 
            if(!comment.isBlock) {
                var referencedCode = getFileReferenceFromReferencePath(comment.getText()); 
                if(referencedCode != null) {
                    referencedCode.minChar = comment.startPos; 
                    referencedCode.limChar = referencedCode.minChar + comment.value.length; 
                    referencedFiles.push(referencedCode); 
                }
                getStyleSettings(comment.getText(), settings.styleSettings); 
                var isNoLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/igm; 
                var isNoLibMatch = isNoLibRegex.exec(comment.getText()); 
                isLibFile = isNoLibMatch != null && isNoLibMatch[3] == "true"; 
            }
        }
        return {
            settings: settings,
            referencedFiles: referencedFiles,
            importedFiles: importedFiles,
            isLibFile: isLibFile
        }; 
    }
    Tools.preProcessFile = preProcessFile;
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    var IncrementalParser = (function () {
        function IncrementalParser(logger) {
            this.logger = logger;
            this.astLogger = new Tools.AstLogger(this.logger); 
        }
        IncrementalParser.prototype.attemptIncrementalUpdateUnit = function(previousScript, scriptId, newSourceText, editRange) {
            this.logger.log(("attemptIncrementalUpdateUnit(\"" + scriptId) + "\")"); 
            if(!editRange || editRange.isUnknown()) {
                this.logger.log("  Bailing out because edit range is unknown"); 
                return null; 
            }
            var scope1 = Tools.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false); 
            var scope2 = Tools.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false); 
            if(scope1 == null || scope2 == null) {
                this.logger.log("  Bailing out because containing scopes cannot be determined"); 
                return null; 
            }
            if(scope1.scopeStartAST !== scope2.scopeStartAST) {
                this.logger.log("  Bailing out because edit overlaps 2 disctint scopes"); 
                return null; 
            }
            var newScopeLength = (scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar) + editRange.delta; 
            if(newScopeLength <= 0) {
                this.logger.log("  Bailing out because scope has been entirely removed from new source text"); 
                return null; 
            }
            if(newScopeLength >= newSourceText.getLength() / 2) {
                this.logger.log(("  Bailing out because range of scope to reparse (" + newScopeLength) + " characters) is greater than half the size of the source text"); 
                return null; 
            }
            var parseErrors = []; 
            var errorCapture = function(minChar, charLen, message, unitIndex) {
                parseErrors.push(new Tools.ErrorEntry(unitIndex, minChar, minChar + charLen, message)); 
            }; 
            var quickParseResult = Tools.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture); 
            if(quickParseResult.endLexState != Tools.LexState.Start) {
                this.logger.log("  Bailing out because scope contains unterminated comment"); 
                return null; 
            }
            var scriptFragment = quickParseResult.Script; 
            if(scriptFragment.vars.members.length !== 0) {
                this.logger.log("  Bailing out because new source text defines variables"); 
                return null; 
            }
            if(scriptFragment.bod.members.length !== 1) {
                this.logger.log("  Bailing out because new source text defines more than one scope (or none)"); 
                return null; 
            }
            var oldScope = scope1.scopeStartAST; 
            var newScope = scriptFragment.bod.members[0]; 
            if(oldScope.nodeType != newScope.nodeType) {
                this.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope"); 
                return null; 
            }
            if(!(oldScope).leftCurlyCount || !(oldScope).rightCurlyCount) {
                this.logger.log("  Bailing out because sopce doesn't have left/right curly count"); 
            }
            if((oldScope).leftCurlyCount !== (newScope).leftCurlyCount) {
                this.logger.log("  Bailing out because new source text contains more (or fewer) left curly braces"); 
                return null; 
            }
            if((oldScope).rightCurlyCount !== (newScope).rightCurlyCount) {
                this.logger.log("  Bailing out because new source text contains more (or fewer) right curly braces"); 
                return null; 
            }
            if(newScope.minChar !== 0) {
                this.logger.log("  Bailing out because new function declaration does not start at position 0"); 
                return null; 
            }
            if(newScope.limChar !== newScopeLength) {
                this.logger.log("  Bailing out because new function declaration does not end at the new end position"); 
                return null; 
            }
            return Tools.UpdateUnitResult.editsInsideFunctionBody(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors); 
        };
        IncrementalParser.prototype.mergeTrees = function(updateResult) {
            var _self = this;
            Tools.timeFunction(this.logger, "mergeTrees()", function() {
                var editRange = new Tools.ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta); 
                _self.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta); 
                _self.applyDeltaPosition(updateResult.script2, 0, editRange.minChar); 
                _self.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange); 
                _self.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2); 
            }); 
        };
        IncrementalParser.prototype.replaceAST = function(script, oldAst, newAst) {
            var _self = this;
            var ctx = {
                goChildren: true,
                goNextSibling: true
            }; 
            var pre = function(cur, parent, ctx) {
                if(cur === oldAst) {
                    newAst.preComments = cur.preComments; 
                    newAst.postComments = cur.postComments; 
                    _self.logger.log("replaced old AST node with new one in script AST"); 
                    ctx.goChildren = false; 
                    return newAst; 
                }
                if(Tools.isValidAstNode(cur)) {
                    if(cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {
                        ctx.goChildren = false; 
                    }
                }
                return cur; 
            }; 
            script.walk(pre, null, null, ctx); 
        };
        IncrementalParser.prototype.mergeLocationInfo = function(script, partial, editRange) {
            var lineMap1 = script.locationInfo.lineMap; 
            var lineMap2 = partial.locationInfo.lineMap; 
            if(this.logger.information()) {
                this.logger.log("lineMap1 (before):"); 
                this.astLogger.logLinemap(lineMap1); 
                this.logger.log("lineMap2 (quick parse):"); 
                this.astLogger.logLinemap(lineMap2); 
                this.logger.log("EditRange=" + editRange); 
            }
            var i1 = 2; 
            var i2 = 2; 
            var len1 = lineMap1.length; 
            var len2 = lineMap2.length; 
            while(i1 < len1 || i2 < len2) {
                if(i1 < len1) {
                    if(lineMap1[i1] <= editRange.minChar) {
                        i1++; 
                    } else  {
                        if(lineMap1[i1] >= editRange.limChar) {
                            lineMap1[i1] += editRange.delta; 
                            i1++; 
                        } else  {
                            if(i2 < len2) {
                                lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar); 
                                i1++; 
                                len1++; 
                                i2++; 
                            } else  {
                                lineMap1.splice(i1, 1); 
                                len1--; 
                            }
                        }
                    }
                } else  {
                    lineMap1.push(lineMap2[i2] + editRange.minChar); 
                    i2++; 
                }
            }
            if(this.logger.information()) {
                this.logger.log("lineMap1 (after merge):"); 
                this.astLogger.logLinemap(lineMap1); 
            }
        };
        IncrementalParser.prototype.applyDeltaPosition = function(ast, start, delta) {
            var ctx = {
                goChildren: true,
                goNextSibling: true
            }; 
            var applyDelta = function(ast) {
                if(ast.minChar !== -1 && ast.minChar >= start) {
                    ast.minChar += delta; 
                }
                if(ast.limChar !== -1 && ast.limChar >= start) {
                    ast.limChar += delta; 
                }
            }; 
            var applyDeltaToComments = function(comments) {
                if(comments && comments.length > 0) {
                    for(var i = 0; i < comments.length; i++) {
                        applyDelta(comments[i]); 
                    }
                }
            }; 
            var pre = function(cur, parent, ctx) {
                if(cur.limChar !== -1 && cur.limChar < start) {
                    ctx.goChildren = false; 
                }
                applyDelta(cur); 
                applyDeltaToComments(cur.preComments); 
                applyDeltaToComments(cur.postComments); 
                return cur; 
            }; 
            ast.walk(pre, null, null, ctx); 
        };
        return IncrementalParser;
    })();
    Tools.IncrementalParser = IncrementalParser;
    
})(Tools||(Tools={}));

var Tools;
(function(Tools) {
    (function(UpdateUnitKind) {
        UpdateUnitKind._map = []; 
        UpdateUnitKind._map[0] = "Unknown"; 
        UpdateUnitKind.Unknown = 0; 
        UpdateUnitKind._map[1] = "NoEdits"; 
        UpdateUnitKind.NoEdits = 1; 
        UpdateUnitKind._map[2] = "EditsInsideSingleScope"; 
        UpdateUnitKind.EditsInsideSingleScope = 2; 
    })(Tools.UpdateUnitKind||(Tools.UpdateUnitKind={}));
    var UpdateUnitKind = Tools.UpdateUnitKind;

    var ScriptEditRange = (function () {
        function ScriptEditRange(minChar, limChar, delta) {
            this.minChar = minChar;
            this.limChar = limChar;
            this.delta = delta;
        }
        function unknown() {
            return new ScriptEditRange(-1, -1, -1); 
        }
        ScriptEditRange.unknown = unknown;
        ScriptEditRange.prototype.isUnknown = function() {
            return this.minChar === -1 && this.limChar === -1 && this.delta === -1; 
        };
        ScriptEditRange.prototype.containsPosition = function(pos) {
            return (this.minChar <= pos && pos < this.limChar) || (this.minChar <= pos && pos < this.limChar + this.delta); 
        };
        ScriptEditRange.prototype.toString = function() {
            return ((((("editRange(minChar=" + this.minChar) + ", limChar=") + this.limChar) + ", delta=") + this.delta) + ")"; 
        };
        return ScriptEditRange;
    })();
    Tools.ScriptEditRange = ScriptEditRange;
    
    var UpdateUnitResult = (function () {
        function UpdateUnitResult(kind, unitIndex, script1, script2) {
            this.kind = kind;
            this.unitIndex = unitIndex;
            this.script1 = script1;
            this.script2 = script2;
            this.scope1 = null; 
            this.scope2 = null; 
            this.editRange = null; 
            this.parseErrors = []; 
        }
        function noEdits(unitIndex) {
            return new UpdateUnitResult(UpdateUnitKind.NoEdits, unitIndex, null, null); 
        }
        UpdateUnitResult.noEdits = noEdits;
        function unknown(script1, script2, parseErrors) {
            var result = new UpdateUnitResult(UpdateUnitKind.Unknown, script1.locationInfo.unitIndex, script1, script2); 
            result.parseErrors = parseErrors; 
            return result; 
        }
        UpdateUnitResult.unknown = unknown;
        function editsInsideFunctionBody(script1, script2, scope1, scope2, editRange, parseErrors) {
            var result = new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope, script1.locationInfo.unitIndex, script1, script2); 
            result.scope1 = scope1; 
            result.scope2 = scope2; 
            result.editRange = editRange; 
            result.parseErrors = parseErrors; 
            return result; 
        }
        UpdateUnitResult.editsInsideFunctionBody = editsInsideFunctionBody;
        return UpdateUnitResult;
    })();
    Tools.UpdateUnitResult = UpdateUnitResult;
    
    var ErrorEntry = (function () {
        function ErrorEntry(unitIndex, minChar, limChar, message) {
            this.unitIndex = unitIndex;
            this.minChar = minChar;
            this.limChar = limChar;
            this.message = message;
        }
        return ErrorEntry;
    })();
    Tools.ErrorEntry = ErrorEntry;
    
    Tools.defaultSettings = new Tools.CompilationSettings(); 
    var StradaCompiler = (function () {
        function StradaCompiler(outfile, errorOutput, logger, settings) {
            if (typeof logger === "undefined") {logger = new Tools.NullLogger(); }
            if (typeof settings === "undefined") {settings = Tools.defaultSettings; }
            this.outfile = outfile;
            this.errorOutput = errorOutput;
            this.logger = logger;
            this.settings = settings;
            this.parser = new Tools.Parser(); 
            this.typeChecker = null; 
            this.typeFlow = null; 
            this.scripts = new Tools.ASTList(); 
            this.units = new Array(); 
            this.errorReporter = new Tools.ErrorReporter(this.outfile); 
            this.persistentTypeState = new Tools.PersistentGlobalTypeState(this.errorReporter); 
            this.errorReporter.parser = this.parser; 
            this.initTypeChecker(this.errorOutput); 
            this.parser.style_requireSemi = this.settings.styleSettings.requireSemi; 
            this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop; 
            this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment; 
            this.emitSettings = {
                minWhitespace: this.settings.minWhitespace,
                propagateConstants: this.settings.propagateConstants,
                emitComments: this.settings.emitComments
            }; 
        }
        StradaCompiler.prototype.timeFunction = function(funcDescription, func) {
            return Tools.timeFunction(this.logger, funcDescription, func); 
        };
        StradaCompiler.prototype.initTypeChecker = function(errorOutput) {
            this.persistentTypeState.refreshPersistentState(); 
            this.typeChecker = new Tools.TypeChecker(this.persistentTypeState); 
            this.typeChecker.errorReporter = this.errorReporter; 
            this.typeChecker.checkControlFlow = this.settings.controlFlow; 
            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef; 
            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow; 
            this.typeChecker.errorsOnWith = this.settings.errorOnWith; 
            this.typeChecker.styleSettings = this.settings.styleSettings; 
            this.typeChecker.addMembersToClassScope = !this.settings.propertiesRequireThis; 
            this.errorReporter.checker = this.typeChecker; 
            this.setErrorOutput(this.errorOutput); 
        };
        StradaCompiler.prototype.setErrorOutput = function(outerr) {
            this.errorOutput = outerr; 
            this.errorReporter.setErrOut(outerr); 
            this.parser.outfile = outerr; 
        };
        StradaCompiler.prototype.emitCommentsToOutput = function() {
            this.emitSettings = {
                minWhitespace: this.settings.minWhitespace,
                propagateConstants: this.settings.propagateConstants,
                emitComments: this.settings.emitComments
            }; 
        };
        StradaCompiler.prototype.setErrorCallback = function(fn) {
            this.parser.errorCallback = fn; 
        };
        StradaCompiler.prototype.updateUnit = function(prog, filename, setRecovery) {
            return this.updateSourceUnit(new Tools.StringSourceText(prog), filename, setRecovery); 
        };
        StradaCompiler.prototype.updateSourceUnit = function(sourceText, filename, setRecovery) {
            var _self = this;
            return this.timeFunction(("updateSourceUnit(" + filename) + ")", function() {
                var updateResult = _self.partialUpdateUnit(sourceText, filename, setRecovery); 
                return _self.applyUpdateResult(updateResult); 
            }); 
        };
        StradaCompiler.prototype.applyUpdateResult = function(updateResult) {
            switch(updateResult.kind) {
                case UpdateUnitKind.NoEdits: {
                    return false; 

                }
                case UpdateUnitKind.Unknown: {
                    this.scripts.members[updateResult.unitIndex] = updateResult.script2; 
                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo; 
                    for(var i = 0, len = updateResult.parseErrors.length; i < len; i++) {
                        var e = updateResult.parseErrors[i]; 
                        if(this.parser.errorCallback != null) {
                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex); 
                        }
                    }
                    return true; 

                }
                case UpdateUnitKind.EditsInsideSingleScope: {
                    new Tools.IncrementalParser(this.logger).mergeTrees(updateResult); 
                    return true; 

                }
            }
        };
        StradaCompiler.prototype.partialUpdateUnit = function(sourceText, filename, setRecovery) {
            var _self = this;
            return this.timeFunction(("partialUpdateUnit(" + filename) + ")", function() {
                for(var i = 0, len = _self.units.length; i < len; i++) {
                    if(_self.units[i].filename == filename) {
                        if((_self.scripts.members[i]).isResident) {
                            return UpdateUnitResult.noEdits(i); 
                        }
                        if(setRecovery) {
                            _self.parser.setErrorRecovery(null, 0, 0); 
                        }
                        var updateResult; 
                        var parseErrors = []; 
                        var errorCapture = function(minChar, charLen, message, unitIndex) {
                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message)); 
                        }; 
                        var svErrorCallback = _self.parser.errorCallback; 
                        if(svErrorCallback != null) {
                            _self.parser.errorCallback = errorCapture; 
                        }
                        var oldScript = _self.scripts.members[i]; 
                        var newScript = _self.parser.parse(sourceText, filename, i); 
                        if(svErrorCallback != null) {
                            _self.parser.errorCallback = svErrorCallback; 
                        }
                        updateResult = UpdateUnitResult.unknown(oldScript, newScript, parseErrors); 
                        return updateResult; 
                    }
                }
                throw new Error(("Unknown file \"" + filename) + "\"");
            }); 
        };
        StradaCompiler.prototype.addUnit = function(prog, filename, keepResident) {
            if (typeof keepResident === "undefined") {keepResident = false; }
            return this.addSourceUnit(new Tools.StringSourceText(prog), filename, keepResident); 
        };
        StradaCompiler.prototype.addSourceUnit = function(sourceText, filename, keepResident) {
            if (typeof keepResident === "undefined") {keepResident = false; }
            var _self = this;
            return this.timeFunction(((("addSourceUnit(" + filename) + ", ") + keepResident) + ")", function() {
                var script = _self.parser.parse(sourceText, filename, _self.units.length, Tools.AllowedElements.Global); 
                script.isResident = keepResident; 
                _self.persistentTypeState.setCollectionMode(keepResident ? Tools.TypeCheckCollectionMode.Resident : Tools.TypeCheckCollectionMode.Transient); 
                var index = _self.units.length; 
                _self.units[index] = script.locationInfo; 
                _self.typeChecker.collectTypes(script); 
                _self.scripts.append(script); 
                return script; 
            }); 
        };
        StradaCompiler.prototype.getInScopeNamesAndTypesFromPosition = function(enclosingScopeContext) {
            var members = enclosingScopeContext.isMemberCompletion; 
            var getTypeNamesForNames = function(allNames, scope) {
                var typeNames = []; 
                var names = []; 
                var enclosingScope = enclosingScopeContext.getScope(); 
                for(var i = 0; i < allNames.length; i++) {
                    try  {
                        var name = allNames[i]; 
                        var publicsOnly = enclosingScopeContext.publicsOnly && members; 
                        var symbol = scope.find(name, publicsOnly, false); 
                        if(symbol == null) {
                            symbol = scope.find(name, publicsOnly, true); 
                        }
                        if(!Tools.isQuoted(symbol.name) && !Tools.isRelative(symbol.name)) {
                            var typeName = symbol.getType().getScopedTypeName(enclosingScope); 
                            names.push(name); 
                            typeNames.push(typeName); 
                        }
                    } catch (e) {
                        if(allNames[i] == "true" || allNames[i] == "false") {
                            names.push(allNames[i]); 
                            typeNames.push("bool"); 
                        }
                    }
                }
                return {
                    names: names,
                    types: typeNames
                }; 
            }; 
            var scope = enclosingScopeContext != null ? (members ? this.typeFlow.findMemberScopeAt(enclosingScopeContext) : enclosingScopeContext.getScope()) : null; 
            if(scope != null) {
                if(enclosingScopeContext.scopeStartAST.nodeType == Tools.NodeType.ObjectLit) {
                    scope = (scope.container).type.memberScope; 
                }
                var inScopeNames = new Tools.StringHashTable(); 
                var allSymbolNames = scope.getAllSymbolNames(members); 
                var name = ""; 
                var symbol = null; 
                for(var i = 0; i < allSymbolNames.length; i++) {
                    name = allSymbolNames[i]; 
                    if(name == Tools.globalId || name == "_Core" || name == "_element") {
                        continue;
                    }
                    inScopeNames.add(name, ""); 
                }
                var svModuleDecl = this.typeChecker.currentModDecl; 
                this.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl; 
                var result = getTypeNamesForNames(inScopeNames.getAllKeys(), scope); 
                this.typeChecker.currentModDecl = svModuleDecl; 
                return result; 
            } else  {
                return null; 
            }
        };
        StradaCompiler.prototype.parseUnit = function(prog, filename) {
            return this.parseSourceUnit(new Tools.StringSourceText(prog), filename); 
        };
        StradaCompiler.prototype.parseSourceUnit = function(sourceText, filename) {
            this.parser.setErrorRecovery(this.outfile, -1, -1); 
            var script = this.parser.parse(sourceText, filename, 0); 
            script.walk(Tools.prePrintAST, Tools.postPrintAST, null, new Tools.PrintContext(this.outfile, this.parser)); 
        };
        StradaCompiler.prototype.typeCheck = function() {
            var _self = this;
            return this.timeFunction("typeCheck()", function() {
                var binder = new Tools.Binder(_self.typeChecker); 
                _self.typeChecker.units = _self.units; 
                binder.bind(_self.typeChecker.globalScope, _self.typeChecker.globals); 
                binder.bind(_self.typeChecker.globalScope, _self.typeChecker.ambientGlobals); 
                binder.bind(_self.typeChecker.globalScope, _self.typeChecker.globalTypes); 
                binder.bind(_self.typeChecker.globalScope, _self.typeChecker.ambientGlobalTypes); 
                _self.typeFlow = new Tools.TypeFlow(_self.logger, _self.typeChecker.globalScope, _self.parser, _self.typeChecker); 
                var i = 0; 
                var script = null; 
                var len = _self.scripts.members.length; 
                _self.persistentTypeState.setCollectionMode(Tools.TypeCheckCollectionMode.Resident); 
                for(i = 0; i < len; i++) {
                    script = _self.scripts.members[i]; 
                    if(!script.isResident || script.hasBeenTypeChecked) {
                        continue;
                    }
                    _self.typeFlow.assignScopes(script); 
                    _self.typeFlow.initLibs(); 
                }
                for(i = 0; i < len; i++) {
                    script = _self.scripts.members[i]; 
                    if(!script.isResident || script.hasBeenTypeChecked) {
                        continue;
                    }
                    _self.typeFlow.typeCheck(script); 
                    script.hasBeenTypeChecked = true; 
                }
                _self.persistentTypeState.setCollectionMode(Tools.TypeCheckCollectionMode.Transient); 
                len = _self.scripts.members.length; 
                for(i = 0; i < len; i++) {
                    script = _self.scripts.members[i]; 
                    if(script.isResident) {
                        continue;
                    }
                    _self.typeFlow.assignScopes(script); 
                    _self.typeFlow.initLibs(); 
                }
                for(i = 0; i < len; i++) {
                    script = _self.scripts.members[i]; 
                    if(script.isResident) {
                        continue;
                    }
                    _self.typeFlow.typeCheck(script); 
                }
                return null; 
            }); 
        };
        StradaCompiler.prototype.cleanASTTypesForReTypeCheck = function(ast) {
            function cleanASTType(ast, parent, context) {
                ast.type = null; 
                if(ast.nodeType == Tools.NodeType.VarDecl) {
                    var vardecl = ast; 
                    vardecl.sym = null; 
                } else  {
                    if(ast.nodeType == Tools.NodeType.ArgDecl) {
                        var argdecl = ast; 
                        argdecl.sym = null; 
                    } else  {
                        if(ast.nodeType == Tools.NodeType.Name) {
                            var name = ast; 
                            name.sym = null; 
                        } else  {
                            if(ast.nodeType == Tools.NodeType.FuncDecl) {
                                var funcdecl = ast; 
                                funcdecl.signature = null; 
                                funcdecl.freeVariables = new Array(); 
                                funcdecl.symbols = null; 
                                funcdecl.accessorSymbol = null; 
                            } else  {
                                if(ast.nodeType == Tools.NodeType.Module) {
                                    var modDecl = ast; 
                                    modDecl.anonExportedSymbols = null; 
                                    modDecl.mod = null; 
                                } else  {
                                    if(ast.nodeType == Tools.NodeType.With) {
                                        (ast).withSym = null; 
                                    } else  {
                                        if(ast.nodeType == Tools.NodeType.Catch) {
                                            (ast).containedScope = null; 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return ast; 
            }
            ast.walk(cleanASTType, null, null, {
                goChildren: true,
                goNextSibling: true
            }); 
        };
        StradaCompiler.prototype.cleanTypesForReTypeCheck = function() {
            var _self = this;
            return this.timeFunction("cleanTypesForReTypeCheck()", function() {
                for(var i = 0, len = _self.scripts.members.length; i < len; i++) {
                    var script = _self.scripts.members[i]; 
                    if((script).isResident) {
                        continue;
                    }
                    _self.cleanASTTypesForReTypeCheck(script); 
                    _self.typeChecker.collectTypes(script); 
                }
                return null; 
            }); 
        };
        StradaCompiler.prototype.attemptIncrementalTypeCheck = function(updateResult) {
            return this.timeFunction("attemptIncrementalTypeCheck()", function() {
                return false; 
            }); 
        };
        StradaCompiler.prototype.reTypeCheck = function() {
            var _self = this;
            return this.timeFunction("reTypeCheck()", function() {
                Tools.CompilerDiagnostics.analysisPass++; 
                _self.initTypeChecker(_self.errorOutput); 
                _self.persistentTypeState.setCollectionMode(Tools.TypeCheckCollectionMode.Transient); 
                _self.cleanTypesForReTypeCheck(); 
                return _self.typeCheck(); 
            }); 
        };
        StradaCompiler.prototype.emitTypes = function() {
            var emitter = new Tools.Emitter(this.typeChecker, this.outfile, this.emitSettings); 
            for(var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = this.scripts.members[i]; 
                script.emitType(emitter); 
            }
        };
        StradaCompiler.prototype.emit = function(outputMany, createFile) {
            var emitter = null; 
            for(var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = this.scripts.members[i]; 
                if(!script.emitRequired()) {
                    continue;
                }
                var outf = this.outfile; 
                if(outputMany) {
                    var fname = this.units[i].filename; 
                    var splitFname = fname.split("."); 
                    var outFname = ""; 
                    for(var j = 0, splitLen = splitFname.length; j < splitLen - 1; j++) {
                        outFname += (splitFname[j] + "."); 
                    }
                    outFname += "js"; 
                    outf = createFile(outFname); 
                    emitter = new Tools.Emitter(this.typeChecker, outf, this.emitSettings); 
                    if(this.settings.mapSourceFiles) {
                        emitter.setSourceMappings(new Tools.SourceMapper(fname, outFname, outf, createFile(outFname + Tools.SourceMapper.MapFileExtension))); 
                    }
                } else  {
                    if(emitter == null) {
                        emitter = new Tools.Emitter(this.typeChecker, this.outfile, this.emitSettings); 
                        if(this.settings.mapSourceFiles) {
                            emitter.setSourceMappings(new Tools.SourceMapper(script.locationInfo.filename, this.settings.outputFileName, this.outfile, createFile(this.settings.outputFileName + Tools.SourceMapper.MapFileExtension))); 
                        }
                    } else  {
                        if(this.settings.mapSourceFiles) {
                            emitter.setSourceMappings(new Tools.SourceMapper(script.locationInfo.filename, emitter.sourceMapper.jsFileName, this.outfile, emitter.sourceMapper.sourceMapOut)); 
                        }
                    }
                }
                this.typeChecker.locationInfo = script.locationInfo; 
                emitter.emitJavascript(script, Tools.TokenID.Comma, false); 
                if(outputMany) {
                    if(this.settings.mapSourceFiles) {
                        emitter.emitSourceMappings(); 
                    }
                    outf.Close(); 
                }
            }
            if(!outputMany && this.settings.mapSourceFiles) {
                emitter.emitSourceMappings(); 
            }
        };
        StradaCompiler.prototype.emitToOutfile = function() {
            var emitter = null; 
            if(this.settings.mapSourceFiles) {
                throw Error("Outputing map not supported in this case because dont know how to createFile");
            }
            for(var i = 0, len = this.scripts.members.length; i < len; i++) {
                if(emitter == null) {
                    emitter = new Tools.Emitter(this.typeChecker, this.outfile, this.emitSettings); 
                }
                var script = this.scripts.members[i]; 
                this.typeChecker.locationInfo = script.locationInfo; 
                emitter.emitJavascript(script, Tools.TokenID.Comma, false); 
            }
        };
        return StradaCompiler;
    })();
    Tools.StradaCompiler = StradaCompiler;
    
})(Tools||(Tools={}));

var StringTextWriter = (function () {
    function StringTextWriter() {
        this.buff = ""; 
    }
    StringTextWriter.prototype.Write = function(s) {
        this.buff += s; 
    };
    StringTextWriter.prototype.WriteLine = function(s) {
        this.buff += s + "\n"; 
    };
    StringTextWriter.prototype.Close = function() {
    };
    return StringTextWriter;
})();

var libString = "/// <reference no-default-lib=\"true\"/>\n\n// A subset of lib.str containting only what\'s relevant to the compiler and tests\ndeclare module _Core {\n    export interface Array {\n        toString(): string;\n        toLocaleString(): string;\n        concat(...items: _element[][]): _element[];\n        join(seperator: string): string;\n        pop(): _element;\n        push(...items: _element[]): void;\n        reverse(): _element[];\n        shift(): _element;\n        slice(start: number): _element[];\n        slice(start: number, end: number): _element[];\n        sort(): _element[];\n        sort(compareFn: (a: _element, b: _element) => number): _element[];\n        splice(start: number): _element[];\n        splice(start: number, deleteCount: number, ...items: _element[]): _element[];\n        unshift(...items: _element[]): number;\n\n        indexOf(searchElement: _element): number;\n        indexOf(searchElement: _element, fromIndex: number): number;\n        lastIndexOf(searchElement: _element): number;\n        lastIndexOf(searchElement: _element, fromIndex: number): number;\n        every(callbackfn: (value: _element, index: number, array: _element[]) => bool): bool;\n        every(callbackfn: (value: _element, index: number, array: _element[]) => bool, thisArg: any): bool;\n        some(callbackfn: (value: _element, index: number, array: _element[]) => bool): bool;\n        some(callbackfn: (value: _element, index: number, array: _element[]) => bool, thisArg: any): bool;\n        forEach(callbackfn: (value: _element, index: number, array: _element[]) => void ): void;\n        forEach(callbackfn: (value: _element, index: number, array: _element[]) => void , thisArg: any): void;\n        map(callbackfn: (value: _element, index: number, array: _element[]) => any): any[];\n        map(callbackfn: (value: _element, index: number, array: _element[]) => any, thisArg: any): any[];\n        filter(callbackfn: (value: _element, index: number, array: _element[]) => bool): _element[];\n        filter(callbackfn: (value: _element, index: number, array: _element[]) => bool, thisArg: any): _element[];\n        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: _element[]) => any): any;\n        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: _element[]) => any, initialValue: any): any;\n        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: _element[]) => any): any;\n        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: _element[]) => any, initialValue: any): any;\n\n        length: number;\n    }\n}\ndeclare module {\n    export oldclass RegExp {\n\n        property  exec(string: string): string[];\n        property  test(string: string): bool;\n        property source: string;\n        property global: bool;\n        property ignoreCase: bool;\n        property multiline: bool;\n        property lastIndex: bool;\n\n        static new (pattern: string): RegExp;\n        static new (pattern: string, flags: string): RegExp;\n        static (pattern: string): RegExp;\n        static (pattern: string, flags: string): RegExp;\n    }\n\n    export oldclass String {\n        property charAt(pos: number): string;\n        property charCodeAt(index: number): number;\n        property concat(...strings: string[]): string;\n        property indexOf(searchString: string): number;\n        property indexOf(searchString: string, position: number): number;\n        property lastIndexOf(searchString: string): number;\n        property lastIndexOf(searchString: string, position: number): number;\n        property localeCompare(that: string): number;\n        property match(regexp: string): string[];\n        property match(regexp: RegExp): string[];\n        property replace(searchValue: string, replaceValue: string): string;\n        property replace(searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string;\n        property replace(searchValue: RegExp, replaceValue: string): string;\n        property replace(searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string;\n        property search(regexp: string): number;\n        property search(regexp: RegExp): number;\n        property slice(start: number): string;\n        property slice(start: number, end: number): string;\n        property split(seperator: string): string[];\n        property split(seperator: string, limit: number): string[];\n        property split(seperator: RegExp): string[];\n        property split(seperator: RegExp, limit: number): string[];\n        property substring(start: number): string;\n        property substring(start: number, end: number): string;\n        property toLowerCase(): string;\n        property toLocaleLowerCase(): string;\n        property toUpperCase(): string;\n        property toLocaleUpperCase(): string;\n        property trim(): string;\n\n        property length: number;\n\n        // IE extensions\n        property substr(from: number): string;\n        property substr(from: number, length: number): string;\n\n        static fromCharCode(...codes: number[]): string;\n    }\n\n    export var ActiveXObject: { new (s: string): any; };\n\n    export function alert(msg: string): void;\n    export function parseInt(s: string): number;\n    export function parseInt(s: string, radix: number): number;\n    export function parseFloat(string: string): number;\n    export function eval(x: string): any;\n\n    export interface ITextWriter {\n        Write(s: string): void;\n        WriteLine(s: string): void;\n        Close(): void;\n    }\n\n    export module WScript {\n        export function Echo(s);\n        export var StdErr: ITextWriter;\n        export var StdOut: ITextWriter;\n        export var Arguments: { length: number; Item(n: number): string; };\n        export var ScriptFullName: string;\n    }\n\n    export module Math {\n        export function max(...values: number[]): number;\n        export function min(...values: number[]): number;\n        export function floor(val: number): number;\n        export function round(val: number): number;\n        export function sin(val: number): number;\n        export function cos(val: number): number;\n        export function pow(val: number, exponent: number): number;\n        export function random(): number;\n        export function abs(val: number): number;\n        export function sqrt(val: number): number;\n        export var PI: number;\n    }\n\n    export interface IArguments {\n        [index: number]: any;\n        length: number;\n        callee: Function;\n    }\n\n    export oldclass Function {\n        property  (...args: any[]): any;\n        property  toString(): string; // TODO: Is this needed in class signture, given that it just overrides?\n        property  apply(thisArg: any, ...argArray: any[]): any;\n        property  call(thisArg: any, ...argArray: any[]): any;\n        property  bind(thisArg: any, ...argArray: any[]): any; // TODO: Not sure about this\n\n        property prototype: any;\n        property length: number;\n\n        static new (...args: string[]): Function;\n        static (...args: string[]): Function;\n    }\n\n    export oldclass Error {\n\n        property name: string;\n        property message: string;\n\n        static new (): Error;\n        static new (message: string): Error;\n        static(): Error;\n        static (message: string): Error;\n    }\n\n    export oldclass EvalError extends Error {\n        static new (): EvalError;\n        static new (message: string): EvalError;\n        static(): EvalError;\n        static (message: string): EvalError;\n    }\n\n    export oldclass RangeError extends Error {\n        static new (): RangeError;\n        static new (message: string): RangeError;\n        static(): RangeError;\n        static (message: string): RangeError;\n    }\n\n    export oldclass ReferenceError extends Error {\n        static new (): ReferenceError;\n        static new (message: string): ReferenceError;\n        static(): ReferenceError;\n        static (message: string): ReferenceError;\n    }\n\n    export oldclass SyntaxError extends Error {\n        static new (): SyntaxError;\n        static new (message: string): SyntaxError;\n        static(): SyntaxError;\n        static (message: string): SyntaxError;\n    }\n\n    export oldclass TypeError extends Error {\n        static new (): TypeError;\n        static new (message: string): TypeError;\n        static(): TypeError;\n        static (message: string): TypeError;\n    }\n\n    export oldclass URIError extends Error {\n        static new (): URIError;\n        static new (message: string): URIError;\n        static(): URIError;\n        static (message: string): URIError;\n    }\n\n    export oldclass Date();\n    export oldclass Date(year: number, month: number);\n    export oldclass Date(year: number, month: number, date: number);\n    export oldclass Date(year: number, month: number, date: number, hours: number);\n    export oldclass Date(year: number, month: number, date: number, hours: number, minutes: number);\n    export oldclass Date(year: number, month: number, date: number, hours: number, minutes: number, seconds: number);\n    export oldclass Date(year: number, month: number, date: number, hours: number, minutes: number, seconds: number, ms: number);\n    export function Date(): string;\n    export oldclass Date(value: number) {\n\n        property toString(): string;\n        property toDateString(): string;\n        property toTimeString(): string;\n        property toLocaleString(): string;\n        property toLocaleDateString(): string;\n        property toLocaleTimeString(): string;\n        property valueOf(): number;\n        property getTime(): number;\n        property getFullYear(): number;\n        property getUTCFullYear(): number;\n        property getMonth(): number;\n        property getUTCMonth(): number;\n        property getDate(): number;\n        property getUTCDate(): number;\n        property getDay(): number;\n        property getUTCDay(): number;\n        property getHours(): number;\n        property getUTCHours(): number;\n        property getMinutes(): number;\n        property getUTCMinutes(): number;\n        property getSeconds(): number;\n        property getUTCSeconds(): number;\n        property getMilliseconds(): number;\n        property getUTCMilliseconds(): number;\n        property getTimezoneOffset(): number;\n        property setTime(time: number): void;\n        property setMilliseconds(ms: number): void;\n        property setUTCMilliseconds(ms: number): void;\n        property setSeconds(sec: number, ms?: number): void;\n        property setUTCSeconds(sec: number, ms?: number): void;\n        property setMinutes(min: number, sec?: number, ms?: number): void;\n        property setUTCMinutes(min: number, sec?: number, ms?: number): void;\n        property setHours(hours: number, min?: number, sec?: number, ms?: number): void;\n        property setUTCHours(hours: number, min?: number, sec?: number, ms?: number): void;\n        property setDate(date: number): void;\n        property setUTCDate(date: number): void;\n        property setMonth(month: number, date?: number): void;\n        property setUTCMonth(month: number, date?: number): void;\n        property setFullYear(year: number, month?: number, date?: number): void;\n        property setUTCFullYear(year: number, month?: number, date?: number): void;\n        property toUTCString(): string;\n        property toISOString(): string;\n        property toJSON(key?: any): string;\n\n\n        static parse(s: string): number;\n        static UTC(year: number, month: number): number;\n        static UTC(year: number, month: number, date: number): number;\n        static UTC(year: number, month: number, date: number, hours: number): number;\n        static UTC(year: number, month: number, date: number, hours: number, minutes: number): number;\n        static UTC(year: number, month: number, date: number, hours: number, minutes: number, seconds: number): number;\n        static UTC(year: number, month: number, date: number, hours: number, minutes: number, seconds: number, ms: number): number;\n        static now(): number;\n    }\n\n}\n\ndeclare var Array: {\n    new (...items: any[]): any[];\n    (...items: any[]): any[];\n    isArray(arg: any): bool;\n    prototype: _Core.Array;\n}"; 
var compilerString = "\n\nmodule Tools {\n    export interface IWalkContext {\n        goChildren: bool;\n        goNextSibling: bool;\n        // visit siblings in reverse execution order\n        reverseSiblings: bool;\n    }\n\n    export oldclass BaseWalkContext() implements IWalkContext {\n        property goChildren = true;\n        property goNextSibling = true;\n        property reverseSiblings = false;\n    }\n}\n\nmodule Tools {\n\n    export oldclass AST(property nodeType: NodeType) {\n        property type: Type = null;\n        property flags = ASTFlags.Writeable;\n\n        property minChar: number = -1;  // -1 = \"undefined\" or \"compiler generated\"\n        property limChar: number = -1;  // -1 = \"undefined\" or \"compiler generated\"\n\n        // REVIEW: for diagnostic purposes\n        property passCreated: number = CompilerDiagnostics.analysisPass;\n\n        property preComments: Comment[] = null;\n        property postComments: Comment[] = null;\n\n        property isParenthesized = false;\n\n        property isStatementOrExpression() => false;\n        property isCompoundStatement() => false;\n        property isLeaf() => this.isStatementOrExpression() && (!this.isCompoundStatement());\n\n        property typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    this.type = typeFlow.anyType;\n                    break;\n                case NodeType.Self:\n                    return typeFlow.typeCheckSelf(this);\n                case NodeType.This:\n                    return typeFlow.typeCheckThis(this);\n                case NodeType.Null:\n                    this.type = typeFlow.nullType;\n                    break;\n                case NodeType.False:\n                case NodeType.True:\n                    this.type = typeFlow.booleanType;\n                    break;\n                case NodeType.Super:\n                    return typeFlow.typeCheckSuper(this);\n                case NodeType.EndCode:\n                case NodeType.Empty:\n                case NodeType.Void:\n                    this.type = typeFlow.voidType;\n                    break;\n                default:\n                    throw new Error(\"please implement in derived class\");\n                //type=typeFlow.anyType;\n                // break;\n            }\n            return this;\n        }\n\n        property emitType(emitter: Emitter) {\n            // default do nothing because ast not a type or member declaration\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            switch (this.nodeType) {\n                case NodeType.This:\n                    if ((emitter.thisFnc != null) && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction))) {\n                        emitter.writeToOutput(\"_self\");\n                    }\n                    else {\n                        emitter.writeToOutput(\"this\");\n                    }\n                    break;\n                case NodeType.Self:\n                    if ((emitter.thisFnc != null) && (!emitter.thisFnc.isMethod())) {\n                        emitter.writeToOutput(\"_self\");\n                    }\n                    else {\n                        emitter.writeToOutput(\"this\");\n                    }\n                    break;\n                case NodeType.Null:\n                    emitter.writeToOutput(\"null\");\n                    break;\n                case NodeType.False:\n                    emitter.writeToOutput(\"false\");\n                    break;\n                case NodeType.True:\n                    emitter.writeToOutput(\"true\");\n                    break;\n                case NodeType.Super:\n                    emitter.emitSuperReference();\n                case NodeType.EndCode:\n                    break;\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    break;\n\n                case NodeType.Empty:\n                    emitter.writeToOutput(\";\");\n                    break;\n                case NodeType.Void:\n                    emitter.writeToOutput(\"void \");\n                    break;\n                default:\n                    throw new Error(\"please implement in derived class\");\n                // break;\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property print(context: PrintContext) {\n            context.startLine();\n            var lineCol = { line: -1, col: -1 };\n            var limLineCol = { line: -1, col: -1 };\n            if (context.parser !== null) {\n                context.parser.getSourceLineCol(lineCol, this.minChar);\n                context.parser.getSourceLineCol(limLineCol, this.limChar);\n                context.write(\"(\" + lineCol.line + \",\" + lineCol.col + \")--\" +\n                              \"(\" + limLineCol.line + \",\" + limLineCol.col + \"): \");\n            }\n            var lab = this.printLabel();\n            if (hasFlag(this.flags, ASTFlags.Error)) {\n                lab += \" (Error)\";\n            }\n            context.writeLine(lab);\n        }\n\n        property printLabel() {\n            if (nodeTypeTable[this.nodeType] !== undefined) {\n                return nodeTypeTable[this.nodeType];\n            }\n            else {\n                return (<any>NodeType)._map[this.nodeType];\n            }\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            // by default, AST adds itself to current basic block and does not check its children\n            context.goChildren = false;\n            context.addContent(this);\n        }\n\n        property netFreeUses(container: Symbol, freeUses: StringHashTable) {\n        }\n\n        property treeViewLabel() {\n            return (<any>NodeType)._map[this.nodeType];\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n        }\n\n        property walk(pre: (cur: AST, parent: AST, context: IWalkContext) =>AST,\n            post: (cur: AST, parent: AST, context: IWalkContext) =>AST,\n            parent: AST, context: IWalkContext): AST {\n            var ast: AST = pre(this, parent, context);\n            if (ast === undefined) {\n                ast = this;\n            }\n            if (context.goChildren) {\n                var svGoSib = context.goNextSibling;\n                context.goNextSibling = true;\n                ast.walkChildren(pre, post, this, context);\n                context.goNextSibling = svGoSib;\n            }\n            else {\n                // no go only applies to children of node issuing it\n                context.goChildren = true;\n            }\n            if (post != null) {\n                var postAst = post(ast, parent, context);\n                if (postAst === undefined) {\n                    postAst = ast;\n                }\n                return postAst;\n            }\n            else {\n                return ast;\n            }\n        }\n    }\n\n    export oldclass IncompleteAST(min: number, lim: number) extends AST(NodeType.Error) {\n        this.minChar = min;\n        this.limChar = lim;\n    }\n\n    export oldclass ASTList() extends AST(NodeType.List) {\n        property enclosingScope: SymbolScope = null;\n        property members: AST[] = new AST[];\n\n        property addToControlFlow(context: ControlFlowContext) {\n            var len = this.members.length;\n            for (var i = 0; i < len; i++) {\n                if (context.noContinuation) {\n                    context.addUnreachable(this.members[i]);\n                    break;\n                }\n                else {\n                    this.members[i] = this.members[i].walk(context.pre, null, this, context);\n                }\n            }\n            context.goChildren = false;\n        }\n\n        property append(ast: AST) {\n            this.members[this.members.length] = ast;\n            return this;\n        }\n\n        property appendAll(ast: AST) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                for (var i = 0, len = list.members.length; i < len; i++) {\n                    this.append(list.members[i]);\n                }\n            }\n            else {\n                this.append(ast);\n            }\n            return this;\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptList(this, null, TokenID.SColon, startLine, false, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            var len = this.members.length;\n            typeFlow.nestingLevel++;\n            for (var i = 0; i < len; i++) {\n                if (this.members[i] != null) {\n                    this.members[i] = this.members[i].typeCheck(typeFlow);\n                }\n            }\n            typeFlow.nestingLevel--;\n            return this;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            var len = this.members.length;\n            if (context.reverseSiblings) {\n                for (var i = len - 1; i >= 0; i--) {\n                    if (context.goNextSibling) {\n                        this.members[i] = this.members[i].walk(pre, post, this, context);\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < len; i++) {\n                    if (context.goNextSibling) {\n                        this.members[i] = this.members[i].walk(pre, post, this, context);\n                    }\n                }\n            }\n        }\n    }\n\n    export oldclass Identifier(property text: string) extends AST(NodeType.Name) {\n        property sym: Symbol = null;\n        property cloId = -1;\n\n        property isMissing() => false;\n        property isLeaf() => true;\n\n        property treeViewLabel() {\n            return \"id: \" + this.text;\n        }\n\n        property printLabel() {\n            if (this.text != null) {\n                return \"id: \" + this.text;\n            }\n            else {\n                return \"name node\";\n            }\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckName(this);\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptName(this, true);\n        }\n\n    }\n\n    export oldclass MissingIdentifier() extends Identifier(\"__missing\") {\n        property isMissing() => true;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            // Emit nothing for a missing ID\n        }\n    }\n\n    export oldclass Label(property id: Identifier) extends AST(NodeType.Label) {\n        property printLabel() => this.id.text + \":\";\n\n        property typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeLineToOutput(this.id.text + \":\");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n    }\n\n    export oldclass UnaryExpression(property nty: number, property operand: AST) extends AST(this.nty) {\n\n        property acceptTargetType: bool = false;\n        property castTerm: AST = null;\n        property isStatementOrExpression() => true;\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            // TODO: add successor as catch block/finally block if present\n            if (this.nodeType == NodeType.Throw) {\n                context.returnStmt();\n            }\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.castTerm != null) {\n                this.castTerm = this.castTerm.walk(pre, post, this, context);\n            }\n            if (this.operand != null) {\n                this.operand = this.operand.walk(pre, post, this, context);\n            }\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            switch (this.nty) {\n                case NodeType.Not:\n                    return typeFlow.typeCheckBitNot(this);\n\n                case NodeType.LogNot:\n                    return typeFlow.typeCheckLogNot(this);\n\n                case NodeType.Pos:\n                case NodeType.Neg:\n                    return typeFlow.typeCheckUnaryNumberOperator(this);\n\n                case NodeType.IncPost:\n                case NodeType.IncPre:\n                case NodeType.DecPost:\n                case NodeType.DecPre:\n                    return typeFlow.typeCheckIncOrDec(this);\n\n                case NodeType.ArrayLit:\n                    typeFlow.typeCheckArrayLit(this);\n                    return this;\n\n                case NodeType.ObjectLit:\n                    typeFlow.typeCheckObjectLit(this);\n                    return this;\n\n                case NodeType.Throw:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.voidType;\n                    return this;\n\n                case NodeType.Typeof:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.stringType;\n                    return this;\n\n                case NodeType.Await:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = this.operand.type;\n                    return this;\n\n                case NodeType.Delete:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.voidType;\n                    break;\n\n                case NodeType.Cast:\n                    this.castTerm = typeFlow.typeCheck(this.castTerm);\n                    var applyTargetType = !this.operand.isParenthesized;\n\n                    typeFlow.checker.typeCheckWithTargetType(this.castTerm.type, applyTargetType, this.operand);\n                    var castNode = typeFlow.castWithCoercion(this.operand, this.castTerm.type, applyTargetType);\n                    this.type = castNode.type;\n                    return this;\n\n                case NodeType.Void:\n                    // REVIEW - Although this is good to do for completeness\'s sake,\n                    // this shouldn\'t be strictly necessary from the void operator\'s\n                    // point of view\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.anyType; // the type of \"undefined\"\n                    break;\n\n                default:\n                    throw new Error(\"please implement in derived class\");\n                // type = typeFlow.anyType;\n                // break;\n            }\n            return this;\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            switch (this.nty) {\n                case NodeType.IncPost:\n                    emitter.emitJavascript(this.operand, TokenID.Inc, false);\n                    emitter.writeToOutput(\"++\");\n                    break;\n                case NodeType.LogNot:\n                    emitter.writeToOutput(\"!\");\n                    emitter.emitJavascript(this.operand, TokenID.Bang, false);\n                    break;\n                case NodeType.DecPost:\n                    emitter.emitJavascript(this.operand, TokenID.Dec, false);\n                    emitter.writeToOutput(\"--\");\n                    break;\n                case NodeType.ObjectLit:\n                    emitter.emitObjectLiteral(this.operand);\n                    break;\n                case NodeType.ArrayLit:\n                    emitter.emitArrayLiteral(this.operand);\n                    break;\n                case NodeType.Not:\n                    emitter.writeToOutput(\"~\");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Neg:\n                    emitter.writeToOutput(\"-\");\n                    if (this.operand.nodeType == NodeType.Neg) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Sub, false);\n                    break;\n                case NodeType.Pos:\n                    emitter.writeToOutput(\"+\");\n                    if (this.operand.nodeType == NodeType.Pos) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Add, false);\n                    break;\n                case NodeType.IncPre:\n                    emitter.writeToOutput(\"++\");\n                    emitter.emitJavascript(this.operand, TokenID.Inc, false);\n                    break;\n                case NodeType.DecPre:\n                    emitter.writeToOutput(\"--\");\n                    emitter.emitJavascript(this.operand, TokenID.Dec, false);\n                    break;\n                case NodeType.Throw:\n                    emitter.writeToOutput(\"throw \");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    emitter.writeToOutput(\";\");\n                    break;\n                case NodeType.Typeof:\n                    emitter.writeToOutput(\"typeof \");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Await:\n                    // pass-through for now\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Delete:\n                    emitter.writeToOutput(\"delete \");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Void:\n                    emitter.writeToOutput(\"void \");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Cast:\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                default:\n                    throw new Error(\"please implement in derived class\");\n                // break;\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n    }\n\n    export oldclass CallExpression(property nty: number, property target: AST, property args: ASTList) extends AST(this.nty) {\n        this.minChar = this.target.minChar;\n        property signature: Signature = null;\n        property isStatementOrExpression() => true;\n        property typeCheck(typeFlow: TypeFlow) {\n            if (this.nty == NodeType.New) {\n                return typeFlow.typeCheckNew(this);\n            }\n            else {\n                return typeFlow.typeCheckCall(this);\n            }\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n\n            if (this.nty == NodeType.New) {\n                emitter.emitNew(this.target, this.args);\n            }\n            else {\n                emitter.emitCall(this, this.target, this.args);\n            }\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (!context.reverseSiblings) {\n                this.target = this.target.walk(pre, post, this, context);\n            }\n            if ((this.args != null) && (context.goNextSibling)) {\n                this.args.walk(pre, post, this, context);\n            }\n            if ((context.reverseSiblings) && (context.goNextSibling)) {\n                this.target = this.target.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass BinaryExpression(property nty: number, property operand1: AST, property operand2: AST) extends AST(this.nty) {\n        property isStatementOrExpression() => true;\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            var visitOperand1 = this.operand1;\n            var visitOperand2 = this.operand2;\n            if (context.reverseSiblings) {\n                visitOperand1 = this.operand2;\n                visitOperand2 = this.operand1;\n            }\n            if (visitOperand1 != null) {\n                visitOperand1 = visitOperand1.walk(pre, post, this, context);\n            }\n            if ((visitOperand2 != null) && (context.goNextSibling)) {\n                visitOperand2 = visitOperand2.walk(pre, post, this, context);\n            }\n        }\n\n\n        property typeCheck(typeFlow: TypeFlow) {\n            switch (this.nty) {\n                case NodeType.Dot:\n                    return typeFlow.typeCheckDotOperator(this);\n                case NodeType.Asg:\n                    return typeFlow.typeCheckAsgOperator(this);\n                case NodeType.Add:\n                case NodeType.Sub:\n                case NodeType.Mul:\n                case NodeType.Div:\n                case NodeType.Mod:\n                case NodeType.Or:\n                case NodeType.And:\n                    return typeFlow.typeCheckArithmeticOperator(this, false);\n                case NodeType.Xor:\n                    return typeFlow.typeCheckBitwiseOperator(this, false);\n                case NodeType.Ne:\n                case NodeType.Eq:\n                    var text: string;\n                    if (typeFlow.checker.styleSettings.eqeqeq) {\n                        text = nodeTypeTable[this.nty];\n                        typeFlow.checker.errorReporter.styleError(this, \"use of \" + text);\n                    }\n                    else if (typeFlow.checker.styleSettings.eqnull) {\n                        text = nodeTypeTable[this.nty];\n                        if ((this.operand2 !== null) && (this.operand2.nodeType == NodeType.Null)) {\n                            typeFlow.checker.errorReporter.styleError(this, \"use of \" + text + \" to compare with null\");\n                        }\n                    }\n                case NodeType.Eqv:\n                case NodeType.NEqv:\n                case NodeType.Lt:\n                case NodeType.Le:\n                case NodeType.Ge:\n                case NodeType.Gt:\n                    return typeFlow.typeCheckBooleanOperator(this);\n                case NodeType.Index:\n                    return typeFlow.typeCheckIndex(this);\n                case NodeType.Member:\n                    this.type = typeFlow.voidType;\n                    return this;\n                case NodeType.LogOr:\n                    return typeFlow.typeCheckLogOr(this);\n                case NodeType.LogAnd:\n                    return typeFlow.typeCheckLogAnd(this);\n                case NodeType.AsgAdd:\n                case NodeType.AsgSub:\n                case NodeType.AsgMul:\n                case NodeType.AsgDiv:\n                case NodeType.AsgMod:\n                case NodeType.AsgOr:\n                case NodeType.AsgAnd:\n                    return typeFlow.typeCheckArithmeticOperator(this, true);\n                case NodeType.AsgXor:\n                    return typeFlow.typeCheckBitwiseOperator(this, true);\n                case NodeType.Lsh:\n                case NodeType.Rsh:\n                case NodeType.Rs2:\n                    return typeFlow.typeCheckShift(this, false);\n                case NodeType.AsgLsh:\n                case NodeType.AsgRsh:\n                case NodeType.AsgRs2:\n                    return typeFlow.typeCheckShift(this, true);\n                case NodeType.Comma:\n                    return typeFlow.typeCheckCommaOperator(this);\n                case NodeType.InstOf:\n                    return typeFlow.typeCheckInstOf(this);\n                case NodeType.In:\n                    return typeFlow.typeCheckInOperator(this);\n                case NodeType.From:\n                    typeFlow.checker.errorReporter.simpleError(this, \"Illegal use of \'from\' keyword in binary expression\");\n                    break;\n                default:\n                    throw new Error(\"please implement in derived class\");\n                // type=typeFlow.anyType;\n                // break;\n            }\n            return this;\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var binTokenId = nodeTypeToTokTable[this.nodeType];\n\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (binTokenId != undefined) {\n\n                emitter.emitJavascript(this.operand1, binTokenId, false);\n\n                if (tokenTable[binTokenId].text == \"instanceof\") {\n                    emitter.writeToOutput(\" instanceof \");\n                }\n                else if (tokenTable[binTokenId].text == \"in\") {\n                    emitter.writeToOutput(\" in \");\n                }\n                else {\n                    emitter.writeToOutputTrimmable(\" \" + tokenTable[binTokenId].text + \" \");\n                }\n\n                emitter.emitJavascript(this.operand2, binTokenId, false);\n            }\n            else {\n                switch (this.nty) {\n                    case NodeType.Dot:\n                        if (!emitter.tryEmitConstant(this)) {\n                            emitter.emitJavascript(this.operand1, TokenID.Dot, false);\n                            emitter.writeToOutput(\".\");\n                            emitter.emitJavascriptName(this.operand2, false);\n                        }\n                        break;\n                    case NodeType.Index:\n                        emitter.emitIndex(this.operand1, this.operand2);\n                        break;\n                    // TODO: accessor pattern\n                    case NodeType.Member:\n                        if (this.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor()) {\n                            var funcDecl = <FuncDecl>this.operand2;\n                            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                                emitter.writeToOutput(\"get \");\n                            }\n                            else {\n                                emitter.writeToOutput(\"set \");\n                            }\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                        }\n                        else {\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                            emitter.writeToOutputTrimmable(\": \");\n                        }\n                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Comma:\n                        emitter.emitJavascript(this.operand1, TokenID.Comma, false);\n                        if (emitter.emitState.inObjectLiteral) {\n                            emitter.writeLineToOutput(\", \");\n                        }\n                        else {\n                            emitter.writeToOutput(\",\");\n                        }\n                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Is:\n                        throw new Error(\"should be de-sugared during type check\");\n                    //  break;\n                    default:\n                        throw new Error(\"please implement in derived class\");\n                    // break;\n                }\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n    }\n\n    export oldclass TrinaryExpression(property nty: number, property operand1: AST, property operand2: AST,\n                            property operand3: AST) extends AST(this.nty) {\n        property isStatementOrExpression() => true;\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckQMark(this);\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.operand1, TokenID.QMark, false);\n            emitter.writeToOutput(\" ? \");\n            emitter.emitJavascript(this.operand2, TokenID.QMark, false);\n            emitter.writeToOutput(\" : \");\n            emitter.emitJavascript(this.operand3, TokenID.QMark, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n\n            if (this.operand1 != null) {\n                this.operand1 = this.operand1.walk(pre, post, this, context);\n            }\n            if ((this.operand2 != null) && (context.goNextSibling)) {\n                this.operand2 = this.operand2.walk(pre, post, this, context);\n            }\n            if ((this.operand3 != null) && (context.goNextSibling)) {\n                this.operand3 = this.operand3.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass NumberLiteral(property value: number) extends AST(NodeType.NumberLit) {\n        property isStatementOrExpression() => true;\n        property isNegativeZero = false;\n        property typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.doubleType;\n            return this;\n        }\n        property treeViewLabel() {\n            return \"num: \" + this.value;\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isNegativeZero) {\n                emitter.writeToOutput(\"-\");\n            }\n            \n            emitter.writeToOutput(this.value.toString());\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property printLabel() {\n            if (Math.floor(this.value) != this.value) {\n                return this.value.toFixed(2).toString();\n            }\n            else {\n                return this.value.toString();\n            }\n        }\n    }\n\n    export oldclass RegexLiteral(property regex) extends AST(NodeType.Regex) {\n        property isStatementOrExpression() => true;\n        property typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.regexType;\n            return this;\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            // TODO: fix formatting\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.regex.toString());\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export oldclass StringLiteral(property text: string) extends AST(NodeType.QString) {\n        property isStatementOrExpression() => true;\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitStringLiteral(this.text);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.stringType;\n            return this;\n        }\n\n        property treeViewLabel() {\n            return \"st: \" + this.text;\n        }\n\n        property printLabel() {\n            return this.text;\n        }\n    }\n\n    export oldclass ImportDecl(property id: Identifier, property alias: AST) extends AST(NodeType.Import) {\n        property isStatementOrExpression() => true;\n        property varFlags = VarFlags.None;\n        property isDynamicImport = false;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var mod: ModuleType = this.alias.type;\n\n            // REVIEW: Only modules may be aliased for now, though there\'s no real\n            // restriction on what the type symbol may be\n            if (!this.isDynamicImport || (this.id.sym != null && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef)) {\n                var prevModAliasId = emitter.modAliasId;\n                var prevFirstModAlias = emitter.firstModAlias;\n\n                emitter.recordSourceMappingStart(this);\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.writeToOutput(\"var \" + this.id.text + \" = \");\n                emitter.modAliasId = this.id.text;\n                emitter.firstModAlias = this.firstAliasedModToString();\n\n                emitter.emitJavascript(this.alias, TokenID.Tilde, false);\n                \n                // the dynamic import case will insert the semi-colon automatically\n                if (!this.isDynamicImport) {\n                    emitter.writeToOutput(\";\");\n                }\n                emitter.emitParensAndCommentsInPlace(this, false);\n                emitter.recordSourceMappingEnd(this);\n\n                emitter.modAliasId = prevModAliasId;\n                emitter.firstModAlias = prevFirstModAlias;\n            }\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckImportDecl(this);\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.id != null) {\n                this.id = this.id.walk(pre, post, this, context);\n            }\n            if (this.alias != null) {\n                this.alias = this.alias.walk(pre, post, this, context);\n            }\n        }\n\n        property firstAliasedModToString() {\n            if (this.alias.nodeType == NodeType.Name) {\n                return (<Identifier>this.alias).text;\n            }\n            else {\n                var dotExpr = <BinaryExpression>this.alias;\n                var firstMod = <Identifier>dotExpr.operand1;\n                return firstMod.text;\n            }\n        }\n    }\n\n    export oldclass BoundDecl(property id: Identifier, nodeType: NodeType, property nestingLevel: number) extends AST(nodeType) {\n        property init: AST = null;\n        property typeExpr: AST = null;\n        property varFlags: number = VarFlags.None;\n        property sym: Symbol = null;\n        property isStatementOrExpression() => true;\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckBoundDecl(this);\n        }\n\n        property printLabel() {\n            return this.treeViewLabel();\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.id != null) {\n                this.id = this.id.walk(pre, post, this, context);\n            }\n            if (this.init != null) {\n                this.init = this.init.walk(pre, post, this, context);\n            }\n            if ((this.typeExpr != null) && (context.goNextSibling)) {\n                this.typeExpr = this.typeExpr.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass VarDecl(id: Identifier, nest: number) extends BoundDecl(id, NodeType.VarDecl, nest) {\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptVarDecl(this, tokenId);\n        }\n\n        property emitType(emitter: Emitter) {\n            if (hasFlag(this.varFlags, VarFlags.Property)) {\n                emitter.emitVarType(this);\n            }\n        }\n\n        property treeViewLabel() {\n            return \"var \" + this.id.text;\n        }\n    }\n\n    export oldclass ArgDecl(id: Identifier) extends BoundDecl(id, NodeType.ArgDecl, 0) {\n\n        property isOptional = false;\n\n        property isOptionalArg() { return this.isOptional || (this.init != null); }\n\n        property treeViewLabel() {\n            return \"arg: \" + this.id.text;\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.id.text);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    var internalId = 0;\n\n    export oldclass FuncDecl(property name: Identifier, property bod: ASTList, property isConstructor: bool,\n                   property args: ASTList, property vars: ASTList, property scopes: ASTList, property statics: ASTList,\n        nodeType: number) extends AST(nodeType) {\n        // note: if you add a property, make sure to modify the duplicate method\n        property hint: string = null;\n        property fncFlags = FncFlags.None;\n        property returnTypeAnnotation: AST = null;\n        property symbols: IHashTable;\n        property variableArgList = false;\n        property signature: Signature;\n        property envids: Identifier[];\n        property jumpRefs: Identifier[] = null;\n        property internalNameCache: string = null;\n        property tmp1Declared = false;\n        property enclosingFnc: FuncDecl = null;\n        property freeVariables: Symbol[] = new Symbol[];\n        property unitIndex = -1;\n        property classDecl: Record = null;\n        property boundToProperty: VarDecl = null;\n        property isOverload = false;\n        property innerStaticFuncs: FuncDecl[] = [];\n        property isTargetTypedAsMethod = false;\n        property isInlineCallLiteral = false;\n        property accessorSymbol: Symbol = null;\n        property leftCurlyCount = 0;\n        property rightCurlyCount = 0;\n        property returnStatements: ReturnStatement[] = [];\n\n        property isAccessor() => hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor);\n\n        property internalName(): string {\n            if (this.internalNameCache == null) {\n                var extName = this.getNameText();\n                if (extName != null) {\n                    this.internalNameCache = \"_internal_\" + extName;\n                }\n                else {\n                    this.internalNameCache = \"_internal_\" + internalId++;\n                }\n            }\n            return this.internalNameCache;\n        }\n\n        property hasSelfReference() => hasFlag(this.fncFlags, FncFlags.HasSelfReference);\n        property setHasSelfReference() { this.fncFlags |= FncFlags.HasSelfReference; }\n\n        property addCloRef(id: Identifier, sym: Symbol): number {\n            if (this.envids == null) {\n                this.envids = new Identifier[];\n            }\n            this.envids[this.envids.length] = id;\n            var outerFnc = this.enclosingFnc;\n            if (sym != null) {\n                while ((outerFnc != null) && (outerFnc.type.symbol != sym.container)) {\n                    outerFnc.addJumpRef(sym);\n                    outerFnc = outerFnc.enclosingFnc;\n                }\n            }\n            return this.envids.length - 1;\n        }\n\n        property addJumpRef(sym: Symbol): void {\n            if (this.jumpRefs == null) {\n                this.jumpRefs = new Identifier[];\n            }\n            var id = new Identifier(sym.name);\n            this.jumpRefs[this.jumpRefs.length] = id;\n            id.sym = sym;\n            id.cloId = this.addCloRef(id, null);\n        }\n\n        property buildControlFlow(): ControlFlowContext {\n            function controlFlowPrefix(ast: AST, parent: AST, context: ControlFlowContext) {\n                ast.addToControlFlow(context);\n                return ast;\n            }\n\n            var entry = new BasicBlock();\n            var exit = new BasicBlock();\n            var context = new ControlFlowContext(entry, exit, controlFlowPrefix);\n            this.bod.walk(controlFlowPrefix, null, this, context);\n\n            return context;\n        }\n\n        property emitType(emitter: Emitter) {\n            if (this.isMethod()) {\n                emitter.emitFuncType(this);\n            }\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFunction(this);\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptFunction(this);\n        }\n\n        property getNameText() {\n            if (this.name != null) {\n                return this.name.text;\n            }\n            else {\n                return this.hint;\n            }\n        }\n\n        property isMethod() {\n            return (this.fncFlags & FncFlags.Method) != FncFlags.None;\n        }\n\n        property isCallMember() => hasFlag(this.fncFlags, FncFlags.CallMember);\n        property isConstructMember() => hasFlag(this.fncFlags, FncFlags.ConstructMember);\n        property isIndexerMember() => hasFlag(this.fncFlags, FncFlags.IndexerMember);\n        property isSpecialFn() => this.isCallMember() || this.isIndexerMember() || this.isConstructMember();\n        property isAnonymousFn() => { return this.name === null; }\n\n        property treeViewLabel() {\n            if (this.name == null) {\n                return \"funcExpr\";\n            }\n            else {\n                return \"func: \" + this.name.text\n            }\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.name != null) {\n                this.name = this.name.walk(pre, post, this, context);\n            }\n            if ((this.args != null) && (this.args.members.length > 0) && (context.goNextSibling)) {\n                this.args = this.args.walk(pre, post, this, context);\n            }\n            if ((this.returnTypeAnnotation != null) && (context.goNextSibling)) {\n                this.returnTypeAnnotation = this.returnTypeAnnotation.walk(pre, post, this, context);\n            }\n            if ((this.bod != null) && (this.bod.members.length > 0) && (context.goNextSibling)) {\n                this.bod = this.bod.walk(pre, post, this, context);\n            }\n        }\n\n        property ClearFlags(): void {\n            this.fncFlags = FncFlags.None;\n        }\n\n        property isSignature() =>(this.fncFlags & FncFlags.Signature) != FncFlags.None;\n    }\n\n    export oldclass LocationInfo(property filename: string, property lineMap: number[], property unitIndex) {\n    }\n\n    export var unknownLocationInfo = new LocationInfo(\"unknown\", null, -1);\n\n    export oldclass Script(property vars: ASTList, property scopes: ASTList) extends FuncDecl(new Identifier(\"script\"), null, false, null, this.vars, this.scopes, null, NodeType.Script) {\n        property locationInfo: LocationInfo = null;\n        property requiresGlobal = false;\n        property requiresInherits = false;\n        property isResident = false;\n        property isDeclareFile = false;\n        property hasBeenTypeChecked = false;\n        property topLevelMod: ModuleDecl = null;\n        property leftCurlyCount = 0;\n        property rightCurlyCount = 0;\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckScript(this);\n        }\n\n        property treeViewLabel() {\n            return \"Script\";\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.bod != null) {\n                this.bod = this.bod.walk(pre, post, this, context);\n            }\n        }\n\n        property emitRequired() {\n            if (!this.isDeclareFile && !this.isResident && this.bod != null) {\n                for (var i = 0, len = this.bod.members.length; i < len; i++) {\n                    var stmt = this.bod.members[i];\n                    if (stmt.nodeType == NodeType.Module) {\n                        if (!hasFlag((<ModuleDecl>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient)) {\n                            return true;\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.Class) {\n                        if (!hasFlag((<TypeDecl>stmt).varFlags, VarFlags.Ambient)) {\n                            return true;\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.ES6Class) {\n                        if (!hasFlag((<TypeDecl>stmt).varFlags, VarFlags.Ambient)) {\n                            return true;\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.VarDecl) {\n                        if (!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient)) {\n                            return true;\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.FuncDecl) {\n                        if (!(<FuncDecl>stmt).isSignature()) {\n                            return true;\n                        }\n                    }\n                    else if (stmt.nodeType != NodeType.Interface) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        property emitType(emitter: Emitter) {\n            emitter.emitTypeList(this.bod);\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (this.emitRequired()) {\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.recordSourceMappingStart(this);\n                emitter.emitPrologue(this.requiresInherits);\n                emitter.emitJavascriptList(this.bod, null, TokenID.SColon, true, false, false);\n                emitter.recordSourceMappingEnd(this);\n                emitter.emitParensAndCommentsInPlace(this, false);\n            }\n        }\n\n    }\n\n    export oldclass Record(property nty: number, property name: AST, property members: AST) extends AST(this.nty) {\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            this.name = this.name.walk(pre, post, this, context);\n            if ((context.goNextSibling) && (this.members != null)) {\n                this.members = this.members.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass ModuleDecl(property name: Identifier, property members: ASTList, property vars: ASTList, property scopes: ASTList) extends Record(NodeType.Module, this.name, this.members) {\n\n        property modFlags: number = ModuleFlags.ShouldEmitModuleDecl;\n        property mod: ModuleType;\n        property alias: AST = null;\n        property isAnonInnerMod: bool = false;\n        property anonParentMod: ModuleDecl = null;\n        property anonExportedSymbols: Symbol[];\n        property leftCurlyCount = 0;\n        property rightCurlyCount = 0;\n        property prettyName: string = this.name.text;\n        property amdDependencies: string[] = [];\n\n        property recordNonInterface() {\n            this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckModule(this);\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl)) {\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.emitJavascriptModule(this);\n                emitter.emitParensAndCommentsInPlace(this, false);\n            }\n        }\n\n        property emitType(emitter: Emitter) {\n            if (!hasFlag(this.modFlags, ModuleFlags.Ambient)) {\n                emitter.emitModuleType(this);\n            }\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            super.walkChildren(pre, post, this, context);\n            if ((context.goNextSibling) && (this.alias != null)) {\n                this.alias = this.alias.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass NamedType(nty: NodeType, property name: Identifier, property extendsList: ASTList, property implementsList: ASTList, property members: AST)\n        extends Record(nty, this.name, this.members) { }\n\n    export oldclass ES6ClassDecl(property name: Identifier, property definitionMembers: ASTList, property baseClass: ASTList,\n                            property implementsList: ASTList) extends NamedType(NodeType.ES6Class, this.name, this.baseClass, this.implementsList, this.definitionMembers) {\n        property varFlags = VarFlags.None;\n        property leftCurlyCount = 0;\n        property rightCurlyCount = 0;\n        property knownMemberNames: any = {};\n        property constructorDecl: FuncDecl = null;\n        property constructorNestingLevel = 0;\n        property allMemberDefinitions: ASTList = new ASTList();\n        property baseConstructorCall: ASTList = new ASTList();\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckES6Class(this);\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (!hasFlag(this.varFlags, VarFlags.Ambient)) {\n                emitter.emitJavascriptES6Class(this);\n            }\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            super.walkChildren(pre, post, this, context);\n\n            if ((context.goNextSibling) && (this.baseClass != null)) {\n                this.baseClass = this.baseClass.walk(pre, post, this, context);\n            }\n\n            if ((context.goNextSibling) && (this.implementsList != null)) {\n                this.implementsList = this.implementsList.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass TypeDecl(property nty: number, property name: Identifier, property members: AST, property args: ASTList, property extendsList: ASTList,\n                            property implementsList: ASTList) extends NamedType(this.nty, this.name, this.extendsList, this.implementsList, this.members) {\n        property varFlags = VarFlags.None;\n        property isOverload = false;\n        property leftCurlyCount = 0;\n        property rightCurlyCount = 0;\n\n        property typeCheck(typeFlow: TypeFlow) {\n            if (this.nty == NodeType.Class) {\n                return typeFlow.typeCheckClass(this);\n            }\n            else if (this.nty == NodeType.Interface) {\n                return typeFlow.typeCheckInterface(this);\n            }\n            else {\n                throw new Error(\"please implement type check for node type\" + this.nty);\n            }\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (this.nty == NodeType.Class) {\n                emitter.emitJavascriptClass(this);\n            }\n            else if (this.nty == NodeType.Interface) {\n                // nothing for now\n            }\n            else {\n                throw new Error(\"please implement emit for node type\" + this.nty);\n            }\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            super.walkChildren(pre, post, this, context);\n\n            // walked args as part of members\n            if ((context.goNextSibling) && (this.extendsList != null)) {\n                this.extendsList = this.extendsList.walk(pre, post, this, context);\n            }\n\n            if ((context.goNextSibling) && (this.implementsList != null)) {\n                this.implementsList = this.implementsList.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass Statement(nty: number) extends AST(nty) {\n        this.flags |= ASTFlags.IsStatement;\n        property isLoop() => false;\n        property isCompoundStatement() => this.isLoop();\n        property typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    // The following two classes are for future implementation of async methods\n    // transfers control to an extended block\n    export oldclass GotoExtendedBlock(property cont: Continuation, property withRet: bool) extends Statement(NodeType.GotoEB) {\n    }\n\n    // labels an extended block\n    export oldclass ExtendedBlockStart(property cont: Continuation) extends Statement(NodeType.EBStart) {\n    }\n\n    export oldclass LabeledStatement(property labels: ASTList, property stmt: AST) extends Statement(NodeType.LabeledStatement) {\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.labels != null) {\n                var labelsLen = this.labels.members.length;\n                for (var i = 0; i < labelsLen; i++) {\n                    this.labels.members[i].emit(emitter, tokenId, startLine);\n                }\n            }\n            this.stmt.emit(emitter, tokenId, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            typeFlow.typeCheck(this.labels);\n            this.stmt = this.stmt.typeCheck(typeFlow);\n            return this;\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            var beforeBB = context.current;\n            var bb = new BasicBlock();\n            context.current = bb;\n            beforeBB.addSuccessor(bb);\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            this.labels = this.labels.walk(pre, post, this, context);\n            if (context.goNextSibling) {\n                this.stmt = this.stmt.walk(pre, post, this, context);\n            }\n        }\n    }\n\n\n    export oldclass Block(property stmts: ASTList, property visible: bool) extends Statement(NodeType.Block) {\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.visible) {\n                emitter.writeLineToOutput(\" {\");\n                emitter.increaseIndent();\n            }\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.stmts != null) {\n                emitter.emitJavascriptList(this.stmts, null, TokenID.SColon, true, false, false);\n            }\n            if (this.visible) {\n                emitter.decreaseIndent();\n                emitter.emitIndent();\n                emitter.writeToOutput(\"}\");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property addToControlFlow(context: ControlFlowContext) {\n            var afterIfNeeded = new BasicBlock();\n            context.pushStatement(this, context.current, afterIfNeeded);\n            if (this.stmts != null) {\n                this.stmts.walk(context.pre, null, this, context);\n            }\n            context.goChildren = false;\n            context.popStatement();\n            if (afterIfNeeded.predecessors.length > 0) {\n                context.current.addSuccessor(afterIfNeeded);\n                context.current = afterIfNeeded;\n            }\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            if (!typeFlow.checker.styleSettings.emptyBlocks) {\n                if ((this.stmts === null) || (this.stmts.members.length == 0)) {\n                    typeFlow.checker.errorReporter.styleError(this, \"empty block\");\n                }\n            }\n            typeFlow.typeCheck(this.stmts);\n            return this;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.stmts != null) {\n                this.stmts = this.stmts.walk(pre, post, this, context);\n            }\n        }\n    }\n\n\n    export oldclass Jump(property nty: number) extends Statement(this.nty) {\n        property target: string = null;\n        property hasExplicitTarget() =>(this.target != null);\n        property resolvedTarget: Statement = null;\n\n        property setResolvedTarget(parser: Parser, stmt: Statement): bool {\n            if (stmt.isLoop()) {\n                this.resolvedTarget = stmt;\n                return true;\n            }\n            if (this.nty === NodeType.Continue) {\n                parser.reportParseError(\"continue statement applies only to loops\");\n                return false;\n            }\n            else {\n                if ((stmt.nodeType == NodeType.Switch) || this.hasExplicitTarget()) {\n                    this.resolvedTarget = stmt;\n                    return true;\n                }\n                else {\n                    parser.reportParseError(\"break statement with no label can apply only to a loop or switch statement\");\n                    return false;\n                }\n            }\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.unconditionalBranch(this.resolvedTarget, (this.nty == NodeType.Continue));\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.nty == NodeType.Break) {\n                emitter.writeToOutput(\"break\");\n            }\n            else {\n                emitter.writeToOutput(\"continue\");\n            }\n            if (this.hasExplicitTarget()) {\n                emitter.writeToOutput(\" \" + this.target);\n            }\n            emitter.writeToOutput(\";\");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export oldclass WhileStatement(property cond: AST) extends Statement(NodeType.While) {\n        property isStatementOrExpression() => true;\n        property body: AST = null;\n        property isLoop() => true;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput(\"while(\");\n            emitter.emitJavascript(this.cond, TokenID.WHILE, false);\n            emitter.writeToOutput(\")\");\n            emitter.emitJavascriptStatements(this.body, false, false);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWhile(this);\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            context.addContent(this.cond);\n            var condBlock = context.current;\n            var targetInfo: ITargetInfo = null;\n            if (this.body != null) {\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n                context.pushStatement(this, loopStart, afterLoop);\n                this.body.walk(context.pre, null, this, context);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            condBlock.addSuccessor(afterLoop);\n            // TODO: check for while (true) and then only continue if afterLoop has predecessors\n            context.noContinuation = false;\n            context.goChildren = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            this.cond = this.cond.walk(pre, post, this, context);\n            if ((this.body != null) && (context.goNextSibling)) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass DoWhileStatement() extends Statement(NodeType.DoWhile) {\n        property isStatementOrExpression() => true;\n        property body: AST = null;\n        property whileAST: AST = null;\n        property cond: AST = null;\n        property isLoop() => true;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput(\"do\");\n            emitter.emitJavascriptStatements(this.body, true, false);\n            emitter.recordSourceMappingStart(this.whileAST);\n            emitter.writeToOutput(\"while\");\n            emitter.recordSourceMappingEnd(this.whileAST);\n            emitter.writeToOutput(\'(\');\n            emitter.emitJavascript(this.cond, TokenID.RParen, false);\n            emitter.writeToOutput(\")\");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckDoWhile(this);\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var targetInfo: ITargetInfo = null;\n            if (this.body != null) {\n                context.pushStatement(this, loopStart, afterLoop);\n                this.body.walk(context.pre, null, this, context);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n                context.addContent(this.cond);\n                // TODO: check for while (true) \n                context.current = afterLoop;\n                loopEnd.addSuccessor(afterLoop);\n            }\n            else {\n                context.addUnreachable(this.cond);\n            }\n            context.goChildren = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            this.cond = this.cond.walk(pre, post, this, context);\n            if ((this.body != null) && (context.goNextSibling)) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n\n    }\n\n    export oldclass IfStatement(property cond: AST) extends Statement(NodeType.If) {\n        property isStatementOrExpression() => true;\n        property thenBod: AST;\n        property elseBod: AST = null;\n\n        property isCompoundStatement() => true;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput(\"if(\");\n            emitter.emitJavascript(this.cond, TokenID.IF, false);\n            emitter.writeToOutput(\")\");\n            emitter.emitJavascriptStatements(this.thenBod, true, false);\n            if (this.elseBod != null) {\n                emitter.writeToOutput(\" else \");\n                emitter.emitJavascriptStatements(this.elseBod, true, true);\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckIf(this);\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            this.cond.addToControlFlow(context);\n            var afterIf = new BasicBlock();\n            var beforeIf = context.current;\n            context.pushStatement(this, beforeIf, afterIf);\n            var hasContinuation = false;\n            context.current = new BasicBlock();\n            beforeIf.addSuccessor(context.current);\n            this.thenBod.walk(context.pre, null, this, context);\n            if (!context.noContinuation) {\n                hasContinuation = true;\n                context.current.addSuccessor(afterIf);\n            }\n            if (this.elseBod != null) {\n                // current block will be thenBod\n                context.current = new BasicBlock();\n                context.noContinuation = false;\n                beforeIf.addSuccessor(context.current);\n                this.elseBod.walk(context.pre, null, this, context);\n                if (!context.noContinuation) {\n                    hasContinuation = true;\n                    context.current.addSuccessor(afterIf);\n                }\n                else {\n                    // thenBod created continuation for if statement\n                    if (hasContinuation) {\n                        context.noContinuation = false;\n                    }\n                }\n            }\n            else {\n                beforeIf.addSuccessor(afterIf);\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            var targetInfo = context.popStatement();\n            if (afterIf.predecessors.length > 0) {\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            if (hasContinuation) {\n                context.current = afterIf;\n            }\n            context.goChildren = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            this.cond = this.cond.walk(pre, post, this, context);\n            if ((this.thenBod != null) && (context.goNextSibling)) {\n                this.thenBod = this.thenBod.walk(pre, post, this, context);\n            }\n            if ((this.elseBod != null) && (context.goNextSibling)) {\n                this.elseBod = this.elseBod.walk(pre, post, this, context);\n            }\n        }\n\n    }\n\n    export oldclass ReturnStatement() extends Statement(NodeType.Return) {\n        property returnExpression: AST = null;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.returnExpression != null) {\n                emitter.writeToOutput(\"return \");\n                emitter.emitJavascript(this.returnExpression, TokenID.SColon, false);\n            }\n            else {\n                emitter.writeToOutput(\"return;\");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.returnStmt();\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckReturn(this);\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.returnExpression != null) {\n                this.returnExpression = this.returnExpression.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass EndCode() extends AST(NodeType.EndCode) {\n    }\n\n    export oldclass ForInStatement(property lval: AST, property obj: AST) extends Statement(NodeType.ForIn) {\n        if ((this.lval != null) && (this.lval.nodeType == NodeType.VarDecl)) {\n            (<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit;\n        }\n        property body: AST;\n        property isStatementOrExpression() => true;\n        property isLoop() => true;\n\n        property isFiltered() {\n            if (this.body != null) {\n                var singleItem: AST = null;\n                if (this.body.nodeType == NodeType.List) {\n                    var stmts: ASTList = this.body;\n                    if (stmts.members.length == 1) {\n                        singleItem = stmts.members[0];\n                    }\n                }\n                else {\n                    singleItem = this.body;\n                }\n                // match template for filtering \'own\' properties from obj\n                if (singleItem !== null) {\n                    if (singleItem.nodeType == NodeType.Block) {\n                        var block: Block = singleItem;\n                        if ((block.stmts !== null) && (block.stmts.members.length == 1)) {\n                            singleItem = block.stmts.members[0];\n                        }\n                    }\n                    if (singleItem.nodeType == NodeType.If) {\n                        var cond = (<IfStatement>singleItem).cond;\n                        if (cond.nodeType == NodeType.Call) {\n                            var target = (<CallExpression>cond).target;\n                            if (target.nodeType == NodeType.Dot) {\n                                var binex = <BinaryExpression>target;\n                                if ((binex.operand1.nodeType == NodeType.Name) &&\n                                    (this.obj.nodeType == NodeType.Name) &&\n                                    ((<Identifier>binex.operand1).text == (<Identifier>this.obj).text)) {\n                                    var prop: Identifier = binex.operand2;\n                                    if (prop.text == \"hasOwnProperty\") {\n                                        var args = (<CallExpression>cond).args;\n                                        if ((args !== null) && (args.members.length == 1)) {\n                                            var arg = args.members[0];\n                                            if ((arg.nodeType == NodeType.Name) &&\n                                                 (this.lval.nodeType == NodeType.Name)) {\n                                                if (((<Identifier>this.lval).text) == (<Identifier>arg).text) {\n                                                    return true;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput(\"for(\");\n            emitter.emitJavascript(this.lval, TokenID.FOR, false);\n            emitter.writeToOutput(\" in \");\n            emitter.emitJavascript(this.obj, TokenID.FOR, false);\n            emitter.writeToOutput(\")\");\n            emitter.emitJavascriptStatements(this.body, true, false);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            if (typeFlow.checker.styleSettings.forin) {\n                if (!this.isFiltered()) {\n                    typeFlow.checker.errorReporter.styleError(this, \"no hasOwnProperty filter\");\n                }\n            }\n            return typeFlow.typeCheckForIn(this);\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            if (this.lval != null) {\n                context.addContent(this.lval);\n            }\n            if (this.obj != null) {\n                context.addContent(this.obj);\n            }\n\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            if (this.body != null) {\n                context.pushStatement(this, loopStart, afterLoop);\n                this.body.walk(context.pre, null, this, context);\n                context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            context.noContinuation = false;\n            loopHeader.addSuccessor(afterLoop);\n            context.goChildren = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            this.lval = this.lval.walk(pre, post, this, context);\n            if (context.goNextSibling) {\n                this.obj = this.obj.walk(pre, post, this, context);\n            }\n            if ((this.body != null) && (context.goNextSibling)) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass ForStatement(property init: AST) extends Statement(NodeType.For) {\n        property cond: AST;\n        property body: AST;\n        property incr: AST;\n        property isStatementOrExpression() => true;\n        property isLoop() => true;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput(\"for(\");\n            if (this.init != null) {\n                if (this.init.nodeType != NodeType.List) {\n                    emitter.emitJavascript(this.init, TokenID.FOR, false);\n                }\n                else {\n                    emitter.emitForVarList(this.init);\n                }\n            }\n            emitter.writeToOutput(\"; \");\n            emitter.emitJavascript(this.cond, TokenID.FOR, false);\n            emitter.writeToOutput(\"; \");\n            emitter.emitJavascript(this.incr, TokenID.FOR, false);\n            emitter.writeToOutput(\")\");\n            emitter.emitJavascriptStatements(this.body, true, false);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFor(this);\n        }\n\n        property addToControlFlow(context: ControlFlowContext): void {\n            if (this.init != null) {\n                context.addContent(this.init);\n            }\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var condBlock: BasicBlock = null;\n            var continueTarget = loopStart;\n            var incrBB: BasicBlock = null;\n            if (this.incr != null) {\n                incrBB = new BasicBlock();\n                continueTarget = incrBB;\n            }\n            if (this.cond != null) {\n                condBlock = context.current;\n                context.addContent(this.cond);\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n            }\n            var targetInfo: ITargetInfo = null;\n            if (this.body != null) {\n                context.pushStatement(this, continueTarget, afterLoop);\n                this.body.walk(context.pre, null, this, context);\n                targetInfo = context.popStatement();\n            }\n            if (this.incr != null) {\n                if (context.noContinuation) {\n                    if (incrBB.predecessors.length == 0) {\n                        context.addUnreachable(this.incr);\n                    }\n                }\n                else {\n                    context.current.addSuccessor(incrBB);\n                    context.current = incrBB;\n                    context.addContent(this.incr);\n                }\n            }\n            var loopEnd = context.current;\n            if (!(context.noContinuation)) {\n                loopEnd.addSuccessor(loopStart);\n\n            }\n            if (condBlock != null) {\n                condBlock.addSuccessor(afterLoop);\n                context.noContinuation = false;\n            }\n            if (afterLoop.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterLoop;\n            }\n            context.goChildren = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.init != null) {\n                this.init = this.init.walk(pre, post, this, context);\n            }\n\n            if ((this.cond != null) && context.goNextSibling) {\n                this.cond = this.cond.walk(pre, post, this, context);\n            }\n\n            if ((this.incr != null) && context.goNextSibling) {\n                this.incr = this.incr.walk(pre, post, this, context);\n            }\n\n            if ((this.body != null) && context.goNextSibling) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass WithStatement(property expr: AST) extends Statement(NodeType.With) {\n        property body: AST;\n        property isStatementOrExpression() => true;\n        property isCompoundStatement() => true;\n        property withSym: WithSymbol = null;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(\"with (\");\n            if (this.expr != null) {\n                emitter.emitJavascript(this.expr, TokenID.WITH, false);\n            }\n\n            emitter.writeToOutput(\")\");\n            emitter.emitJavascriptStatements(this.body, true, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWith(this);\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.expr != null) {\n                this.expr = this.expr.walk(pre, post, this, context);\n            }\n\n            if ((this.body != null) && context.goNextSibling) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass SwitchStatement(property val: AST) extends Statement(NodeType.Switch) {\n        property caseList: ASTList;\n        property defaultCase: CaseStatement = null;\n        property isStatementOrExpression() => true;\n        property isCompoundStatement() => true;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput(\"switch(\");\n            emitter.emitJavascript(this.val, TokenID.ID, false);\n            emitter.writeLineToOutput(\") {\");\n            emitter.increaseIndent();\n            var casesLen = this.caseList.members.length;\n            for (var i = 0; i < casesLen; i++) {\n                var caseExpr = this.caseList.members[i];\n                emitter.emitJavascript(caseExpr, TokenID.CASE, true);\n                emitter.writeLineToOutput(\"\");\n            }\n            emitter.decreaseIndent();\n            emitter.emitIndent();\n            emitter.writeToOutput(\"}\");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            var len = this.caseList.members.length;\n            this.val = typeFlow.typeCheck(this.val);\n            for (var i = 0; i < len; i++) {\n                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);\n            }\n            this.defaultCase = typeFlow.typeCheck(this.defaultCase);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // if there are break statements that match this switch, then just link cond block with block after switch\n        property addToControlFlow(context: ControlFlowContext) {\n            var condBlock = context.current;\n            context.addContent(this.val);\n            var execBlock = new BasicBlock();\n            var afterSwitch = new BasicBlock();\n\n            condBlock.addSuccessor(execBlock);\n            context.pushSwitch(execBlock);\n            context.current = execBlock;\n            context.pushStatement(this, execBlock, afterSwitch);\n            this.caseList.walk(context.pre, null, this, context);\n            context.popSwitch();\n            var targetInfo = context.popStatement();\n            var hasCondContinuation = (this.defaultCase == null);\n            if (this.defaultCase == null) {\n                condBlock.addSuccessor(afterSwitch);\n            }\n            if (afterSwitch.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterSwitch;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.goChildren = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.val != null) {\n                this.val = this.val.walk(pre, post, this, context);\n            }\n\n            if ((this.caseList != null) && context.goNextSibling) {\n                this.caseList = this.caseList.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass CaseStatement() extends Statement(NodeType.Case) {\n        property expr: AST = null;\n        property body: ASTList;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.expr != null) {\n                emitter.writeToOutput(\"case \");\n                emitter.emitJavascript(this.expr, TokenID.ID, false);\n            }\n            else {\n                emitter.writeToOutput(\"default\");\n            }\n            emitter.writeToOutput(\":\");\n            emitter.emitJavascriptStatements(this.body, false, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            this.expr = typeFlow.typeCheck(this.expr);\n            typeFlow.typeCheck(this.body);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // TODO: more reasoning about unreachable cases (such as duplicate literals as case expressions)\n        // for now, assume all cases are reachable, regardless of whether some cases fall through\n        property addToControlFlow(context: ControlFlowContext) {\n            var execBlock = new BasicBlock();\n            var sw = context.currentSwitch[context.currentSwitch.length - 1];\n            // TODO: fall-through from previous (+ to end of switch)\n            if (this.expr != null) {\n                var exprBlock = new BasicBlock();\n                context.current = exprBlock;\n                sw.addSuccessor(exprBlock);\n                context.addContent(this.expr);\n                exprBlock.addSuccessor(execBlock);\n            }\n            else {\n                sw.addSuccessor(execBlock);\n            }\n            context.current = execBlock;\n            if (this.body != null) {\n                this.body.walk(context.pre, null, this, context);\n            }\n            context.noContinuation = false;\n            context.goChildren = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.expr != null) {\n                this.expr = this.expr.walk(pre, post, this, context);\n            }\n\n            if ((this.body != null) && context.goNextSibling) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass TypeReference(property term: AST, property arrayCount: number) extends AST(NodeType.TypeRef) {\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            throw new Error(\"should not emit a type ref\");\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            var prevInTCTR = typeFlow.inTypeRefTypeCheck;\n            typeFlow.inTypeRefTypeCheck = true;\n            var typeLink = getTypeLink(this, typeFlow.checker, true);\n            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);\n\n            typeFlow.checkForVoidConstructor(typeLink.type, this);\n\n            this.type = typeLink.type;\n\n            // in error recovery cases, there may not be a term\n            if (this.term) {\n                this.term.type = this.type;\n            }\n\n            typeFlow.inTypeRefTypeCheck = prevInTCTR;\n            return this;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.term != null) {\n                this.term = this.term.walk(pre, post, this, context);\n            }\n        }\n\n    }\n\n    export oldclass TryFinally(property tryNode: AST, property finallyNode: AST) extends Statement(NodeType.TryFinally) {\n        property isStatementOrExpression() => true;\n        property isCompoundStatement() => true;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.TRY, false);\n            emitter.emitJavascript(this.finallyNode, TokenID.FINALLY, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = typeFlow.typeCheck(this.tryNode);\n            this.finallyNode = typeFlow.typeCheck(this.finallyNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        property addToControlFlow(context: ControlFlowContext) {\n            var afterFinally = new BasicBlock();\n            this.tryNode.walk(context.pre, null, this, context);\n            var finBlock = new BasicBlock();\n            if (context.current != null) {\n                context.current.addSuccessor(finBlock);\n            }\n            context.current = finBlock;\n            context.pushStatement(this, null, afterFinally);\n            this.finallyNode.walk(context.pre, null, this, context);\n            if ((!context.noContinuation) && (context.current != null)) {\n                context.current.addSuccessor(afterFinally);\n            }\n            if (afterFinally.predecessors.length > 0) {\n                context.current = afterFinally;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.popStatement();\n            context.goChildren = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.tryNode != null) {\n                this.tryNode = this.tryNode.walk(pre, post, this, context);\n            }\n\n            if ((this.finallyNode != null) && context.goNextSibling) {\n                this.finallyNode = this.finallyNode.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass TryCatch(property tryNode: AST, property catchNode: AST) extends Statement(NodeType.TryCatch) {\n        property isStatementOrExpression() => true;\n        property isCompoundStatement() => true;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.TRY, false);\n            emitter.emitJavascript(this.catchNode, TokenID.CATCH, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property addToControlFlow(context: ControlFlowContext) {\n            var beforeTry = context.current;\n            var tryBlock = new BasicBlock();\n            beforeTry.addSuccessor(tryBlock);\n            context.current = tryBlock;\n            var afterTryCatch = new BasicBlock();\n            context.pushStatement(this, null, afterTryCatch);\n            this.tryNode.walk(context.pre, null, this, context);\n            if (!context.noContinuation) {\n                if (context.current != null) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = new BasicBlock();\n            beforeTry.addSuccessor(context.current);\n            this.catchNode.walk(context.pre, null, this, context);\n            context.popStatement();\n            if (!context.noContinuation) {\n                if (context.current != null) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = afterTryCatch;\n            context.goChildren = false;\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = typeFlow.typeCheck(this.tryNode);\n            this.catchNode = typeFlow.typeCheck(this.catchNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.tryNode != null) {\n                this.tryNode = this.tryNode.walk(pre, post, this, context);\n            }\n\n            if ((this.catchNode != null) && context.goNextSibling) {\n                this.catchNode = this.catchNode.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass Try(property body: AST) extends Statement(NodeType.Try) {\n        property isStatementOrExpression() => true;\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(\"try \");\n            emitter.emitJavascript(this.body, TokenID.TRY, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n\n        property addToControlFlow(context: ControlFlowContext) {\n            if (this.body != null) {\n                this.body.walk(context.pre, null, this, context);\n            }\n            context.goChildren = false;\n            context.noContinuation = false;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.body != null) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass Catch(property param: VarDecl, property body: AST) extends Statement(NodeType.Catch) {\n        if (this.param != null) {\n            this.param.varFlags |= VarFlags.AutoInit;\n        }\n        property containedScope: SymbolScope = null;\n\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(\" catch (\");\n            emitter.emitJavascript(this.param, TokenID.LParen, false);\n            emitter.writeToOutput(\")\");\n            emitter.emitJavascript(this.body, TokenID.CATCH, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property addToControlFlow(context: ControlFlowContext) {\n            if (this.param != null) {\n                context.addContent(this.param);\n                var bodBlock = new BasicBlock();\n                context.current.addSuccessor(bodBlock);\n                context.current = bodBlock;\n            }\n            if (this.body != null) {\n                this.body.walk(context.pre, null, this, context);\n            }\n            context.noContinuation = false;\n            context.goChildren = false;\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            var prevScope = typeFlow.scope;\n            typeFlow.scope = this.containedScope;\n            this.param = typeFlow.typeCheck(this.param);\n            var exceptVar = new ValueLocation();\n            var varSym = new VariableSymbol((<VarDecl>this.param).id.text,\n                                          this.param.minChar,\n                                          typeFlow.checker.locationInfo.unitIndex,\n                                          exceptVar);\n            exceptVar.symbol = varSym;\n            exceptVar.typeLink = new TypeLink();\n            // var type for now (add syntax for type annotation)\n            exceptVar.typeLink.type = typeFlow.anyType;\n            var thisFnc = typeFlow.thisFnc;\n            if ((thisFnc != null) && (thisFnc.type != null)) {\n                exceptVar.symbol.container = thisFnc.type.symbol;\n            }\n            else {\n                exceptVar.symbol.container = null;\n            }\n            this.param.sym = exceptVar.symbol;\n            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,\n                                 typeFlow.checker.errorReporter, false, false, false);\n            this.body = typeFlow.typeCheck(this.body);\n            this.type = typeFlow.voidType;\n            typeFlow.scope = prevScope;\n            return this;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.param != null) {\n                this.param = this.param.walk(pre, post, this, context);\n            }\n\n            if ((this.body != null) && context.goNextSibling) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n    }\n\n\n    export oldclass Finally(property body: AST) extends Statement(NodeType.Finally) {\n        property emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(\"finally\");\n            emitter.emitJavascript(this.body, TokenID.FINALLY, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        property addToControlFlow(context: ControlFlowContext) {\n            if (this.body != null) {\n                this.body.walk(context.pre, null, this, context);\n            }\n            context.goChildren = false;\n            context.noContinuation = false;\n        }\n\n        property typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n\n        property walkChildren(pre, post, parent: AST, context: IWalkContext): void {\n            if (this.body != null) {\n                this.body = this.body.walk(pre, post, this, context);\n            }\n        }\n    }\n\n    export oldclass Comment(property content: string, property isBlockComment: bool, property endsLine) extends AST(NodeType.Comment) {\n\n        property text: string[] = null;\n\n        property getText(): string[]{\n            if (this.text == null) {\n                if (this.isBlockComment) {\n                    this.text = this.content.split(\"\\n\");\n                    for (var i = 0; i < this.text.length; i++) {\n                        this.text[i] = this.text[i].replace(/^\\s+|\\s+$/g, \'\');\n                    }\n                }\n                else {\n                    this.text = [(this.content.replace(/^\\s+|\\s+$/g, \'\'))];\n                }\n            }\n\n            return this.text;\n        }\n    }\n}\n\n\nmodule Tools {\n\n    export oldclass ASTEdit(property ast1: AST, property ast2: AST) {\n\n    }\n\n    //\n    // Simple tree comparer:\n    //  Given two syntax trees, detects if all the edit(s) happened inside a single function.\n    //\n    // Algorithm:\n    //  Given 2 nodes of the AST, they are \n    // \n    //\n    export oldclass ASTComparer(property script1: AST, property script2: AST) {\n\n        property compareTopLevelTrees(oldScript: Script, newScript: Script): ASTEdit[]{\n            return [];\n        }\n\n        //property compareScripts(oldScript:Script, newScript:Script):UpdateUnitResult {\n        //    return compareAstNodes(null, oldScript, null, newScript, new AstPath());\n        //}\n\n        //property compareAstNodes(parentOldNode:AST, oldNode:AST, parentNewNode:AST, newNode:AST, path:AstPath):UpdateUnitResult {\n        //    if (oldNode === null && newNode === null) {\n        //        return UpdateUnitResult.NoEdits;\n        //    }\n        //    else if (oldNode === null && newNode !== null) {\n        //        return UpdateUnitResult.Unknown;\n        //    }\n        //    else if (oldNode !== null && newNode === null) {\n        //        return UpdateUnitResult.Unknown;\n        //    }\n\n        //    if (!astNodesAreEqual(oldNode, newNode))\n        //        return UpdateUnitResult.Unknown;\n\n        //    //if(path.is\n        //    // If we are at a top level function\n        //    var ctx1 = new BaseWalkContext();\n        //    oldNode.walk(null, null, parentOldNode, ctx1);\n\n        //    //return compareAstNodes(oldNode, newNode);\n        //    return null;\n        //}\n\n        //property astNodesAreEqual(node1:AST, node2:AST):bool {\n        //    if (node1 === null && node2 === null)\n        //        return true;\n\n        //    if (node1 !== null && node2 === null)\n        //        return false;\n\n        //    if (node1 === null && node2 !== null)\n        //        return false;\n\n        //    if (node1.nodeType !== node2.nodeType)\n        //        return false;\n\n        //    switch(node1.nodeType) {\n        //        case NodeType.Module:\n        //            return (<ModuleDecl>node1).name == (<ModuleDecl>node2).name &&\n        //                astNodesAreEqual((<ModuleDecl>node1).alias, (<ModuleDecl>node2).name);\n\n        //        case NodeType.Class:\n        //        case NodeType.Interface:\n        //            return (<TypeDecl>node1).name == (<TypeDecl>node2).name;\n        //    }\n        //    return true;\n        //}\n\n    }\n\n}\nmodule Tools {\n    export oldclass AstLogger(public logger: ILogger) {\n\n        public logScript(script: Tools.Script): void {\n            this.logLinemap(script.locationInfo.lineMap);\n\n            var ctx = {\n                goChildren: true,\n                goNextSibling: true,\n                reverseSiblings: false,\n                stack: []\n            }\n\n            var pre = (cur: Tools.AST, parent: Tools.AST, ctx) => {\n                ctx.stack.push(cur);\n                var indent = (ctx.stack.length - 1) * 2;\n                this.logComments(script, cur.preComments, indent);\n                this.logNode(script, cur, indent);\n                this.logComments(script, cur.postComments, indent);\n                return cur;\n            }\n\n            var post = (cur: Tools.AST, parent: Tools.AST, ctx) => {\n                ctx.stack.pop();\n                return cur;\n            }\n            script.walk(pre, post, null, ctx)\n        }\n\n\n        public logNode(script: Tools.Script, cur: Tools.AST, indent: number) {\n            var msg = this.addPadding(\"\", indent, \"| \", true);\n\n            msg = msg.concat(\"+ \" + cur.treeViewLabel());\n            msg = this.addPadding(msg, 70, \" \", false);\n\n            msg = msg + this.addLineColumn(script, cur.minChar);\n            msg = this.addPadding(msg, 80, \" \", false);\n\n            msg = msg + \"=> \";\n            msg = msg + this.addLineColumn(script, cur.limChar);\n            msg = this.addPadding(msg, 102, \" \", false);\n\n            msg = msg.concat(\"[\" + this.addPadding(cur.minChar.toString(), 1, \" \", true) + \", \" + this.addPadding(cur.limChar.toString(), 1, \" \", true) + \"]\");\n\n            msg = this.addPadding(msg, 115, \" \", false);\n            msg = msg.concat(\"sym=\" + (<any>cur).sym);\n\n            msg = this.addPadding(msg, 135, \" \", false);\n            msg = msg.concat(\"type=\" + (cur.type === null ? \"null\" : cur.type.getTypeName()));\n            this.logger.log(msg);\n        }\n\n        private logComments(script: Tools.Script, comments: Tools.AST[], indent: number) {\n            if (comments == null)\n                return;\n\n            for (var i = 0; i < comments.length; i++) {\n                this.logNode(script, comments[i], indent);\n            }\n        }\n\n        public logLinemap(linemap: number[]) {\n            var result = \"[\";\n            for (var i = 0; i < linemap.length; i++) {\n                if (i > 0)\n                    result += \",\";\n                result += linemap[i];\n            }\n            result += \"]\";\n            this.logger.log(\"linemap: \" + result);\n        }\n\n        private addPadding(s: string, targetLength: number, paddingString: string, leftPadding: bool): string {\n            var result = (leftPadding ? \"\" : s);\n            for (var i = s.length; i < targetLength; i++) {\n                result = result + paddingString;\n            }\n            result = result + (leftPadding ? s : \"\");\n            return result;\n        }\n\n        private addLineColumn(script: Tools.Script, position: number): string {\n            // just for calling getSourceLineColFromMap\n            var lineInfo = {\n                line: -1,\n                col: -1\n            }\n            Tools.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap);\n\n            if (lineInfo.col !== -1) {\n                lineInfo.col++; //TODO: function above seems to consider line as 1-based, and column as 0-based\n            }\n\n            return \"(\" + lineInfo.line + \", \" + lineInfo.col + \")\";\n        }\n    }\n}\n\n\nmodule Tools {\n    export function lastOf(items: any[]): any {\n        return (items === null || items.length === 0) ? null : items[items.length - 1];\n    }\n\n    export function max(a: number, b: number): number {\n        return a >= b ? a : b;\n    }\n\n    export function min(a: number, b: number): number {\n        return a <= b ? a : b;\n    }\n\n    //\n    // Helper class representing a path from a root ast node to a (grand)child ast node.\n    // This is helpful as our tree don\'t have parents.\n    //\n    export oldclass AstPath() {\n        property asts: Tools.AST[] = [];\n        property top: number = -1;\n\n        static reverseIndexOf(items: any[], index: number): any {\n            return (items === null || items.length <= index) ? null : items[items.length - index - 1];\n        }\n\n        public clone(): AstPath {\n            var clone = new AstPath();\n            clone.asts = this.asts.map((value) => { return value; });\n            clone.top = this.top;\n            return clone;\n        }\n\n        property pop(): Tools.AST {\n            var head = this.ast();\n            this.up();\n\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            return head;\n        }\n\n        property push(ast: Tools.AST) {\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            this.top = this.asts.length;\n            this.asts.push(ast);\n        }\n\n        property up() {\n            if (this.top <= -1)\n                throw new Error(\"Invalid call to \'up\'\");\n            this.top--;\n        }\n\n        property down() {\n            if (this.top == this.ast.length - 1)\n                throw new Error(\"Invalid call to \'down\'\");\n            this.top++;\n        }\n\n        property nodeType(): Tools.NodeType {\n            if (this.ast() == null)\n                return Tools.NodeType.None;\n            return this.ast().nodeType;\n        }\n\n        property ast() {\n            return <Tools.AST>reverseIndexOf(this.asts, this.asts.length - (this.top + 1));\n        }\n\n        property parent() {\n            return <Tools.AST>reverseIndexOf(this.asts, this.asts.length - this.top);\n        }\n\n        property count() {\n            return this.top + 1;\n        }\n\n        property get(index: number): Tools.AST {\n            return this.asts[index];\n        }\n\n        property isNameOfClass(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === Tools.NodeType.Name) &&\n                (this.parent().nodeType === Tools.NodeType.Class) &&\n                ((<Tools.TypeDecl>this.parent()).name === this.ast());\n        }\n\n        property isNameOfES6Class(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === Tools.NodeType.Name) &&\n                (this.parent().nodeType === Tools.NodeType.ES6Class) &&\n                ((<Tools.TypeDecl>this.parent()).name === this.ast());\n        }\n\n        property isNameOfInterface(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === Tools.NodeType.Name) &&\n                (this.parent().nodeType === Tools.NodeType.Interface) &&\n                ((<Tools.TypeDecl>this.parent()).name === this.ast());\n        }\n\n        property isNameOfArgument(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === Tools.NodeType.Name) &&\n                (this.parent().nodeType === Tools.NodeType.ArgDecl) &&\n                ((<Tools.ArgDecl>this.parent()).id === this.ast());\n        }\n\n        property isNameOfVariable(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === Tools.NodeType.Name) &&\n                (this.parent().nodeType === Tools.NodeType.VarDecl) &&\n                ((<Tools.VarDecl>this.parent()).id === this.ast());\n        }\n\n        property isNameOfModule(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === Tools.NodeType.Name) &&\n                (this.parent().nodeType === Tools.NodeType.Module) &&\n                ((<Tools.ModuleDecl>this.parent()).name === this.ast());\n        }\n\n        property isNameOfFunction(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === Tools.NodeType.Name) &&\n                (this.parent().nodeType === Tools.NodeType.FuncDecl) &&\n                ((<Tools.FuncDecl>this.parent()).name === this.ast());\n        }\n\n        property isChildOfScript(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.Script;\n        }\n\n        property isChildOfModule(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.Module;\n        }\n\n        property isChildOfClass(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 4 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.FuncDecl &&\n                this.asts[this.top - 3].nodeType === Tools.NodeType.Class;\n        }\n\n        property isChildOfES6Class(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.ES6Class;\n        }\n\n        property isChildOfInterface(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.Interface;\n        }\n\n        property isTopLevelImplicitModule() {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === Tools.NodeType.Module &&\n                Tools.hasFlag((<Tools.ModuleDecl>this.asts[this.top]).modFlags, Tools.ModuleFlags.IsWholeFile);\n        }\n\n        property isBodyOfTopLevelImplicitModule() {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === Tools.NodeType.List &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Module &&\n                 (<Tools.ModuleDecl>this.asts[this.top - 1]).members == this.asts[this.top - 0] &&\n                Tools.hasFlag((<Tools.ModuleDecl>this.asts[this.top -1]).modFlags, Tools.ModuleFlags.IsWholeFile);\n        }\n\n        property isBodyOfScript(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Script &&\n                 (<Tools.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        property isBodyOfSwitch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Switch &&\n                 (<Tools.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0];\n        }\n\n        property isBodyOfModule(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Module &&\n                 (<Tools.ModuleDecl>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        property isBodyOfClass(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.FuncDecl &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.Class &&\n                 (<Tools.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        property isBodyOfES6Class(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.ES6Class &&\n                 (<Tools.ES6ClassDecl>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        property isBodyOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.FuncDecl &&\n                 (<Tools.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        property isBodyOfInterface(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Interface &&\n                 (<Tools.TypeDecl>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        property isBodyOfBlock(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Block &&\n                (<Tools.Block>this.asts[this.top - 1]).stmts == this.asts[this.top - 0];\n        }\n\n        property isBodyOfFor(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.For &&\n                (<Tools.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isBodyOfCase(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Case &&\n                (<Tools.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isBodyOfTry(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Try &&\n                (<Tools.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isBodyOfCatch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Catch &&\n                (<Tools.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isBodyOfDoWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.DoWhile &&\n                (<Tools.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isBodyOfWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.While &&\n                (<Tools.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isBodyOfForIn(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.ForIn &&\n                (<Tools.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isBodyOfWith(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.With &&\n                (<Tools.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isBodyOfFinally(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Finally &&\n                (<Tools.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        property isCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List &&\n                (<Tools.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1];\n        }\n\n        property isDefaultCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List &&\n                (<Tools.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] &&\n                (<Tools.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];\n        }\n\n        property isListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === Tools.NodeType.List &&\n                (<Tools.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        property isListOfArrayLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.ArrayLit &&\n                this.asts[this.top - 0].nodeType === Tools.NodeType.List &&\n                (<Tools.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        property isTargetOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Member &&\n                (<Tools.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];\n        }\n\n        property isMemberOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.Member &&\n                (<Tools.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        property isItemOfList(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List;\n                //(<Tools.ASTList>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        property isThenOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.If &&\n                (<Tools.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];\n        }\n\n        property isElseOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.If &&\n                (<Tools.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];\n        }\n\n        property isBodyOfDefaultCase(): bool {\n            return this.isBodyOfCase();\n        }\n\n        property isSingleStatementList(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === Tools.NodeType.List &&\n                (<Tools.ASTList>this.asts[this.top]).members.length === 1;\n        }\n\n        property isArgumentListOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === Tools.NodeType.List &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.FuncDecl &&\n                (<Tools.FuncDecl>this.asts[this.top - 1]).args === this.asts[this.top - 0];\n        }\n\n        property isArgumentOfFunction(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 1].nodeType === Tools.NodeType.List &&\n                this.asts[this.top - 2].nodeType === Tools.NodeType.FuncDecl &&\n                (<Tools.FuncDecl>this.asts[this.top - 2]).args === this.asts[this.top - 1];\n        }\n\n        property isSynthesizedBlock(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top - 0].nodeType === Tools.NodeType.Block &&\n                (<Tools.Block>this.asts[this.top - 0]).visible === false;\n        }\n    }\n\n    export function isValidAstNode(ast: Tools.AST): bool {\n        if (ast === null)\n            return false;\n\n        if (ast.minChar === -1 || ast.limChar === -1)\n            return false;\n\n        return true;\n    }\n\n    export oldclass AstPathContext implements Tools.IWalkContext {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false;\n        public path = new Tools.AstPath();\n    }\n\n    export enum GetAstPathOptions {\n        Default = 0,\n        EdgeInclusive = 1,\n        //We need this options dealing with an AST coming from an incomplete AST. For example:\n        //     class foo { // r\n        // If we ask for the AST at the position after the \"r\" character, we won\'t see we are \n        // inside a comment, because the \"class\" AST node has a limChar corresponding to the position of \n        // the \"{\" character, meaning we don\'t traverse the tree down to the stmt list of the class, meaning\n        // we don\'t find the \"precomment\" attached to the errorneous empty stmt.\n        //TODO: It would be nice to be able to get rid of this.\n        DontPruneSearchBasedOnPosition = 1 << 1,\n    }\n\n    ///\n    /// Return the stack of AST nodes containing \"position\"\n    ///\n    export function getAstPathToPosition(script: Tools.AST, pos: number, options = GetAstPathOptions.Default): Tools.AstPath {\n        var ctx = new AstPathContext();\n\n        var lookInComments = (comments: Tools.Comment[]) => {\n            if (comments && comments.length > 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    var minChar = comments[i].minChar;\n                    var limChar = comments[i].limChar;\n                    if (!comments[i].isBlockComment) {\n                        limChar++; // For single line comments, include 1 more character (for the newline)\n                    }\n                    if (pos >= minChar && pos < limChar) {\n                        ctx.path.push(comments[i]);\n                    }\n                }\n            }\n        }\n\n        var pre = function (cur: Tools.AST, parent: Tools.AST, ctx: AstPathContext) {\n            if (isValidAstNode(cur)) {\n\n                // Add \"cur\" to the stack if it contains our position\n                // For \"identifier\" nodes, we need a special case: A position equal to \"limChar\" is\n                // valid, since the position corresponds to a caret position (in between characters)\n                // For example:\n                //  bar\n                //  0123\n                // If \"position == 3\", the caret is at the \"right\" of the \"r\" character, which should be considered valid\n                var inclusive = hasFlag(options, GetAstPathOptions.EdgeInclusive) || cur.nodeType === Tools.NodeType.Name;\n                var minChar = cur.minChar;\n                var limChar = cur.limChar + (inclusive ? 1 : 0)\n                if (pos >= minChar && pos < limChar) {\n\n                    // TODO: Since AST is sometimes not correct wrt to position, only add \"cur\" if it\'s better\n                    //       than top of the stack.\n                    var previous = ctx.path.ast();\n                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {\n                        ctx.path.push(cur);\n                    }\n                    else {\n                        //logger.log(\"TODO: Ignoring node because minChar, limChar not better than previous node in stack\");\n                    }\n                }\n\n                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually\n                if (pos < limChar) {\n                    lookInComments(cur.preComments);\n                }\n                if (pos >= minChar) {\n                    lookInComments(cur.postComments);\n                }\n\n                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {\n                    // Don\'t go further down the tree if pos is outside of [minChar, limChar]\n                    ctx.goChildren = (minChar <= pos && pos <= limChar);\n                }\n            }\n            return cur;\n        }\n\n        script.walk(pre, null, null, ctx);\n\n        return ctx.path;\n    }\n\n    //\n    // Find a source text offset that is safe for lexing tokens at the given position.\n    // This is used when \"position\" might be inside a comment or string, etc.\n    //\n    export function getTokenizationOffset(script: Tools.Script, position: number): number {\n        var bestOffset = 0;\n        var context = new Tools.BaseWalkContext();\n        var pre = (cur: Tools.AST, parent: Tools.AST, context: Tools.IWalkContext): Tools.AST => {\n            if (Tools.isValidAstNode(cur)) {\n                // Did we find a closer offset?\n                if (cur.minChar < position) {\n                    bestOffset = max(bestOffset, cur.minChar);\n                }\n\n                // Stop the walk if this node is not related to \"minChar\"\n                if (cur.minChar > position || cur.limChar < bestOffset) {\n                    context.goChildren = false;\n                }\n            }\n\n            return cur;\n        }\n\n        script.walk(pre, null, script, context);\n        return bestOffset;\n    }\n\n    ///\n    /// Simple function to Walk an AST using a simple callback function.\n    ///\n    export function walkAST(ast: Tools.AST, callback: (path:AstPath, ctx: IWalkContext) => void): void {\n        var path = new AstPath();\n        var pre = function (cur: Tools.AST, parent: Tools.AST, ctx: IWalkContext) {\n            path.push(cur);\n            callback(path, ctx);\n            return cur;\n        }\n        var post = function (cur: Tools.AST, parent: Tools.AST, ctx: IWalkContext) {\n            path.pop();\n        }\n\n        ast.walk(pre, post, null, new BaseWalkContext());\n    }\n}\n\n\nmodule Tools {\n\n    class Base64Format {\n        static encodedValues = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/\';\n        static encode(inValue: number) {\n            if (inValue < 64) {\n                return encodedValues.charAt(inValue);\n            }\n            throw TypeError(inValue + \": not a 64 based value\");\n        };\n    }\n\n    export class Base64VLQFormat {\n        static encode(inValue: number) {\n\n            // Add a new least significant bit that has the sign of the value.\n            // if negative number the least significant bit that gets added to the number has value 1\n            // else least significant bit value that gets added is 0\n            // eg. -1 changes to binary : 01 [1] => 3\n            //     +1 changes to binary : 01 [0] => 2\n            if (inValue < 0) {\n                inValue = ((-inValue) << 1) + 1;\n            }\n            else {\n                inValue = inValue << 1;\n            }\n\n            // Encode 5 bits at a time starting from least significant bits\n            var encodedStr = \"\";\n            do {\n                var currentDigit = inValue & 31; // 11111\n                inValue = inValue >> 5;\n                if (inValue > 0) {\n                    // There are still more digits to decode, set the msb (6th bit)\n                    currentDigit = currentDigit | 32; \n                }\n                encodedStr = encodedStr + Base64Format.encode(currentDigit);\n            } while (inValue > 0);\n\n            return encodedStr;\n        }\n    }\n}\n\n\nmodule Tools {\n    export oldclass Binder(property checker: TypeChecker) {\n        property resolveBaseTypeLinks(typeLinks: TypeLink[], scope: SymbolScope) {\n            var extendsList: Type[] = null;\n            if (typeLinks != null) {\n                extendsList = new Type[];\n                for (var i = 0, len = typeLinks.length; i < len; i++) {\n                    var typeLink = typeLinks[i];\n                    this.checker.resolvingBases = true;\n                    this.checker.resolveTypeLink(scope, typeLink, true);\n                    this.checker.resolvingBases = false;\n                    if (typeLink.type.isClass()) {\n                        extendsList[i] = typeLink.type.instanceType;\n                    }\n                    else {\n                        extendsList[i] = typeLink.type;\n                    }\n                }\n            }\n            return extendsList;\n        }\n\n        property resolveBases(scope: SymbolScope, type: Type) {\n            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);\n\n            var i = 0, len = type.extendsList.length;\n            var derivedIsClass = type.isClassInstance();\n            for (; i < len; i++) {\n                var baseIsClass = type.extendsList[i].isClassInstance();\n                if (type.extendsList[i] != this.checker.anyType) {\n                    if (derivedIsClass) {\n                        if (!baseIsClass) {\n                            this.checker.errorReporter.simpleErrorFromSym(type.symbol,\n                                                                     \"A export class may only extend other classes, \" + type.extendsList[i].symbol.fullName() + \" is an interface.\");\n                        }\n                    }\n                    else {\n                        if (baseIsClass) {\n                            this.checker.errorReporter.simpleErrorFromSym(type.symbol,\n                                                                     \"An interface may only extend other interfaces, \" + type.extendsList[i].symbol.fullName() + \" is a class.\");\n                        }\n                    }\n                }\n            }\n\n            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);\n\n            if (type.implementsList != null) {\n                for (i = 0, len = type.implementsList.length; i < len; i++) {\n                    var iface = type.implementsList[i];\n                    if (iface.isClassInstance()) {\n                        if (derivedIsClass) {\n                            this.checker.errorReporter.simpleErrorFromSym(type.symbol,\n                                                                     \"A class may only implement an interface; \" + iface.symbol.fullName() + \" is a class.\");\n                        }\n                    }\n                }\n            }\n        }\n\n        property resolveSignatureGroup(signatureGroup: SignatureGroup, scope: SymbolScope, instanceType: Type) {\n            var supplyVar = !(signatureGroup.hasImplementation);\n            for (var i = 0, len = signatureGroup.signatures.length; i < len; i++) {\n                var signature = signatureGroup.signatures[i];\n                if (instanceType != null) {\n                    signature.returnType.type = instanceType;\n                }\n                else {\n                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);\n                }\n                var paramLen = signature.parameters.length;\n                for (var j = 0; j < paramLen; j++) {\n                    this.bindSymbol(scope, signature.parameters[j]);\n                }\n                if (signature.hasVariableArgList) {\n                    // check that last parameter has an array type\n                    var lastParam = <ParameterSymbol>signature.parameters[paramLen - 1];\n                    lastParam.argsOffset = paramLen - 1;\n                    if (!lastParam.getType().isArray()) {\n                        this.checker.errorReporter.simpleErrorFromSym(lastParam,\n                                                                 \"... parameter must have array type\");\n                    }\n                }\n            }\n        }\n\n        property bindType(scope: SymbolScope, type: Type, instanceType: Type): void {\n            if (instanceType != null) {\n                this.bindType(scope, instanceType, null);\n            }\n            if (type.hasMembers()) {\n                var members = type.members;\n                var ambientMembers = type.ambientMembers;\n                var typeMembers = type.getAllEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var memberScope = new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);\n                var agg = new SymbolAggregateScope(type.symbol);\n                var prevCurrentModDecl = this.checker.currentModDecl;\n                var prevBindStatus = this.checker.inBind;\n                agg.addParentScope(memberScope);\n                agg.addParentScope(scope);\n                if (type.isModuleType()) {\n                    this.checker.currentModDecl = type.symbol.declAST;\n                    this.checker.inBind = true;\n                }\n                if (members != null) {\n                    this.bind(agg, type.members.allMembers); // REVIEW: Should only be getting exported types?\n                }\n                if (typeMembers != null) {\n                    this.bind(agg, typeMembers.allMembers);\n                }\n                if (ambientMembers != null) {\n                    this.bind(agg, ambientMembers.allMembers);\n                }\n                if (ambientTypeMembers != null) {\n                    this.bind(agg, ambientTypeMembers.allMembers);\n                }\n                this.checker.currentModDecl = prevCurrentModDecl;\n                this.checker.inBind = prevBindStatus;\n            }\n            if (type.extendsTypeLinks != null) {\n                this.resolveBases(scope, type);\n            }\n            if (type.construct != null) {\n                this.resolveSignatureGroup(type.construct, scope, instanceType);\n            }\n            if (type.call != null) {\n                this.resolveSignatureGroup(type.call, scope, null);\n            }\n            if (type.index != null) {\n                this.resolveSignatureGroup(type.index, scope, null);\n            }\n            if (type.elementType != null) {\n                this.bindType(scope, type.elementType, null);\n            }\n        }\n\n        property bindSymbol(scope: SymbolScope, symbol: Symbol) {\n            if (!symbol.bound) {\n                var prevLocationInfo = this.checker.locationInfo;\n                if ((this.checker.units != null) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];\n                }\n                switch (symbol.kind()) {\n                    case SymbolKind.Type:\n                        var typeSym = <TypeSymbol>symbol;\n                        if (typeSym.type != this.checker.mod && !typeSym.isAlias) {\n                            this.bindType(scope, typeSym.type, typeSym.instanceType);\n\n                            // bind expansions on the parent type symbol\n                            if (typeSym.type.isModuleType()) {\n                                for (var i = 0; i < typeSym.expansions.length; i++) {\n                                    this.bindType(scope, typeSym.expansions[i], typeSym.instanceType);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Field:\n                        this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,\n                                                false);\n                        break;\n                    case SymbolKind.Parameter:\n                        this.checker.resolveTypeLink(scope,\n                                                (<ParameterSymbol>symbol).parameter.typeLink,\n                                                true);\n                        break;\n                }\n                this.checker.locationInfo = prevLocationInfo;\n            }\n            symbol.bound = true;\n        }\n\n        property bind(scope: SymbolScope, table: IHashTable) {\n            table.map(\n                (key, sym, binder) => {\n                    binder.bindSymbol(scope, sym);\n                },\n                this);\n        }\n    }\n\n}\n\n\nmodule Tools {\n    export module CompilerDiagnostics {\n        export var debug = false;\n        export interface IDiagnosticWriter {\n            Alert(output: string): void;\n        }\n\n        export var diagnosticWriter: IDiagnosticWriter = null;\n\n        export var analysisPass: number = 0;\n\n        export function Alert(output: string) {\n            if (diagnosticWriter != null) {\n                diagnosticWriter.Alert(output);\n            }\n        }\n\n        export function debugPrint(s: string) {\n            if (debug) {\n                Alert(s);\n            }\n        }\n\n    }\n\n    export interface ILogger {\n        information(): bool;\n        debug(): bool;\n        warning(): bool;\n        error(): bool;\n        fatal(): bool;\n        log(s: string): void;\n    }\n\n    export oldclass NullLogger implements ILogger {\n        public information(): bool { return false; }\n        public debug(): bool { return false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        property log(s: string): void {\n        }\n    }\n\n    export oldclass LoggerAdapter(public logger: ILogger) implements ILogger {\n        private _information = this.logger.information();\n        private _debug = this.logger.debug();\n        private _warning = this.logger.warning();\n        private _error = this.logger.error();\n        private _fatal = this.logger.fatal();\n\n        public information(): bool { return this._information; }\n        public debug(): bool { return this._debug; }\n        public warning(): bool { return this._warning; }\n        public error(): bool { return this._error; }\n        public fatal(): bool { return this._fatal; }\n        property log(s: string): void {\n            this.logger.log(s);\n        }\n    }\n\n    export oldclass BufferedLogger implements ILogger {\n        public logContents = [];\n\n        public information(): bool { return false; }\n        public debug(): bool { return false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        property log(s: string): void {\n            this.logContents.push(s);\n        }\n    }\n\n    export function timeFunction(logger: ILogger, funcDescription: string, func: () =>any): any {\n        var start = +new Date();\n        var result = func();\n        var end = +new Date();\n        logger.log(funcDescription + \" completed in \" + (end - start) + \" msec\");\n        return result;\n    }\n\n    export function stringToLiteral(value: string, length: number): string {\n        var result = \"\";\n\n        var addChar = (index: number) => {\n            var ch = value.charCodeAt(index);\n            switch (ch) {\n                case 0x09: // tab\n                    result += \"\\\\t\";\n                    break;\n                case 0x0a: // line feed\n                    result += \"\\\\n\";\n                    break;\n                case 0x0b: // vertical tab\n                    result += \"\\\\v\";\n                    break;\n                case 0x0c: // form feed\n                    result += \"\\\\f\";\n                    break;\n                case 0x0d: // carriage return\n                    result += \"\\\\r\";\n                    break;\n                case 0x22:  // double quote\n                    result += \"\\\\\\\"\";\n                    break;\n                case 0x27: // single quote\n                    result += \"\\\\\\\'\";\n                    break;\n                case 0x5c: // Backslash\n                    result += \"\\\\\";\n                    break;\n                default:\n                    result += value.charAt(index);\n            }\n        }\n\n        var tooLong = (value.length > length);\n        if (tooLong) {\n            var mid = length >> 1;\n            for (var i = 0; i < mid; i++) addChar(i);\n            result += \"(...)\";\n            for (var i = value.length - mid; i < value.length; i++) addChar(i);\n        }\n        else {\n            length = value.length;\n            for (var i = 0; i < length; i++) addChar(i);\n        }\n        return result;\n    }\n}\n\n\nmodule Tools {\n\n    export enum EmitContainer {\n        Prog,\n        Module,\n        DynamicModule,\n        OldClass,\n        ES6Class,\n        Constructor,\n        Function,\n        Args,\n        Interface,\n    }\n\n    export class EmitState {\n        public indentAmt: number;\n        public column: number;\n        public line: number;\n        public pretty: bool;\n        public inObjectLiteral: bool;\n        public container: EmitContainer;\n\n        constructor() {\n            this.indentAmt = 0;\n            this.column = 0;\n            this.line = 0;\n            this.pretty = false;\n            this.inObjectLiteral = false;\n            this.container = EmitContainer.Prog;\n        }\n    }\n\n    export interface IEmitOptions {\n        minWhitespace: bool;\n        propagateConstants: bool;\n        emitComments: bool;\n    }\n\n    export oldclass Emitter(property checker: TypeChecker, property outfile: ITextWriter, property emitOptions: IEmitOptions) {\n        property prologueEmitted = false;\n        property indentStep = 4;\n        property thisClassNode: NamedType = null;\n        property thisFnc: FuncDecl = null;\n        property moduleDeclList: ModuleDecl[] = [];\n        property moduleName = \"\";\n        property emitState = new EmitState();\n        property indentStrings: string[] = [];\n        property ambientModule = false;\n        property modAliasId: string = null;\n        property firstModAlias: string = null;\n        property allSourceMappers: SourceMapper[] = [];\n        property sourceMapper: SourceMapper = null;\n\n        property setSourceMappings(mapper: SourceMapper) {\n            this.allSourceMappers.push(mapper);\n            this.sourceMapper = mapper;\n        }\n\n        property increaseIndent() { this.emitState.indentAmt += this.indentStep; }\n        property decreaseIndent() { this.emitState.indentAmt -= this.indentStep; }\n\n        property writeToOutput(s: string) {\n            this.outfile.Write(s);\n            // TODO: check s for newline\n            this.emitState.column += s.length;\n        }\n\n        property writeToOutputTrimmable(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                s = s.replace(/[\\s]*/g, \'\');\n            }\n            this.writeToOutput(s);\n        }\n\n        property writeLineToOutput(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                this.writeToOutput(s);\n                var c = s.charCodeAt(s.length - 1);\n                if (!((c == LexCodeSpace) || (c == LexCodeSMC) || (c == LexCodeLBR))) {\n                    this.writeToOutput(\' \');\n                }\n            }\n            else {\n                this.outfile.WriteLine(s);\n                this.emitState.column = 0\n                this.emitState.line++;\n            }\n        }\n\n        property setInObjectLiteral(val: bool): bool {\n            var temp = this.emitState.inObjectLiteral;\n            this.emitState.inObjectLiteral = val;\n            return temp;\n        }\n\n        property setContainer(c: number): number {\n            var temp = this.emitState.container;\n            this.emitState.container = c;\n            return temp;\n        }\n\n        property emitIndent() {\n            if (this.emitOptions.minWhitespace) {\n            }\n            else {\n                var indentString = this.indentStrings[this.emitState.indentAmt];\n                if (indentString === undefined) {\n                    indentString = \"\";\n                    for (var i = 0; i < this.emitState.indentAmt; i++) {\n                        indentString += \" \";\n                    }\n                    this.indentStrings[this.emitState.indentAmt] = indentString;\n                }\n                this.writeToOutput(indentString);\n            }\n        }\n\n        property emitCommentInPlace(comment: Comment) {\n            this.recordSourceMappingStart(comment);\n            var text = comment.getText();\n            var hadNewLine = false;\n\n            if (comment.isBlockComment) {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.writeToOutput(text[0]);\n\n                if (text.length > 1 || comment.endsLine) {\n                    this.writeLineToOutput(\"\");\n                    for (var i = 1; i < text.length; i++) {\n                        this.emitIndent();\n                        this.writeLineToOutput(text[i]);\n                    }\n                    hadNewLine = true;\n                }\n            }\n            else {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.writeLineToOutput(text[0]);\n                hadNewLine = true;\n            }\n\n            if (hadNewLine) {\n                this.emitIndent();\n            }\n            else {\n                this.writeToOutput(\" \");\n            }\n            this.recordSourceMappingEnd(comment);\n        }\n\n        property emitParensAndCommentsInPlace(ast: AST, pre: bool) {\n            var comments = pre ? ast.preComments : ast.postComments;\n\n            // comments should be printed before the LParen, but after the RParen\n            if (ast.isParenthesized && !pre) {\n                this.writeToOutput(\")\");\n            }\n            if (this.emitOptions.emitComments && comments != null && comments.length != 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    this.emitCommentInPlace(comments[i]);\n                }\n            }\n            if (ast.isParenthesized && pre) {\n                this.writeToOutput(\"(\");\n            }\n        }\n\n        // TODO: emit accessor pattern\n        property emitObjectLiteral(content: ASTList) {\n            this.writeLineToOutput(\"{\");\n            this.increaseIndent();\n            var inObjectLiteral = this.setInObjectLiteral(true);\n            this.emitJavascriptList(content, \",\", TokenID.Comma, true, false, false);\n            this.setInObjectLiteral(inObjectLiteral);\n            this.decreaseIndent();\n            this.emitIndent();\n            this.writeToOutput(\"}\");\n        }\n\n        property emitArrayLiteral(content: ASTList) {\n            this.writeToOutput(\"[\");\n            if (content != null) {\n                this.writeToOutput(\"\");\n                this.increaseIndent();\n                this.emitJavascriptList(content, \", \", TokenID.Comma, true, false, false);\n                this.decreaseIndent();\n                //emitIndent();\n            }\n            this.writeToOutput(\"]\");\n        }\n\n        property emitNew(target: AST, args: ASTList) {\n            this.recordSourceMappingStart(target);\n            this.writeToOutput(\"new \");\n            if (target.nodeType == NodeType.TypeRef) {\n                this.writeToOutput(\"Array()\");\n            }\n            else {\n                this.emitJavascript(target, TokenID.Tilde, false);\n                this.writeToOutput(\"(\");\n                this.emitJavascriptList(args, \", \", TokenID.Comma, false, false, false);\n                this.writeToOutput(\")\");\n            }\n            this.recordSourceMappingEnd(target);\n        }\n\n        property tryEmitConstant(dotExpr: BinaryExpression) {\n            if (!this.emitOptions.propagateConstants) {\n                return false;\n            }\n            var propertyName = <Identifier>dotExpr.operand2;\n            if ((propertyName != null) && (propertyName.sym != null) && (propertyName.sym.isVariable())) {\n                if (hasFlag(propertyName.sym.flags, SymbolFlags.Constant)) {\n                    if (propertyName.sym.declAST != null) {\n                        var boundDecl = <BoundDecl>propertyName.sym.declAST;\n                        if ((boundDecl.init != null) && (boundDecl.init.nodeType == NodeType.NumberLit)) {\n                            var numLit = <NumberLiteral>boundDecl.init;\n                            this.writeToOutput(numLit.value.toString());\n                            var comment = \" /* \";\n                            comment += propertyName.text;\n                            comment += \" */ \";\n                            this.writeToOutput(comment);\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        property emitCall(callNode: CallExpression, target: AST, args: ASTList) {\n            if (!this.emitSuperCall(callNode)) {\n                if (!hasFlag(callNode.flags, ASTFlags.ES6ClassBaseConstructorCall)) {\n                    if (target.nodeType == NodeType.FuncDecl) {\n                        this.writeToOutput(\"(\");\n                    }\n                    this.emitJavascript(target, TokenID.LParen, false);\n                    if (target.nodeType == NodeType.FuncDecl) {\n                        this.writeToOutput(\")\");\n                    }\n                    this.writeToOutput(\"(\");\n                    this.emitJavascriptList(args, \", \", TokenID.Comma, false, false, false);\n                    this.writeToOutput(\")\");\n                }\n                else {\n                    this.decreaseIndent();\n                    this.decreaseIndent();\n                    this.emitConstructorCalls((<ES6ClassDecl>this.thisClassNode).baseConstructorCall, this.thisClassNode);\n                    this.increaseIndent();\n                    this.increaseIndent();\n                }\n            }\n        }\n\n        property defaultValue(type: Type): string {\n            if (type == this.checker.anyType) {\n                return \"undefined\";\n            }\n            else if (type == this.checker.doubleType) {\n                return \"0\";\n            }\n            else if (type == this.checker.stringType) {\n                return \'\"\"\';\n            }\n            else if (type == this.checker.booleanType) {\n                return \"false\";\n            }\n            else {\n                return \"null\";\n            }\n        }\n\n        property emitConstructorCalls(bases: ASTList, classDecl: NamedType) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            this.recordSourceMappingStart(classDecl);\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    baseSymbol = (<CallExpression>baseExpr).target.type.symbol;\n                }\n                else {\n                    baseSymbol = baseExpr.type.symbol;\n                }\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.emitIndent();\n                    var callEx = <CallExpression>baseExpr;\n                    this.writeToOutput(classDecl.name.text + \"._super.constructor\");\n                    //emitJavascript(callEx.target,TokenID.LParen,false);\n                    this.writeToOutput(\".call(this\");\n                    var args: ASTList = callEx.args;\n                    if ((args != null) && (args.members.length > 0)) {\n                        this.writeToOutput(\", \");\n                        this.emitJavascriptList(args, \", \", TokenID.Comma, false, false, false);\n                    }\n                    this.writeLineToOutput(\");\");\n                }\n                else {\n                    if ((baseExpr.type != null) && (baseExpr.type.isClassInstance())) {\n                        // parameterless constructor call;\n                        this.emitIndent();\n                        this.writeToOutput(classDecl.name.text + \"._super.constructor\");\n                        //emitJavascript(baseExpr,TokenID.LParen,false);\n                        this.writeLineToOutput(\".call(this);\");\n                    }\n                }\n            }\n            this.recordSourceMappingEnd(classDecl);\n        }\n\n        property emitInnerFunction(funcDecl: FuncDecl, printName: bool, isProtoMember: bool,\n            bases: ASTList, hasSelfRef: bool, classDecl: NamedType) {\n            /// REVIEW: The code below causes functions to get pushed to a newline in cases where they shouldn\'t\n            /// such as: \n            ///     Foo.prototype.bar = \n            ///         function() {\n            ///         };\n            /// Once we start emitting comments, we should pull this code out to place on the outer context where the function\n            /// is used.\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n            //    this.writeLineToOutput(\"\");\n            //    this.increaseIndent();\n            //    emitIndent();\n            //}\n\n            var isES6ClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod);\n            var hasNonObjectBaseType = isES6ClassConstructor && hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseType) && !hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n            var es6PropertiesMustComeAfterSuperCall = hasNonObjectBaseType && hasFlag((<ES6ClassDecl>this.thisClassNode).varFlags, VarFlags.ES6ClassSuperMustBeFirstCallInConstructor);\n\n            this.emitParensAndCommentsInPlace(funcDecl, true);\n            this.recordSourceMappingStart(funcDecl);\n            if (!(funcDecl.isAccessor() && (<FieldSymbol>funcDecl.accessorSymbol).isObjectLitField)) {\n                this.writeToOutput(\"function\");\n            }\n            if (printName) {\n                var id = funcDecl.getNameText();\n                if (id != null && !funcDecl.isAccessor()) {\n                    this.writeToOutput(\" \" + id);\n                }\n            }\n\n            this.writeToOutput(\"(\");\n            var argsLen = 0;\n            var i = 0;\n            var arg: ArgDecl;\n            var defaultArgs: ArgDecl[] = [];\n            if (funcDecl.args != null) {\n                var tempContainer = this.setContainer(EmitContainer.Args);\n                argsLen = funcDecl.args.members.length;\n                var printLen = argsLen;\n                if (funcDecl.variableArgList) {\n                    printLen--;\n                }\n                for (i = 0; i < printLen; i++) {\n                    arg = funcDecl.args.members[i];\n                    if (arg.init != null) {\n                        defaultArgs.push(arg);\n                    }\n                    this.emitJavascript(arg, TokenID.LParen, false);\n                    if (i < (printLen - 1)) {\n                        this.writeToOutput(\", \");\n                    }\n                }\n                this.setContainer(tempContainer);\n            }\n            this.writeLineToOutput(\") {\");\n            this.increaseIndent();\n\n            // set default args first\n            for (i = 0; i < defaultArgs.length; i++) {\n                var arg = defaultArgs[i];\n                this.emitIndent();\n                this.recordSourceMappingStart(arg);\n                this.writeToOutput(\"if (typeof \" + arg.id.text + \" === \\\"undefined\\\") {\");//\n                this.recordSourceMappingStart(arg.id);\n                this.writeToOutput(arg.id.text);\n                this.recordSourceMappingEnd(arg.id);\n                this.writeToOutput(\" = \");\n                this.emitJavascript(arg.init, TokenID.LParen, false);\n                this.writeLineToOutput(\"; }\")\n                this.recordSourceMappingEnd(arg);\n            }\n            if (funcDecl.isConstructor && !es6PropertiesMustComeAfterSuperCall) {\n                if (funcDecl.args != null) {\n                    argsLen = funcDecl.args.members.length;\n                    for (i = 0; i < argsLen; i++) {\n                        arg = funcDecl.args.members[i];\n                        if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(arg);\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput(\"this.\" + arg.id.text);\n                            this.recordSourceMappingEnd(arg.id);\n                            this.writeToOutput(\" = \");\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput(arg.id.text);\n                            this.recordSourceMappingEnd(arg.id);\n                            this.writeLineToOutput(\";\");\n                            this.recordSourceMappingEnd(arg);\n                        }\n                    }\n                }\n\n                // For ES6 classes, the constructor needs to be explicitly called\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)) {\n                    this.emitConstructorCalls(bases, classDecl);\n                }\n            }\n            if (hasSelfRef) {\n                this.emitIndent();\n                this.writeLineToOutput(\"var _self = this;\");\n            }\n            if (funcDecl.variableArgList) {\n                argsLen = funcDecl.args.members.length;\n                var lastArg = <ArgDecl>funcDecl.args.members[argsLen - 1];\n                this.emitIndent();\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput(\"var \");\n                this.recordSourceMappingStart(lastArg.id);\n                this.writeToOutput(lastArg.id.text);\n                this.recordSourceMappingEnd(lastArg.id);\n                this.writeLineToOutput(\" = [];\");\n                this.recordSourceMappingEnd(lastArg);\n                this.emitIndent();\n                this.writeLineToOutput(\"for (var _i = 0; _i < (arguments.length - \" + (argsLen - 1) +\n                                  \"); _i++) {\");\n                this.increaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput(lastArg.id.text + \"[_i] = arguments[_i+\" + (argsLen - 1) + \"];\");\n                this.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput(\"}\");\n            }\n\n            // if it\'s an ES6 class, emit the uninitializedMembers, first emit the non-proto class body members\n            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod) && !es6PropertiesMustComeAfterSuperCall) {\n\n                var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                for (var i = 0; i < nProps; i++) {\n                    if ((<ASTList>this.thisClassNode.members).members[i].nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];\n                        if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                            this.writeLineToOutput(\"\");\n                            this.emitIndent();\n                            this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                        }\n                    }\n                }\n                this.writeLineToOutput(\"\");\n            }\n\n            this.emitBareJavascriptStatements(funcDecl.bod, es6PropertiesMustComeAfterSuperCall);\n\n            this.decreaseIndent();\n            this.emitIndent();\n            this.writeToOutput(\"}\");\n            if (!isProtoMember &&\n                //funcDecl.name != null &&\n                !hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) &&\n                (hasFlag(funcDecl.fncFlags, FncFlags.Definition) || funcDecl.isConstructor)) {\n                this.writeLineToOutput(\"\");\n            }\n\n            // Emit the function\'s statics\n            if (!funcDecl.isConstructor && (funcDecl.statics.members.length > 0 || funcDecl.innerStaticFuncs.length > 0)) {\n                this.writeLineToOutput(\"\");\n                this.emitIndent();\n                var funcName = funcDecl.getNameText();\n                this.writeLineToOutput(\"(function(\" + funcName + \") {\");\n                this.increaseIndent();\n\n                var len = 0;\n                var i = 0;\n\n                // Emit the function\'s local inner static functions\n                len = funcDecl.innerStaticFuncs.length;\n                for (i = 0; i < len; i++) {\n                    var innerFunc = funcDecl.innerStaticFuncs[i];\n                    if (innerFunc.isOverload) {\n                        continue;\n                    }\n                    this.emitIndent();\n                    if (innerFunc.isAccessor()) {\n                        this.emitPropertyAccessor(innerFunc, funcDecl.name.text, false);\n                    }\n                    else {\n                        this.writeToOutput(funcName + \".\" + innerFunc.name.text + \" = \");\n                        this.emitInnerFunction(innerFunc, (innerFunc.name != null && !innerFunc.name.isMissing()), false,\n                                         null, innerFunc.hasSelfReference(), null);\n                    }\n                }\n\n                // Emit the function\'s local static values\n                if (funcDecl.statics != null) {\n                    this.recordSourceMappingStart(funcDecl.statics);\n                    len = funcDecl.statics.members.length;\n                    for (i = 0; i < len; i++) {\n                        this.emitIndent();\n                        this.writeToOutput(funcName);\n                        this.emitJavascript(funcDecl.statics.members[i], TokenID.Tilde, false);\n                        this.writeLineToOutput(\"\");\n                    }\n                    this.recordSourceMappingEnd(funcDecl.statics);\n                }\n\n                this.decreaseIndent();\n                this.emitIndent();\n                var printProto = isProtoMember && (this.thisClassNode != null);\n                var prefix = printProto ? this.thisClassNode.name.text + \".prototype.\" : \"\";\n                this.writeLineToOutput(\"})(\" + prefix + funcName + \");\")\n            }\n            this.recordSourceMappingEnd(funcDecl);\n            this.emitParensAndCommentsInPlace(funcDecl, false);\n            /// TODO: See the other part of this at the beginning of function\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n            //    this.decreaseIndent();\n            //}           \n        }\n\n        property emitTypeList(list: ASTList) {\n            if (list != null) {\n                if (list.nodeType == NodeType.List) {\n                    for (var i = 0, len = list.members.length; i < len; i++) {\n                        var emitNode = list.members[i];\n                        emitNode.emitType(this);\n                    }\n                }\n                else {\n                    list.emitType(this);\n                }\n            }\n        }\n\n        property emitEnumMemberList(enumMembers: ASTList) {\n            this.recordSourceMappingStart(enumMembers);\n            for (var i = 0, len = enumMembers.members.length; i < len; i++) {\n                var emitNode = enumMembers.members[i];\n                if (emitNode.nodeType == NodeType.VarDecl) {\n                    var varDecl = <VarDecl>emitNode;\n                    if (varDecl.id.text != \"_map\") {\n                        this.emitIndent();\n                        this.writeLineToOutput(varDecl.id.text + \", \");\n                    }\n                }\n            }\n            this.recordSourceMappingEnd(enumMembers);\n        }\n\n        property emitEnumType(moduleDecl: ModuleDecl) {\n            this.writeLineToOutput(\"enum \" + moduleDecl.name.text + \" {\");\n            this.increaseIndent();\n            this.emitEnumMemberList(moduleDecl.members);\n            this.decreaseIndent();\n            this.emitIndent();\n            this.writeLineToOutput(\"}\");\n        }\n\n        property emitArgTypes(args: ASTList, indexer: bool) {\n            if ((args != null) && (args.members.length > 0)) {\n                if (indexer) {\n                    this.writeToOutput(\"[\");\n                }\n                else {\n                    this.writeToOutput(\"(\");\n                }\n\n                for (var j = 0, argsLen = args.members.length; j < argsLen; j++) {\n                    var arg = <ArgDecl>args.members[j];\n                    if (j > 0) {\n                        this.writeToOutput(\", \");\n                    }\n                    if (hasFlag(arg.varFlags, VarFlags.Property)) {\n                        this.writeToOutput(\"property \");\n                    }\n                    if (arg.type == null) {\n                        arg.type = this.checker.anyType;\n                    }\n                    this.writeToOutput(arg.id.text + \": \" + arg.type.getTypeName());\n                }\n                if (indexer) {\n                    this.writeToOutput(\"]\");\n                }\n                else {\n                    this.writeToOutput(\")\");\n                }\n            }\n        }\n\n        property emitFuncType(funcDecl: FuncDecl) {\n            this.emitIndent();\n            if (this.emitState.container != EmitContainer.Interface) {\n                this.writeToOutput(\"function \");\n            }\n\n            if (funcDecl.isConstructMember()) {\n                this.writeToOutput(\"new\");\n            }\n            else if (funcDecl.isCallMember() || funcDecl.isIndexerMember()) {\n            }\n            else {\n                this.writeToOutput(funcDecl.getNameText());\n            }\n\n            if (funcDecl.isSignature()) {\n                this.writeLineToOutput(funcDecl.signature.toString() + \";\");\n            }\n            else {\n                this.emitArgTypes(funcDecl.args, funcDecl.isIndexerMember());\n                if ((funcDecl.args == null) || (funcDecl.args.members.length == 0)) {\n                    this.writeToOutput(\"()\");\n                }\n                if (funcDecl.signature.returnType.type == null) {\n                    // REVIEW: Why are we setting this to \'any\' here?\n                    funcDecl.signature.returnType.type = this.checker.anyType;\n                }\n                this.writeLineToOutput(\": \" + funcDecl.signature.returnType.type.getTypeName() + \";\");\n            }\n        }\n\n        property emitVarType(varDecl: VarDecl) {\n            this.emitIndent();\n            if (this.emitState.container != EmitContainer.Interface) {\n                this.writeToOutput(\"property \");\n            }\n            var type: Type = this.checker.anyType;\n            if (varDecl.typeExpr != null) {\n                type = varDecl.typeExpr.type;\n            }\n            else if (varDecl.sym != null) {\n                type = (<FieldSymbol>varDecl.sym).getType();\n                if (type == null) {\n                    type = this.checker.anyType;\n                }\n            }\n            this.writeLineToOutput(varDecl.id.text + \": \" + type.getTypeName() + \";\");\n        }\n\n        property emitBaseList(bases: ASTList, qual: string) {\n            if ((bases != null) && (bases.members.length > 0)) {\n                this.writeToOutput(\" \" + qual + \" \");\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    var baseExpr = bases.members[i];\n                    var baseSymbol: Symbol;\n                    if (baseExpr.nodeType == NodeType.Call) {\n                        baseSymbol = (<CallExpression>baseExpr).target.type.symbol;\n                    }\n                    else {\n                        baseSymbol = baseExpr.type.symbol;\n                    }\n                    var baseName = baseSymbol.name;\n                    if (i > 0) {\n                        this.writeToOutput(\", \");\n                    }\n                    this.writeToOutput(baseName);\n                }\n            }\n        }\n\n        property emitBaseTypes(typeDecl: TypeDecl) {\n            this.emitBaseList(typeDecl.extendsList, \"extends\");\n            this.emitBaseList(typeDecl.implementsList, \"implements\");\n        }\n\n        property emitInterfaceType(interfaceDecl: TypeDecl) {\n            this.emitIndent();\n            this.writeToOutput(\"interface \" + interfaceDecl.name.text);\n            this.emitBaseTypes(interfaceDecl);\n            this.writeLineToOutput(\" {\");\n            this.increaseIndent();\n            var temp = this.setContainer(EmitContainer.Interface);\n            this.emitTypeList(interfaceDecl.members);\n            this.setContainer(temp);\n            this.decreaseIndent();\n            this.emitIndent();\n            this.writeLineToOutput(\"}\");\n        }\n\n\n        property emitClassType(classDecl: TypeDecl) {\n            this.emitIndent();\n            this.writeToOutput(\"class \" + classDecl.name.text);\n            this.emitArgTypes(classDecl.args, false);\n            this.emitBaseTypes(classDecl);\n            this.writeLineToOutput(\" {\");\n            this.increaseIndent();\n            var constrDecl = <FuncDecl>classDecl.members;\n            this.emitTypeList(constrDecl.bod);\n            this.decreaseIndent();\n            this.emitIndent();\n            this.writeLineToOutput(\"}\");\n        }\n\n        property emitModuleType(moduleDecl: ModuleDecl) {\n            var svAmbientModule = this.ambientModule;\n            this.ambientModule = true;\n            this.emitIndent();\n            if (!svAmbientModule) {\n                this.writeToOutput(\"declare \");\n            }\n            if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum)) {\n                this.emitEnumType(moduleDecl);\n            }\n            else {\n                this.writeLineToOutput(\"module \" + moduleDecl.name.text + \" {\");\n                this.increaseIndent();\n                this.emitTypeList(moduleDecl.members);\n                this.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput(\"}\");\n            }\n            this.ambientModule = svAmbientModule;\n        }\n\n        property emitJavascriptModule(moduleDecl: ModuleDecl) {\n\n            if (!moduleDecl.isAnonInnerMod) {\n                var modName = moduleDecl.name.text;\n                if (modName.length > 4 && modName.substring(modName.length - 4, modName.length) == \".str\") {\n                    moduleDecl.name.text = modName.substring(0, modName.length - 4);\n                }\n            }\n\n            if (!hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {\n                var temp = this.setContainer(EmitContainer.Module);\n                var svModuleName = this.moduleName;\n                var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n                var isDynamicMod = hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);\n                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;\n\n                if (!moduleDecl.isAnonInnerMod) {\n                    this.moduleName = moduleDecl.name.text;\n                }\n\n                this.recordSourceMappingStart(moduleDecl);\n                // prologue\n                if (isDynamicMod) {\n                    // create the new outfile for this module\n                    var modFilePath = stripQuotes(moduleDecl.name.text) + \".js\";\n\n                    this.setContainer(EmitContainer.DynamicModule); // discard the previous \'Module\' container\n\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        var dependencyList = \"[\\\"require\\\", \\\"exports\\\"\";\n                        var importList = \"require, exports\";\n                        var importStatement: ImportDecl = null;\n\n                        // all dependencies are quoted\n                        for (var i = 0; i < (<ModuleType>moduleDecl.mod).importedModules.length; i++) {\n                            importStatement = (<ModuleType>moduleDecl.mod).importedModules[i]\n\n                            // if the imported module is only used in a type position, do not add it as a requirement\n                            if (importStatement.id.sym != null &&\n                                !(<TypeSymbol>importStatement.id.sym).onlyReferencedAsTypeRef) {\n                                if (i <= (<ModuleType>moduleDecl.mod).importedModules.length - 1) {\n                                    dependencyList += \", \";\n                                    importList += \", \";\n                                }\n\n                                importList += \"__\" + importStatement.id.text + \"__\";\n                                dependencyList += importStatement.firstAliasedModToString();\n                            }\n                        }\n\n                        // emit any potential amd dependencies\n                        for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {\n                            dependencyList += \", \\\"\" + moduleDecl.amdDependencies[i] + \"\\\"\";\n                        }\n\n                        dependencyList += \"]\";\n\n                        this.writeLineToOutput(\"define(\" + dependencyList + \",\" + \" function(\" + importList + \") {\");\n                    }\n                    else { // Node\n\n                    }\n                }\n                else {\n\n                    if (!isExported) {\n                        this.writeLineToOutput(\"var \" + this.moduleName + \";\");\n                        this.emitIndent();\n                    }\n\n                    if (moduleDecl.isAnonInnerMod) {\n                        this.writeLineToOutput(\"(function() {\");\n                    }\n                    else {\n                        this.writeLineToOutput(\"(function(\" + this.moduleName + \") {\");\n                    }\n                }\n\n                // body - don\'t indent for Node\n                if (moduleGenTarget != ModuleGenTarget.Synchronous) {\n                    this.increaseIndent();\n                }\n                this.emitJavascriptList(moduleDecl.members, null, TokenID.SColon, true, false, false);\n                if (moduleGenTarget != ModuleGenTarget.Synchronous) {\n                    this.decreaseIndent();\n                }\n                this.emitIndent();\n\n                // epilogue\n                if (isDynamicMod) {\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        this.writeLineToOutput(\"})\");\n                    }\n                    else { // Node\n                    }\n                }\n                else {\n                    if (temp == EmitContainer.Prog && isExported) {\n                        this.writeLineToOutput(\"})(this.\" + this.moduleName + \"||(this.\" + this.moduleName + \"={}));\");\n                    }\n                    else if (!moduleDecl.isAnonInnerMod && (isExported || temp == EmitContainer.Prog)) {\n                        var dotMod = svModuleName != \"\" ? svModuleName + \".\" : svModuleName;\n                        this.writeLineToOutput(\"})(\" + dotMod + this.moduleName + \"||(\" + dotMod + this.moduleName + \"={}));\");\n                    }\n                    else if (!moduleDecl.isAnonInnerMod && (!isExported && temp != EmitContainer.Prog)) {\n                        this.writeLineToOutput(\"})(\" + this.moduleName + \"||(\" + this.moduleName + \"={}));\");\n                    }\n                    else {\n                        this.writeLineToOutput(\"})();\");\n                    }\n                    if (temp != EmitContainer.Prog && !moduleDecl.isAnonInnerMod && isExported) {\n                        this.emitIndent();\n                        this.writeLineToOutput(\"var \" + this.moduleName + \" = \" + svModuleName + \".\" + this.moduleName + \";\");\n                    }\n                }\n\n                this.recordSourceMappingEnd(moduleDecl);\n                this.setContainer(temp);\n                this.moduleName = svModuleName;\n                this.moduleDeclList.length--;\n            }\n        }\n\n        property emitIndex(operand1: AST, operand2: AST) {\n            var temp = this.setInObjectLiteral(false);\n            this.emitJavascript(operand1, TokenID.Tilde, false);\n            this.writeToOutput(\"[\");\n            this.emitJavascriptList(operand2, \", \", TokenID.Comma, false, false, false);\n            this.writeToOutput(\"]\");\n            this.setInObjectLiteral(temp);\n        }\n\n        property emitStringLiteral(text: string) {\n            // should preserve escape etc.\n            // TODO: simplify object literal simple name\n            this.writeToOutput(text);\n        }\n\n        property emitJavascriptFunction(funcDecl: FuncDecl) {\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isOverload) {\n                return;\n            }\n            var temp: number;\n            var tempFnc = this.thisFnc;\n            this.thisFnc = funcDecl;\n\n            if (funcDecl.isConstructor) {\n                temp = this.setContainer(EmitContainer.Constructor);\n            }\n            else {\n                temp = this.setContainer(EmitContainer.Function);\n            }\n\n            var bases: ASTList = null;\n            var hasSelfRef = false;\n            var funcName = funcDecl.getNameText();\n\n            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) &&\n                ((temp != EmitContainer.Constructor) ||\n                ((funcDecl.fncFlags & FncFlags.Method) == FncFlags.None))) {\n                var tempLit = this.setInObjectLiteral(false);\n                if (this.thisClassNode != null) {\n                    bases = this.thisClassNode.extendsList;\n                }\n                hasSelfRef = funcDecl.hasSelfReference();\n                this.recordSourceMappingStart(funcDecl);\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Exported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {\n                    this.writeToOutput(\"this.\" + funcName + \" = \");\n                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);\n                }\n                else {\n                    this.emitInnerFunction(funcDecl, (funcDecl.name != null && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);\n                }\n                this.recordSourceMappingEnd(funcDecl);\n                this.setInObjectLiteral(tempLit);\n            }\n            this.setContainer(temp);\n            this.thisFnc = tempFnc;\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Definition)) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Static)) {\n                    if (this.thisClassNode != null) {\n                        if (funcDecl.isAccessor()) {\n                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.text, false);\n                        }\n                        else {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(funcDecl);\n                            this.writeLineToOutput(this.thisClassNode.name.text + \".\" + funcName +\n                                          \" = \" + funcName + \";\");\n                            this.recordSourceMappingEnd(funcDecl);\n                        }\n                    }\n                }\n                else if ((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && hasFlag(funcDecl.fncFlags, FncFlags.Exported)) {\n                    this.emitIndent();\n                    var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : \"exports\";\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeLineToOutput(modName + \".\" + funcName +\n                                      \" = \" + funcName + \";\");\n                    this.recordSourceMappingEnd(funcDecl);\n                }\n            }\n        }\n\n        property emitAmbientVarDecl(varDecl: VarDecl) {\n            if (varDecl.init != null) {\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.text);\n                this.recordSourceMappingEnd(varDecl.id);\n                this.writeToOutput(\" = \");\n                this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                this.recordSourceMappingEnd(varDecl);\n                this.writeToOutput(\"; \");\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        property emitForVarList(varDeclList: ASTList) {\n            if (varDeclList != null) {\n                this.recordSourceMappingStart(varDeclList);\n                var len = varDeclList.members.length;\n                for (var i = 0; i < len; i++) {\n                    var varDecl = varDeclList.members[i];\n                    this.emitJavascriptVarDecl(varDecl, (i == 0) ? TokenID.FOR : TokenID.LParen);\n                    if (i < (len - 1)) {\n                        this.writeToOutput(\", \");\n                    }\n                }\n                this.recordSourceMappingEnd(varDeclList);\n            }\n        }\n\n        property emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {\n            if ((varDecl.varFlags & VarFlags.Ambient) == VarFlags.Ambient) {\n                this.emitAmbientVarDecl(varDecl);\n            }\n            else {\n                var sym = varDecl.sym;\n                var hasInitializer = (varDecl.init != null);\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                if ((sym != null) && (sym.isMember()) && (sym.container != null) &&\n                    (sym.container.kind() == SymbolKind.Type)) {\n                    var type = (<TypeSymbol>sym.container).type;\n                    if (type.isClass() && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {\n                        // class\n                        if (this.emitState.container != EmitContainer.Args) {\n                            if (hasFlag(sym.flags, SymbolFlags.Static)) {\n                                this.writeToOutput(sym.container.name + \".\");\n                            }\n                            else {\n                                this.writeToOutput(\"this.\");\n                            }\n                        }\n                    }\n                    else if (type.hasImplementation()) {\n                        // module\n                        if (!hasFlag(sym.flags, SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !hasFlag(sym.flags, SymbolFlags.Property))) {\n                            this.writeToOutput(\"var \");\n                        }\n                        else if (hasFlag(varDecl.varFlags, VarFlags.LocalStatic)) {\n                            this.writeToOutput(\".\");\n                        }\n                        else {\n                            if (this.emitState.container == EmitContainer.DynamicModule) {\n                                this.writeToOutput(\"exports.\");\n                            }\n                            else {\n                                this.writeToOutput(this.moduleName + \".\");\n                            }\n                        }\n                    }\n                    else {\n                        // function, constructor, method etc.\n                        if (tokenId != TokenID.LParen) {\n                            if (hasFlag(sym.flags, SymbolFlags.Exported) && sym.container == this.checker.gloMod) {\n                                this.writeToOutput(\"this.\");\n                            }\n                            else {\n                                this.writeToOutput(\"var \");\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (tokenId != TokenID.LParen) {\n                        this.writeToOutput(\"var \");\n                    }\n                }\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.text);\n                this.recordSourceMappingEnd(varDecl.id);\n                if (hasInitializer) {\n                    this.writeToOutputTrimmable(\" = \");\n                    this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                }\n                else if ((sym != null) && (sym.isMember()) &&\n                         (this.emitState.container == EmitContainer.Constructor)) {\n                    this.writeToOutputTrimmable(\" = \");\n                    this.writeToOutput(this.defaultValue(varDecl.type));\n                }\n                if ((tokenId != TokenID.FOR) && (tokenId != TokenID.LParen)) {\n                    this.writeToOutputTrimmable(\"; \");\n                }\n                this.recordSourceMappingEnd(varDecl);\n\n            }\n            this.emitParensAndCommentsInPlace(varDecl, false);\n        }\n\n        property declEnclosed(moduleDecl: ModuleDecl): bool {\n            if (moduleDecl == null) {\n                return true;\n            }\n            for (var i = 0, len = this.moduleDeclList.length; i < len; i++) {\n                if (this.moduleDeclList[i] == moduleDecl) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        property emitJavascriptName(name: Identifier, addThis: bool) {\n            var sym = name.sym;\n            this.emitParensAndCommentsInPlace(name, true);\n            this.recordSourceMappingStart(name);\n            if (!name.isMissing()) {\n                if (addThis && (this.emitState.container != EmitContainer.Args) && (sym != null)) {\n                    // TODO: flag global module with marker other than string name\n                    if ((sym.container != null) && (sym.container.name != globalId)) {\n                        if (hasFlag(sym.flags, SymbolFlags.Static) && (hasFlag(sym.flags, SymbolFlags.Property))) {\n                            if (sym.declModule != null && hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                this.writeToOutput(\"exports.\");\n                            }\n                            else {\n                                this.writeToOutput(sym.container.name + \".\");\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Field) {\n                            var fieldSym = <FieldSymbol>sym;\n                            if (hasFlag(fieldSym.flags, SymbolFlags.ModuleMember)) {\n                                if ((sym.container != this.checker.gloMod) && ((hasFlag(sym.flags, SymbolFlags.Property)) || hasFlag(sym.flags, SymbolFlags.Exported))) {\n                                    if (sym.declModule.isAnonInnerMod) {\n                                        this.writeToOutput(sym.declModule.anonParentMod.name.text + \".\");\n                                    }\n                                    else {\n                                        if (hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                            this.writeToOutput(\"exports.\");\n                                        }\n                                        else {\n                                            this.writeToOutput(sym.container.name + \".\");\n                                        }\n                                    }\n                                }\n                            }\n                            else {\n                                if (sym.isInstanceProperty()) {\n                                    if ((this.thisFnc != null) && (!this.thisFnc.isMethod()) &&\n                                        (!this.thisFnc.isConstructor)) {\n                                        this.writeToOutput(\"_self.\");\n                                    }\n                                    else {\n                                        this.writeToOutput(\"this.\");\n                                    }\n                                }\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Type) {\n                            if (sym.isInstanceProperty()) {\n                                var typeSym = <TypeSymbol>sym;\n                                var type = typeSym.type;\n                                if ((type.call != null) && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {\n                                    if ((this.thisFnc != null) && (!this.thisFnc.isMethod()) &&\n                                        (!this.thisFnc.isConstructor)) {\n                                        this.writeToOutput(\"_self.\");\n                                    }\n                                    else {\n                                        this.writeToOutput(\"this.\");\n                                    }\n                                }\n                            }\n                            else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {\n                                this.writeToOutput(sym.container.name + \".\")\n                            }\n                        }\n                    }\n                    else if (sym.container == this.checker.gloMod &&\n                                hasFlag(sym.flags, SymbolFlags.Exported) &&\n                                !((sym.isType() || sym.isMember()) &&\n                                    sym.declModule != null &&\n                                    hasFlag(sym.declModule.modFlags, ModuleFlags.Ambient)) &&\n                                this.emitState.container == EmitContainer.Prog &&\n                                sym.declAST.nodeType != NodeType.FuncDecl) {\n                        this.writeToOutput(\"this.\");\n                    }\n                }\n\n                // If it\'s a dynamic module, we need to print the \"require\" invocation\n                if (sym != null &&\n                    sym.declAST != null &&\n                    sym.declAST.nodeType == NodeType.Module &&\n                    (hasFlag((<ModuleDecl>sym.declAST).modFlags, ModuleFlags.IsDynamic))) {\n                    var moduleDecl: ModuleDecl = <ModuleDecl>sym.declAST;\n\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                        this.writeLineToOutput(\"__\" + this.modAliasId + \"__;\");\n                    }\n                    else {\n                        var modPath = name.text;//(<ModuleDecl>moduleDecl.mod.symbol.declAST).name.text;\n                        var isAmbient = moduleDecl.mod.symbol.declAST != null && hasFlag((<ModuleDecl>moduleDecl.mod.symbol.declAST).modFlags, ModuleFlags.Ambient);\n                        modPath = isAmbient ? modPath : this.firstModAlias != null ? this.firstModAlias : quoteBaseName(modPath);\n                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr(\"./\" + stripQuotes(modPath)) : modPath);\n                        this.writeToOutput(\"require(\" + modPath + \")\");\n                    }\n                }\n                else {\n                    this.writeToOutput(name.text);\n                }\n            }\n            this.recordSourceMappingEnd(name);\n            this.emitParensAndCommentsInPlace(name, false);\n        }\n\n        property emitJavascriptStatements(stmts: AST, emitEmptyBod: bool, newlineAfterBlock: bool) {\n            if (stmts != null) {\n                if (stmts.nodeType != NodeType.Block) {\n                    this.recordSourceMappingStart(stmts);\n                    this.writeLineToOutput(\" {\");\n                    this.increaseIndent();\n                    this.emitJavascriptList(stmts, null, TokenID.SColon, true, false, false);\n                    this.writeLineToOutput(\"\");\n                    this.decreaseIndent();\n                    this.emitIndent();\n                    this.writeToOutput(\"}\");\n                    this.recordSourceMappingEnd(stmts);\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.SColon, true);\n                }\n            }\n            else if (emitEmptyBod) {\n                this.writeToOutput(\"{ }\");\n            }\n        }\n\n        property emitBareJavascriptStatements(stmts: AST, emitES6ClassPropertiesAfterSuperCall: bool) {\n            // just the statements without enclosing curly braces\n            if (stmts.nodeType != NodeType.Block) {\n                if (stmts.nodeType == NodeType.List) {\n                    var stmtList = <ASTList>stmts;\n                    if ((stmtList.members.length == 2) &&\n                        (stmtList.members[0].nodeType == NodeType.Block) &&\n                        (stmtList.members[1].nodeType == NodeType.EndCode)) {\n                        this.emitJavascript(stmtList.members[0], TokenID.SColon, true);\n                        this.writeLineToOutput(\"\");\n                    }\n                    else {\n                        this.emitJavascriptList(stmts, null, TokenID.SColon, true, false, emitES6ClassPropertiesAfterSuperCall);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.SColon, true);\n                }\n            }\n            else {\n                this.emitJavascript(stmts, TokenID.SColon, true);\n            }\n        }\n\n        property recordSourceMappingStart(ast: AST) {\n            if ((this.sourceMapper != null) && (ast != null)) {\n                var lineCol = { line: -1, col: -1 };\n                var sourceMapping = new SourceMapping(ast);\n                sourceMapping.emittedStartColumn = this.emitState.column;\n                sourceMapping.emittedStartLine = this.emitState.line;\n                // REVIEW: check time consumed by this binary search (about two per leaf statement)\n                getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                sourceMapping.sourceStartColumn = lineCol.col;\n                sourceMapping.sourceStartLine = lineCol.line;\n                getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);\n                sourceMapping.sourceEndColumn = lineCol.col;\n                sourceMapping.sourceEndLine = lineCol.line;\n                sourceMapping.parent = this.sourceMapper.currentMapping;\n                this.sourceMapper.currentMapping = this.sourceMapper.sourceMappings.length;\n                this.sourceMapper.sourceMappings.push(sourceMapping);\n                if (sourceMapping.parent >= 0) {\n                    var parentMapping = this.sourceMapper.sourceMappings[sourceMapping.parent];\n                    if (parentMapping.firstChild == -1) {\n                        parentMapping.firstChild = this.sourceMapper.currentMapping;\n                    }\n                }\n            }\n        }\n\n        property recordSourceMappingEnd(ast: AST) {\n            if ((this.sourceMapper != null) && (ast != null)) {\n                var currentMappingIndex = this.sourceMapper.currentMapping;\n                var sourceMapping = this.sourceMapper.sourceMappings[currentMappingIndex];\n                //if (sourceMapping.__debugAST !== ast) {\n                //    throw Error(\"Unbalanced AST start and stop record found\");\n                //}\n                sourceMapping.emittedEndColumn = this.emitState.column;\n                sourceMapping.emittedEndLine = this.emitState.line;\n                this.sourceMapper.currentMapping = sourceMapping.parent;\n            }\n        }\n\n        property emitSourceMappings() {\n            SourceMapper.EmitSourceMapping(this.allSourceMappers);\n        }\n\n        property emitJavascriptList(ast: AST, delimiter: string, tokenId: TokenID, startLine: bool, onlyStatics: bool, emitES6ClassPropertiesAfterSuperCall: bool) {\n            if (ast == null) {\n                return;\n            }\n            else if (ast.nodeType != NodeType.List) {\n                this.emitJavascript(ast, tokenId, startLine);\n            }\n            else {\n                this.emitParensAndCommentsInPlace(ast, true);\n                var list = <ASTList>ast;\n                var len = list.members.length;\n                for (var i = 0; i < len; i++) {\n\n                    // In some circumstances, ES6 class property initializers must be emitted immediately after the \'super\' constructor\n                    // call which, in these cases, must be the first statement in the constructor body\n                    if (i == 1 && emitES6ClassPropertiesAfterSuperCall) {\n\n                        // emit any parameter properties first\n                        var constructorDecl = (<ES6ClassDecl>this.thisClassNode).constructorDecl;\n\n                        if (constructorDecl && constructorDecl.args != null) {\n                            var argsLen = constructorDecl.args.members.length;\n                            for (var iArg = 0; iArg < argsLen; iArg++) {\n                                var arg = <BoundDecl>constructorDecl.args.members[iArg];\n                                if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(arg);\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput(\"this.\" + arg.id.text);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeToOutput(\" = \");\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput(arg.id.text);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeLineToOutput(\";\");\n                                    this.recordSourceMappingEnd(arg);\n                                }\n                            }\n                        }\n\n                        var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                        for (var iMember = 0; iMember < nProps; iMember++) {\n                            if ((<ASTList>this.thisClassNode.members).members[iMember].nodeType == NodeType.VarDecl) {\n                                var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[iMember];\n                                if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                    this.writeLineToOutput(\"\");\n                                    this.emitIndent();\n                                    this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                }\n                            }\n                        }\n                        this.writeLineToOutput(\"\");\n                    }\n\n                    var emitNode = list.members[i];\n\n                    var isStaticDecl =\n                                (emitNode.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>emitNode).fncFlags, FncFlags.Static)) ||\n                                (emitNode.nodeType == NodeType.VarDecl && hasFlag((<VarDecl>emitNode).varFlags, VarFlags.Static))\n\n                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {\n                        continue;\n                    }\n                    this.emitJavascript(emitNode, tokenId, startLine);\n\n                    if ((delimiter != null) && (i < (len - 1))) {\n                        if (startLine) {\n                            this.writeLineToOutput(delimiter);\n                        }\n                        else {\n                            this.writeToOutput(delimiter);\n                        }\n                    }\n                    else if (startLine &&\n                             (emitNode.nodeType != NodeType.Interface) &&\n                             (!((emitNode.nodeType == NodeType.VarDecl) &&\n                                ((((<VarDecl>emitNode).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                                (((<VarDecl>emitNode).init) == null))) &&\n                             (emitNode.nodeType != NodeType.EndCode) &&\n                             (emitNode.nodeType != NodeType.FuncDecl)) {\n                        this.writeLineToOutput(\"\");\n                    }\n                }\n                this.emitParensAndCommentsInPlace(ast, false);\n            }\n        }\n\n        // tokenId is the id the preceding token\n        property emitJavascript(ast: AST, tokenId: TokenID, startLine: bool) {\n            if (ast == null) {\n                return;\n            }\n\n\n            var parenthesize = false;\n            // REVIEW: simplify rules for indenting\n            if (startLine && (this.emitState.indentAmt > 0) && (ast.nodeType != NodeType.List) &&\n                (ast.nodeType != NodeType.Block)) {\n                if ((ast.nodeType != NodeType.Interface) &&\n                    (!((ast.nodeType == NodeType.VarDecl) &&\n                       ((((<VarDecl>ast).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                       (((<VarDecl>ast).init) == null))) &&\n                    (ast.nodeType != NodeType.EndCode) &&\n                    ((ast.nodeType != NodeType.FuncDecl) ||\n                     (this.emitState.container != EmitContainer.Constructor))) {\n                    this.emitIndent();\n                }\n            }\n\n            var binopNodeTokenId = nodeTypeToTokTable[ast.nodeType];\n            if (binopNodeTokenId != undefined) {\n                var tokenInfo = tokenTable[tokenId];\n                var prec = tokenInfo.unopPrecedence;\n                if (prec != OperatorPrecedence.No) {\n                    parenthesize = !ast.isParenthesized && ast.nodeType != NodeType.Dot;\n                }\n                else {\n                    prec = tokenInfo.binopPrecedence;\n                    var binopTokInfo = tokenTable[binopNodeTokenId];\n                    parenthesize = !ast.isParenthesized && prec > binopTokInfo.binopPrecedence;\n                }\n            }\n\n            if (parenthesize) {\n                this.writeToOutput(\"(\");\n            }\n\n            ast.emit(this, tokenId, startLine);\n\n            if (parenthesize) {\n                this.writeToOutput(\")\");\n            }\n\n            if ((tokenId == TokenID.SColon) && (ast.nodeType < NodeType.GeneralNode)) {\n                this.writeToOutput(\"; \");\n            }\n        }\n\n        property emitPropertyAccessor(funcDecl: FuncDecl, className: string, isProto: bool) {\n            if (!(<FieldSymbol>funcDecl.accessorSymbol).hasBeenEmitted) {\n                var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n                this.recordSourceMappingStart(funcDecl);\n                this.writeLineToOutput(\"Object.defineProperty(\" + className + (isProto ? \".prototype,\" : \",\"));\n                this.increaseIndent();\n\n                this.emitIndent();\n                this.writeLineToOutput(\"\\\"\" + funcDecl.name.text + \"\\\"\" + \",\");\n                this.emitIndent();\n\n                if (accessorSymbol.getter != null) {\n                    var getter: FuncDecl = <FuncDecl>accessorSymbol.getter.declAST;\n\n                    this.writeLineToOutput(\"{ get: \");\n                    this.increaseIndent();\n                    this.emitIndent();\n                    this.emitInnerFunction(getter, false, isProto, null, funcDecl.hasSelfReference(), null);\n                    this.writeLineToOutput(\",\");\n                    this.decreaseIndent();\n                    this.emitIndent();\n                }\n\n                if (accessorSymbol.setter != null) {\n                    var setter: FuncDecl = <FuncDecl>accessorSymbol.setter.declAST;\n\n                    this.writeLineToOutput(\" set: \");\n                    this.increaseIndent();\n                    this.emitIndent();\n                    this.emitInnerFunction(setter, false, isProto, null, funcDecl.hasSelfReference(), null);\n                    this.writeLineToOutput(\",\");\n                    this.decreaseIndent();\n                    this.emitIndent();\n                }\n\n                this.writeLineToOutput(\"enumerable: true,\");\n                this.emitIndent();\n                this.writeLineToOutput(\"configurable: true });\");\n\n                this.recordSourceMappingEnd(funcDecl);\n                this.decreaseIndent();\n\n                accessorSymbol.hasBeenEmitted = true;\n            }\n        }\n\n        property emitPrototypeMember(member: AST, className: string) {\n            if (member.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>member;\n                if (funcDecl.isAccessor()) {\n                    this.emitPropertyAccessor(funcDecl, className, true);\n                }\n                else {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeToOutput(className + \".prototype.\" + funcDecl.getNameText() + \" = \");\n                    this.emitInnerFunction(funcDecl, false, true, null, funcDecl.hasSelfReference(), null);\n                    this.recordSourceMappingEnd(funcDecl);\n                    this.writeLineToOutput(\";\");\n                }\n            }\n            else if (member.nodeType == NodeType.VarDecl) {\n                var varDecl = <VarDecl>member;\n\n                if (varDecl.init != null) {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(varDecl);\n                    this.recordSourceMappingStart(varDecl.id);\n                    this.writeToOutput(className + \".prototype.\" + varDecl.id.text);\n                    this.recordSourceMappingEnd(varDecl.id);\n                    this.writeToOutput(\" = \");\n                    this.emitJavascript(varDecl.init, TokenID.Asg, false);\n                    this.recordSourceMappingEnd(varDecl);\n                    this.writeLineToOutput(\";\");\n                }\n            }\n        }\n\n        property emitAddBaseMethods(className: string, base: Type, classDecl: NamedType): void {\n            if (base.members != null) {\n                var baseSymbol = base.symbol;\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                base.members.allMembers.map(function(key, s, c) {\n                    var sym = <Symbol>s;\n                    if ((sym.kind() == SymbolKind.Type) &&\n                        ((<TypeSymbol>sym).type.call != null)) {\n                        this.recordSourceMappingStart(sym.declAST);\n                        this.writeLineToOutput(className + \".prototype.\" + sym.name + \" = \" +\n                                          baseName + \".prototype.\" + sym.name + \";\");\n                        this.recordSourceMappingEnd(sym.declAST);\n                    }\n                }, null);\n            }\n            if (base.extendsList != null) {\n                for (var i = 0, len = base.extendsList.length; i < len; i++) {\n                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);\n                }\n            }\n        }\n\n        property emitJavascriptES6Class(classDecl: ES6ClassDecl) {\n            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient)) {\n                var svClassNode = this.thisClassNode;\n                var i = 0;\n                this.thisClassNode = classDecl;\n                var className = classDecl.name.text;\n                this.emitParensAndCommentsInPlace(classDecl, true);\n\n                this.recordSourceMappingStart(classDecl);\n                if (hasFlag(classDecl.varFlags, VarFlags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {\n                    this.writeLineToOutput(\"this.\" + className + \" = (function () {\");\n                }\n                else {\n                    this.writeLineToOutput(\"var \" + className + \" = (function () {\");\n                }\n                this.increaseIndent();\n\n                var temp = this.setContainer(EmitContainer.ES6Class);\n\n                var _class: Type = classDecl.type;\n                var instanceType = _class.instanceType;\n                var baseClass = instanceType ? instanceType.baseClass() : null;\n                var baseNameDecl: AST = null;\n                var baseName: AST = null;\n\n                if (baseClass != null) {\n                    baseNameDecl = classDecl.extendsList.members[0];\n                    baseName = baseNameDecl.nodeType == NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;\n                    this.emitIndent();\n                    this.writeToOutput(\"_inheritsFrom(\" + className + \", \");// + baseName + \");\");\n                    this.emitJavascript(baseName, TokenID.Tilde, false);\n                    this.writeLineToOutput(\");\");\n                    var elen = instanceType.extendsList.length;\n                    if (elen > 1) {\n                        // REVIEW: mixins\n                        for (var i = 1; i < elen; i++) {\n                            var base = instanceType.extendsList[i];\n                            this.emitAddBaseMethods(className, base, classDecl);\n                        }\n                    }\n                }\n\n                this.emitIndent();\n\n                var constrDecl = classDecl.constructorDecl;\n\n                // output constructor\n                if (constrDecl) {\n                    // declared constructor\n                    this.emitJavascript(classDecl.constructorDecl, TokenID.LParen, false);\n                }\n                else {\n                    var wroteProps = 0;\n\n                    this.recordSourceMappingStart(classDecl);\n                    // default constructor\n                    this.increaseIndent();\n                    this.writeToOutput(\"function \" + classDecl.name.text + \"() {\");\n                    if (baseClass) {\n                        this.writeLineToOutput(\"\");\n                        this.emitIndent();\n                        this.emitJavascript(baseName, TokenID.Tilde, false);\n                        this.writeLineToOutput(\".apply(this, arguments);\");\n                        wroteProps++;\n                    }\n\n                    var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                    // output initialized properties\n                    for (var i = 0; i < nProps; i++) {\n                        if ((<ASTList>this.thisClassNode.members).members[i].nodeType == NodeType.VarDecl) {\n                            var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];\n                            if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                this.writeLineToOutput(\"\");\n                                this.emitIndent();\n                                this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                wroteProps++;\n                            }\n                        }\n                    }\n                    if (wroteProps) {\n                        this.writeLineToOutput(\"\");\n                        this.decreaseIndent();\n                        this.emitIndent();\n                    }\n                    else {\n                        this.decreaseIndent();\n                    }\n                    this.writeLineToOutput(\"}\");\n\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                var membersLen = classDecl.definitionMembers.members.length;\n                for (var j = 0; j < membersLen; j++) {\n\n                    var memberDecl: AST = classDecl.definitionMembers.members[j];\n\n                    if (memberDecl.nodeType == NodeType.FuncDecl) {\n                        var fn = <FuncDecl>memberDecl;\n\n                        if (hasFlag(fn.fncFlags, FncFlags.Method) && !fn.isSignature()) {\n                            if (!hasFlag(fn.fncFlags, FncFlags.Static)) {\n                                this.emitPrototypeMember(fn, className);\n                            }\n                            else { // static functions\n                                if (fn.isAccessor()) {\n                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.text, false);\n                                }\n                                else {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(fn)\n                                    this.writeToOutput(classDecl.name.text + \".\" + fn.name.text + \" = \");\n                                    this.emitInnerFunction(fn, (fn.name != null && !fn.name.isMissing()), false,\n                                            null, fn.hasSelfReference(), null);\n                                    this.recordSourceMappingEnd(fn)\n                                }\n                            }\n                        }\n                    }\n                    else if (memberDecl.nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>memberDecl;\n                        if (hasFlag(varDecl.varFlags, VarFlags.Static)) {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(varDecl);\n                            this.writeToOutput(classDecl.name.text + \".\" + varDecl.id.text + \" = \");\n                            if (varDecl.init != null) {\n                                this.emitJavascript(varDecl.init, TokenID.Asg, false);\n                                this.writeLineToOutput(\";\");\n                            }\n                            else {\n                                // REVIEW: We should not be initializing uninitialized member declarations, here and elsewhere\n                                this.writeLineToOutput(this.defaultValue(varDecl.type) + \";\");\n                            }\n                            this.recordSourceMappingEnd(varDecl);\n                        }\n                    }\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl);\n                this.writeLineToOutput(\"return \" + className + \";\");\n                this.recordSourceMappingEnd(classDecl);\n                this.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput(\"})();\");\n\n                if ((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {\n                    this.emitIndent();\n                    var modName = temp == EmitContainer.Module ? this.moduleName : \"exports\";\n                    this.recordSourceMappingStart(classDecl);\n                    this.writeLineToOutput(modName + \".\" + className + \" = \" + className + \";\");\n                    this.recordSourceMappingEnd(classDecl);\n                }\n                this.emitIndent();\n                this.recordSourceMappingEnd(classDecl);\n                this.emitParensAndCommentsInPlace(classDecl, false);\n                this.setContainer(temp);\n                this.thisClassNode = svClassNode;\n            }\n        }\n\n        property emitJavascriptClass(classDecl: TypeDecl) {\n            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient) && !classDecl.isOverload) {\n                var svClassNode = this.thisClassNode;\n                var i = 0;\n                this.thisClassNode = classDecl;\n                var className = classDecl.name.text;\n                this.emitParensAndCommentsInPlace(classDecl, true);\n\n                this.recordSourceMappingStart(classDecl);\n                if (hasFlag(classDecl.varFlags, VarFlags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {\n                    this.writeLineToOutput(\"this.\" + className + \" = (function () {\");\n                }\n                else {\n                    this.writeLineToOutput(\"var \" + className + \" = (function () {\");\n                }\n                this.increaseIndent();\n\n                var temp = this.setContainer(EmitContainer.OldClass);\n\n                var _class: Type = classDecl.type;\n                var instanceType = _class.instanceType;\n                var baseClass = instanceType ? instanceType.baseClass() : null;\n\n                if (baseClass != null) {\n                    var baseNameDecl = classDecl.extendsList.members[0];\n                    var baseName: AST = baseNameDecl.nodeType == NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;\n                    this.emitIndent();\n                    this.writeToOutput(\"_inheritsFrom(\" + className + \", \");// + baseName + \");\");\n                    this.emitJavascript(baseName, TokenID.Tilde, false);\n                    this.writeLineToOutput(\");\");\n                    var elen = instanceType.extendsList.length;\n                    if (elen > 1) {\n                        // REVIEW: mixins\n                        for (var i = 1; i < elen; i++) {\n                            var base = instanceType.extendsList[i];\n                            this.emitAddBaseMethods(className, base, classDecl);\n                        }\n                    }\n                }\n                this.emitIndent();\n                // emit constructor body\n                this.emitJavascript(classDecl.members, TokenID.LParen, false);\n\n                // emit static members\n                this.emitJavascriptList((<FuncDecl>classDecl.members).bod, null, TokenID.SColon, true, true, false);\n\n                var constrDecl = <FuncDecl>classDecl.members;\n                var fns: ASTList = constrDecl.scopes;\n                var fnsLen = fns.members.length;\n                for (var j = 0; j < fnsLen; j++) {\n                    var fn: FuncDecl = fns.members[j];\n                    if (hasFlag(fn.fncFlags, FncFlags.Method) &&\n                        (!hasFlag(fn.fncFlags, FncFlags.Static)) &&\n                        (!fn.isSignature())) {\n                        this.emitPrototypeMember(fn, className);\n                    }\n                }\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl);\n                this.writeLineToOutput(\"return \" + className + \";\");\n                this.recordSourceMappingEnd(classDecl);\n                this.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput(\"})();\");\n\n                if ((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {\n                    this.emitIndent();\n                    var modName = temp == EmitContainer.Module ? this.moduleName : \"exports\";\n                    this.recordSourceMappingStart(classDecl);\n                    this.writeLineToOutput(modName + \".\" + className + \" = \" + className + \";\");\n                    this.recordSourceMappingEnd(classDecl);\n                }\n                this.emitIndent();\n                this.recordSourceMappingEnd(classDecl);\n                this.emitParensAndCommentsInPlace(classDecl, false);\n                this.setContainer(temp);\n                this.thisClassNode = svClassNode;\n            }\n        }\n\n\n        property emitPrologue(reqInherits: bool) {\n            // TODO: emit only if inheritence used in unit\n            if (!this.prologueEmitted) {\n                if (reqInherits) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput(\"if (!(this._inheritsFrom)) {\");\n                    this.writeLineToOutput(\"    this._inheritsFrom=function(childCtor, parentCtor) {\");\n                    this.writeLineToOutput(\"        function Beget() { this.constructor = childCtor; }\");\n                    this.writeLineToOutput(\"        childCtor._super = parentCtor.prototype;\");\n                    this.writeLineToOutput(\"        Beget.prototype = parentCtor.prototype;\");\n                    this.writeLineToOutput(\"        childCtor.prototype = new Beget();\");\n                    this.writeLineToOutput(\"    }\");\n                    this.writeLineToOutput(\"}\");\n                    this.writeLineToOutput(\"var _inheritsFrom = this._inheritsFrom;\");\n                }\n                /*\n                this.writeLineToOutput(\"if (!(this.mixin)) {\");\n                this.writeLineToOutput(\"    this.mixin=function(base,extra) {\");\n                this.writeLineToOutput(\"        for (var f in extra.prototype) {\");\n                this.writeLineToOutput(\"            base.prototype[f]=extra.prototype[f];\");\n                this.writeLineToOutput(\"        }\");    \n                this.writeLineToOutput(\"    }\");    \n                this.writeLineToOutput(\"}\");    \n                this.writeLineToOutput(\"function _toString(x) { return x.toString(); }\");\n                */\n            }\n        }\n\n        property emitSuperReference() {\n            if (this.thisClassNode != null) {\n                this.writeToOutput(this.thisClassNode.name.text + \"._super\");\n            }\n            else {\n                this.writeToOutput(\"this._super\");\n            }\n        }\n\n        property emitSuperCall(callEx: CallExpression): bool {\n            if (callEx.target.nodeType == NodeType.Dot) {\n                var dotNode = <BinaryExpression>callEx.target;\n                if (dotNode.operand1.nodeType == NodeType.Super) {\n                    this.emitJavascript(dotNode, TokenID.LParen, false);\n                    this.writeToOutput(\".call(this\");\n                    if (callEx.args != null) {\n                        this.writeToOutput(\", \");\n                        this.emitJavascriptList(callEx.args, \", \", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(\")\");\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n}\n\n\nmodule Tools {\n    export interface ILineCol {\n        line: number;\n        col: number;\n    }\n\n    export oldclass ErrorReporter(property outfile: ITextWriter) {\n        property parser: Parser = null;\n        property checker: TypeChecker = null;\n        property lineCol = { line: 0, col: 0 };\n        property emitAsComments = true;\n\n        property setErrOut(outerr) {\n            this.outfile = outerr;\n            this.emitAsComments = false;\n        }\n\n        property emitPrefix() {\n            if (this.emitAsComments) {\n                this.outfile.Write(\"// \");\n            }\n            this.outfile.Write(this.checker.locationInfo.filename + \"(\" + this.lineCol.line + \",\" + this.lineCol.col + \"): \");\n        }\n\n        property writePrefix(ast: AST): void {\n            if (ast != null) {\n                this.setError(ast);\n            }\n            else {\n                this.lineCol.line = -1;\n                this.lineCol.col = -1;\n            }\n            this.emitPrefix();\n        }\n\n        property writePrefixFromSym(symbol: Symbol): void {\n            if ((symbol != null) && (this.checker.locationInfo.lineMap != null)) {\n                getSourceLineColFromMap(this.lineCol, symbol.location,\n                                        this.checker.locationInfo.lineMap);\n            }\n            else {\n                this.lineCol.line = -1;\n                this.lineCol.col = -1;\n            }\n            this.emitPrefix();\n        }\n\n        property setError(ast: AST) {\n            if (ast != null) {\n                ast.flags |= ASTFlags.Error;\n                if (this.checker.locationInfo.lineMap != null) {\n                    getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                }\n            }\n        }\n\n        property reportError(ast: AST, message: string) {\n            var len = (ast.limChar - ast.minChar);\n            if (this.parser.errorRecovery && this.parser.errorCallback != null) {\n                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefix(ast);\n                this.outfile.WriteLine(message); // Right after the semi-colon\n            }\n        }\n\n        property reportErrorFromSym(symbol: Symbol, message: string) {\n            if (this.parser.errorRecovery && this.parser.errorCallback != null) {\n                this.parser.errorCallback(symbol.location, 1, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefixFromSym(symbol);\n                this.outfile.WriteLine(message);\n            }\n        }\n\n        property interfaceDeclNotImpl(t1: Type, t2: Type) {\n            this.reportErrorFromSym(t2.symbol, \"Class \" + t2.getTypeName() +\n                              \" declares interface \" + t1.getTypeName() +\n                              \" but does not implement it\");\n        }\n\n        property duplicateIdentifier(ast: AST, name: string) {\n            this.reportError(ast, \"Duplicate identifier \" + name);\n        }\n\n        property showRef(ast: AST, text: string, symbol: Symbol) {\n            var defLineCol = { line: -1, col: -1 };\n            // TODO: multiple def locations\n            this.parser.getSourceLineCol(defLineCol, symbol.location);\n            this.reportError(ast, \"symbol \" + text + \" defined at (\" + defLineCol.line + \",\" +\n                              defLineCol.col + \")\");\n        }\n\n        property unresolvedSymbol(ast: AST, name: string) {\n            this.reportError(ast, \"Unresolved symbol \" + name);\n        }\n\n        property typeExpected(symbol: Symbol) {\n            this.reportErrorFromSym(symbol, \"Expected \" + symbol.name + \" to be a type\");\n        }\n\n        property symbolDoesNotReferToAValue(ast: AST, name: string): void {\n            this.reportError(ast, \"Symbol \" + name + \" does not refer to a value\");\n        }\n\n        property styleError(ast: AST, msg: string): void {\n            this.reportError(ast, \"STYLE: \" + msg);\n        }\n\n        property simpleError(ast: AST, msg: string): void {\n            this.reportError(ast, msg);\n        }\n\n        property simpleErrorFromSym(sym: Symbol, msg: string): void {\n            this.reportErrorFromSym(sym, msg);\n        }\n\n        property invalidThisReference(ast: AST) {\n            this.simpleError(ast, \"Invalid this reference\");\n        }\n\n        property invalidSuperReference(ast: AST) {\n            this.simpleError(ast, \"Invalid super reference\");\n        }\n\n        property valueCannotBeModified(ast: AST) {\n            this.simpleError(ast, \"Illegal lhs of assignment expression\");\n        }\n\n        property invalidCall(ast: AST, nodeType: number): void {\n            var opString = (nodeType == NodeType.Call) ? \"call\" : \"new\";\n            var catString = (nodeType == NodeType.Call) ? \"function\" : \"class\";\n            this.reportError(ast, \"Target of \" + opString + \" is not var or \" + catString);\n        }\n\n        property indexLHS(ast: AST): void {\n            this.simpleError(ast, \"Illegal lhs of index expression\");\n        }\n\n        property incompatibleTypes(ast: AST, t1: Type, t2: Type, op: string, scope: SymbolScope) {\n            if (t1 == null) {\n                t1 = this.checker.anyType;\n            }\n            if (t2 == null) {\n                t2 = this.checker.anyType;\n            }\n            // TODO: re-implement reason generation\n            var reason = \"\";\n            if (op != null) {\n                this.reportError(ast, op + \" can not be applied to types \" + t1.getScopedTypeName(scope) +\n                                  \" and \" + t2.getScopedTypeName(scope) + \" \" + reason);\n            }\n            else {\n                this.reportError(ast, \"Can not convert \" + t1.getScopedTypeName(scope) +\n                                  \" to \" + t2.getScopedTypeName(scope) + \" \" + reason);\n            }\n        }\n\n        property qMarkIncompatibleTypes(ast: AST, t1: Type, t2: Type, scope: SymbolScope) {\n            this.reportError(ast, \"Types \" + t1.getScopedTypeName(scope) + \" and \" + t2.getScopedTypeName(scope) +\n                              \" are incompatible in ?: operator\");\n        }\n\n        property valuesCannotBeCompared(ast: AST, t1: Type, t2: Type) {\n            this.reportError(ast, \"Values of type \" + t1.getTypeName() + \" and \" + t2.getTypeName() +\n                              \" can not be compared\");\n        }\n\n        property expectedClassOrInterface(ast: AST): void {\n            this.simpleError(ast, \"Expected var, class, interface, or module\");\n        }\n\n        property unaryOperatorTypeError(ast: AST, op: string, type: Type) {\n            this.reportError(ast, \"Can not apply \" + op + \" to value of type \" + type.getTypeName());\n        }\n    }\n}\n\n\nmodule Tools {\n\n    export function hasFlag(val: number, flag: number) {\n        return (val & flag) != 0;\n    }\n\n    export enum ErrorRecoverySet {\n        None = 0,\n        Comma = 1, // Comma\n        SColon = 1 << 1, // SColon\n        Asg = 1 << 2, // Asg\n        BinOp = 1 << 3, // Lsh, Rsh, Rs2, Le, Ge, INSTANCEOF, EQ, NE, Eqv, NEqv, LogAnd, LogOr, AsgMul, AsgDiv\n        // AsgMod, AsgAdd, AsgSub, AsgLsh, AsgRsh, AsgRs2, AsgAnd, AsgXor, AsgOr, QMark, Mult, Div, \n        // Pct, GT, LT, And, Xor, Or\n        RBrack = 1 << 4, // RBrack\n        RCurly = 1 << 5, // RCurly\n        RParen = 1 << 6, // RParen\n        Dot = 1 << 7, // Dot\n        Colon = 1 << 8, // Colon\n        PrimType = 1 << 9, // number, string, bool\n        AddOp = 1 << 10, // Add, Sub\n        LCurly = 1 << 11, // LCurly\n        PreOp = 1 << 12, // Tilde, Bang, Inc, Dec\n        RegExp = 1 << 13, // RegExp\n        LParen = 1 << 14, // LParen\n        LBrack = 1 << 15, // LBrack\n        Scope = 1 << 16, // Scope\n        In = 1 << 17, // IN\n        SCase = 1 << 18, // CASE, DEFAULT\n        Else = 1 << 19, // ELSE\n        Catch = 1 << 20, // CATCH, FINALLY\n        Var = 1 << 21, // \n        Stmt = 1 << 22, // BREAK, RETURN, THROW, DEBUGGER, FOR, SWITCH, DO, IF, TRY, WITH\n        While = 1 << 23, // WHILE\n        ID = 1 << 24, // ID\n        Prefix = 1 << 25, // VOID, DELETE, TYPEOF, AWAIT\n        Literal = 1 << 26, // IntCon, FltCon, StrCon\n        RLit = 1 << 27, // THIS, TRUE, FALSE, NULL\n        Func = 1 << 28, // FUNCTION\n        EOF = 1 << 29, // EOF\n        StradaS = 1 << 30, // PROPERTY, PRIVATE, STATIC, INTERFACE, CLASS, MODULE, EXPORT, IMPORT\n        ExprStart = SColon | AddOp | LCurly | PreOp | RegExp | LParen | LBrack | ID | Prefix | RLit | Func | Literal,\n        StmtStart = ExprStart | SColon | Var | Stmt | While | StradaS,\n        Postfix = Dot | LParen | LBrack,\n    }\n\n    export enum AllowedElements {\n        None = 0,\n        Statements = 1,\n        FunctionDecls = 1 << 1,\n        ModuleDecls = 1 << 2,\n        ClassDecls = 1 << 3,\n        InterfaceDecls = 1 << 4,\n        TypedFuncDecls = 1 << 5,\n        TypedDecls = 1 << 6,\n        TypedFuncSignatures = 1 << 8,\n        TypedSignatures = 1 << 9,\n        AmbientDecls = 1 << 10,\n        Properties = 1 << 11,\n        \n        Block = Statements | FunctionDecls | TypedFuncDecls | TypedDecls,\n        Global = Statements | FunctionDecls | ModuleDecls | ClassDecls | InterfaceDecls | AmbientDecls,\n        FunctionBody = Statements | FunctionDecls,\n        ModuleMembers = TypedFuncDecls | FunctionDecls | ModuleDecls | ClassDecls | InterfaceDecls | TypedDecls | Statements | AmbientDecls,\n        ClassMembers = TypedFuncDecls | FunctionDecls | Statements | TypedDecls | Properties,\n        InterfaceMembers = TypedFuncSignatures | TypedSignatures,\n        QuickParse = Global | Properties,\n    }\n\n    export enum Modifiers {\n        None = 0,\n        Private = 1,\n        Public = 1 << 1,\n        Readonly = 1 << 2,\n        Ambient = 1 << 3,\n        Exported = 1 << 4,\n        Getter = 1 << 5,\n        Setter = 1 << 6,\n        Static = 1 << 7,\n    }\n\n\n    export enum ASTFlags {\n        None = 0,\n        ExplicitSemicolon = 1, // statment terminated by an explicit semicolon\n        AutomaticSemicolon = 1 << 1, // statment terminated by an automatic semicolon\n        Writeable = 1 << 2,  // node is lhs that can be modified\n        Error = 1 << 3, // node has an error\n        DotLHSPartial = 1 << 4, // node is the lhs of an incomplete dot expr at cursor\n        DotLHS = 1 << 5, // node is the lhs of a dot expr\n        IsStatement = 1 << 6, // node is a statement\n        StrictMode = 1 << 7, // node is in the strict mode environment\n        PossibleOptionalParameter = 1 << 8,\n        ES6ClassBaseConstructorCall = 1 << 9,\n    }\n\n    export enum ModuleFlags {\n        None = 0,\n        IsEnum = 1,\n        Ambient = 1 << 1,\n        ShouldEmitModuleDecl = 1 << 2,\n        Glo = 1 << 3,\n        Exported = 1 << 4,\n        IsWholeFile = 1 << 5,\n        IsDynamic = 1 << 6,\n    }\n\n    export enum SymbolFlags {\n        None = 0,\n        Public = 1,\n        Private = 1 << 1,\n        Property = 1 << 2,\n        Ambient = 1 << 3,\n        Readonly = 1 << 4,\n        ModuleMember = 1 << 5,\n        InterfaceMember = 1 << 6,\n        ClassMember = 1 << 7,\n        Static = 1 << 8,\n        BuiltIn = 1 << 9,\n        Exported = 1 << 10,\n        TypeSetDuringScopeAssignment = 1 << 11,\n        Constant = 1 << 12,\n    }\n\n    export enum VarFlags {\n        None = 0,\n        AutoInit = 1,\n        Static = 1 << 1,\n        Property = 1 << 2,\n        Private = 1 << 3,\n        Ambient = 1 << 4,\n        Public = 1 << 5,\n        Readonly = 1 << 6,\n        Exported = 1 << 7,\n        LocalStatic = 1 << 8,\n        ES6Class = 1 << 9,\n        ES6ClassProperty = 1 << 10,\n        ES6ClassBodyProperty = 1 << 11,\n        ES6ClassConstructorProperty = 1 << 12,\n        ES6ClassSuperMustBeFirstCallInConstructor = 1 << 13,\n        Constant = 1 << 14,\n    }\n\n    export enum FncFlags {\n        None = 0,\n        Definition = 1,\n        Private = 1 << 1,\n        Signature = 1 << 2,\n        Method = 1 << 3,\n        HasReturnValue = 1 << 4,\n        Public = 1 << 5,\n        GetAccessor = 1 << 6,\n        CallMember = 1 << 7,\n        ConstructMember = 1 << 8,\n        HasSelfReference = 1 << 9,\n        IsFatArrowFunction = 1 << 10,\n        IndexerMember = 1 << 11,\n        Static = 1 << 12,\n        Ambient = 1 << 13,\n        Exported = 1 << 14,\n        SetAccessor = 1 << 15,\n        IsFunctionExpression = 1 << 16,\n        ES6ClassMethod = 1 << 17,\n    }\n\n    export enum TypeFlags {\n        None = 0,\n        HasImplementation = 1,\n        HasSelfReference = 1 << 1,\n        MergeResult = 1 << 2,\n        IsEnum = 1 << 3,\n        BuildingName = 1 << 4,\n        HasBaseType = 1 << 5,\n        HasBaseTypeOfObject = 1 << 6,\n    }\n\n    export enum CodeGenTarget {\n        ES3 = 0,\n        ES5 = 1,\n        ES6 = 1 << 1,\n    }\n\n    export enum ModuleGenTarget {\n        Synchronous = 0,\n        Asynchronous = 1,\n        Local = 1 << 1,\n    }\n\n    // Compiler defaults to generating ES5-compliant code for\n    //  - getters and setters\n    export var codeGenTarget: CodeGenTarget = CodeGenTarget.ES5;\n\n    export var moduleGenTarget: ModuleGenTarget = ModuleGenTarget.Asynchronous;\n\n    export var optimizeModuleCodeGen = true;\n\n    export function flagsToString(e, flags: number): string {\n        var builder = \"\";\n        for (var i = 1; i < (1 << 31) ; i = i << 1) {\n            if ((flags & i) != 0) {\n                for (var k in e) {\n                    if (e[k] == i) {\n                        if (builder.length > 0) {\n                            builder += \"|\";\n                        }\n                        builder += k;\n                        break;\n                    }\n                }\n            }\n        }\n        return builder;\n    }\n\n}\n\n\nmodule Tools {\n    export var HashSmallSize = 7;\n    export var HashMediumSize = 16;\n    export var HashLargeSize = 128;\n\n    export interface IEquatable {\n        getHashCode: number;\n    }\n\n    export oldclass StringHashEntry(property key: string, property data) {\n        property next: StringHashEntry;\n    }\n\n    export function StringHashFn(key: string): number {\n        var val: number = 0;\n        for (var i: number = 0; i < key.length; i++) {\n            val = (val << i) ^ key.charCodeAt(i);\n        }\n        if (val > 0) {\n            return val;\n        }\n        else {\n            return -val;\n        }\n    }\n\n    // do not remove: here for comparison \n    export oldclass StringHashTableOld(property size: number) {\n        property itemCount = 0;\n        property table = new StringHashEntry[];\n\n        for (var j: number = 0; j < this.size; j++) {\n            this.table[j] = null;\n        }\n\n        property getAllKeys(): string[]{\n            var result: string[] = [];\n            for (var i = 0; i < this.size; i++) {\n                for (var current = this.table[i]; current != null ; current = current.next) {\n                    result[result.length] = current.key;\n                }\n            }\n            return result;\n        }\n\n\n        property add(key: string, data): bool {\n            var current: StringHashEntry;\n            var entry: StringHashEntry = new StringHashEntry(key, data);\n            var val: number = StringHashFn(key);\n            val = val % this.size;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (key == current.key) {\n                    return false;\n                }\n            }\n            entry.next = this.table[val];\n            this.table[val] = entry;\n            this.itemCount++;\n            return true;\n        }\n\n        property map(fn: (k: string, v, c) => void , context) {\n            for (var i = 0; i < this.size; i++) {\n                for (var current = this.table[i]; current != null ; current = current.next) {\n                    fn(current.key, current.data, context);\n                }\n            }\n        }\n\n        property census() {\n            var current: StringHashEntry;\n            var pop = 0;\n            for (var i = 0; i < this.size; i++) {\n                for (current = this.table[i]; current != null ; current = current.next) {\n                    pop++;\n                }\n            }\n            return pop;\n        }\n\n        property every(fn: (k: string, v, c) => bool, context) {\n            for (var i = 0; i < this.size; i++) {\n                for (var current = this.table[i]; current != null ; current = current.next) {\n                    if (!fn(current.key, current.data, context)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        property some(fn: (k: string, v, c) => bool, context) {\n            for (var i = 0; i < this.size; i++) {\n                for (var current = this.table[i]; current != null ; current = current.next) {\n                    if (fn(current.key, current.data, context)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        property count(): number => this.itemCount;\n\n        property lookup(key: string) {\n            var current: StringHashEntry;\n            var val = StringHashFn(key);\n            val = val % this.size;\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (key == current.key) {\n                    return (current.data);\n                }\n            }\n            return (null);\n        }\n    }\n\n    export oldclass BlockIntrinsics() {\n        property constructor = undefined;\n        property prototype = undefined;\n        property toString = undefined;\n        property toLocaleString = undefined;\n        property valueOf = undefined;\n        property hasOwnProperty = undefined;\n        property propertyIsEnumerable = undefined;\n        property isPrototypeOf = undefined;\n    }\n\n    export interface IHashTable {\n        getAllKeys(): string[];\n        add(key: string, data): bool;\n        addOrUpdate(key: string, data): bool;\n        map(fn: (k: string, v, c) => void , context): void;\n        every(fn: (k: string, v, c) => bool, context): bool;\n        some(fn: (k: string, v, c) => bool, context): bool;\n        count(): number;\n        lookup(key: string): any;\n    }\n\n    export oldclass StringHashTable() implements IHashTable {\n        property itemCount = 0;\n        property table = <any[]>(<any> new BlockIntrinsics());\n\n        property getAllKeys(): string[]{\n            var result: string[] = [];\n            for (var k: string in this.table) {\n                if (this.table[k] != undefined) {\n                    result[result.length] = k;\n                }\n            }\n            return result;\n        }\n\n        property add(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        property addOrUpdate(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                this.table[key] = data;\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        property map(fn: (k: string, v, c) => void , context) {\n            for (var k: string in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    fn(k, this.table[k], context);\n                }\n            }\n        }\n\n        property every(fn: (k: string, v, c) => bool, context) {\n            for (var k: string in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (!fn(k, this.table[k], context)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        property some(fn: (k: string, v, c) => bool, context) {\n            for (var k: string in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (fn(k, this.table[k], context)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        property count(): number => this.itemCount;\n\n        property lookup(key: string) {\n            var data = this.table[key];\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return (null);\n            }\n        }\n    }\n\n    // The resident table is expected to reference the same table object, whereas the \n    // transientTable may reference different objects over time\n    // REVIEW:  WARNING:  For performance reasons, neither the primary nor secondary table may be null\n    export oldclass DualStringHashTable(public primaryTable: IHashTable,\n                                        public secondaryTable: IHashTable) implements IHashTable {\n\n        public insertPrimary = true;\n\n        public getAllKeys(): string[]{\n            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());\n        }\n\n        public add(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.add(key, data);\n            }\n            else {\n                return this.secondaryTable.add(key, data);\n            }\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.addOrUpdate(key, data);\n            }\n            else {\n                return this.secondaryTable.addOrUpdate(key, data);\n            }\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            this.primaryTable.map(fn, context);\n            this.secondaryTable.map(fn, context);\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);\n        }\n\n        public count() {\n            return this.primaryTable.count() + this.secondaryTable.count();\n        }\n\n        public lookup(key: string) {\n            var data = this.primaryTable.lookup(key);\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return this.secondaryTable.lookup(key);\n            }\n        }\n    }\n\n    export function numberHashFn(key: number): number {\n        var c2 = 0x27d4eb2d; // a prime or an odd constant\n        key = (key ^ 61) ^ (key >>> 16);\n        key = key + (key << 3);\n        key = key ^ (key >>> 4);\n        key = key * c2;\n        key = key ^ (key >>> 15);\n        return key;\n    }\n\n    export function combineHashes(key1: number, key2: number) {\n        return key2 ^ ((key1 >> 5) + key1);\n    }\n\n    export oldclass HashEntry(property key, property data) {\n        property next: HashEntry;\n    }\n\n    export oldclass HashTable(property size: number, property hashFn: (key) =>number,\n                    property equalsFn: (key1, key2) =>bool) {\n        property itemCount: number = 0;\n        property table = new HashEntry[];\n\n        for (var i: number = 0; i < this.size; i++) {\n            this.table[i] = null;\n        }\n\n        property add(key, data): bool {\n            var current: HashEntry;\n            var entry: HashEntry = new HashEntry(key, data);\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return false;\n                }\n            }\n            entry.next = this.table[val];\n            this.table[val] = entry;\n            this.itemCount++;\n            return true;\n        }\n\n        property remove(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            var result = null;\n            var prevEntry: HashEntry = null;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    result = current.data;\n                    this.itemCount--;\n                    if (prevEntry != null) {\n                        prevEntry.next = current.next;\n                    }\n                    else {\n                        this.table[val] = current.next;\n                    }\n                    break;\n                }\n                prevEntry = current;\n            }\n            return result;\n        }\n\n        property count(): number => this.itemCount;\n\n        property lookup(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return (current.data);\n                }\n            }\n            return (null);\n        }\n    }\n\n}\nmodule Tools {\n\n    export oldclass IncrementalParser(private logger: Tools.ILogger) {\n        private astLogger = new AstLogger(this.logger);\n\n        public attemptIncrementalUpdateUnit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): UpdateUnitResult {\n            this.logger.log(\"attemptIncrementalUpdateUnit(\\\"\" + scriptId + \"\\\")\");\n\n            if (!editRange || editRange.isUnknown()) {\n                this.logger.log(\"  Bailing out because edit range is unknown\");\n                return null;\n            }\n\n            var scope1 = Tools.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false);\n            var scope2 = Tools.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false);\n            if (scope1 == null || scope2 == null) {\n                this.logger.log(\"  Bailing out because containing scopes cannot be determined\");\n                return null;\n            }\n\n            // We only support changes within a single containing scope\n            if (scope1.scopeStartAST !== scope2.scopeStartAST) {\n                this.logger.log(\"  Bailing out because edit overlaps 2 disctint scopes\");\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n            if (newScopeLength <= 0) {\n                this.logger.log(\"  Bailing out because scope has been entirely removed from new source text\");\n                return null;\n            }\n\n            // Heuristic: if the range to reparse is too big, bail out. \n            // This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups \n            if (newScopeLength >= newSourceText.getLength() / 2) {\n                this.logger.log(\"  Bailing out because range of scope to reparse (\" + newScopeLength + \" characters) is greater than half the size of the source text\");\n                return null;\n            }\n\n            // Capture parsing errors so that they are part of \"updateResult\"\n            var parseErrors: Tools.ErrorEntry[] = [];\n            var errorCapture = function(minChar: number, charLen: number, message: string, unitIndex: number): void {\n                parseErrors.push(new Tools.ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n            };\n\n            var quickParseResult = Tools.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture);\n            if (quickParseResult.endLexState != Tools.LexState.Start) {\n                this.logger.log(\"  Bailing out because scope contains unterminated comment\");\n                return null;\n            }\n\n            var scriptFragment = quickParseResult.Script;\n            if (scriptFragment.vars.members.length !== 0) {\n                this.logger.log(\"  Bailing out because new source text defines variables\");\n                return null;\n            }\n\n            //if (scriptFragment.scopes.members.length !== 1) {\n            //    logger.log(\"  Bailing out because new source text defines more than one scope (or none)\");\n            //    return null;\n            //}\n\n            // This detects adding close curlies, since they have the side effect of having the parser \n            // parse more members in the scope range.\n            if (scriptFragment.bod.members.length !== 1) {\n                this.logger.log(\"  Bailing out because new source text defines more than one scope (or none)\");\n                return null;\n            }\n\n            var oldScope = scope1.scopeStartAST;\n            var newScope = scriptFragment.bod.members[0];\n\n            if (oldScope.nodeType != newScope.nodeType) {\n                this.logger.log(\"  Bailing out because new source text does not define the same scope type as the existing scope\");\n                return null;\n            }\n\n            if (!(<any>oldScope).leftCurlyCount || !(<any>oldScope).rightCurlyCount) {\n                this.logger.log(\"  Bailing out because sopce doesn\'t have left/right curly count\");\n            }\n\n            if ((<any>oldScope).leftCurlyCount !== (<any>newScope).leftCurlyCount) {\n                this.logger.log(\"  Bailing out because new source text contains more (or fewer) left curly braces\");\n                return null;\n            }\n\n            if ((<any>oldScope).rightCurlyCount !== (<any>newScope).rightCurlyCount) {\n                this.logger.log(\"  Bailing out because new source text contains more (or fewer) right curly braces\");\n                return null;\n            }\n\n            if (newScope.minChar !== 0) {\n                this.logger.log(\"  Bailing out because new function declaration does not start at position 0\");\n                return null;\n            }\n\n            if (newScope.limChar !== newScopeLength) {\n                this.logger.log(\"  Bailing out because new function declaration does not end at the new end position\");\n                return null;\n            }\n\n            return Tools.UpdateUnitResult.editsInsideFunctionBody(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors);\n        }\n\n        public mergeTrees(updateResult: UpdateUnitResult): void {\n            Tools.timeFunction(this.logger, \"mergeTrees()\", () => {\n                var editRange = new ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta);\n                // Update positions in current ast\n                this.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta);\n                // Update positions in new (partial) ast\n                this.applyDeltaPosition(updateResult.script2, 0, editRange.minChar);\n                // Merge linemaps\n                this.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange);\n                //  Replace old AST for scope with new one\n                this.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2);\n            });\n        }\n\n        private replaceAST(script: Tools.AST, oldAst: Tools.AST, newAst: Tools.AST) {\n            var ctx = {\n                goChildren: true,\n                goNextSibling: true,\n            }\n\n            var pre = (cur: Tools.AST, parent: Tools.AST, ctx: IWalkContext) => {\n                if (cur === oldAst) {\n                    // Transfer comments ownership to new AST. We need this because when \"quick parsing\" the\n                    // new AST, we don\'t take into account the text before and after the \"minChar/limChar\" pair\n                    // of the scope, which don\'t include pre/post-comments.\n                    newAst.preComments = cur.preComments;\n                    newAst.postComments = cur.postComments;\n\n                    this.logger.log(\"replaced old AST node with new one in script AST\");\n                    ctx.goChildren = false;\n                    return newAst;\n                }\n\n                // Avoid visiting sub-trees outside of the edit range\n                if (Tools.isValidAstNode(cur)) {\n                    if (cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {\n                        ctx.goChildren = false;\n                    }\n                }\n                return cur;\n            }\n\n            script.walk(pre, null, null, ctx);\n        }\n\n        private mergeLocationInfo(script: Tools.Script, partial: Tools.Script, editRange: ScriptEditRange) {\n            // Don\'t merger these fields, as the original script has the right values\n            //script.locationInfo.unitIndex = partial.locationInfo.unitIndex;\n            //script.locationInfo.filename = partial.locationInfo.filename;\n\n            var lineMap1 = script.locationInfo.lineMap;\n            var lineMap2 = partial.locationInfo.lineMap;\n\n            if (this.logger.information()) {\n                this.logger.log(\"lineMap1 (before):\");\n                this.astLogger.logLinemap(lineMap1);\n                this.logger.log(\"lineMap2 (quick parse):\");\n                this.astLogger.logLinemap(lineMap2);\n                this.logger.log(\"EditRange=\" + editRange);\n            }\n\n            // Skip entries < minChar\n            var i1 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var i2 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var len1 = lineMap1.length;\n            var len2 = lineMap2.length;\n            while (i1 < len1 || i2 < len2) {\n                if (i1 < len1) {\n                    if (lineMap1[i1] <= editRange.minChar) {\n                        // Nothing to do for this entry, since it\'s before the range of the change\n                        i1++;\n                    } else if (lineMap1[i1] >= editRange.limChar) {\n                        // Apply delta to this entry, since it\'s outside the range of the change\n                        lineMap1[i1] += editRange.delta;\n                        i1++;\n                    }\n                    else {\n                        if (i2 < len2) {\n                            // Add a new entry to lineMap1 corresponding to lineMap2 in new range\n                            lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                            i1++;\n                            len1++;\n                            i2++;\n                        }\n                        else { /* i2 >= len 2 */\n                            // Remove this entry, since there is no corresponding entry in the new map\n                            lineMap1.splice(i1, 1);\n                            len1--;\n                        }\n                    }\n                }\n                else { /* i1 >= len1 && i2 < len2 */\n                    lineMap1.push(lineMap2[i2] + editRange.minChar);\n                    i2++;\n                }\n            }\n            if (this.logger.information()) {\n                this.logger.log(\"lineMap1 (after merge):\");\n                this.astLogger.logLinemap(lineMap1);\n            }\n        }\n\n        private applyDeltaPosition(ast: Tools.AST, start: number, delta: number) {\n            var ctx = {\n                goChildren: true,\n                goNextSibling: true,\n            }\n\n            var applyDelta = (ast: Tools.AST) => {\n                if (ast.minChar !== -1 && ast.minChar >= start) {\n                    ast.minChar += delta;\n                }\n                if (ast.limChar !== -1 && ast.limChar >= start) {\n                    ast.limChar += delta;\n                }\n            }\n\n            var applyDeltaToComments = (comments: Tools.Comment[]) => {\n                if (comments && comments.length > 0) {\n                    for (var i = 0; i < comments.length; i++) {\n                        applyDelta(comments[i]);\n                    }\n                }\n            }\n\n            var pre = function(cur: Tools.AST, parent: Tools.AST, ctx: IWalkContext) {\n                // *Before* applying delta to this, check if we need to go to children\n                if (cur.limChar !== -1 && cur.limChar < start) {\n                    ctx.goChildren = false; // Done with applying Delta for this sub-tree\n                }\n\n                // Apply delta to this node\n                applyDelta(cur);\n                applyDeltaToComments(cur.preComments);\n                applyDeltaToComments(cur.postComments);\n\n                return cur;\n            }\n\n            ast.walk(pre, null, null, ctx);\n        }\n    }\n}\ninterface IResolvedFile {\n    content: string;\n    path: string;\n}\n\ninterface IIO {\n    readFile(path: string): string;\n    writeFile(path: string, contents: string): void;\n    createFile(path: string): ITextWriter;\n    deleteFile(path: string): void;\n    dir(path: string, re?: RegExp, options?: { recursive: bool; }): string[];\n    fileExists(path: string): bool;\n    directoryExists(path: string): bool;\n    createDirectory(path: string): void;\n    resolvePath(path: string): string;\n    dirName(path: string): string;\n    findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n    print(str: string): void;\n    printLine(str: string): void;\n    arguments: string[];\n    stderr: ITextWriter;\n    watchFiles(files: string[], callback: () => void ): bool;\n    run(source: string, filename: string): void;\n}\n\n// Declare dependencies needed for all supported hosts\ndeclare oldclass Enumerator(o: any) {\n    public atEnd(): bool;\n    public moveNext();\n    public item(): any;\n}\ndeclare function setTimeout(callback: () =>void , ms?: number);\ndeclare var require: any;\ndeclare module process {\n    export var argv: string[];\n    export var platform: string;\n    export function on(event: string, handler: (any) => void ): void;\n    export module stdout {\n        export function write(str: string);\n    }\n    export module stderr {\n        export function write(str: string);\n    }\n}\n\nvar IO = (function() {\n\n    // Create an IO object for use inside CScript hosts\n    // Depends on WSCript and FileSystemObject\n    function getCScriptIO() {\n        var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n\n        var args = [];\n        for (var i = 0; i < WScript.Arguments.length; i++) {\n            args[i] = WScript.Arguments.Item(i);\n        }\n\n        return <IIO>{\n            readFile: function(path) {\n                try {\n                    var file = fso.OpenTextFile(path);\n                    var str = file.ReadAll();\n                    file.close();\n                    return <string>str;\n                }\n                catch (err) {\n                    throw new Error(\"Error reading file \\\"\" + path + \"\\\": \" + err.message);\n                }\n            },\n\n            writeFile: function(path, contents) {\n                var file = fso.OpenTextFile(path, 2, true);\n                file.Write(contents);\n                file.Close();\n            },\n\n            fileExists: function(path: string): bool {\n                return fso.FileExists(path);\n            },\n\n            resolvePath: function(path: string): string {\n                return fso.GetAbsolutePathName(path);\n            },\n\n            dirName: function(path: string): string {\n                return fso.GetParentFolderName(path);\n            },\n\n            findFile: function(rootPath: string, partialFilePath: string): IResolvedFile {\n                var path = fso.GetAbsolutePathName(rootPath) + \"/\" + partialFilePath;\n\n                while (true) {\n                    if (fso.FileExists(path)) {\n                        try {\n                            var file = fso.OpenTextFile(path);\n                            var content = <string>file.ReadAll();\n                            file.Close();\n                            return { content: content, path: path };\n                        }\n                        catch (err) {\n                            Tools.CompilerDiagnostics.debugPrint(\"Could not find \" + path + \", trying parent\");\n                        }\n                    }\n                    else {\n                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));\n\n                        if (rootPath == \"\") {\n                            return null;\n                        }\n                        else {\n                            path = fso.BuildPath(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n\n            deleteFile: function(path: string): void {\n                if (fso.FileExists(path)) {\n                    fso.DeleteFile(path, true); // true: delete read-only files\n                }\n            },\n\n            createFile: function(path) {\n                try {\n                    return fso.CreateTextFile(path, true, false);\n                } catch (ex) {\n                    WScript.StdErr.WriteLine(\"Couldn\'t write to file \'\" + path + \"\'\");\n                    throw ex;\n                }\n            },\n\n            directoryExists: function(path) {\n                return <bool>fso.FolderExists(path);\n            },\n\n            createDirectory: function(path) {\n                if (!this.directoryExists(path)) {\n                    fso.CreateFolder(path);\n                }\n            },\n\n            dir: function(path, spec, options) {\n                options = options || {};\n                function filesInFolder(folder, root): string[]{\n                    var paths = [];\n                    var fc: Enumerator;\n\n                    if (options.recursive) {\n                        fc = new Enumerator(folder.subfolders);\n\n                        for (; !fc.atEnd() ; fc.moveNext()) {\n                            paths = paths.concat(filesInFolder(fc.item(), root + \"\\\\\" + fc.item().Name));\n                        }\n                    }\n\n                    fc = new Enumerator(folder.files);\n\n                    for (; !fc.atEnd() ; fc.moveNext()) {\n                        if (!spec || fc.item().Name.match(spec)) {\n                            paths.push(root + \"\\\\\" + fc.item().Name);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                var folder = fso.GetFolder(path);\n                var paths = [];\n\n                return filesInFolder(folder, path);\n            },\n\n            print: function(str) {\n                WScript.StdOut.Write(str);\n            },\n\n            printLine: function(str) {\n                WScript.Echo(str);\n            },\n\n            arguments: <string[]>args,\n            stderr: WScript.StdErr,\n            watchFiles: function(files, callback) {\n                return false;\n            },\n            run: function(source, filename) {\n                eval(source);\n            }\n        }\n\n    };\n\n    // Create an IO object for use inside Node.js hosts\n    // Depends on \'fs\' and \'path\' modules\n    function getNodeIO() {\n\n        var _fs = require(\'fs\');\n        var _path = require(\'path\');\n        var _module = require(\'module\');\n\n        return <IIO> {\n            readFile: function(file) {\n                var rawData = _fs.readFileSync(file).toString();\n                // Remove byte order marker if present - this is how Node \'fixes\' reading\n                // BOM\'d JS files; but is not a fix for UTF16BE reading (which\n                // is currently broken)\n                if (rawData.charCodeAt(0) == 0xFEFF) { // UTF-16 LE\n                    rawData = rawData.slice(1);\n                } else if (rawData.charCodeAt(0) == 0xEFBB) { // UTF-8\n                    rawData = rawData.slice(3);\n                }\n                return rawData;\n            },\n            writeFile: <(path: string, contents: string) => void >_fs.writeFileSync,\n            deleteFile: function(path) {\n                try {\n                    _fs.unlinkSync(path);\n                } catch (e) {\n\n                }\n            },\n            fileExists: function(path): bool {\n                return _fs.existsSync(path);\n            },\n            createFile: function(path) {\n                function mkdirRecursiveSync(path) {\n                    var stats = _fs.statSync(path);\n                    if (stats.isFile()) {\n                        throw \"\\\"\" + path + \"\\\" exists but isn\'t a directory.\";\n                    } else if (stats.isDirectory()) {\n                        return;\n                    } else {\n                        mkdirRecursiveSync(_path.dirname(path));\n                        _fs.mkdirSync(path, 0775);\n                    }\n                }\n                mkdirRecursiveSync(_path.dirname(path));\n\n                var fd = _fs.openSync(path, \'w\');\n                return {\n                    Write: function(str) { _fs.writeSync(fd, str); },\n                    WriteLine: function(str) { _fs.writeSync(fd, str + \'\\r\\n\'); },\n                    Close: function() { _fs.closeSync(fd); fd = null; }\n                };\n            },\n            dir: function dir(path, spec, options) {\n                options = options || {};\n\n                function filesInFolder(folder: string): string[]{\n                    var paths = [];\n\n                    var files = _fs.readdirSync(folder);\n                    for (var i = 0; i < files.length; i++) {\n                        var stat = _fs.statSync(folder + \"\\\\\" + files[i]);\n                        if (options.recursive && stat.isDirectory()) {\n                            paths = paths.concat(filesInFolder(folder + \"\\\\\" + files[i]));\n                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {\n                            paths.push(folder + \"\\\\\" + files[i]);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                return filesInFolder(path);\n            },\n            createDirectory: function(path: string): void {\n                _fs.mkdirSync(path);\n            },\n\n            directoryExists: function(path: string): bool {\n                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();\n            },\n            resolvePath: function(path: string): string {\n                return _path.resolve(path);\n            },\n            dirName: function(path: string): string {\n                return _path.dirname(path);\n            },\n            findFile: function(rootPath: string, partialFilePath): IResolvedFile {\n                var path = rootPath + \"/\" + partialFilePath;\n\n                while (true) {\n                    if (_fs.existsSync(path)) {\n                        try {\n                            var content = <string>_fs.readFileSync(path).toString();\n                            // Remove byte order marker if present - this is how Node \'fixes\' reading\n                            // UTF-8 BOM\'d JS files; but is not a fix for UTF16[BE|LE] reading (which\n                            // is currently broken)\n                            if (content.charCodeAt(0) == 0xFEFF) {\n                                content = content.slice(1);\n                            }\n                            return { content: content, path: path };\n                        } catch (err) {\n                            Tools.CompilerDiagnostics.debugPrint((\"Could not find \" + path) + \", trying parent\");\n                        }\n                    }\n                    else {\n                        rootPath = _path.resolve(_path.dirname(rootPath), \"..\");\n\n                        // Node will just continue to repeat the root path, rather than return null\n                        if (rootPath == _path.dirname(path)) {\n                            return null;\n                        }\n                        else {\n                            path = _path.resolve(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n            print: function(str) { process.stdout.write(str) },\n            printLine: function(str) { process.stdout.write(str + \'\\n\') },\n            arguments: process.argv.slice(2),\n            stderr: {\n                Write: function(str) { process.stderr.write(str); },\n                WriteLine: function(str) { process.stderr.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            watchFiles: function(files, callback) {\n                var watchers = [];\n                var firstRun = true;\n                var isWindows = /^win/.test(process.platform);\n                var processingChange = false;\n\n                var fileChanged: any = function(e, fn) {\n                    if (!firstRun && !isWindows) {\n                        for (var i = 0; i < files.length; ++i) {\n                            _fs.unwatchFile(files[i]);\n                        }\n                    }\n                    firstRun = false;\n                    if (!processingChange) {\n                        processingChange = true;\n                        callback();\n                        setTimeout(function() { processingChange = false; }, 100);\n                    }\n                    if (isWindows && watchers.length === 0) {\n                        for (var i = 0; i < files.length; ++i) {\n                            var watcher = _fs.watch(files[i], fileChanged);\n                            watchers.push(watcher);\n                            watcher.on(\'error\', function(e) {\n                                process.stderr.write(\"ERROR\" + e);\n                            });\n                        }\n                    } else if (!isWindows) {\n                        for (var i = 0; i < files.length; ++i) {\n                            _fs.watchFile(files[i], { interval: 500 }, fileChanged);\n                        }\n                    }\n                };\n\n                fileChanged();\n                return true;\n            },\n            run: function(source, filename) {\n                require.main.filename = filename;\n                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(filename)));\n                require.main._compile(source, filename);\n            }\n        }\n    };\n\n    if (typeof ActiveXObject === \"function\")\n        return getCScriptIO();\n    else if (typeof require === \"function\")\n        return getNodeIO();\n    else\n        return null; // Unsupported host\n})();\n\n\nmodule Tools {\n    export enum NodeType {\n        None,\n        Empty,\n        EmptyExpr,\n        True,\n        False,\n        This,\n        Self,\n        Super,\n        QString,\n        Regex,\n        Null,\n        ArrayLit,\n        ObjectLit,\n        Void,\n        Comma,\n        Pos,\n        Neg,\n        Delete,\n        Await,\n        In,\n        Dot,\n        From,\n        Is,\n        InstOf,\n        Typeof,\n        NumberLit,\n        Name,\n        TypeRef,\n        Index,\n        Call,\n        New,\n        Asg,\n        AsgAdd,\n        AsgSub,\n        AsgDiv,\n        AsgMul,\n        AsgMod,\n        AsgAnd,\n        AsgXor,\n        AsgOr,\n        AsgLsh,\n        AsgRsh,\n        AsgRs2,\n        QMark,\n        LogOr,\n        LogAnd,\n        Or,\n        Xor,\n        And,\n        Eq,\n        Ne,\n        Eqv,\n        NEqv,\n        Lt,\n        Le,\n        Gt,\n        Ge,\n        Add,\n        Sub,\n        Mul,\n        Div,\n        Mod,\n        Lsh,\n        Rsh,\n        Rs2,\n        Not,\n        LogNot,\n        IncPre,\n        DecPre,\n        IncPost,\n        DecPost,\n        Cast,\n        FuncDecl,\n        Member,\n        VarDecl,\n        ArgDecl,\n        Return,\n        Break,\n        Continue,\n        Throw,\n        For,\n        ForIn,\n        If,\n        While,\n        DoWhile,\n        Block,\n        Case,\n        Switch,\n        Try,\n        TryCatch,\n        TryFinally,\n        Finally,\n        Catch,\n        List,\n        Script,\n        Class,\n        ES6Class,\n        Interface,\n        Module,\n        Import,\n        With,\n        Label,\n        LabeledStatement,\n        EBStart,\n        GotoEB,\n        EndCode,\n        Error,\n        Comment,\n        GeneralNode = FuncDecl,\n        LastAsg = AsgRs2,\n    }\n}\ninterface IOptions {\n    name: string;\n    flag: bool;\n    short: string;\n    usage: string;\n    set: (s: string) => void;\n    type: string;\n    experimental: bool;\n}\n\noldclass OptionsParser(host: IIO) {\n    private DEFAULT_SHORT_FLAG = \"-\";\n    private DEFAULT_LONG_FLAG = \"--\";\n\n    // Find the option record for the given string. Returns null if not found.\n    private findOption(arg: string) {\n\n        for (var i = 0; i < this.options.length; i++) {\n\n            if (arg === this.options[i].short || arg === this.options[i].name) {\n                return this.options[i];\n            }\n        }\n\n        return null;\n    }\n\n    public unnamed: string[] = [];\n\n    public options: IOptions[] = [];\n\n    public printUsage() {\n        IO.printLine(\"Syntax:   stradac [options] [file ..]\");\n        IO.printLine(\"\");\n        IO.printLine(\"Examples: stradac hello.str\");\n        IO.printLine(\"          stradac --out foo.js foo.str\");\n        IO.printLine(\"          stradac @args.txt\");\n        IO.printLine(\"\");\n        IO.printLine(\"Options:\");\n\n        var output = [];\n        var maxLength = 0;\n\n        this.options = this.options.sort(function(a, b) {\n            var aName = a.name.toLowerCase();\n            var bName = b.name.toLowerCase();\n\n            if (aName > bName) {\n                return 1;\n            } else if (aName < bName) {\n                return -1;\n            } else {\n                return 0;\n            }\n        });\n\n        // Build up output array\n        for (var i = 0; i < this.options.length; i++) {\n            var option = this.options[i];\n\n            if (option.experimental) {\n                continue;\n            }\n\n            if (!option.usage) {\n                break;\n            }\n\n            var usageString = \"  \";\n            var type = option.type ? \" \" + option.type.toUpperCase() : \"\";\n\n            if (option.short) {\n                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + \", \";\n            }\n\n            usageString += this.DEFAULT_LONG_FLAG + option.name + type;\n\n            output.push([usageString, option.usage]);\n\n            if (usageString.length > maxLength) {\n                maxLength = usageString.length;\n            }\n        }\n\n        output.push([\"  @<file>\", \"Insert command line options and files from a file.\"]);\n\n        // Print padded output\n        for (var i = 0; i < output.length; i++) {\n            IO.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(\" \") + output[i][1]);\n        }\n    }\n\n    public option(name: string, config: IOptions);\n    public option(name: string, config: IOptions, short: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = false;\n\n        this.options.push(config);\n    }\n\n    public flag(name: string, config: IOptions);\n    public flag(name: string, config: IOptions, short: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = true\n\n        this.options.push(config);\n    }\n\n\n\n    // Parse an arguments string\n    public parseString(argString: string) {\n        var position = 0;\n        var tokens = argString.match(/\\s+|\"|[^\\s\"]+/g);\n\n        function peek() {\n            return tokens[position];\n        }\n\n        function consume() {\n            return tokens[position++];\n        }\n\n        function consumeQuotedString() {\n            var value = \'\';\n            consume(); // skip opening quote.\n\n            var token = peek();\n\n            while (token && token !== \'\"\') {\n                consume();\n\n                value += token;\n\n                token = peek();\n            }\n\n            consume(); // skip ending quote;\n\n            return value;\n        }\n\n        var args: string[] = [];\n        var currentArg = \'\';\n\n        while (position < tokens.length) {\n            var token = peek();\n\n            if (token === \'\"\') {\n                currentArg += consumeQuotedString();\n            } else if (token.match(/\\s/)) {\n                if (currentArg.length > 0) {\n                    args.push(currentArg);\n                    currentArg = \'\';\n                }\n\n                consume();\n            } else {\n                consume();\n                currentArg += token;\n            }\n        }\n\n        if (currentArg.length > 0) {\n            args.push(currentArg);\n        }\n\n        this.parse(args);\n    }\n\n    // Parse arguments as they come from the platform: split into arguments.\n    public parse(args: string[]) {\n        var position = 0;\n\n        function consume() {\n            return args[position++];\n        }\n\n        while (position < args.length) {\n            var current = consume();\n            var match = current.match(/^(--?|\\/|@)(.*)/);\n            var value = null;\n\n            if (match) {\n                if (match[1] === \'@\') {\n                    this.parseString(IO.readFile(match[2]));\n                } else {\n                    var arg = match[2];\n                    var option = this.findOption(arg);\n\n                    if (option === null) {\n                        IO.printLine(\"Unknown option \" + arg);\n                        IO.printLine(\"\");\n                        this.printUsage();\n                    } else {\n                        if (!option.flag)\n                            value = consume();\n\n                        option.set(value);\n                    }\n                }\n            } else {\n                this.unnamed.push(current);\n            }\n        }\n    }\n}\n\n\nmodule Tools {\n\n    export enum TypeContext {\n        NoTypes = 0,\n        ArraySuffix = 1,\n        Primitive = 2,\n        Named = 4,\n        AllSimpleTypes = Primitive | Named,\n        AllTypes = Primitive | Named | ArraySuffix,\n    }\n\n    export enum ParseState {\n        None,\n        StartScript,\n        StartStmtList,\n        StartStatement,\n        StartFncDecl,\n        FncDeclName,\n        FncDeclArgs,\n        FncDeclReturnType,\n        ForInit,\n        ForInitAfterVar,\n        ForCondStart,\n        EndStmtList,\n        EndScript,\n    }\n\n    export interface IStatementInfo {\n        stmt: Statement;\n        labels: ASTList;\n    }\n\n    export interface ILambdaArgumentContext {\n        preProcessedLambdaArgs: AST;\n    }\n\n    export oldclass QuickParseResult(public Script: Script, public endLexState: LexState) {\n    }\n\n    export oldclass Parser() {\n        property varLists: ASTList[] = [];\n        property scopeLists: ASTList[] = [];\n        property staticsLists: ASTList[] = [];\n        property scanner: IScanner = new Scanner();\n        property tok: Token = null;\n        property needTerminator = false;\n        // TODO: consolidate these\n        property inFnc = false;\n        property inStaticFnc = false;\n        property inInterfaceDecl = false;\n        property currentClassDecl: TypeDecl = null;\n        property inFncDecl = false;  // this is only for FuncDecls - not constructors, like inFnc\n        property anonId = new Identifier(\"_anonymous\");\n        property style_requireSemi = false;\n        property style_funcInLoop = true;\n        property incremental = false;\n        property errorRecovery = false;\n        property outfile: ITextWriter = undefined;\n        property errorCallback: (minChar: number, charLen: number, message: string, unit: number) =>void = null;\n        property state: ParseState = ParseState.StartStmtList;\n        property cursorLine = -1;\n        property cursorColumn = -1;\n        property cursorState: ParseState = ParseState.None;\n        property errorMessage = \"\";\n        property ambientModule = false;\n        property ambientClass = false;\n        property topLevel = true;\n        property currentUnitIndex = (-1);\n        property prevIDTok: Token = null;\n        property stmtStack: IStatementInfo[] = new IStatementInfo[];\n        property hasTopLevelImportOrExport = false; // for imports, only true if it\'s a dynamic module\n        property strictMode = false;\n        property nestingLevel = 0;\n        property prevExpr: AST = null;\n        property currentES6ClassDefinition: ES6ClassDecl = null;\n        property parsingES6ClassConstructorDefinition = false;\n        property parsingDeclareFile = false;\n        property amdDependencies: string[] = [];\n        property inferPropertiesFromThisAssignment = false;\n\n        property resetStmtStack() {\n            this.stmtStack = new IStatementInfo[];\n        }\n\n        property inLoop() {\n            for (var j = this.stmtStack.length - 1; j >= 0; j--) {\n                if (this.stmtStack[j].stmt.isLoop()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        property pushStmt(stmt: Statement, labels: ASTList) {\n            // allocate here to avoid always storing this information in statements\n            var info = { stmt: stmt, labels: labels };\n            this.stmtStack.push(info);\n        }\n\n        property popStmt(): IStatementInfo {\n            return this.stmtStack.pop();\n        }\n\n        property resolveJumpTarget(jump: Jump): void {\n            var len = this.stmtStack.length;\n            for (var i = len - 1; i >= 0; i--) {\n                var info = this.stmtStack[i];\n                if (jump.target != null) {\n                    if ((info.labels != null) && (info.labels.members.length > 0)) {\n                        for (var j = 0, labLen = info.labels.members.length; j < labLen; j++) {\n                            var label: Label = info.labels.members[j];\n                            if (label.id.text == jump.target) {\n                                jump.setResolvedTarget(this, info.stmt);\n                                return;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (info.stmt.isLoop()) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                    else if ((info.stmt.nodeType == NodeType.Switch) && (jump.nodeType == NodeType.Break)) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                }\n            }\n            // no luck\n            if (jump.target != null) {\n                this.reportParseError(\"could not find enclosing statement with label \" + jump.target);\n            }\n            else {\n                if (jump.nodeType == NodeType.Break) {\n                    this.reportParseError(\"break statement requires enclosing loop or switch\");\n                }\n                else {\n                    this.reportParseError(\"continue statement requires enclosing loop\");\n                }\n            }\n        }\n\n        property setNonInteractive() {\n            this.errorRecovery = false;\n        }\n\n        property setErrorRecovery(outf, l: number, c: number) {\n            this.outfile = outf;\n            this.cursorLine = l;\n            this.cursorColumn = c;\n            this.cursorState = ParseState.None;\n\n            this.errorRecovery = true;\n        }\n\n        property posMatchesCursor(pos: number) {\n            var lineCol = { line: -1, col: -1 };\n            this.getSourceLineCol(lineCol, pos);\n            return (lineCol.line == this.cursorLine) && (lineCol.col == this.cursorColumn);\n        }\n\n        property getSourceLineCol(lineCol: ILineCol, minChar: number): void {\n            getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap);\n        }\n\n        property createRef(text: string, minChar: number): Identifier {\n            var id = new Identifier(text);\n            id.minChar = minChar;\n            return id;\n        }\n\n        property reportParseStyleError(message: string) {\n            this.reportParseError(\"STYLE: \" + message);\n        }\n\n        property reportParseError(message: string) {\n            var len = Math.max(1, this.scanner.pos - this.scanner.startPos);\n            if (this.errorCallback != null) {\n                this.errorCallback(this.scanner.startPos, len, message, this.currentUnitIndex);\n            }\n            else if (this.errorRecovery) {\n                // TODO: mark error in editor if interactive\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, this.scanner.startPos);\n                if (this.outfile != null) {\n                    this.outfile.WriteLine(\"// \" + this.fname + \" (\" + lineCol.line + \",\" + lineCol.col + \"): \" + message);\n                }\n            }\n            else {\n                throw new SyntaxError(this.fname + \" (\" + this.scanner.line + \",\" + this.scanner.col + \"): \" + message);\n            }\n        }\n\n        property chkNxtTok(tokenId: TokenID, errorText: string, errorRecoverySet: ErrorRecoverySet): void {\n            this.tok = this.scanner.scan();\n            this.chkCurTok(tokenId, errorText, errorRecoverySet);\n        }\n\n        property skip(errorRecoverySet: ErrorRecoverySet) {\n            errorRecoverySet |= ErrorRecoverySet.EOF;\n            var ersTok = ErrorRecoverySet.None;\n            var tokenInfo = lookupToken(this.tok.tokenId);\n            if (tokenInfo != undefined) {\n                ersTok = tokenInfo.ers;\n            }\n            while ((ersTok & errorRecoverySet) == ErrorRecoverySet.None) {\n                this.tok = this.scanner.scan();\n                ersTok = ErrorRecoverySet.None;\n                tokenInfo = lookupToken(this.tok.tokenId);\n                if (tokenInfo != undefined) {\n                    ersTok = tokenInfo.ers;\n                }\n                // TODO: regex rescan and track curly braces\n            }\n        }\n\n        property chkCurTok(tokenId: TokenID, errorText: string, errorRecoverySet: ErrorRecoverySet): void {\n            if (this.tok.tokenId != tokenId) {\n                this.reportParseError(errorText);\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n                }\n            }\n            else {\n                this.tok = this.scanner.scan();\n            }\n        }\n\n        property pushDeclLists() {\n            this.staticsLists.push(new ASTList());\n            this.varLists.push(new ASTList());\n            this.scopeLists.push(new ASTList());\n        }\n\n        property popDeclLists() {\n            this.staticsLists.pop();\n            this.varLists.pop();\n            this.scopeLists.pop();\n        }\n\n        property topVarList() {\n            return this.varLists[this.varLists.length - 1];\n        }\n\n        property topScopeList() {\n            return this.scopeLists[this.scopeLists.length - 1];\n        }\n\n        property topStaticsList() {\n            return this.staticsLists[this.staticsLists.length - 1];\n        }\n\n        property parseComment(comment: CommentToken) {\n\n            if (comment != null) {\n                var c: Comment = new Comment(comment.value, comment.isBlock, comment.endsLine);\n                c.minChar = comment.startPos;\n                c.limChar = comment.startPos + comment.value.length;\n\n                if (!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == \"///\") {\n                    var dependencyPath = getAdditionalDependencyPath(comment.value);\n\n                    if (dependencyPath) {\n                        this.amdDependencies.push(dependencyPath);\n                    }\n                }\n\n                return c;\n            }\n            else {\n                return null;\n            }\n\n        }\n\n        property parseCommentsInner(comments: CommentToken[]) {\n            if (comments != null) {\n                var commentASTs: Comment[] = new Comment[];\n                for (var i = 0; i < comments.length; i++) {\n                    commentASTs.push(this.parseComment(comments[i]));\n                }\n                return commentASTs;\n            } else {\n                return null;\n            }\n        }\n\n        property parseComments() {\n            var comments = this.scanner.getComments();\n            return this.parseCommentsInner(comments);\n        }\n\n        property parseCommentsForLine(line: number) {\n            var comments = this.scanner.getCommentsForLine(line);\n\n            return this.parseCommentsInner(comments);\n        }\n\n        property combineComments(comment1: Comment[], comment2: Comment[]) {\n            if (comment1 == null) {\n                return comment2;\n            }\n            else if (comment2 == null) {\n                return comment1;\n            }\n            else {\n                return comment1.concat(comment2);\n            }\n        }\n\n        property parseEnumDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ModuleDecl {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var name: Identifier = null;\n            if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                name = new Identifier(this.tok.getText());\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.tok = this.scanner.scan();\n            }\n            else {\n                this.reportParseError(\"enum declaration requires identifier\");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.startPos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.chkCurTok(TokenID.LCurly, \"expected \'{\'\", errorRecoverySet | ErrorRecoverySet.ID);\n            this.pushDeclLists();\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var mapDecl = new VarDecl(new Identifier(\"_map\"), 0);\n            mapDecl.varFlags |= VarFlags.Exported;\n            mapDecl.varFlags |= VarFlags.Private;\n\n            // REVIEW: Is this still necessary?\n            mapDecl.varFlags |= (VarFlags.Property | VarFlags.Public);\n            mapDecl.init = new UnaryExpression(NodeType.ArrayLit, null);\n            members.append(mapDecl);\n            var lastValue: NumberLiteral = null;\n            for (; ;) {\n                var minChar = this.scanner.startPos;\n                var limChar;\n                var memberName: Identifier = null;\n                var memberValue: AST = null;\n                var preComments = null;\n                var postComments = null;\n\n                if ((this.tok.tokenId == TokenID.ID) || convertTokToIDName(this.tok)) {\n                    memberName = new Identifier(this.tok.getText());\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.tok.tokenId == TokenID.RCurly) {\n                    break;\n                }\n                else {\n                    this.reportParseError(\"expected identifer of enum member\");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.limChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                    }\n                }\n\n                limChar = this.scanner.pos;\n                preComments = this.parseComments();\n                this.tok = this.scanner.scan();\n                postComments = this.parseComments();\n\n                if (this.tok.tokenId == TokenID.Asg) {\n                    this.tok = this.scanner.scan();\n                    memberValue = this.parseExpr(errorRecoverySet, OperatorPrecedence.Cma, true,\n                                          TypeContext.NoTypes);\n                    lastValue = memberValue;\n                    limChar = memberValue.limChar;\n                }\n                else {\n                    if (lastValue == null) {\n                        memberValue = new NumberLiteral(0);\n                        lastValue = memberValue;\n                    }\n                    else {\n                        memberValue = new NumberLiteral(lastValue.value + 1);\n                        lastValue = memberValue;\n                    }\n                    var map: BinaryExpression =\n                        new BinaryExpression(NodeType.Asg,\n                                             new BinaryExpression(NodeType.Index,\n                                                                  new Identifier(\"_map\"),\n                                                                  memberValue),\n                                             new StringLiteral(\'\"\' + memberName.text + \'\"\'));\n                    members.append(map);\n                }\n                var member = new VarDecl(memberName, this.nestingLevel);\n                member.minChar = minChar;\n                member.limChar = limChar;\n                member.init = memberValue;\n                // Note: Leave minChar, limChar as \"-1\" on typeExpr as this is a parsing artifact.\n                member.typeExpr = new TypeReference(this.createRef(name.text, -1), 0);\n                member.varFlags |= (VarFlags.Readonly | VarFlags.Property );\n                if (memberValue.nodeType == NodeType.NumberLit) {\n                    member.varFlags |= VarFlags.Constant;\n                }\n                member.preComments = preComments;\n                members.append(member);\n                member.postComments = postComments;\n                // all enum members are exported\n                member.varFlags |= VarFlags.Exported;\n\n                if (this.tok.tokenId == TokenID.Comma) {\n                    this.tok = this.scanner.scan();\n                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    if ((this.tok.tokenId == TokenID.ID) || (convertTokToIDName(this.tok))) {\n                        continue;\n                    }\n                }\n                break;\n            }\n            this.chkCurTok(TokenID.RCurly, \"expected }\", errorRecoverySet);\n            members.limChar = this.scanner.lastTokenLimChar();\n            var modDecl = new ModuleDecl(name, members, this.topVarList(), this.topScopeList());\n            modDecl.modFlags |= ModuleFlags.IsEnum;\n            this.popDeclLists();\n\n            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return modDecl;\n        }\n\n        property parseDottedName(enclosedList: AST[]): void {\n            this.tok = this.scanner.scan();\n            if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                var id = new Identifier(this.tok.getText());\n                id.preComments = this.parseComments();\n                enclosedList[enclosedList.length] = id;\n                id.minChar = this.scanner.startPos;\n                id.limChar = this.scanner.pos;\n                this.tok = this.scanner.scan();\n                if (this.tok.tokenId == TokenID.Dot) {\n                    this.parseDottedName(enclosedList);\n                }\n            }\n            else {\n                this.reportParseError(\"need identifier after \'.\'\");\n            }\n        }\n\n        // REVIEW: This is much more lenient than the spec - we\'re basically just checking to see if the\n        // path is rooted or contains an extension, not if it could potentially be a bogus file path\n        property isValidImportPath(importPath: string) {\n            importPath = stripQuotes(importPath);\n\n            if (!importPath ||\n                importPath.indexOf(\':\') != -1 || \n                importPath.indexOf(\'\\\\\') != -1 ||\n                //(importPath.indexOf(\'.\') != -1 && importPath.charAt(0) != \'.\') ||\n                importPath.charAt(0) == \'/\') {\n                return false;\n            }\n            return true;\n        }\n\n            property parseImportDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ImportDecl {\n\n                var name: Identifier = null;\n                var alias: AST = null;\n                var importDecl: ImportDecl = null;\n                var minChar = this.scanner.startPos;\n                var isDynamicImport = false;\n\n                this.tok = this.scanner.scan();\n\n                if (this.tok.tokenId == TokenID.ID || convertTokToID(this.tok, this.strictMode)) {\n                    name = new Identifier(this.tok.getText());\n                }\n                else {\n                    this.reportParseError(\"Expected identifer after \'import\'\");\n                    name = new MissingIdentifier();\n                }\n\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n\n                this.tok = this.scanner.scan();\n\n                this.chkCurTok(TokenID.Asg, \"expected =\", errorRecoverySet | ErrorRecoverySet.ID);\n\n                var aliasPreComments = this.parseComments();\n\n                if (this.tok.tokenId == TokenID.ID || convertTokToID(this.tok, this.strictMode)) {\n\n                    if (this.tok.tokenId == TokenID.MODULE) {\n                        this.tok = this.scanner.scan();\n                        if (this.tok.tokenId == TokenID.LParen) {\n                            this.tok = this.scanner.scan();\n\n                            if (this.tok.tokenId == TokenID.QString || this.tok.tokenId == TokenID.ID || convertTokToID(this.tok, this.strictMode)) {\n\n                                if (this.tok.tokenId == TokenID.QString) {\n\n                                    if (this.topLevel) {\n                                        this.hasTopLevelImportOrExport = true;\n                                    }\n\n                                    var aliasText = this.tok.getText();\n\n                                    if (!this.isValidImportPath(aliasText)) {\n                                        this.reportParseError(\"Invalid import path\");\n                                    }\n\n                                    alias = new Identifier(aliasText);\n                                    alias.minChar = this.scanner.startPos;\n                                    alias.limChar = this.scanner.pos;\n\n                                    isDynamicImport = true;\n                                    this.tok = this.scanner.scan();\n                                    \n                                    alias.preComments = aliasPreComments;\n                                }\n                                else {\n                                    alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                              OperatorPrecedence.Asg, true,\n                                              TypeContext.NoTypes);\n                                    \n                                    alias.preComments = aliasPreComments;\n                                }\n                            }\n\n                            this.chkCurTok(TokenID.RParen, \"expected \')\'\", errorRecoverySet | ErrorRecoverySet.ID);\n                            \n                            if (alias) {\n                                alias.postComments = this.parseComments();\n                            }\n                            \n                            // gobble up the \';\' if there is one...\n                            if (this.tok.tokenId == TokenID.SColon) {\n                                this.tok = this.scanner.scan();\n                            }\n                        }\n                    }\n                    else {\n                        alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                              OperatorPrecedence.Asg, true,\n                                              TypeContext.NoTypes);\n                    }\n                }\n                else {\n                    this.reportParseError(\"Expected module name\");\n                    alias = new MissingIdentifier();\n                }\n\n                importDecl = new ImportDecl(name, alias);\n                importDecl.isDynamicImport = isDynamicImport;\n\n                if (hasFlag(modifiers, Modifiers.Exported)) {\n                    importDecl.varFlags |= VarFlags.Exported;\n                }\n\n                importDecl.minChar = minChar;\n                importDecl.limChar = this.scanner.pos;\n\n                return importDecl;\n            }\n\n            property parseModuleDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ModuleDecl {\n                var leftCurlyCount = this.scanner.leftCurlyCount;\n                var rightCurlyCount = this.scanner.rightCurlyCount;\n\n                var svAmbient = this.ambientModule;\n                var svTopLevel = this.topLevel;\n                this.topLevel = false;\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    this.ambientModule = true;\n                }\n\n                this.tok = this.scanner.scan();\n                var name: AST = null;\n                var enclosedList: AST[] = null;\n                this.pushDeclLists();\n                var glo = false;\n                var modulePreComments = this.parseComments();\n                var minChar = this.scanner.startPos;\n                var isAnonInnerMod = false;\n                var isDynamicMod = false;\n\n                if ((this.tok.tokenId == TokenID.ID) || (this.tok.tokenId == TokenID.QString) || convertTokToID(this.tok, this.strictMode)) {\n                    var nameText = this.tok.getText();\n\n                    if (this.tok.tokenId == TokenID.QString) {\n                        isDynamicMod = true;\n                        if (!this.ambientModule) {\n                            this.reportParseError(\"Only ambient dynamic modules may have string literal names\");\n                        }\n                    }\n\n                    name = new Identifier(nameText);\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.pos;\n\n                    this.tok = this.scanner.scan();\n                }\n                else if (this.tok.tokenId == TokenID.LCurly) {\n                    if (svTopLevel) {\n                        // ambient global declarations\n                        glo = true;\n                        name = new Identifier(globalId);\n                    }\n                    else {\n                        name = new Identifier(\"__INNER_MOD\");\n                        isAnonInnerMod = true;\n                    }\n                    // \"fake\" position of where the ID would be\n                    name.minChar = minChar;\n                    name.limChar = minChar;\n                }\n\n                if (this.tok.tokenId == TokenID.Dot) {\n                    enclosedList = new AST[];\n                    this.parseDottedName(enclosedList);\n                }\n\n                if (name == null) {\n                    name = new MissingIdentifier();\n                }\n\n                var moduleBody = new ASTList();\n                var bodyMinChar = this.scanner.startPos;\n                this.chkCurTok(TokenID.LCurly, \"expected {\", errorRecoverySet | ErrorRecoverySet.ID);\n                this.parseStmtList(errorRecoverySet | ErrorRecoverySet.RCurly, moduleBody, true, true,\n                                AllowedElements.ModuleMembers, modifiers);\n                moduleBody.minChar = bodyMinChar;\n                moduleBody.limChar = this.scanner.pos;\n                this.chkCurTok(TokenID.RCurly, \"expected }\", errorRecoverySet);\n\n                var limChar = this.scanner.pos;\n                var moduleDecl: ModuleDecl;\n                if ((enclosedList != null) && (enclosedList.length > 0)) {\n                    var len = enclosedList.length;\n                    var innerName = enclosedList[len - 1];\n                    var innerDecl = new ModuleDecl(innerName, moduleBody, this.topVarList(),\n                                                    this.topScopeList());\n\n                    if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                        innerDecl.modFlags |= ModuleFlags.Ambient;\n                    }\n\n                    innerDecl.modFlags |= ModuleFlags.Exported;\n\n                    // REVIEW: will also possibly need to re-parent comments as well\n                    innerDecl.minChar = minChar;\n                    innerDecl.limChar = limChar;\n\n                    this.popDeclLists();\n                    var outerModBod: ASTList;\n                    for (var i = len - 2; i >= 0; i--) {\n                        outerModBod = new ASTList();\n                        outerModBod.append(innerDecl);\n                        innerName = enclosedList[i];\n                        innerDecl = new ModuleDecl(innerName, outerModBod, new ASTList(),\n                                                    new ASTList());\n                        outerModBod.minChar = innerDecl.minChar = minChar;\n                        outerModBod.limChar = innerDecl.limChar = limChar;\n\n                        if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                            innerDecl.modFlags |= ModuleFlags.Ambient;\n                        }\n\n                        innerDecl.modFlags |= ModuleFlags.Exported;\n                    }\n                    outerModBod = new ASTList();\n                    outerModBod.append(innerDecl);\n                    outerModBod.minChar = minChar;\n                    outerModBod.limChar = limChar;\n                    moduleDecl = new ModuleDecl(name, outerModBod, new ASTList(),\n                                                new ASTList());\n                }\n                else {\n                    moduleDecl = new ModuleDecl(name, moduleBody, this.topVarList(), this.topScopeList());\n                    this.popDeclLists();\n                }\n\n                if (glo) {\n                    moduleDecl.modFlags |= ModuleFlags.Glo;\n                }\n\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    moduleDecl.modFlags |= ModuleFlags.Ambient;\n                }\n                if (hasFlag(modifiers, Modifiers.Exported)) {\n                    moduleDecl.modFlags |= ModuleFlags.Exported;\n                }\n                if (isDynamicMod) {\n                    moduleDecl.modFlags |= ModuleFlags.IsDynamic;\n                }\n\n                moduleDecl.preComments = modulePreComments;\n                moduleDecl.postComments = this.parseComments();\n                moduleDecl.isAnonInnerMod = isAnonInnerMod;\n                this.ambientModule = svAmbient;\n\n                this.topLevel = svTopLevel;\n                moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n                moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n\n                return moduleDecl;\n            }\n\n            property parseTypeReferenceTail(errorRecoverySet: ErrorRecoverySet, minChar: number,\n            term: AST) {\n                var result = new TypeReference(term, 0);\n                result.minChar = minChar;\n                while (this.tok.tokenId == TokenID.LBrack) {\n                    this.tok = this.scanner.scan();\n                    result.arrayCount++;\n                    this.chkCurTok(TokenID.RBrack, \"expected \']\'\",\n                              errorRecoverySet | ErrorRecoverySet.LBrack);\n                }\n                result.limChar = this.scanner.lastTokenLimChar();\n                return result;\n            }\n\n\n            property parseNamedType(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST, tail: bool): AST {\n                this.tok = this.scanner.scan();\n                if (this.tok.tokenId == TokenID.Dot) {\n                    var curpos = this.scanner.pos;\n                    this.tok = this.scanner.scan();\n                    if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                        var op2 = new Identifier(this.tok.getText());\n                        op2.minChar = this.scanner.startPos;\n                        op2.limChar = this.scanner.pos;\n                        var dotNode = new BinaryExpression(NodeType.Dot, term, op2);\n                        dotNode.minChar = term.minChar;\n                        dotNode.limChar = op2.limChar;\n                        return this.parseNamedType(errorRecoverySet, minChar,\n                                              dotNode, tail);\n                    }\n                    else {\n                        this.reportParseError(\"need identifier after \'.\'\");\n                        if (this.errorRecovery) {\n                            term.flags |= ASTFlags.DotLHS;\n                            // We set \"limChar\" to be slightly innacurate for completion list behavior\n                            // (last AST node from \"quickParse\" will match DotLHS and be at end of file position)\n                            // This is to match the behavior of TokenId.Dot processing in parsePostfixOperators.\n                            term.limChar = this.scanner.lastTokenLimChar();\n                            return term;\n                        }\n                        else {\n                            var eop2 = new MissingIdentifier();\n                            eop2.minChar = this.scanner.pos;\n                            eop2.limChar = this.scanner.pos;\n                            var edotNode = new BinaryExpression(NodeType.Dot, term, eop2);\n                            edotNode.flags |= ASTFlags.Error;\n                            edotNode.minChar = term.minChar;\n                            edotNode.limChar = eop2.limChar;\n                            return this.parseNamedType(errorRecoverySet, minChar,\n                                                  edotNode, tail);\n                        }\n                    }\n                }\n                else {\n                    if (tail) {\n                        return this.parseTypeReferenceTail(errorRecoverySet, minChar, term);\n                    }\n                    else {\n                        return term;\n                    }\n                }\n            }\n\n            property parseTypeReference(errorRecoverySet: ErrorRecoverySet, allowVoid: bool): AST {\n                var minChar = this.scanner.startPos;\n                var isConstructorMember = false;\n                switch (this.tok.tokenId) {\n                    case TokenID.VOID:\n                        if (!allowVoid) {\n                            this.reportParseError(\"void not a valid type in this context\");\n                        }\n                    // Intentional fall-through\n                    case TokenID.NUMBER:\n                    case TokenID.BOOL:\n                    case TokenID.ANY:\n                    case TokenID.STRING: {\n                        var text = tokenTable[this.tok.tokenId].text;\n                        var primId = new Identifier(text);\n                        primId.minChar = minChar;\n                        primId.limChar = this.scanner.pos;\n                        this.tok = this.scanner.scan();\n                        return this.parseTypeReferenceTail(errorRecoverySet, minChar,\n                                                      primId);\n                    }\n                    // TODO: conversion\n                    case TokenID.ID:\n                        var ident = this.createRef(this.tok.getText(), minChar);\n                        ident.limChar = this.scanner.pos;\n                        return this.parseNamedType(errorRecoverySet, minChar,\n                                              ident, true);\n                    case TokenID.LCurly:\n                        // interface type\n                        this.tok = this.scanner.scan();\n                        var members = new ASTList();\n                        members.minChar = minChar;\n                        var prevInInterfaceDecl = this.inInterfaceDecl;\n                        this.inInterfaceDecl = true;\n                        this.parseInterfaceMembers(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                              members);\n                        this.inInterfaceDecl = prevInInterfaceDecl;\n                        this.chkCurTok(TokenID.RCurly, \"expected }\", errorRecoverySet);\n                        var interfaceDecl = new TypeDecl(NodeType.Interface, this.anonId,\n                                                       members, null, null, null);\n                        interfaceDecl.minChar = minChar;\n                        return this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl);\n\n                    case TokenID.NEW:\n                        this.tok = this.scanner.scan();\n                        // can\'t use chkCurrentTok, since we don\'t want to advance the token\n                        if (this.tok.tokenId != TokenID.LParen) {\n                            this.reportParseError(\"Expected \'(\'\");\n                        }\n                        else {\n                            isConstructorMember = true;\n                            // fall through...\n                        }\n\n                    case TokenID.LParen: {\n                        // ( formals ) => type\n                        var formals = new ASTList();\n                        var variableArgList =\n                            this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                              formals, false, false, true, false, false, false, null);\n                        this.chkCurTok(TokenID.Arrow, \"expected =>\", errorRecoverySet);\n                        var returnType = this.parseTypeReference(errorRecoverySet, true);\n                        var funcDecl = new FuncDecl(null, null, false, formals, null, null, null,\n                                                  NodeType.FuncDecl);\n                        funcDecl.returnTypeAnnotation = returnType;\n                        funcDecl.variableArgList = variableArgList;\n                        funcDecl.fncFlags |= FncFlags.Signature;\n\n                        if (isConstructorMember) {\n                            funcDecl.fncFlags |= FncFlags.ConstructMember;\n                            funcDecl.hint = \"_construct\";\n                            funcDecl.classDecl = null;\n                        }\n                        funcDecl.minChar = minChar;\n                        return this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl);\n                    }\n\n                    default:\n                        this.reportParseError(\"expected type name\");\n                        var etr = new TypeReference(null, 0);\n                        etr.flags |= ASTFlags.Error;\n                        etr.minChar = this.scanner.pos;\n                        etr.limChar = this.scanner.pos;\n                        return etr;\n                }\n                // return null;\n            }\n\n            property parseFunctionStatements(errorRecoverySet: ErrorRecoverySet,\n            name: Identifier,\n            isConstructor: bool,\n            isMethod: bool,\n            args: ASTList,\n            allowedElements: AllowedElements,\n            minChar: number,\n            requiresSignature: bool,\n            parentModifiers: Modifiers) {\n\n                this.pushDeclLists();\n                // start new statement stack\n                var svStmtStack = this.stmtStack;\n                this.resetStmtStack();\n\n                var bod: ASTList = null;\n                var wasShorthand = false;\n                var isAnonLambda = false;\n\n                if (!requiresSignature) {\n                    bod = new ASTList();\n                    var bodMinChar = this.scanner.startPos;\n                    if (this.tok.tokenId == TokenID.Arrow) {\n                        wasShorthand = true;\n                        this.tok = this.scanner.scan();\n                    }\n                    if (wasShorthand && this.tok.tokenId != TokenID.LCurly) {\n                        var retExpr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                              OperatorPrecedence.Asg, true,\n                                              TypeContext.NoTypes);\n                        var retStmt = new ReturnStatement();\n                        retStmt.returnExpression = retExpr;\n                        bod.minChar = bodMinChar;\n                        bod.append(retStmt);\n                    }\n                    else {\n                        this.state = ParseState.StartStmtList;\n                        this.chkCurTok(TokenID.LCurly, \"expected {\", errorRecoverySet |\n                                  ErrorRecoverySet.StmtStart);\n                        var svInFnc = this.inFnc;\n                        isAnonLambda = wasShorthand;\n                        this.inFnc = true;\n                        this.parseStmtList(errorRecoverySet | ErrorRecoverySet.RCurly |\n                                      ErrorRecoverySet.StmtStart,\n                                      bod, true, false, allowedElements, parentModifiers);\n                        bod.minChar = bodMinChar;\n                        bod.limChar = this.scanner.pos;\n                        this.inFnc = svInFnc;\n                        var ec = new EndCode();\n                        ec.minChar = bod.limChar;\n                        ec.limChar = ec.minChar;\n                        bod.append(ec);\n                    }\n                }\n\n                var funcDecl = new FuncDecl(name, bod, isConstructor, args, this.topVarList(),\n                                          this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);\n                this.popDeclLists();\n                var scopeList = this.topScopeList();\n                scopeList.append(funcDecl);\n                var staticFuncDecl = false;\n                var limChar = this.scanner.pos;\n                if (requiresSignature) {\n                    if (this.tok.tokenId == TokenID.LCurly && (!isMethod || this.currentClassDecl == null || this.inStaticFnc)) {\n                        this.state = ParseState.StartStmtList;\n                        var bodMinChar = this.scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        bod = new ASTList();\n                        var svInFnc = this.inFnc;\n                        var svInStaticFnc = this.inStaticFnc;\n                        this.inFnc = true;\n                        this.inStaticFnc = true;\n                        this.parseStmtList(errorRecoverySet | ErrorRecoverySet.RCurly |\n                                      ErrorRecoverySet.StmtStart,\n                                      bod, true, false, AllowedElements.FunctionDecls, parentModifiers);\n                        this.inFnc = svInFnc;\n                        this.inStaticFnc = svInStaticFnc;\n                        bod.minChar = bodMinChar;\n                        bod.limChar = this.scanner.pos;\n                        var ec = new EndCode();\n                        ec.minChar = bod.limChar;\n                        ec.limChar = ec.minChar;\n                        bod.append(ec);\n                        limChar = this.scanner.pos;\n                        this.chkCurTok(TokenID.RCurly, \"expected }\", errorRecoverySet);\n                    }\n                    else {\n                        this.chkCurTok(TokenID.SColon, \"expected semicolon\", errorRecoverySet);\n                    }\n                }\n                else {\n                    if (!wasShorthand || isAnonLambda) {\n                        this.chkCurTok(TokenID.RCurly, \"expected }\", errorRecoverySet);\n\n                        if (isAnonLambda) {\n                            funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                        }\n                    }\n                    else {\n                        //chkCurTok(TokenID.SColon,\"expected semicolon\", errorRecoverySet);      \n                        funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n\n                        // eliminate the trailing semicolon\n                        if (this.tok.tokenId == TokenID.SColon) {\n                            this.tok = this.scanner.scan();\n                        }\n                    }\n                }\n                funcDecl.minChar = minChar;\n                funcDecl.limChar = limChar;\n\n                if (!requiresSignature) {\n                    funcDecl.fncFlags |= FncFlags.Definition;\n                }\n\n                this.stmtStack = svStmtStack;\n                return funcDecl;\n            }\n\n            property transformAnonymousArgsIntoFormals(formals: ASTList, argList: AST) {\n\n                var translateBinExOperand = (operand: AST) => {\n                    if (operand.nodeType == NodeType.Comma) {\n                        this.transformAnonymousArgsIntoFormals(formals, operand);\n                    }\n                    else if (operand.nodeType == NodeType.Name || operand.nodeType == NodeType.Asg) {\n                        var opArg = operand.nodeType == NodeType.Asg ? (<BinaryExpression>operand).operand1 : operand;\n\n                        var arg = new ArgDecl(<Identifier>opArg);\n                        arg.preComments = opArg.preComments;\n                        arg.postComments = opArg.postComments;\n                        arg.minChar = opArg.minChar;\n                        arg.limChar = opArg.limChar;\n\n                        if (hasFlag(opArg.flags, ASTFlags.PossibleOptionalParameter)) {\n                            arg.isOptional = true;\n                        }\n\n                        if (operand.nodeType == NodeType.Asg) {\n                            arg.init = (<BinaryExpression>operand).operand2;\n                        }\n\n                        formals.append(arg);\n                    }\n                    else {\n                        this.reportParseError(\"Invalid lambda argument\");\n                    }\n\n                }\n\n                if (argList) {\n                    if (argList.nodeType == NodeType.Comma) {\n                        var commaList = <BinaryExpression> argList;\n                        translateBinExOperand(commaList.operand1);\n                        translateBinExOperand(commaList.operand2);\n                    }\n                    else {\n                        translateBinExOperand(argList);\n                    }\n                }\n            }\n\n            property parseFormalParameterList(errorRecoverySet: ErrorRecoverySet,\n                                                formals: ASTList,\n                                                isConstr: bool,\n                                                isES6Constr: bool,\n                                                isSig: bool,\n                                                isIndexer: bool,\n                                                isGetter: bool,\n                                                isSetter: bool,\n                                                preProcessedLambdaArgs: AST): bool \n            {\n\n                formals.minChar = this.scanner.startPos; // \'(\' or \'[\'\n                if (isIndexer) {\n                    this.tok = this.scanner.scan();\n                }\n                else if (!preProcessedLambdaArgs) {\n                    this.chkCurTok(TokenID.LParen, \"expected \'(\'\",\n                              errorRecoverySet | ErrorRecoverySet.RParen);\n                }\n                var sawEllipsis = false;\n                var firstArg = true;\n                var hasOptional = false;\n                var haveFirstArgID = false;\n\n                // REVIEW: hasPartialArgList is used to eliminate the trailing RParen in the case that parseTerm\n                // wasn\'t able to gather a complete param list for an anonymous function (e.g., if one of the parameters\n                // contained a type annotation or was optional)\n                var hasPartialArgList = false;\n\n                // if preProcessedLambdaArgs is \"true\", we either have a typeless argument list, or we have\n                // a single identifier node and the current token is the \':\' before a typereference\n                if (preProcessedLambdaArgs) {\n                    this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs);\n                    haveFirstArgID = true;\n                }\n\n                while (true) {\n                    var munchedArg = false;\n                    var argFlags = VarFlags.None;\n                    var argMinChar = this.scanner.startPos;\n\n                    if (this.inferPropertiesFromThisAssignment && this.tok.tokenId == TokenID.THIS) {\n                        if (!isES6Constr) {\n                            this.reportParseError(\"Instance property declarations using \'this\' may only be used in ES6-style class constructors\");\n                        }\n                        this.tok = this.scanner.scan(); // consume the \'.\'\n\n                        argFlags |= (VarFlags.Public | VarFlags.Property);\n                        if (this.currentES6ClassDefinition) {\n                            this.currentES6ClassDefinition.varFlags |= VarFlags.ES6ClassSuperMustBeFirstCallInConstructor;\n                        }\n                    }\n                    if (this.tok.tokenId == TokenID.PROPERTY || this.tok.tokenId == TokenID.PUBLIC) {\n                        argFlags |= (VarFlags.Public | VarFlags.Property);\n\n                        if (this.currentES6ClassDefinition) {\n                            this.currentES6ClassDefinition.varFlags |= VarFlags.ES6ClassSuperMustBeFirstCallInConstructor;\n                        }\n                    }\n                    else if (this.tok.tokenId == TokenID.PRIVATE) {\n                        argFlags |= (VarFlags.Private | VarFlags.Property);\n\n                        if (this.currentES6ClassDefinition) {\n                            this.currentES6ClassDefinition.varFlags |= VarFlags.ES6ClassSuperMustBeFirstCallInConstructor;\n                        }\n                    }\n\n                    if (argFlags != VarFlags.None) {\n                        if (!isConstr) {\n                            this.reportParseError(\"only constructor parameters can be properties\");\n                        }\n                        this.tok = this.scanner.scan();\n\n                        if (this.inferPropertiesFromThisAssignment && this.tok.tokenId == TokenID.THIS) {\n                            if (!isES6Constr) {\n                                this.reportParseError(\"Instance property declarations using \'this\' may only be used in ES6-style class constructors\");\n                            }\n                            this.tok = this.scanner.scan(); // consume the \'.\'\n                            this.tok = this.scanner.scan();\n                        }\n                    }\n                    else if (this.tok.tokenId == TokenID.Ellipsis) {\n                        sawEllipsis = true;\n                        this.tok = this.scanner.scan();\n                    }\n\n                    var argId: Identifier = null;\n\n                    if (!haveFirstArgID && (this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                        argId = new Identifier(this.tok.getText());\n                        argId.minChar = this.scanner.startPos;\n                        argId.limChar = this.scanner.pos;\n                    }\n\n                    if (haveFirstArgID || argId != null) {\n                        munchedArg = true;\n                        var type: AST = null;\n                        var arg: ArgDecl = null;\n\n                        if (haveFirstArgID && formals.members.length) {\n                            arg = formals.members[formals.members.length - 1];\n\n                            if (arg.isOptional) {\n                                hasOptional = true;\n                                hasPartialArgList = true;\n                            }\n                        }\n                        else {\n                            arg = new ArgDecl(argId);\n\n                            if (isGetter) {\n                                this.reportParseError(\"Property getters may not take any arguments\");\n                            }\n\n                            if (isSetter && !firstArg) {\n                                this.reportParseError(\"Property setters may only take one argument\");\n                            }\n\n                            arg.minChar = argMinChar;\n                            arg.preComments = this.parseComments();\n                            this.tok = this.scanner.scan();\n                        }\n\n                        if (this.tok.tokenId == TokenID.QMark) {\n                            arg.isOptional = true;\n                            hasOptional = true;\n                            this.tok = this.scanner.scan();\n                        }\n\n                        if (this.tok.tokenId == TokenID.Colon) {\n                            this.tok = this.scanner.scan();\n                            type = this.parseTypeReference(errorRecoverySet, false);\n                            if (preProcessedLambdaArgs) {\n                                hasPartialArgList = true;\n                            }\n                        }\n\n                        // check for default parameter\n                        // REVIEW: In the case of a typed reference, assume that parseTypeReference or one\n                        // of its children in the call graph advanced tok\n                        if (this.tok.tokenId == TokenID.Asg) {\n                            if (isSig) {\n                                this.reportParseError(\"Arguments in signatures may not have default values\");\n                            }\n\n                            hasOptional = true;\n                            this.tok = this.scanner.scan();\n                            arg.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                                OperatorPrecedence.Cma, false,\n                                                TypeContext.NoTypes);\n\n                        }\n\n                        if (hasOptional && !arg.isOptionalArg()) {\n                            this.reportParseError(\"Optional parameters may only be followed by other optional parameters\");\n                        }\n\n                        if (sawEllipsis && arg.isOptionalArg()) {\n                            this.reportParseError(\"Varargs may not be optional or have default parameters\");\n                        }\n\n                        // REVIEW: Ok for lambdas?\n                        arg.postComments = this.parseComments();\n                        arg.typeExpr = type;\n                        arg.limChar = this.scanner.lastTokenLimChar();\n                        arg.varFlags |= argFlags;\n                        if (!haveFirstArgID) {\n                            formals.append(arg);\n                        }\n                        else {\n                            haveFirstArgID = false;\n                        }\n                    }\n                    firstArg = false;\n                    if (this.tok.tokenId == TokenID.Comma) {\n                        if ((munchedArg) && (!sawEllipsis)) {\n                            this.tok = this.scanner.scan();\n                            continue;\n                        }\n                        else {\n                            this.reportParseError(\"unexpected \',\' in argument list\");\n                            if (this.errorRecovery) {\n                                this.tok = this.scanner.scan();\n                                continue;\n                            }\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n\n                if (isIndexer) {\n                    this.chkCurTok(TokenID.RBrack, \"expected \']\'\", errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n                }\n                else if (!preProcessedLambdaArgs || hasPartialArgList) {\n                    this.chkCurTok(TokenID.RParen, \"expected \')\'\", errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n                }\n                formals.limChar = this.scanner.lastTokenLimChar(); // \')\' or \']\'\n                return sawEllipsis;\n            }\n\n            property parseFncDecl(errorRecoverySet: ErrorRecoverySet,\n            isDecl: bool, requiresSignature: bool,\n            isMethod: bool,\n            methodName: Identifier,\n            indexer: bool,\n            isStatic: bool,\n            markedAsAmbient: bool,\n            modifiers: Modifiers,\n            lambdaArgContext: ILambdaArgumentContext): AST {\n\n                var leftCurlyCount = this.scanner.leftCurlyCount;\n                var rightCurlyCount = this.scanner.rightCurlyCount;\n\n                var name: Identifier = null;\n                var fnMin = this.scanner.startPos;\n                var minChar = this.scanner.pos;\n                var prevNestingLevel = this.nestingLevel;\n                this.nestingLevel = 0;\n                if ((!this.style_funcInLoop) && this.inLoop()) {\n                    this.reportParseStyleError(\"function declaration in loop\");\n                }\n                if (!isMethod && !isStatic && !indexer && !lambdaArgContext) {\n                    // past function keyword\n                    this.tok = this.scanner.scan();\n                    this.state = ParseState.StartFncDecl;\n                    if ((this.tok.tokenId != TokenID.ID) && (!convertTokToID(this.tok, this.strictMode))) {\n                        if (isDecl) {\n                            this.reportParseError(\"Function declaration must include identifier\");\n\n                            this.nestingLevel = prevNestingLevel;\n                            return new IncompleteAST(fnMin, this.scanner.pos);\n                        }\n                    }\n                    else {\n                        name = new Identifier(this.tok.getText());\n                        name.minChar = this.scanner.startPos;\n                        name.limChar = this.scanner.pos;\n                        this.tok = this.scanner.scan();\n                    }\n                }\n                else {\n                    if (methodName != null) {\n                        name = methodName;\n                    }\n                }\n\n                this.state = ParseState.FncDeclName;\n                var args: ASTList = new ASTList();\n                var variableArgList = false;\n                var isOverload = false;\n                var isGetter = hasFlag(modifiers, Modifiers.Getter);\n                var isSetter = hasFlag(modifiers, Modifiers.Setter);\n                if ((this.tok.tokenId == TokenID.LParen) || (indexer && (this.tok.tokenId == TokenID.LBrack)) || (lambdaArgContext != null && lambdaArgContext.preProcessedLambdaArgs != null)) {\n                    // arg list\n                    variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, false, requiresSignature, indexer, isGetter, isSetter, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null);\n                }\n                this.state = ParseState.FncDeclArgs;\n                var returnType: AST = null;\n                if (this.tok.tokenId == TokenID.Colon) {\n                    this.tok = this.scanner.scan();\n                    if (hasFlag(modifiers, Modifiers.Setter)) {\n                        this.reportParseError(\"Property setters may not declare a return type\");\n                    }\n                    returnType = this.parseTypeReference(errorRecoverySet, true);\n                }\n\n                if (indexer && args.members.length == 0) {\n                    this.reportParseError(\"Index signatures require a parameter type to be specified\");\n                }\n                this.state = ParseState.FncDeclReturnType;\n\n                // REVIEW:\n                // Currently, it\'s imperative that ambient functions *not* be marked as overloads.  At some point, we may\n                // want to unify the two concepts internally\n                if (isDecl && !(this.parsingDeclareFile || markedAsAmbient) && (!isMethod || !(this.ambientModule || this.ambientClass || this.inInterfaceDecl)) && this.tok.tokenId == TokenID.SColon) {\n                    isOverload = true;\n                    isDecl = false;\n                    requiresSignature = true;\n                }\n                var svInFncDecl = this.inFncDecl;\n                this.inFncDecl = true;\n                var funcDecl: FuncDecl =\n                    this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                            name, false, isMethod, args, AllowedElements.FunctionBody,\n                                            minChar, requiresSignature, Modifiers.None);\n                this.inFncDecl = svInFncDecl;\n                funcDecl.variableArgList = variableArgList;\n                funcDecl.isOverload = isOverload;\n\n                if (isDecl) {\n                    funcDecl.fncFlags |= FncFlags.Definition;\n                }\n\n                if (isStatic) {\n                    funcDecl.fncFlags |= FncFlags.Static;\n                }\n\n                if (requiresSignature) {\n                    funcDecl.fncFlags |= FncFlags.Signature;\n                }\n                if (indexer) {\n                    funcDecl.fncFlags |= FncFlags.IndexerMember;\n                }\n                funcDecl.returnTypeAnnotation = returnType;\n                if (isMethod) {\n                    funcDecl.fncFlags |= FncFlags.Method;\n                    // all class property methods are currently exported\n                    funcDecl.fncFlags |= FncFlags.Exported;\n                }\n                funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n                funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n\n                this.nestingLevel = prevNestingLevel;\n\n                return funcDecl;\n            }\n\n            property convertToTypeReference(ast: AST): TypeReference {\n                var result: TypeReference;\n                switch (ast.nodeType) {\n                    case NodeType.TypeRef:\n                        return ast;\n                    case NodeType.Name:\n                        result = new TypeReference(ast, 0);\n                        result.minChar = ast.minChar;\n                        result.limChar = ast.limChar;\n                        return result;\n                    case NodeType.Index: {\n                        var expr: BinaryExpression = ast;\n                        result = this.convertToTypeReference(expr.operand1);\n                        if (result) {\n                            result.arrayCount++;\n                            result.minChar = expr.minChar;\n                            result.limChar = expr.limChar;\n                            return result;\n                        }\n                        else {\n                            var etr = new AST(NodeType.Error);\n                            return etr;\n                        }\n                    }\n                }\n                return null;\n            }\n\n            property parseArgList(errorRecoverySet: ErrorRecoverySet): ASTList {\n                var minChar = this.scanner.pos;\n                // skip left paren\n                this.tok = this.scanner.scan();\n\n                if (this.tok.tokenId == TokenID.RParen) {\n                    return null;\n                }\n                var args: ASTList = new ASTList();\n                args.minChar = minChar;\n                while (true) {\n                    if (args.members.length > 0xffff) {\n                        this.reportParseError(\"max number of args exceeded\");\n                        return args;\n                    }\n                    var arg = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                      OperatorPrecedence.Cma, false, TypeContext.NoTypes);\n                    args.append(arg);\n                    if (this.tok.tokenId != TokenID.Comma) {\n                        break;\n                    }\n                    this.tok = this.scanner.scan();\n                }\n                args.limChar = this.scanner.lastTokenLimChar();\n                return args;\n            }\n\n            property parseBaseList(extendsList: ASTList, implementsList: ASTList, errorRecoverySet: ErrorRecoverySet, interfaceOnly: bool, isES6Class: bool): void {\n                var keyword = true;\n            var currentList = extendsList;\n            for (; ;) {\n                if (keyword) {\n                    if (this.tok.tokenId == TokenID.IMPLEMENTS) {\n                        if (interfaceOnly) {\n                            this.reportParseError(\"interfaces can not implement other types\");\n                        }\n                        currentList = implementsList;\n                    }\n                    this.tok = this.scanner.scan();\n                    keyword = false;\n                }\n                var baseName: Identifier = null;\n                if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                    var minChar = this.scanner.startPos;\n                    baseName = new Identifier(this.tok.getText());\n                    baseName.minChar = minChar;\n                    baseName.limChar = this.scanner.pos;\n                    baseName = this.parseNamedType(errorRecoverySet | ErrorRecoverySet.LCurly,\n                                            minChar, baseName, false);\n                }\n                else {\n                    this.reportParseError(\"expected base name\");\n                    if (this.errorRecovery) {\n                        baseName = new MissingIdentifier();\n                        baseName.minChar = this.scanner.pos;\n                        baseName.limChar = this.scanner.pos;\n                        baseName.flags |= ASTFlags.Error;\n                    }\n                }\n                if (this.tok.tokenId == TokenID.LParen) {\n                    if (isES6Class) {\n                        this.reportParseError(\"ES6 base classes may only be initialized via a \'super\' call within the constructor body\");\n                    }\n                    var baseArgs = this.parseArgList(errorRecoverySet | ErrorRecoverySet.RParen);\n                    var callNode = new CallExpression(NodeType.Call, baseName, baseArgs);\n                    // advance past RParen\n                    this.tok = this.scanner.scan();\n                    callNode.limChar = this.scanner.pos;\n                    currentList.append(callNode);\n                }\n                else {\n                    currentList.append(baseName);\n                }\n\n                if (!interfaceOnly && currentList == extendsList && extendsList.members.length > 1) {\n                    this.reportParseError(\"A class may only extend one other class\");\n                }\n\n                if (this.tok.tokenId == TokenID.Comma) {\n                    this.tok = this.scanner.scan();\n                    continue;\n                }\n                else if ((this.tok.tokenId == TokenID.EXTENDS) ||\n                         (this.tok.tokenId == TokenID.IMPLEMENTS)) {\n                    currentList = extendsList;\n                    keyword = true;\n                    continue;\n                }\n\n                break;\n            }\n        }\n\n        property parseES6ClassDecl(errorRecoverySet: ErrorRecoverySet, minChar: number, modifiers: Modifiers): ES6ClassDecl {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                this.reportParseError(\"const modifier is implicit for class\");\n            }\n\n            // mark the class as ambient, as necessary\n            if (this.parsingDeclareFile || this.ambientModule) {\n                modifiers |= Modifiers.Ambient;\n                modifiers |= Modifiers.Exported;\n            }\n            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None;\n            var svAmbientClass = this.ambientClass;\n            this.ambientClass = classIsMarkedAsAmbient;\n\n            // grab the class\'s name\n            this.tok = this.scanner.scan();\n            var name: Identifier = null;\n            if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                name = new Identifier(this.tok.getText());\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.tok = this.scanner.scan();\n            }\n            else {\n                this.reportParseError(\"class missing name\");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var baseClass: ASTList = null;\n            var interfacesImplemented: ASTList = null;\n            var requiresSignature = false;\n\n            if ((this.tok.tokenId == TokenID.EXTENDS) ||\n                (this.tok.tokenId == TokenID.IMPLEMENTS)) {\n                baseClass = new ASTList();\n                interfacesImplemented = new ASTList();\n                this.parseBaseList(baseClass, interfacesImplemented, errorRecoverySet, false, true);\n            }\n\n            // REVIEW: Note that we don\'t set this as the current class decl\n            var es6ClassDecl = new ES6ClassDecl(name, new ASTList(), baseClass, interfacesImplemented);\n\n            this.currentES6ClassDefinition = es6ClassDecl;\n\n            // parse the classes members\n            this.parseES6ClassElements(es6ClassDecl, errorRecoverySet, modifiers);\n\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                es6ClassDecl.varFlags |= VarFlags.Exported;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                es6ClassDecl.varFlags |= VarFlags.Ambient;\n            }\n\n            // Mark the class decl as an es6 class\n            es6ClassDecl.varFlags |= VarFlags.ES6Class;\n\n            this.ambientClass = svAmbientClass;\n            es6ClassDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            es6ClassDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return es6ClassDecl;\n        }\n\n        property parseES6ClassElements(es6ClassDecl: ES6ClassDecl, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers) {\n            var modifiers = parentModifiers;\n            var resetModifiers = false;\n\n            var membersMinChar = this.scanner.startPos;\n            this.chkCurTok(TokenID.LCurly, \"expected \'{\'\", errorRecoverySet);\n\n            this.nestingLevel++;\n\n            //if (this.tok.tokenId == TokenID.SUPER) {\n            //    if (!es6ClassDecl.baseClass) {\n            //        this.reportError(\"Class has base class initializer, but extends no other class\");\n            //    }\n            //    else {\n            //        var baseArgs = this.parseArgList(errorRecoverySet | ErrorRecoverySet.RParen);\n            //        var callNode = new CallExpression(NodeType.Call, es6ClassDecl.baseClass.members[0], baseArgs);\n            //        // advance past RParen\n            //        this.tok = this.scanner.scan();\n            //        callNode.limChar = this.scanner.pos;\n            //        es6ClassDecl.superCall = callNode;\n            //    }\n            //}\n\n            var currentMemberMinChar = this.scanner.startPos;\n            var wasGetOrSetId = false;\n\n            while (!(this.tok.tokenId == TokenID.RCurly || this.tok.tokenId == TokenID.EOF)) {\n                var scanNext = true;\n\n                // modifiers\n                if (this.tok.tokenId == TokenID.GET) {\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError(\"Duplicate \'get\' declaration in class body\");\n                    }\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError(\"Getter already marked as a setter\");\n                    }\n                    modifiers |= Modifiers.Getter;\n                }\n                else if (this.tok.tokenId == TokenID.SET) {\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError(\"Duplicate \'set\' declaration in class body\");\n                    }\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError(\"Setter already marked as a getter\");\n                    }\n                    modifiers |= Modifiers.Setter;\n\n                }\n                else if (this.tok.tokenId == TokenID.PRIVATE) {\n                    if (modifiers & Modifiers.Private) {\n                        this.reportParseError(\"Duplicate \'private\' modifier\");\n                    }\n                    modifiers |= Modifiers.Private;\n                }\n                else if (this.tok.tokenId == TokenID.PUBLIC) {\n                    modifiers |= Modifiers.Public;\n                }\n                else if (this.tok.tokenId == TokenID.STATIC) {\n                    if (modifiers & Modifiers.Static) {\n                        this.reportParseError(\"Duplicate \'static\' modifier\");\n                    }\n                    modifiers |= Modifiers.Static;\n                }  // constructors\n                else if (this.tok.tokenId == TokenID.CONSTRUCTOR) {\n\n                    if (modifiers != parentModifiers) {\n                        this.reportParseError(\"Constructors may not have modifiers\");\n                    }\n\n                    this.parseES6ClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers);\n                    scanNext = false; // parsing functions advances the token for us\n                    resetModifiers = true;\n                }  // member declarations\n                else if (wasGetOrSetId || this.tok.tokenId == TokenID.ID || convertTokToIDName(this.tok)) {\n\n                    var idText = wasGetOrSetId ? ((modifiers & Modifiers.Getter) ? \"get\" : \"set\") : this.tok.getText();\n                    var id = new Identifier(idText);\n                    id.minChar = this.scanner.startPos;\n                    id.limChar = this.scanner.pos;\n\n                    // unset the get/set bit, if we\'re using it for an id\n                    if (wasGetOrSetId) {\n                        modifiers = modifiers ^ ((modifiers & Modifiers.Getter) ? Modifiers.Getter : Modifiers.Setter);\n                        wasGetOrSetId = false;\n                    }\n                    else {\n                        this.tok = this.scanner.scan();\n                    }\n\n                    if (this.tok.tokenId == TokenID.LParen) {\n                        this.parseES6ClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers);\n                        scanNext = false; // parsing functions advances the token for us\n                    }\n                    else {\n                        if (modifiers & Modifiers.Getter || modifiers & Modifiers.Setter) {\n                            this.reportParseError(\"Property accessors must be functions\");\n                        }\n\n                        var varDecl = this.parseES6ClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers);\n\n                        if (varDecl.init && varDecl.init.nodeType == NodeType.FuncDecl) {\n                            if (this.tok.tokenId == TokenID.RCurly) {\n                                scanNext = false;\n                            }\n                        }\n                        else if (this.tok.tokenId != TokenID.SColon) {\n                            this.reportParseError(\"expected \';\'\");\n                            scanNext = false;\n                        }\n                    }\n\n                    resetModifiers = true;\n                } // catch errant uses of \'super\'\n                else if (this.tok.tokenId == TokenID.SUPER) {\n                    this.reportParseError(\"Base class initializers must be the first statement in a class definition\");\n                }\n                else if (!wasGetOrSetId && ((modifiers & Modifiers.Getter) || (modifiers & Modifiers.Setter)) &&\n                         (this.tok.tokenId == TokenID.LParen) || (this.tok.tokenId == TokenID.Asg)) {\n                             // catch a \'get\' or \'set\' used as an identifier\n                    wasGetOrSetId = true;\n                    scanNext = false;\n\n                }  // mark anything else as an error\n                else if (this.tok.tokenId != TokenID.SColon) { // jettison semicolons\n                    this.reportParseError(\"Unexpected \'\" + this.tok.getText() + \"\' in class definition\");\n                    resetModifiers = true;\n                }\n\n                if (scanNext) {\n                    this.tok = this.scanner.scan();\n                }\n\n                if (resetModifiers) {\n                    modifiers = parentModifiers;\n                    currentMemberMinChar = this.scanner.startPos;\n                    resetModifiers = false;\n                }\n            }\n\n            var membersLimChar = this.scanner.pos;\n            if (this.tok.tokenId == TokenID.RCurly) {\n\n                // for a class with an empty body, consume any \'dangling\' inner comments\n                if (!this.currentES6ClassDefinition.definitionMembers.members.length) {\n                    this.currentES6ClassDefinition.preComments = this.parseComments();\n                }\n\n                this.tok = this.scanner.scan();\n            }\n\n            this.nestingLevel--;\n\n            this.currentES6ClassDefinition.members.minChar = membersMinChar;\n            this.currentES6ClassDefinition.members.limChar = membersLimChar;\n            this.currentES6ClassDefinition.limChar = membersLimChar;\n            this.currentES6ClassDefinition = null;\n        }\n\n        property parseES6ClassConstructorDeclaration(minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            this.parsingES6ClassConstructorDefinition = true;\n\n            var isAmbient = this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient);\n\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var preComments = this.parseComments();\n\n            this.tok = this.scanner.scan(); // scan past the \'constructor\' token\n\n            if (this.tok.tokenId == TokenID.LParen) {\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, true, isAmbient, false, false, false, null);\n                if (args.members.length > 0) {\n                    var lastArg = args.members[args.members.length - 1];\n                }\n            }\n\n            var requiresSignature = isAmbient || this.tok.tokenId == TokenID.SColon;\n\n            if (!requiresSignature) {\n                this.currentES6ClassDefinition.constructorNestingLevel = this.nestingLevel + 1;\n            }\n\n            var constructorFuncDecl: FuncDecl =\n                this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                        this.currentES6ClassDefinition.name, true, false, args, AllowedElements.ClassMembers,\n                                        minChar, requiresSignature, modifiers);\n\n            constructorFuncDecl.preComments = preComments;\n\n            if (requiresSignature && !isAmbient) {\n                constructorFuncDecl.isOverload = true;\n            }\n\n            constructorFuncDecl.variableArgList = variableArgList;\n            this.currentClassDecl = null;\n            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentES6ClassDefinition.name);\n            constructorFuncDecl.classDecl = this.currentES6ClassDefinition;\n\n            if (isAmbient) {\n                constructorFuncDecl.fncFlags |= FncFlags.Ambient;\n            }\n\n            if (requiresSignature) {\n                constructorFuncDecl.fncFlags |= FncFlags.Signature;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                constructorFuncDecl.fncFlags |= FncFlags.Exported;\n            }\n\n\n            if (this.currentES6ClassDefinition.constructorDecl) {\n                if (!isAmbient && !this.currentES6ClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {\n                    this.reportParseError(\"Duplicate constructor definition\");\n                }\n            }\n\n            if (isAmbient || !constructorFuncDecl.isSignature()) {\n                this.currentES6ClassDefinition.constructorDecl = constructorFuncDecl;\n            }\n\n            // REVIEW: Should we have a separate flag for ES6 constructors?  (Constructors are not methods)\n            constructorFuncDecl.fncFlags |= FncFlags.ES6ClassMethod;\n\n            this.currentES6ClassDefinition.definitionMembers.members[this.currentES6ClassDefinition.definitionMembers.members.length] = constructorFuncDecl;\n\n            this.parsingES6ClassConstructorDefinition = false;\n\n            constructorFuncDecl.postComments = this.parseComments();\n\n            return constructorFuncDecl;\n        }\n\n\n        property parseES6ClassMemberVariableDeclaration(text: Identifier, minChar: number, isDeclaredInConstructor: bool, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            //var text: Identifier = null;\n            //var minChar = this.scanner.startPos;\n            //var nameLimChar = minChar;\n\n            var varDecl = new VarDecl(text, this.nestingLevel);\n            varDecl.minChar = minChar;\n            var isStatic = false;\n            varDecl.preComments = this.parseComments();\n\n            if (this.tok.tokenId == TokenID.Colon) {\n                this.tok = this.scanner.scan();\n                varDecl.typeExpr =\n                    this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, false);\n            }\n\n            if (this.tok.tokenId == TokenID.Asg) {\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    this.reportParseError(\"context does not permit variable initializer\");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                // TODO: note assignment for language service\n                this.tok = this.scanner.scan();\n\n                varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                        OperatorPrecedence.Cma, true, TypeContext.NoTypes);\n\n                varDecl.limChar = varDecl.init.limChar;\n\n                // member initializers require that super be invoked as the first call within the constructor\n                this.currentES6ClassDefinition.varFlags |= VarFlags.ES6ClassSuperMustBeFirstCallInConstructor;\n            }\n            else {\n                varDecl.limChar = this.scanner.pos;\n            }\n\n            if (modifiers & Modifiers.Static) {\n                varDecl.varFlags |= VarFlags.Static;\n                isStatic = true;\n            }\n\n            if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                varDecl.varFlags |= VarFlags.Private;\n            }\n            else {\n                varDecl.varFlags |= VarFlags.Public;\n            }\n\n            varDecl.varFlags |= VarFlags.Property;\n\n            if (isDeclaredInConstructor) {\n                varDecl.varFlags |= VarFlags.ES6ClassConstructorProperty;\n            }\n\n            if (!isDeclaredInConstructor && !isStatic) {\n                varDecl.varFlags |= VarFlags.ES6ClassBodyProperty;\n            }\n\n            this.currentES6ClassDefinition.knownMemberNames[text.text] = true;\n\n            if (!isDeclaredInConstructor) {\n                this.currentES6ClassDefinition.definitionMembers.members[this.currentES6ClassDefinition.definitionMembers.members.length] = varDecl;\n            }\n            this.currentES6ClassDefinition.allMemberDefinitions.members[this.currentES6ClassDefinition.allMemberDefinitions.members.length] = varDecl;\n\n            varDecl.postComments = this.parseComments();\n            return varDecl;\n        }\n\n        property parseES6ClassMemberFunctionDeclaration(methodName: Identifier, minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n            var isStatic = hasFlag(modifiers, Modifiers.Static);\n\n            var isAmbient = this.ambientModule || hasFlag(modifiers, Modifiers.Ambient);\n\n            errorRecoverySet |= ErrorRecoverySet.RParen;\n\n            var preComments = this.parseComments();\n\n            // REVIEW: Why bother passing in isAmbient for both requiresSignature and isAmbient?  Shouldn\'t just saying its ambient suffice?\n            var ast: AST = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null);\n            if (ast.nodeType == NodeType.Error) {\n                return ast;\n            }\n\n            var funcDecl = <FuncDecl>ast;\n            funcDecl.preComments = preComments;\n\n            funcDecl.minChar = minChar;\n            if (funcDecl.bod !== null)\n                funcDecl.limChar = funcDecl.bod.limChar;\n\n            if (modifiers & Modifiers.Private) {\n                funcDecl.fncFlags |= FncFlags.Private;\n            }\n            else {\n                funcDecl.fncFlags |= FncFlags.Public;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (isAmbient) {\n                funcDecl.fncFlags |= FncFlags.Ambient;\n            }\n\n            if (isAccessor) {\n                // REVIEW: verify return-type annotations and arguments\n                if (hasFlag(modifiers, Modifiers.Getter)) {\n                    funcDecl.fncFlags |= FncFlags.GetAccessor;\n                    funcDecl.hint = \"get\" + funcDecl.name.text;\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.SetAccessor;\n                    funcDecl.hint = \"set\" + funcDecl.name.text;\n                }\n                funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n            }\n\n            funcDecl.fncFlags |= FncFlags.ES6ClassMethod;\n\n            this.currentES6ClassDefinition.knownMemberNames[methodName.text] = true;\n\n            this.currentES6ClassDefinition.definitionMembers.members[this.currentES6ClassDefinition.definitionMembers.members.length] = funcDecl;\n\n            funcDecl.postComments = this.parseComments();\n\n            return funcDecl;\n        }\n\n        property parseClassDecl(errorRecoverySet: ErrorRecoverySet, minChar: number, modifiers: Modifiers): TypeDecl {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                this.reportParseError(\"const modifier is implicit for class\");\n            }\n            if (this.parsingDeclareFile || this.ambientModule) {\n                modifiers |= Modifiers.Ambient;\n                modifiers |= Modifiers.Exported;\n            }\n            var isAmbient = (modifiers & Modifiers.Ambient) != Modifiers.None;\n            var svAmbientClass = this.ambientClass;\n            this.ambientClass = isAmbient;\n\n            this.tok = this.scanner.scan();\n            var name: Identifier = null;\n            if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                name = new Identifier(this.tok.getText());\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.tok = this.scanner.scan();\n            }\n            else {\n                this.reportParseError(\"class missing name\");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            if (this.tok.tokenId == TokenID.LParen) {\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, false, isAmbient, false, false, false, null);\n                if (args.members.length > 0) {\n                    var lastArg = args.members[args.members.length - 1];\n                }\n            }\n\n            var bases: ASTList = null;\n            var interfaces: ASTList = null;\n            var requiresSignature = false;\n            var isOverload = false;\n            if ((this.tok.tokenId == TokenID.EXTENDS) ||\n                (this.tok.tokenId == TokenID.IMPLEMENTS)) {\n                bases = new ASTList();\n                interfaces = new ASTList();\n                this.parseBaseList(bases, interfaces, errorRecoverySet, false, false);\n            } else if (this.tok.tokenId == TokenID.SColon) {\n                requiresSignature = true;\n                isOverload = requiresSignature;\n            }\n\n            // TODO: use stack if Strada adds nested classes\n            var classDecl = new TypeDecl(NodeType.Class, name, null, args, bases, interfaces);\n            classDecl.isOverload = isOverload;\n            this.currentClassDecl = classDecl;\n\n            var constr: FuncDecl =\n                this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                        name, true, true, args, AllowedElements.ClassMembers,\n                                        minChar, requiresSignature, modifiers);\n            constr.variableArgList = variableArgList;\n            this.currentClassDecl = null;\n            constr.returnTypeAnnotation = this.convertToTypeReference(name);\n            classDecl.members = constr;\n            constr.classDecl = classDecl;\n            if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                classDecl.varFlags |= VarFlags.Private;\n            }\n            if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                classDecl.varFlags |= VarFlags.Public;\n            }\n            if (this.parsingDeclareFile || this.ambientModule || (hasFlag(modifiers, Modifiers.Ambient))) {\n                classDecl.varFlags |= VarFlags.Ambient;\n                constr.fncFlags |= FncFlags.Ambient;\n            }\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                classDecl.varFlags |= VarFlags.Exported;\n                constr.fncFlags |= FncFlags.Exported;\n            }\n            if (requiresSignature) {\n                constr.fncFlags |= FncFlags.Signature;\n            }\n            constr.isOverload = classDecl.isOverload;\n            this.ambientClass = svAmbientClass;\n            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return classDecl;\n        }\n\n        // TODO: async, private and optional function/property\n        property parseInterfaceMember(errorRecoverySet: ErrorRecoverySet): AST {\n            var minChar = this.scanner.startPos;\n            var propertyDecl = this.parsePropertyDecl(errorRecoverySet, Modifiers.Public, true, false);\n            if (propertyDecl.nodeType == NodeType.VarDecl) {\n                this.chkCurTok(TokenID.SColon, \"expected \';\'\", errorRecoverySet);\n            }\n            if (propertyDecl != null) {\n                propertyDecl.minChar = minChar;\n            }\n            return propertyDecl;\n        }\n\n        property parseInterfaceMembers(errorRecoverySet: ErrorRecoverySet, members: ASTList) {\n            for (; ;) {\n                switch (this.tok.tokenId) {\n                    case TokenID.RCurly:\n                    case TokenID.EOF:\n                        members.limChar = this.scanner.pos;\n                        return;\n                }\n                var element = this.parseInterfaceMember(errorRecoverySet | ErrorRecoverySet.StradaS);\n                if (element != null) {\n                    members.append(element);\n                }\n            }\n        }\n\n        property parseInterfaceDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): TypeDecl {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            this.tok = this.scanner.scan();\n            var minChar = this.scanner.pos;\n            var name: Identifier = null;\n            if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                name = new Identifier(this.tok.getText());\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.tok = this.scanner.scan();\n            }\n            else {\n                this.reportParseError(\"interface missing name\");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n            var interfaces: ASTList = null;\n            if (this.tok.tokenId == TokenID.EXTENDS) {\n                interfaces = new ASTList();\n                interfaces.minChar = this.scanner.startPos;\n                this.parseBaseList(interfaces, null, errorRecoverySet, true, false);\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.chkCurTok(TokenID.LCurly, \"expected {\", errorRecoverySet | ErrorRecoverySet.StradaS);\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var prevInInterfaceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseInterfaceMembers(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n            this.chkCurTok(TokenID.RCurly, \"expected }\", errorRecoverySet);\n            var interfaceDecl = new TypeDecl(NodeType.Interface, name, members, null, interfaces, null);\n            if (hasFlag(modifiers, Modifiers.Private)) {\n                interfaceDecl.varFlags |= VarFlags.Private;\n            }\n            if (hasFlag(modifiers, Modifiers.Public)) {\n                interfaceDecl.varFlags |= VarFlags.Public;\n            }\n            if (hasFlag(modifiers, Modifiers.Exported)) {\n                interfaceDecl.varFlags |= VarFlags.Exported;\n            }\n\n            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return interfaceDecl;\n        }\n\n        property makeVarDecl(id: Identifier, nest: number): VarDecl {\n            var varDecl = new VarDecl(id, nest);\n            var currentVarList = this.topVarList();\n            if (currentVarList != null) {\n                currentVarList.append(varDecl);\n            }\n            return varDecl;\n        }\n\n        property parsePropertyDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers, requireSignature: bool, isStatic: bool): AST {\n            var text: Identifier = null;\n            var minChar = this.scanner.startPos;\n            var nameLimChar = minChar;\n            var isNew = false;\n            var isIndexer = false;\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                requireSignature = true;\n            }\n            if (this.tok.tokenId == TokenID.LParen && !wasAccessorID) {\n                if (!requireSignature && !isStatic) {\n                    this.reportParseError(\"expected identifier in property declaration\");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        //REVIEW: Use something else than \"Identifier\"?\n                        text = new MissingIdentifier();\n                    }\n                }\n            }\n            else if (this.tok.tokenId == TokenID.NEW) {\n                if (requireSignature) {\n                    this.tok = this.scanner.scan();\n                    if (this.tok.tokenId == TokenID.LParen) {\n                        isNew = true;\n                    }\n                }\n                if (!isNew) {\n                    // is identifier\n                    if (!requireSignature) {\n                        this.tok = this.scanner.scan();\n                    }\n                    text = new Identifier(\"new\");\n                    text.minChar = this.scanner.pos - 3;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                }\n            }\n            else if ((this.tok.tokenId == TokenID.LBrack) && requireSignature) {\n                // indexer signature\n                isIndexer = true;\n                //REVIEW: Should we use a special \"compiler reserved\" identifier node?\n                text = new Identifier(\"__item\");\n            }\n            else if ((this.tok.tokenId != TokenID.ID) && (!convertTokToIDName(this.tok)) && !wasAccessorID) {\n                this.reportParseError(\"expected identifier in property declaration\");\n                if (this.errorRecovery) {\n                    var eminChar = this.scanner.startPos;\n                    var curpos = this.scanner.pos;\n                    this.skip(errorRecoverySet & (~ErrorRecoverySet.Comma));\n                    if (this.scanner.pos == curpos) {\n                        // ensure progress\n                        this.tok = this.scanner.scan();\n                    }\n\n                    var epd = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                    epd.flags |= ASTFlags.Error;\n                    epd.minChar = eminChar;\n                    epd.limChar = this.scanner.lastTokenLimChar();\n                    return epd;\n                }\n            }\n            else {\n                if (wasAccessorID) {\n                    text = new Identifier(this.prevIDTok.getText());\n                    text.minChar = this.scanner.lastTokenLimChar() - 3;\n                    text.limChar = this.scanner.lastTokenLimChar();\n                    nameLimChar = text.limChar;\n\n                    if (codeGenTarget < CodeGenTarget.ES5) {\n                        this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\n                    }\n\n                    // this block guards against \'get\' and \'set\' tokens that\n                    // were coerced into identifiers\n                    if (this.tok.getText() == text.text && this.tok != this.prevIDTok) {\n                        this.tok = this.scanner.scan();\n                    } // Otherwise, don\'t update the token - we\'re already at \'(\'\n\n                    // reset the previous ID Token\n                    this.prevIDTok = null;\n                }\n                else {\n                    text = new Identifier(this.tok.getText());\n                    text.minChar = this.scanner.startPos;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                    this.tok = this.scanner.scan();\n                }\n            }\n            if ((this.tok.tokenId == TokenID.LParen) ||\n                (isIndexer && (this.tok.tokenId == TokenID.LBrack))) {\n                var ers = errorRecoverySet | ErrorRecoverySet.RParen;\n                if (isIndexer) {\n                    ers = errorRecoverySet | ErrorRecoverySet.RBrack;\n                }\n                var ast = this.parseFncDecl(ers, true, requireSignature,\n                                       !this.inFncDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)), modifiers, null);\n                var funcDecl: FuncDecl;\n                if (ast.nodeType == NodeType.Error) {\n                    return ast;\n                }\n                else {\n                    funcDecl = <FuncDecl>ast;\n                }\n                if (funcDecl.name != null) {\n                    funcDecl.name.minChar = minChar;\n                    funcDecl.name.limChar = nameLimChar;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Private;\n                }\n                if (isStatic) {\n                    funcDecl.fncFlags |= FncFlags.Static;\n                }\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    funcDecl.fncFlags |= FncFlags.Ambient;\n                }\n                if (isAccessor) {\n                    // REVIEW: verify return-type annotations and arguments\n                    if (hasFlag(modifiers, Modifiers.Getter)) {\n                        funcDecl.fncFlags |= FncFlags.GetAccessor;\n                        funcDecl.hint = \"get\" + funcDecl.name.text;\n                    }\n                    else {\n                        funcDecl.fncFlags |= FncFlags.SetAccessor;\n                        funcDecl.hint = \"set\" + funcDecl.name.text;\n                    }\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                }\n\n                if (text == null) {\n                    if (isNew) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = \"_construct\";\n                        funcDecl.classDecl = this.currentClassDecl;\n                    }\n                    else {\n                        funcDecl.hint = \"_call\";\n                        funcDecl.fncFlags |= FncFlags.CallMember;\n                    }\n                }\n                return funcDecl;\n            }\n            else {\n                var varDecl = new VarDecl(text, this.nestingLevel);\n                varDecl.minChar = minChar;\n                if (this.tok.tokenId == TokenID.Colon) {\n                    this.tok = this.scanner.scan();\n                    varDecl.typeExpr =\n                        this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg |\n                                           ErrorRecoverySet.Comma, false);\n                }\n                if (this.tok.tokenId == TokenID.Asg) {\n                    if (requireSignature) {\n                        this.reportParseError(\"context does not permit variable initializer\");\n                        if (this.errorRecovery) {\n                            this.skip(errorRecoverySet);\n                            varDecl.flags |= ASTFlags.Error;\n                            varDecl.limChar = this.scanner.lastTokenLimChar();\n                            return varDecl;\n                        }\n                    }\n                    // TODO: note assignment for language service\n                    this.tok = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Cma, true, TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.text;\n                        funcDecl.boundToProperty = varDecl;\n\n                        if (isAccessor) {\n                            // REVIEW: How could a setter be declared with a fat-arrow function?\n                            if (hasFlag(funcDecl.fncFlags, FncFlags.IsFatArrowFunction)) {\n                                // REVIEW: verify return-type annotations and arguments\n                                if (hasFlag(modifiers, Modifiers.Getter)) {\n                                    funcDecl.fncFlags |= FncFlags.GetAccessor;\n                                    funcDecl.hint = \"get\" + funcDecl.hint;\n                                }\n                                else {\n                                    funcDecl.fncFlags |= FncFlags.SetAccessor;\n                                    funcDecl.hint = \"set\" + funcDecl.hint;\n                                }\n                                funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                            }\n                            else {\n                                this.reportParseError(\"Accessors may only be functions\");\n                            }\n                        }\n                    }\n                    else if (isAccessor) {\n                        this.reportParseError(\"Accessors may only be functions\");\n                    }\n                }\n                else {\n                    varDecl.limChar = this.scanner.pos;\n                }\n                if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Private;\n                }\n                varDecl.varFlags |= VarFlags.Property;\n                return varDecl;\n            }\n        }\n\n        property parseVarDecl(errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            allowIn: bool,\n            requireSignature: bool,\n            isStatic: bool): AST {\n            var isConst = hasFlag(modifiers, Modifiers.Readonly);\n            var minChar = this.scanner.startPos;\n            this.tok = this.scanner.scan();\n            var varDecl: VarDecl = null;\n            var declList: ASTList = null;\n            var multivar = false;\n            var varDeclPreComments = this.parseComments();\n            for (; ;) {\n                if ((this.tok.tokenId != TokenID.ID) && (!convertTokToID(this.tok, this.strictMode))) {\n                    this.reportParseError(\"expected identifier in variable declaration\");\n                    if (this.errorRecovery) {\n\n                        varDecl = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                        varDecl.minChar = minChar;\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n                var text = this.tok.getText();\n                if (this.strictMode && (text == \"eval\")) {\n                    this.reportParseError(\"can not name a variable eval in strict mode\");\n                }\n                varDecl = this.makeVarDecl(new Identifier(text), this.nestingLevel);\n                varDecl.id.minChar = this.scanner.startPos;\n                varDecl.id.limChar = this.scanner.pos;\n                varDecl.preComments = varDeclPreComments;\n\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if (hasFlag(modifiers, Modifiers.Readonly)) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    varDecl.varFlags |= VarFlags.Ambient;\n                }\n                if (hasFlag(modifiers, Modifiers.Exported)) {\n                    varDecl.varFlags |= VarFlags.Exported;\n                }\n                varDecl.minChar = minChar;\n                if (declList != null) {\n                    declList.append(varDecl);\n                }\n                // move past ID; with error recovery need a test \n                this.tok = this.scanner.scan();\n                if (this.tok.tokenId == TokenID.Colon) {\n                    this.tok = this.scanner.scan();\n                    var prevInFncDecl = this.inFncDecl;\n                    this.inFncDecl = false;\n                    varDecl.typeExpr =\n                        this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg |\n                                           ErrorRecoverySet.Comma, false);\n                    this.inFncDecl = prevInFncDecl;\n                }\n\n                if (this.tok.tokenId == TokenID.Asg) {\n                    if (requireSignature) {\n                        this.reportParseError(\"context does not permit variable initializer\");\n                        if (this.errorRecovery) {\n                            this.skip(errorRecoverySet);\n                            varDecl.flags |= ASTFlags.Error;\n                            return varDecl;\n                        }\n                    }\n                    // TODO: note assignment for language service\n                    this.tok = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Cma, allowIn,\n                                           TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        // TODO: use \'as\' operator when can bootstrap\n                        var funcDecl: FuncDecl = varDecl.init;\n                        funcDecl.hint = varDecl.id.text;\n                    }\n                }\n                else {\n                    if (isConst) {\n                        this.reportParseError(\"const declaration requires initializer\");\n                    }\n                    varDecl.limChar = this.scanner.pos;\n                }\n                varDecl.postComments = this.parseCommentsForLine(this.scanner.line);\n\n                if (this.tok.tokenId != TokenID.Comma) {\n                    if (declList != null) {\n                        declList.limChar = varDecl.limChar;\n                        return declList;\n                    }\n                    else {\n                        return varDecl;\n                    }\n                }\n\n                if (!multivar) {\n                    declList = new ASTList();\n                    declList.minChar = varDecl.minChar;\n                    declList.append(varDecl);\n                    multivar = true;\n                }\n\n                this.tok = this.scanner.scan();\n                minChar = this.scanner.startPos;\n            }\n        }\n\n        property parseMemberList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements = new ASTList();\n            if (this.tok.tokenId == TokenID.RCurly) {\n                return elements;\n            }\n\n            var idHint: string = null;\n            var memberName: AST = null;\n            var memberExpr: AST = null;\n            var member: BinaryExpression = null;\n            var minChar = this.scanner.startPos;\n            var isSet = false;\n            var skippedTokenForGetSetId = false;\n            var getSetTok: Token = null;\n            var getSetStartPos = 0;\n            var getSetPos = 0;\n\n            for (; ;) {\n                var accessorPattern = false;\n                if (this.tok.tokenId == TokenID.GET || this.tok.tokenId == TokenID.SET) {\n                    isSet = this.tok.tokenId == TokenID.SET;\n                    getSetTok = this.tok;\n                    getSetStartPos = this.scanner.startPos;\n                    getSetPos = this.scanner.pos;\n\n                    this.tok = this.scanner.scan();\n\n                    if (codeGenTarget < CodeGenTarget.ES5) {\n                        this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\n                    }\n\n                    if ((this.tok.tokenId == TokenID.ID) || convertTokToIDName(this.tok)) {\n                        idHint = isSet ? \"set\" : \"get\";\n                        idHint = idHint + this.tok.getText();\n                        memberName = new Identifier(this.tok.getText());\n                        memberName.minChar = this.scanner.startPos;\n                        accessorPattern = true;\n                    }\n                    else if (this.tok.tokenId != TokenID.Colon) {\n                        this.reportParseError(\"expected identifier, string or number as accessor name\");\n                    }\n                    else {\n                        skippedTokenForGetSetId = true;\n                        memberName = new Identifier(getSetTok.getText());\n                        memberName.minChar = getSetStartPos;\n                        memberName.limChar = getSetPos;\n                    }\n                }\n                else if ((this.tok.tokenId == TokenID.ID) || convertTokToIDName(this.tok)) {\n                    idHint = this.tok.getText();\n                    memberName = new Identifier(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.tok.tokenId == TokenID.QString) {\n                    idHint = this.tok.getText();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                    // TODO: allow reserved words\n                else if (this.tok.tokenId == TokenID.NumberLit) {\n                    var ntok: NumberToken = this.tok;\n                    idHint = ntok.value.toString();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else {\n                    this.reportParseError(\"expected identifier, string or number as member name\");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                        this.skip(errorRecoverySet | ErrorRecoverySet.Comma);\n                        memberName.limChar = this.scanner.lastTokenLimChar();\n                    }\n                }\n\n                if (!skippedTokenForGetSetId) {\n                    this.tok = this.scanner.scan();\n                }\n                else {\n                    skippedTokenForGetSetId = false;\n                }\n\n                if (accessorPattern) {\n                    var args = new ASTList();\n                    this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                      args, false, false, true, false, !isSet, isSet, null);\n\n                    var funcDecl: FuncDecl =\n                        this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                                memberName, false, true, args,\n                                                AllowedElements.FunctionDecls,\n                                                this.scanner.startPos, false, Modifiers.None);\n\n                    if (isSet && funcDecl.returnTypeAnnotation != null) {\n                        this.reportParseError(\"Property setters may not declare a return type\");\n                    }\n\n                    funcDecl.fncFlags |= isSet ? FncFlags.SetAccessor : FncFlags.GetAccessor;\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                    funcDecl.hint = idHint;\n                    memberExpr = funcDecl;\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl: FuncDecl = memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else if (this.tok.tokenId == TokenID.Colon) {\n                    this.tok = this.scanner.scan();\n                    memberExpr = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                         OperatorPrecedence.Cma, true, TypeContext.NoTypes);\n                    // If the memberExpr is a type reference, we can be certain that it was an\n                    // array type declaraion that lacked a \"new\".  We can realistically only\n                    // expect call and name ASTs to be the result of this call to parseExpr.\n                    // If it\'s a constructor without a \"new\", we\'ll flag it as an invalid\n                    // call site later on.\n                    if (memberExpr.nodeType == NodeType.TypeRef) {\n                        this.reportParseError(\"Expected \'new\' on array declaration in member definition\")\n                    }\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl: FuncDecl = memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else {\n                    this.reportParseError(\"expected \':\' in member definition\");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        elements.flags |= ASTFlags.Error;\n                        elements.minChar = minChar;\n                        elements.limChar = this.scanner.lastTokenLimChar();\n                        return elements;\n                    }\n                }\n                idHint = null;\n                elements.append(member);\n                member.limChar = this.scanner.lastTokenLimChar();\n                if (this.tok.tokenId != TokenID.Comma) {\n                    break;\n                }\n                else {\n                    // munch comma\n                    this.tok = this.scanner.scan();\n                }\n\n                // trailing comma allowed\n                if (this.tok.tokenId == TokenID.RCurly) {\n                    break;\n                }\n            }\n\n            if (member != null) {\n                elements.limChar = member.limChar;\n            }\n            elements.minChar = minChar;\n            return elements;\n        }\n\n        property parseArrayList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements: ASTList = null;\n            if (this.tok.tokenId == TokenID.RBrack) {\n                return elements;\n            }\n            else {\n                elements = new ASTList();\n                elements.minChar = this.scanner.startPos;\n            }\n\n            var arg: AST;\n\n            for (; ;) {\n                if ((this.tok.tokenId == TokenID.Comma) ||\n                    (this.tok.tokenId == TokenID.RBrack)) {\n                    arg = new AST(NodeType.EmptyExpr);\n                }\n                else {\n                    arg = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                  OperatorPrecedence.Cma, true, TypeContext.NoTypes);\n                }\n                elements.append(arg);\n                if (this.tok.tokenId != TokenID.Comma) {\n                    break;\n                }\n                this.tok = this.scanner.scan();\n            }\n            elements.limChar = this.scanner.lastTokenLimChar();\n            return elements;\n        }\n\n        property parseArrayLiteral(errorRecoverySet: ErrorRecoverySet): UnaryExpression {\n            var arrayLiteral: UnaryExpression = null;\n            arrayLiteral = new UnaryExpression(NodeType.ArrayLit,\n                                             this.parseArrayList(errorRecoverySet));\n            return arrayLiteral;\n        }\n\n        property parseTerm(errorRecoverySet: ErrorRecoverySet, allowCall: bool, typeContext: TypeContext, inCast: bool): AST {\n            var ast: AST = null;\n            var sawId = false;\n            var inNew = false;\n            var minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var parseAsLambda = false;\n\n            // keywords first\n            switch (this.tok.tokenId) {\n                case TokenID.NUMBER:\n                case TokenID.BOOL:\n                case TokenID.ANY:\n                case TokenID.STRING:\n                    var tid = new Identifier(tokenTable[this.tok.tokenId].text);\n                    if (hasFlag(typeContext, TypeContext.Primitive)) {\n                        ast = new TypeReference(tid, 0);\n                        sawId = true;\n                    }\n                    else {\n                        ast = tid;\n                        sawId = true;\n                    }\n                    ast.minChar = minChar;\n                    this.tok = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.THIS:\n                    ast = new AST(NodeType.This);\n                    ast.minChar = minChar;\n                    this.tok = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.SUPER:\n                    ast = new AST(NodeType.Super);\n                    ast.minChar = minChar;\n                    this.tok = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.TRUE:\n                    ast = new AST(NodeType.True);\n                    this.tok = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.FALSE:\n                    ast = new AST(NodeType.False);\n                    this.tok = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.NULL:\n                    ast = new AST(NodeType.Null);\n                    this.tok = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.NEW:\n                    minChar = this.scanner.pos;\n                    this.tok = this.scanner.scan();\n                    ast = new CallExpression(NodeType.New, this.parseTerm(errorRecoverySet, false,\n                                                                  TypeContext.AllSimpleTypes, inCast),\n                                           null);\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    inNew = true;\n                    break;\n                case TokenID.FUNCTION:\n                    minChar = this.scanner.pos;\n                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, null);\n                    (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                    break;\n            }\n\n            if (ast == null) {\n                if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n\n                    var idText = this.tok.getText();\n                    // TODO: put super here\n                    if ((this.currentClassDecl != null) && (idText == \"self\")) {\n                        ast = new AST(NodeType.Self);\n                    }\n                    else {\n                        ast = this.createRef(idText, minChar);\n                        sawId = true;\n                    }\n                    ast.minChar = minChar;\n                    this.tok = this.scanner.scan();\n\n                    if (this.tok.tokenId == TokenID.QMark) {\n                        ast.flags |= ASTFlags.PossibleOptionalParameter;\n                    }\n                    else if (this.tok.tokenId == TokenID.Arrow) {\n                        parseAsLambda = true;\n                    }\n\n                    limChar = this.scanner.lastTokenLimChar();\n                }\n            }\n\n            if (inCast) {\n                this.chkCurTok(TokenID.GT, \"expected \'>\'\", errorRecoverySet);\n            }\n\n            if (ast == null) {\n                switch (this.tok.tokenId) {\n                    case TokenID.LParen:\n                        minChar = this.scanner.pos;\n                        var prevTokId = this.scanner.previousToken().tokenId;\n                        this.tok = this.scanner.scan();\n\n                        var couldBeLambda = prevTokId == TokenID.LParen || // foo(()=>{});\n                                            prevTokId == TokenID.Comma || // foo(x,()=>{});\n                                            prevTokId == TokenID.EQ || // var foo = ()=>{};\n                                            prevTokId == TokenID.Colon;    // var x = { foo: ()=> {} };\n\n\n                        if (couldBeLambda && this.tok.tokenId == TokenID.RParen) {\n                            parseAsLambda = true;\n                            this.tok = this.scanner.scan();\n                        }\n                        else {\n                            ast = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                          OperatorPrecedence.No, true, TypeContext.NoTypes);\n                            limChar = this.scanner.lastTokenLimChar();\n                            parseAsLambda = couldBeLambda && (ast.nodeType == NodeType.Name || ast.nodeType == NodeType.Comma) &&\n                                            (this.tok.tokenId == TokenID.Colon || this.tok.tokenId == TokenID.QMark);\n                        }\n\n                        // Check for the RParen if it\'s not an anonymous \'=>\' function\n                        // REVIEW: Uncomment the clause below for optional parameters and default arguments\n                        if ((ast && /*(ast.nodeType != NodeType.FuncDecl || !hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) &&*/ !parseAsLambda)) {\n                            this.chkCurTok(TokenID.RParen, \"expected \')\'\", errorRecoverySet);\n                            ast.isParenthesized = true;\n                        }\n\n                        break;\n                    case TokenID.NumberLit: {\n                        var numTok: NumberToken = this.tok;\n                        this.tok = this.scanner.scan();\n                        ast = new NumberLiteral(numTok.value);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.QString:\n                        ast = new StringLiteral(this.tok.getText());\n                        this.tok = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    case TokenID.Regex: {\n                        var rtok: RegexToken = this.tok;\n                        ast = new RegexLiteral(rtok.regex);\n                        this.tok = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.LBrack:\n                        minChar = this.scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        ast = this.parseArrayLiteral(ErrorRecoverySet.RBrack | errorRecoverySet);\n                        ast.minChar = minChar;\n                        this.chkCurTok(TokenID.RBrack, \"expected \']\'\", errorRecoverySet);\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    // TODO: rescan regex for TokenID.Div and AsgDiv\n                    case TokenID.LCurly:\n                        minChar = this.scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        var members = this.parseMemberList(ErrorRecoverySet.RCurly | errorRecoverySet)\n                        this.chkCurTok(TokenID.RCurly, \"expected \'}\'\", errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.ObjectLit, members);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        members.minChar = minChar;\n                        members.limChar = limChar;\n                        break;\n\n                    case TokenID.LT:\n                        minChar = this.scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        var term: AST = this.parseTypeReference(ErrorRecoverySet.BinOp, false);\n                        this.chkCurTok(TokenID.GT, \"expected \'>\'\", errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.Cast, this.parseExpr(errorRecoverySet, OperatorPrecedence.Uni, false, TypeContext.NoTypes));\n                        (<UnaryExpression>ast).castTerm = term;\n                        break;\n\n                    default:\n                        if (this.prevExpr && hasFlag(this.prevExpr.flags, ASTFlags.PossibleOptionalParameter)) {\n                            parseAsLambda = true;\n                            ast = this.prevExpr;\n                        }\n                        else {\n                            this.reportParseError(\"check format of expression term\");\n                            if (this.errorRecovery) {\n                                var ident = new MissingIdentifier();\n                                ident.minChar = minChar;\n                                ident.flags |= ASTFlags.Error;\n                                this.skip(errorRecoverySet | ErrorRecoverySet.Postfix);\n                                if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                                    ident.text = this.tok.getText();\n                                    this.tok = this.scanner.scan();\n                                    limChar = this.scanner.lastTokenLimChar();\n                                }\n                                else {\n                                    limChar = this.scanner.lastTokenLimChar();\n                                    //tok=scanner.scan();\n                                }\n\n                                // REVIEW: set sawId\n                                ast = ident;\n                            }\n                        }\n                }\n            }\n\n            if (parseAsLambda) {\n                // If the next token is an fat arrow or a colon, we either have a parameter list, or can rightly assume\n                // that we have a typed formal, so we proceed with the lambda parse\n                if (this.tok.tokenId == TokenID.Arrow ||\n                    this.tok.tokenId == TokenID.Colon ||\n                    this.tok.tokenId == TokenID.Comma ||\n                    this.tok.tokenId == TokenID.RParen) {\n\n                        // We won\'t scan in the \':\' case, since keeping the \':\' simplifies argument handling in parseTypedFormals\n                        // Note that we don\'t set the minchar in this case\n                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: ast });\n                    (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                    (<FuncDecl>ast).fncFlags |= FncFlags.IsFatArrowFunction;\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                }\n                else if (ast) {\n                    ast.isParenthesized = true;\n                }\n            }\n\n            if (sawId) {\n                typeContext |= TypeContext.ArraySuffix;\n            }\n\n            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar);\n\n            // Defensive error check...\n            if (postFix != null) {\n                if (sawId && (postFix.nodeType == NodeType.Index)) {\n                    var binExpr: BinaryExpression = postFix;\n                    if (binExpr.operand2 == null) {\n                        postFix = this.convertToTypeReference(postFix);\n                    }\n                }\n                postFix.minChar = minChar;\n                postFix.limChar = this.scanner.lastTokenLimChar();\n                return postFix;\n            }\n            else {\n                return new AST(NodeType.Error);\n            }\n\n        }\n\n        property parseExpr(errorRecoverySet: ErrorRecoverySet, minPrecedence: number, allowIn: bool,\n            typeContext: TypeContext): AST {\n            var ast: AST = null;\n            var tokenInfo = lookupToken(this.tok.tokenId);\n            var canAssign: bool = true;\n            var idHint: string = null;\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            var exprIsAnonLambda = false;\n\n            if ((tokenInfo != undefined) && (tokenInfo.unopNodeType != NodeType.None)) {\n                canAssign = false;\n                this.tok = this.scanner.scan();\n                var tempExpr = this.parseExpr(ErrorRecoverySet.BinOp | errorRecoverySet,\n                                       tokenInfo.unopPrecedence, allowIn,\n                                       TypeContext.NoTypes);\n\n                // fold unary +- into constants\n                if ((tokenInfo.unopNodeType == NodeType.Pos) &&\n                    (tempExpr.nodeType == NodeType.NumberLit)) {\n                    ast = tempExpr;\n                }\n                else if ((tokenInfo.unopNodeType == NodeType.Neg) &&\n                         (tempExpr.nodeType == NodeType.NumberLit)) {\n                    var numLit: NumberLiteral = tempExpr;\n                    numLit.value = (-numLit.value);\n                    if (numLit.value == 0) {\n                        numLit.isNegativeZero = true;\n                    }\n                    ast = tempExpr;\n                }\n                else {\n                    ast = new UnaryExpression(tokenInfo.unopNodeType, tempExpr);\n                    ast.limChar = tempExpr.limChar;\n                }\n                ast.minChar = minChar;\n            }\n            else {\n                ast = this.parseTerm(ErrorRecoverySet.BinOp | ErrorRecoverySet.AddOp |\n                              errorRecoverySet, true, typeContext, false);\n                var id: Identifier;\n                var temp: AST;\n                if (ast.nodeType == NodeType.Name) {\n                    id = ast;\n                    idHint = id.text;\n                }\n                else if (ast.nodeType == NodeType.Dot) {\n\n                    // If this is within an ES6 class declaration, and the circumstances are right, we need to\n                    // transform the dotted expression into a member declaration\n                    var subsumedExpr = false;\n\n                    if (this.inferPropertiesFromThisAssignment && \n                        (this.tok.tokenId == TokenID.Colon || this.tok.tokenId == TokenID.Asg) &&\n                         this.parsingES6ClassConstructorDefinition &&\n                         this.nestingLevel == this.currentES6ClassDefinition.constructorNestingLevel && // this nesting level means we\'re at the top-level in the constructor\n                         (<BinaryExpression>ast).operand1.nodeType == NodeType.This) {\n\n                        if ((<BinaryExpression>ast).operand2.nodeType == NodeType.Name) {\n                            var op2ID: Identifier = (<Identifier>(<BinaryExpression>ast).operand2);\n\n                            if (!this.currentES6ClassDefinition.knownMemberNames[op2ID.text]) {\n                                ast = this.parseES6ClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, Modifiers.Public);\n                                subsumedExpr = true;\n                            }\n                        }\n                    }\n\n                    if (!subsumedExpr) {\n                        temp = ast;\n                        while (temp.nodeType == NodeType.Dot) {\n                            var binExpr: BinaryExpression = temp;\n                            temp = binExpr.operand2;\n                        }\n                        if (temp.nodeType == NodeType.Name) {\n                            id = temp;\n                            idHint = id.text;\n                        }\n                    }\n                }\n                if ((!this.scanner.lastTokenHadNewline()) &&\n                    ((this.tok.tokenId == TokenID.Inc) || (this.tok.tokenId == TokenID.Dec))) {\n                    canAssign = false;\n                    var operand = ast;\n                    ast = new UnaryExpression((this.tok.tokenId == TokenID.Inc) ? NodeType.IncPost : NodeType.DecPost, operand);\n                    ast.limChar = this.scanner.pos;\n                    ast.minChar = operand.minChar;\n                    this.tok = this.scanner.scan();\n                }\n            }\n            for (; ;) {\n                tokenInfo = lookupToken(this.tok.tokenId);\n                if ((tokenInfo == undefined) || (tokenInfo.binopNodeType == NodeType.None)) {\n                    break;\n                }\n                if ((!allowIn) && (tokenInfo.binopNodeType == NodeType.In)) {\n                    break;\n                }\n                if (tokenInfo.binopPrecedence == OperatorPrecedence.Asg) {\n                    if (tokenInfo.binopPrecedence < minPrecedence) {\n                        break;\n                    }\n                    if (!canAssign) {\n                        this.reportParseError(\"illegal assignment\");\n                    }\n                }\n                else if (tokenInfo.binopPrecedence <= minPrecedence) {\n                    break;\n                }\n\n                // Precedence is high enough. Consume the operator token.\n                this.tok = this.scanner.scan();\n                canAssign = false;\n                if (tokenInfo.binopNodeType == NodeType.QMark) {\n                    this.prevExpr = ast;\n                    var qmarkNode = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                            OperatorPrecedence.Asg, allowIn,\n                                            TypeContext.NoTypes);\n\n                    // Do not hold onto the prevExpr handle\n                    this.prevExpr = null;\n\n                    // qmarkNode may end up being a FuncDecl, if the \'?\' token above marked\n                    // an optional parameter for a lambda\n                    if (!(qmarkNode.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>qmarkNode).fncFlags, FncFlags.IsFatArrowFunction))) {\n                        this.chkCurTok(TokenID.Colon, \"expected :\", errorRecoverySet |\n                                  ErrorRecoverySet.ExprStart);\n                        ast = new TrinaryExpression(NodeType.QMark, ast, qmarkNode,\n                                                  this.parseExpr(errorRecoverySet |\n                                                            ErrorRecoverySet.BinOp,\n                                                            OperatorPrecedence.Asg,\n                                                            allowIn, TypeContext.NoTypes));\n                    }\n                    else {\n                        ast = qmarkNode;\n                        exprIsAnonLambda = true;\n                    }\n                }\n                else {\n                    var tc = TypeContext.NoTypes;\n                    var binExpr2: BinaryExpression;\n\n                    binExpr2 = new BinaryExpression(tokenInfo.binopNodeType, ast,\n                                                    this.parseExpr(errorRecoverySet |\n                                                            ErrorRecoverySet.BinOp,\n                                                            tokenInfo.binopPrecedence,\n                                                            allowIn, TypeContext.NoTypes));\n                    if (binExpr2.operand2.nodeType == NodeType.FuncDecl) {\n                        var funcDecl: FuncDecl = binExpr2.operand2;\n                        funcDecl.hint = idHint;\n                    }\n\n                    binExpr2.minChar = ast.minChar;\n                    binExpr2.limChar = this.scanner.lastTokenLimChar();\n                    idHint = null;\n                    ast = binExpr2;\n                }\n            }\n            if (canAssign) {\n                ast.flags |= ASTFlags.Writeable;\n            }\n            if (!exprIsAnonLambda) {\n                ast.minChar = minChar;\n                ast.limChar = this.scanner.lastTokenLimChar();\n                ast.preComments = preComments;\n                ast.postComments = this.parseCommentsForLine(this.scanner.line);\n            }\n            return ast;\n        }\n\n        property parsePostfixOperators(errorRecoverySet: ErrorRecoverySet, ast: AST, allowCall: bool, inNew: bool,\n            typeContext: TypeContext, lhsMinChar: number, lhsLimChar: number): AST {\n            var count = 0;\n\n            if (ast != null) {\n                ast.minChar = lhsMinChar;\n                ast.limChar = lhsLimChar;\n            }\n\n            for (; ;) {\n                switch (this.tok.tokenId) {\n                    case TokenID.LParen:\n                        if (inNew) {\n                            var callExpr: CallExpression = ast;\n                            callExpr.args = this.parseArgList(errorRecoverySet);\n                            inNew = false;\n                        }\n                        else {\n                            if (!allowCall) {\n                                return ast;\n                            }\n                            ast = new CallExpression(NodeType.Call, ast,\n                                                   this.parseArgList(errorRecoverySet));\n                            ast.minChar = lhsMinChar;\n                        }\n                        this.chkCurTok(TokenID.RParen, \"expected \')\'\", errorRecoverySet);\n                        ast.limChar = this.scanner.pos;\n                        break;\n                    case TokenID.LBrack:\n                        this.tok = this.scanner.scan();\n                        if (this.tok.tokenId == TokenID.RBrack) {\n                            if (hasFlag(typeContext, TypeContext.ArraySuffix)) {\n                                this.tok = this.scanner.scan();\n                                if (ast.nodeType == NodeType.TypeRef) {\n                                    var typeRef: TypeReference = ast;\n                                    typeRef.arrayCount++;\n                                }\n                                else {\n                                    ast = new BinaryExpression(NodeType.Index, ast, null);\n                                }\n                                ast.limChar = this.scanner.pos;\n                                break; // note early exit from case\n                            }\n                        }\n\n                        ast = new BinaryExpression(NodeType.Index, ast,\n                                                 this.parseExpr(errorRecoverySet | ErrorRecoverySet.RBrack,\n                                                           OperatorPrecedence.No, true,\n                                                           TypeContext.NoTypes));\n                        ast.minChar = lhsMinChar;\n                        this.chkCurTok(TokenID.RBrack, \"expected \']\'\", errorRecoverySet);\n                        ast.limChar = this.scanner.pos;\n                        break;\n                    case TokenID.Dot: {\n                        var name: Identifier = null;\n                        var curpos = this.scanner.pos;\n                        this.tok = this.scanner.scan();\n                        // TODO: enable reserved words\n                        if ((this.tok.tokenId == TokenID.ID) || (!this.scanner.lastTokenHadNewline() && convertTokToIDName(this.tok))) {\n                            ast.flags |= ASTFlags.DotLHS;\n                            name = this.createRef(this.tok.getText(), this.scanner.startPos);\n                            name.limChar = this.scanner.pos;\n                            this.tok = this.scanner.scan();\n                        }\n                        else {\n                            this.reportParseError(\"expected identifier following dot\");\n                            if (this.errorRecovery) {\n                                this.skip(errorRecoverySet);\n                                ast.flags |= (ASTFlags.Error | ASTFlags.DotLHS);\n                                return ast;\n                            }\n                            else {\n                                name = new MissingIdentifier();\n                            }\n                        }\n                        ast = new BinaryExpression(NodeType.Dot, ast, name);\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.Arrow:\n                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: ast });\n                        (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    default:\n                        return ast;\n\n                }\n            }\n        }\n\n\n        property parseTry(tryNode: Try, errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): Try {\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.tok = this.scanner.scan();\n            if (this.tok.tokenId != TokenID.LCurly) {\n                this.reportParseError(\"expected \'{\'\");\n                if (this.errorRecovery) {\n                    var etryNode = tryNode;\n                    etryNode.minChar = minChar;\n                    etryNode.limChar = this.scanner.lastTokenLimChar();\n                    etryNode.flags |= ASTFlags.Error;\n                    return etryNode;\n                }\n            }\n            tryNode.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n            tryNode.minChar = minChar;\n            tryNode.limChar = tryNode.body.limChar;\n            tryNode.preComments = preComments;\n            tryNode.postComments = this.parseComments();\n            return tryNode;\n        }\n\n        property parseCatch(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): Catch {\n            var catchMinChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.tok = this.scanner.scan();\n            this.chkCurTok(TokenID.LParen, \"expected \'(\'\", errorRecoverySet |\n                        ErrorRecoverySet.ExprStart);\n            if ((this.tok.tokenId != TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                this.reportParseError(\"expected identifier in catch header\");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n            var param = new VarDecl(new Identifier(this.tok.getText()), this.nestingLevel);\n            param.id.minChar = this.scanner.startPos;\n            param.id.limChar = this.scanner.pos;\n            param.minChar = param.id.minChar;\n            param.limChar = param.id.limChar;\n            this.tok = this.scanner.scan();\n            this.chkCurTok(TokenID.RParen, \"expected \')\'\", errorRecoverySet |\n                        ErrorRecoverySet.StmtStart);\n            if (this.tok.tokenId != TokenID.LCurly) {\n                this.reportParseError(\"expected \'{\' to start catch body\");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n\n            var catchStmt = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n            var catchNode = new Catch(param, catchStmt);\n            catchNode.minChar = catchMinChar;\n            catchNode.limChar = catchStmt.limChar;\n            catchNode.preComments = preComments;\n            catchNode.postComments = this.parseComments();\n            return catchNode;\n        }\n\n        property parseFinally(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): Finally {\n            var finMinChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.tok = this.scanner.scan();\n            if (this.tok.tokenId != TokenID.LCurly) {\n                this.reportParseError(\"expected \'{\' to start body of finally statement\");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n                    var efin = new Finally(new Statement(NodeType.Empty));\n                    efin.flags |= ASTFlags.Error;\n                    efin.minChar = this.scanner.startPos;\n                    efin.limChar = this.scanner.pos;\n                    return efin;\n                }\n            }\n            var finBody = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers)\n            var fin = new Finally(finBody);\n            fin.minChar = finMinChar;\n            fin.limChar = fin.body.limChar;\n            fin.preComments = preComments;\n            fin.postComments = this.parseComments();\n            return fin;\n        }\n\n        property parseTryCatchFinally(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers, labelList: ASTList): AST {\n            var tryPart: AST = new Try(null);\n            var tryMinChar = this.scanner.startPos;\n            this.pushStmt(tryPart, labelList);\n            this.parseTry(tryPart, errorRecoverySet | ErrorRecoverySet.Catch, allowedElements, parentModifiers);\n            this.popStmt();\n            var tc: TryCatch = null;\n            var tf: TryFinally = null;\n            if (this.tok.tokenId == TokenID.CATCH) {\n                var catchPart = this.parseCatch(errorRecoverySet | ErrorRecoverySet.Catch, allowedElements, parentModifiers);\n                tc = new TryCatch(tryPart, catchPart);\n                tc.minChar = tryPart.minChar;\n                tc.limChar = catchPart.limChar;\n            }\n            if (this.tok.tokenId != TokenID.FINALLY) {\n                if (tc == null) {\n                    this.reportParseError(\"try with neither catch nor finally\");\n                    if (this.errorRecovery) {\n                        var etf = new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                        etf.flags |= ASTFlags.Error;\n                        etf.minChar = this.scanner.startPos;\n                        etf.limChar = this.scanner.pos;\n                        return etf;\n                    }\n                    return new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                }\n                else {\n                    return tc;\n                }\n            }\n            else {\n                if (tc != null) {\n                    tryPart = tc;\n                }\n                var finallyPart = this.parseFinally(errorRecoverySet, allowedElements, parentModifiers)\n                tf = new TryFinally(tryPart, finallyPart);\n                tf.minChar = tryMinChar;\n                tf.limChar = finallyPart.limChar;\n                return tf;\n            }\n        }\n\n        property parseStatement(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): AST {\n            var ast: AST = null;\n            var labelList: ASTList = null;\n            var astList: ASTList = null;\n            var temp: AST;\n            var modifiers = Modifiers.None;\n            var minChar = this.scanner.startPos;\n            var forInOk = false;\n            var needTerminator = false;\n            var fnOrVar: AST = null;\n            var preComments = this.parseComments();\n            this.state = ParseState.StartStatement;\n\n            function isAmbient() {\n                return hasFlag(modifiers, Modifiers.Ambient) || hasFlag(parentModifiers, Modifiers.Ambient);\n            }\n\n            function mayNotBeExported() {\n                if (hasFlag(modifiers, Modifiers.Exported)) {\n                    this.reportError(\"Statement may not be exported\");\n                }\n            }\n\n            for (; ;) {\n                switch (this.tok.tokenId) {\n                    case TokenID.EOF:\n                        ast = new AST(NodeType.Error);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.pos;\n                        break;\n                    case TokenID.FUNCTION:\n                        if (this.inStaticFnc) {\n                            this.reportParseError(\"Ambient static function delarations may only contain other ambient static function declarations\");\n                        }\n                        if (this.parsingDeclareFile || isAmbient() || this.ambientModule) {\n                            modifiers |= Modifiers.Public;\n                            this.tok = this.scanner.scan();\n                            fnOrVar = this.parsePropertyDecl(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                      modifiers, true, false);\n                            if (fnOrVar.nodeType == NodeType.VarDecl) {\n                                this.reportParseError(\"function keyword can only introduce function declaration\");\n                            }\n                            else if ((fnOrVar.nodeType == NodeType.FuncDecl) && ((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            ast = fnOrVar;\n                        }\n                        else {\n                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, isAmbient(), modifiers, null);\n                            if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            if (this.ambientModule) {\n                                this.reportParseError(\"function declaration not permitted within ambient module\");\n                            }\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        break;\n                    case TokenID.MODULE:\n                        if ((allowedElements & AllowedElements.ModuleDecls) == AllowedElements.None) {\n                            this.reportParseError(\"module not allowed in this context\");\n                            this.tok = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseModuleDecl(errorRecoverySet, modifiers);\n                        }\n                        break;\n                    case TokenID.IMPORT:\n                        if ((allowedElements & AllowedElements.ModuleDecls) == AllowedElements.None) {\n                            this.reportParseError(\"module not allowed in this context\");\n                            this.tok = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseImportDecl(errorRecoverySet, modifiers);\n                        }\n                        break;\n                    case TokenID.EXPORT:\n                        if ((allowedElements & AllowedElements.ModuleDecls) == AllowedElements.None) {\n                            this.reportParseError(\"\'export\' statements are only allowed at the global and module levels\");\n                            this.tok = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        if (this.topLevel) {\n                            this.hasTopLevelImportOrExport = true;\n                        }\n                        modifiers |= Modifiers.Exported;\n                        this.tok = this.scanner.scan();\n                        break;\n                    case TokenID.PRIVATE:\n                        modifiers |= Modifiers.Private;\n\n                        this.tok = this.scanner.scan();\n\n                        if (this.parsingES6ClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError(\"Property declarations are not permitted within constructor bodies\");\n                            }\n\n                            minChar = this.scanner.pos;\n                            if (this.inferPropertiesFromThisAssignment && (this.tok.tokenId != TokenID.THIS || (this.tok = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError(\"Expected \'this.\' for property declaration\");\n                                this.tok = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.tok = this.scanner.scan();\n\n                                var id = new Identifier(this.tok.getText());\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.tok = this.scanner.scan();\n                                ast = this.parseES6ClassMemberVariableDeclaration(id, minChar, this.parsingES6ClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if ((this.tok.tokenId != TokenID.OLDCLASS) && (this.tok.tokenId != TokenID.INTERFACE)) {\n                                if (this.tok.tokenId == TokenID.GET) {\n                                    this.prevIDTok = this.tok;\n                                    this.tok = this.scanner.scan();\n                                    if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.tok.tokenId == TokenID.SET) {\n                                    this.prevIDTok = this.tok;\n                                    this.tok = this.scanner.scan();\n                                    if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                fnOrVar = this.parsePropertyDecl(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                          modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && (hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.PROPERTY:\n                    case TokenID.PUBLIC:\n                        if (this.parsingES6ClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError(\"Property declarations are not permitted within constructor bodies\");\n                            }\n\n                            this.tok = this.scanner.scan(); \n                            minChar = this.scanner.pos;\n                            modifiers |= Modifiers.Public;\n                            if (this.inferPropertiesFromThisAssignment && (this.tok.tokenId != TokenID.THIS || (this.tok = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError(\"Expected \'this.\' for property declaration\");\n                                this.tok = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.tok = this.scanner.scan();\n\n                                var id = new Identifier(this.tok.getText());\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.tok = this.scanner.scan();\n                                ast = this.parseES6ClassMemberVariableDeclaration(id, minChar, this.parsingES6ClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if ((allowedElements & AllowedElements.Properties) == AllowedElements.None) {\n                                this.reportParseError(\"\'property\' statements are only allowed within classes\");\n                                this.tok = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                modifiers |= Modifiers.Public;\n                                this.tok = this.scanner.scan();\n                                if (this.tok.tokenId == TokenID.GET) {\n                                    this.prevIDTok = this.tok;\n                                    this.tok = this.scanner.scan();\n                                    if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.tok.tokenId == TokenID.SET) {\n                                    this.prevIDTok = this.tok;\n                                    this.tok = this.scanner.scan();\n                                    if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                fnOrVar = this.parsePropertyDecl(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                            modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.DECLARE:\n                        if (!(allowedElements & AllowedElements.AmbientDecls)) {\n                            this.reportParseError(\"Ambient declarations are only allowed at the top-level or module scopes\")\n                        }\n                        if (hasFlag(parentModifiers, Modifiers.Ambient)) {\n                            this.reportParseError(\"Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)\")\n                        }\n                        modifiers |= Modifiers.Ambient;\n                        this.tok = this.scanner.scan();\n                        break;\n                    case TokenID.OLDCLASS:\n                        if ((allowedElements & AllowedElements.ClassDecls) == AllowedElements.None) {\n                            this.reportParseError(\"class not allowed in this context\");\n                            this.tok = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers);\n                        }\n                        break;\n                    case TokenID.CLASS:\n                        if ((allowedElements & AllowedElements.ClassDecls) == AllowedElements.None) {\n                            this.reportParseError(\"class not allowed in this context\");\n                            this.tok = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseES6ClassDecl(errorRecoverySet, minChar, modifiers);\n                        }\n                        break;\n                    case TokenID.INTERFACE:\n                        if ((allowedElements & AllowedElements.InterfaceDecls) == AllowedElements.None) {\n                            this.reportParseError(\"interface not allowed in this context\");\n                            this.tok = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers);\n                        }\n                        break;\n                    case TokenID.VAR:\n                        var declAst: AST = this.parseVarDecl(errorRecoverySet | ErrorRecoverySet.StmtStart, modifiers,\n                                                     true, false, false);\n                        if (declAst.nodeType == NodeType.VarDecl) {\n                            ast = declAst;\n                        }\n                        else {\n                            ast = new Block(declAst, false);\n                        }\n                        needTerminator = true;\n                        if (this.ambientModule && ast.nodeType == NodeType.VarDecl) {\n                            (<VarDecl>ast).varFlags |= VarFlags.Exported;\n                        }\n                        break;\n                    case TokenID.STATIC:\n\n                        if (this.currentClassDecl == null && !this.inFnc) {\n                            this.reportParseError(\"Statics may only be in class or function bodies\");\n                        }\n                        mayNotBeExported();\n                        modifiers |= Modifiers.Public;\n                        this.tok = this.scanner.scan();\n                        if (this.tok.tokenId == TokenID.GET) {\n                            this.prevIDTok = this.tok;\n                            this.tok = this.scanner.scan();\n                            if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                                modifiers |= Modifiers.Getter;\n                                this.prevIDTok = null;\n                            }\n                        }\n                        else if (this.tok.tokenId == TokenID.SET) {\n                            this.tok = this.scanner.scan();\n                            if ((this.tok.tokenId == TokenID.ID) || convertTokToID(this.tok, this.strictMode)) {\n                                modifiers |= Modifiers.Setter;\n                            }\n                        }\n                        if (isAmbient()) {\n                            modifiers |= Modifiers.Ambient;\n                        }\n                        fnOrVar = this.parsePropertyDecl(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                  modifiers, this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None, true);\n\n                        var staticsList = this.topStaticsList();\n                        if (staticsList != null && fnOrVar.nodeType == NodeType.VarDecl) {\n                            staticsList.append(fnOrVar);\n                        }\n\n                        if (fnOrVar.nodeType == NodeType.VarDecl || ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                            needTerminator = true;\n                        }\n\n                        ast = fnOrVar;\n                        break;\n                    case TokenID.FOR:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"syntax error: for statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.chkNxtTok(TokenID.LParen, \"expected \'(\'\", errorRecoverySet |\n                                  ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n                        this.state = ParseState.ForInit;\n                        forInOk = true;\n                        switch (this.tok.tokenId) {\n                            case TokenID.VAR:\n                                temp = this.parseVarDecl(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                  ErrorRecoverySet.In, Modifiers.None, false, false, false);\n                                break;\n                            case TokenID.SColon:\n                                temp = null;\n                                this.state = ParseState.ForCondStart;\n                                break;\n                            default:\n                                temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                               ErrorRecoverySet.In, OperatorPrecedence.No, false,\n                                               TypeContext.NoTypes);\n                                break;\n                        }\n                        this.state = ParseState.ForInitAfterVar;\n                        if (this.tok.tokenId == TokenID.IN) {\n                            if ((temp == null) || (!forInOk)) {\n                                this.reportParseError(\"malformed for statement\");\n                                if (this.errorRecovery) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = new AST(NodeType.Empty);\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            else {\n                                this.tok = this.scanner.scan();\n                                var forInStmt = new ForInStatement(temp,\n                                                                 this.parseExpr(ErrorRecoverySet.RParen |\n                                                                           errorRecoverySet,\n                                                                           OperatorPrecedence.Cma,\n                                                                           false,\n                                                                           TypeContext.NoTypes));\n                                forInStmt.limChar = this.scanner.pos;\n                                this.chkCurTok(TokenID.RParen, \"expected \')\'\", ErrorRecoverySet.StmtStart |\n                                          errorRecoverySet);\n                                this.pushStmt(forInStmt, labelList);\n                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                                this.popStmt();\n                                forInStmt.minChar = minChar;\n                                ast = forInStmt;\n                            }\n                        }\n                        else {\n                            var forStmt: ForStatement = new ForStatement(temp);\n                            forStmt.minChar = minChar;\n                            this.chkCurTok(TokenID.SColon, \"expected \';\'\", errorRecoverySet);\n                            if (this.tok.tokenId == TokenID.SColon) {\n                                forStmt.cond = null;\n                            }\n                            else {\n                                forStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.No, true,\n                                                       TypeContext.NoTypes);\n                                if (this.tok.tokenId != TokenID.SColon) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = forStmt;\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            this.tok = this.scanner.scan();\n                            if (this.tok.tokenId == TokenID.RParen) {\n                                forStmt.incr = null;\n                            }\n                            else {\n                                forStmt.incr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.No, true,\n                                                       TypeContext.NoTypes);\n                            }\n                            this.chkCurTok(TokenID.RParen, \"expected \')\'\",\n                                      errorRecoverySet | ErrorRecoverySet.LCurly);\n                            this.pushStmt(forStmt, labelList);\n                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            this.popStmt();\n                            forStmt.limChar = forStmt.body.limChar;\n                            ast = forStmt;\n                        }\n                        break;\n                    case TokenID.WITH: {\n                        if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError(\"\'with\' statements are only available in ES5 codegen mode or better\");\n                        }\n\n                        if (this.strictMode) {\n                            this.reportParseError(\"\'with\' statements are not available in strict mode\");\n                        }\n\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"with statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.chkNxtTok(TokenID.LParen, \"expected \'(\'\", errorRecoverySet |\n                                  ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n\n                        var expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.No, true,\n                                                            TypeContext.NoTypes);\n                        this.chkCurTok(TokenID.RParen, \"expected \')\'\",\n                                      errorRecoverySet | ErrorRecoverySet.LCurly);\n\n                        var withStmt = new WithStatement(expr);\n                        withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        withStmt.minChar = minChar;\n                        withStmt.limChar = withStmt.body.limChar;\n                        ast = withStmt;\n                    }\n                        break;\n                    case TokenID.SWITCH: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"switch statement does not take modifiers\");\n                        }\n                        this.chkNxtTok(TokenID.LParen, \"expected \'(\'\", errorRecoverySet |\n                                  ErrorRecoverySet.ExprStart);\n\n                        var switchStmt = new SwitchStatement(this.parseExpr(errorRecoverySet |\n                                                                     ErrorRecoverySet.RParen,\n                                                                     OperatorPrecedence.No,\n                                                                     true,\n                                                                     TypeContext.NoTypes));\n                        this.chkCurTok(TokenID.RParen, \"expected \')\'\",\n                                  errorRecoverySet | ErrorRecoverySet.LCurly);\n                        var caseListMinChar = this.scanner.startPos;\n                        this.chkCurTok(TokenID.LCurly, \"expected \'{\'\",\n                                  errorRecoverySet | ErrorRecoverySet.SCase);\n                        switchStmt.defaultCase = null;\n                        switchStmt.caseList = new ASTList();\n                        var caseStmt: CaseStatement = null;\n                        this.pushStmt(switchStmt, labelList);\n                        for (; ;) {\n                            if ((this.tok.tokenId == TokenID.CASE) ||\n                                (this.tok.tokenId == TokenID.DEFAULT)) {\n                                var isDefault = (this.tok.tokenId == TokenID.DEFAULT);\n                                caseStmt = new CaseStatement();\n                                caseStmt.minChar = this.scanner.startPos;\n                                this.tok = this.scanner.scan();\n                                if (isDefault) {\n                                    switchStmt.defaultCase = caseStmt;\n                                }\n                                else {\n                                    caseStmt.expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.No, true,\n                                                            TypeContext.NoTypes);\n                                }\n                                this.chkCurTok(TokenID.Colon, \"expected \':\'\", errorRecoverySet |\n                                          ErrorRecoverySet.StmtStart);\n                                caseStmt.body = new ASTList();\n                                this.parseStmtList(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                              caseStmt.body, false, true, allowedElements, modifiers);\n                                caseStmt.limChar = caseStmt.body.limChar;\n                                switchStmt.caseList.append(caseStmt);\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        // end of switch statement\n                        switchStmt.caseList.minChar = caseListMinChar;\n                        switchStmt.caseList.limChar = this.scanner.pos;\n                        switchStmt.limChar = switchStmt.caseList.limChar;\n                        this.chkCurTok(TokenID.RCurly, \"expected \'}\'\", errorRecoverySet);\n                        this.popStmt();\n                        ast = switchStmt;\n                        break;\n                    }\n                    case TokenID.WHILE: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"while statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.chkNxtTok(TokenID.LParen, \"expected \'(\'\", ErrorRecoverySet.ExprStart |\n                                  errorRecoverySet);\n                        var whileStmt = new WhileStatement(this.parseExpr(errorRecoverySet |\n                                                                   ErrorRecoverySet.RParen,\n                                                                   OperatorPrecedence.No,\n                                                                   true, TypeContext.NoTypes));\n                        whileStmt.minChar = minChar;\n                        this.chkCurTok(TokenID.RParen, \"expected \')\'\", errorRecoverySet |\n                                  ErrorRecoverySet.StmtStart);\n                        this.pushStmt(whileStmt, labelList);\n                        whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        whileStmt.limChar = whileStmt.body.limChar;\n                        this.popStmt();\n                        ast = whileStmt;\n                        break;\n                    }\n                    case TokenID.DO: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"do statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        var doStmt = new DoWhileStatement();\n                        doStmt.minChar = minChar;\n                        this.pushStmt(doStmt, labelList);\n                        doStmt.body = this.parseStatement(errorRecoverySet | ErrorRecoverySet.While,\n                                                   allowedElements, parentModifiers);\n                        this.popStmt();\n                        doStmt.whileAST = new Identifier(\"while\");\n                        doStmt.whileAST.minChar = this.scanner.startPos;\n                        this.chkCurTok(TokenID.WHILE, \"expected \'while\'\", errorRecoverySet |\n                                  ErrorRecoverySet.LParen);\n                        doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;\n                        this.chkCurTok(TokenID.LParen, \"expected \'(\'\", errorRecoverySet |\n                                  ErrorRecoverySet.ExprStart);\n                        doStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                              OperatorPrecedence.No, true, TypeContext.NoTypes);\n                        doStmt.limChar = this.scanner.pos;\n                        this.chkCurTok(TokenID.RParen, \"expected \')\'\", errorRecoverySet);\n                        ast = doStmt;\n                        // compatibility; more strict would be to require the \';\'\n                        if (this.tok.tokenId == TokenID.SColon) {\n                            this.tok = this.scanner.scan();\n                        }\n                        break;\n                    }\n                    case TokenID.IF: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"if statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.chkNxtTok(TokenID.LParen, \"expected \'(\'\", errorRecoverySet |\n                                  ErrorRecoverySet.ExprStart);\n                        var ifStmt = new IfStatement(this.parseExpr(errorRecoverySet |\n                                                             ErrorRecoverySet.LParen,\n                                                             OperatorPrecedence.No, true,\n                                                             TypeContext.NoTypes));\n                        ifStmt.minChar = minChar;\n                        this.chkCurTok(TokenID.RParen, \"expected \')\'\", errorRecoverySet |\n                                  ErrorRecoverySet.StmtStart);\n                        this.pushStmt(ifStmt, labelList);\n                        ifStmt.thenBod = this.parseStatement(ErrorRecoverySet.Else | errorRecoverySet,\n                                                      allowedElements, parentModifiers);\n                        ifStmt.limChar = ifStmt.thenBod.limChar;\n                        if (this.tok.tokenId == TokenID.ELSE) {\n                            this.tok = this.scanner.scan();\n                            ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            ifStmt.limChar = ifStmt.elseBod.limChar;\n                        }\n                        this.popStmt();\n                        ast = ifStmt;\n                        break;\n                    }\n                    case TokenID.TRY: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"try statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        ast = this.parseTryCatchFinally(errorRecoverySet, AllowedElements.FunctionBody, parentModifiers, labelList);\n                        break;\n                    }\n                    case TokenID.LCurly: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"block does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        var block = new Block(new ASTList(), true);\n                        this.pushStmt(block, labelList);\n                        this.parseStmtList(errorRecoverySet | ErrorRecoverySet.RCurly, block.stmts, false, false,\n                                      AllowedElements.Block, modifiers);\n                        this.popStmt();\n                        block.stmts.minChar = minChar;\n                        block.stmts.limChar = this.scanner.pos;\n                        block.minChar = block.stmts.minChar;\n                        block.limChar = block.stmts.limChar;\n                        this.chkCurTok(TokenID.RCurly, \"expected \'}\'\", errorRecoverySet);\n                        ast = block;\n                        break;\n                    }\n                    case TokenID.SColon:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"modifier can not appear here\");\n                        }\n                        ast = new AST(NodeType.Empty);\n                        this.tok = this.scanner.scan();\n                        break;\n                    case TokenID.BREAK:\n                    case TokenID.CONTINUE: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"modifiers can not appear before jump statement\");\n                        }\n                        var jump =\n                            new Jump((this.tok.tokenId == TokenID.BREAK) ? NodeType.Break : NodeType.Continue);\n                        this.tok = this.scanner.scan();\n                        if ((this.tok.tokenId == TokenID.ID) && (!this.scanner.lastTokenHadNewline())) {\n                            // Labeled break or continue.\n                            jump.target = this.tok.getText();\n                            this.tok = this.scanner.scan();\n                        }\n                        this.resolveJumpTarget(jump);\n                        ast = jump;\n                        needTerminator = true;\n                        break;\n                    }\n                    case TokenID.RETURN: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"modifiers can not appear before return statement\");\n                        }\n                        if (!this.inFnc) {\n                            this.reportParseError(\"return statement outside of function body\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        var retStmt = new ReturnStatement();\n                        retStmt.minChar = minChar;\n                        if ((this.tok.tokenId != TokenID.SColon) &&\n                            (this.tok.tokenId != TokenID.RCurly) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            retStmt.returnExpression = this.parseExpr(errorRecoverySet |\n                                                               ErrorRecoverySet.SColon,\n                                                               OperatorPrecedence.No,\n                                                               true, TypeContext.NoTypes);\n                        }\n                        needTerminator = true;\n                        retStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = retStmt;\n                        break;\n                    }\n                    case TokenID.THROW:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"modifiers can not appear before a throw statement\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        if ((this.tok.tokenId != TokenID.SColon) &&\n                            (this.tok.tokenId != TokenID.RCurly) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                           OperatorPrecedence.No, true, TypeContext.NoTypes);\n                        }\n                        else {\n                            this.reportParseError(\"throw with no target\");\n                            temp = null;\n                        }\n                        ast = new UnaryExpression(NodeType.Throw, temp);\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        needTerminator = true;\n                        break;\n                    case TokenID.ENUM:\n                        // TODO: check module allowed here\n                        //minChar=scanner.startPos;\n                        this.tok = this.scanner.scan();\n                        ast = this.parseEnumDecl(errorRecoverySet, modifiers);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                            (<ModuleDecl>ast).modFlags |= ModuleFlags.Ambient;\n                        }\n                        if (hasFlag(modifiers, Modifiers.Exported)) {\n                            (<ModuleDecl>ast).modFlags |= ModuleFlags.Exported;\n                        }\n                        break;\n                    default:\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"modifiers can not appear before an expression statement or label\");\n                        }\n                        minChar = this.scanner.startPos;\n                        var svPos = this.scanner.pos;\n                        temp = this.parseExpr(ErrorRecoverySet.Colon | ErrorRecoverySet.StmtStart |\n                                       errorRecoverySet, OperatorPrecedence.No, true,\n                                       TypeContext.NoTypes);\n                        if (this.scanner.pos == svPos) {\n                            // no progress\n                            this.tok = this.scanner.scan();\n                            ast = temp;\n                        }\n                        else if ((this.tok.tokenId == TokenID.Colon) && (!this.scanner.lastTokenHadNewline()) &&\n                                        (temp != null) && (temp.nodeType == NodeType.Name)) {\n                                            // It\'s a label\n                            if (labelList == null) {\n                                labelList = new ASTList();\n                            }\n                            labelList.append(new Label(temp));\n                            this.tok = this.scanner.scan();\n                        }\n                        else {\n                            // expression statement\n                            ast = temp;\n                            needTerminator = true;\n                        }\n                }\n                if (ast != null) {\n                    break;\n                }\n            }\n            if (needTerminator) {\n                switch (this.tok.tokenId) {\n                    case TokenID.SColon:\n                        this.tok = this.scanner.scan();\n                        ast.flags |= ASTFlags.ExplicitSemicolon;\n                        break;\n                    case TokenID.EOF:\n                    case TokenID.RCurly:\n                        ast.flags |= ASTFlags.AutomaticSemicolon;\n                        if (this.style_requireSemi) {\n                            this.reportParseStyleError(\"no automatic semicolon\");\n                        }\n                        break;\n                    default:\n                        if (!this.scanner.lastTokenHadNewline()) {\n                            this.reportParseError(\"\';\' expected\");\n                        }\n                        else {\n                            ast.flags |= ASTFlags.AutomaticSemicolon;\n                            if (this.style_requireSemi) {\n                                this.reportParseStyleError(\"no automatic semicolon\");\n                            }\n                        }\n                        break;\n                }\n            }\n            if (labelList != null) {\n                ast = new LabeledStatement(labelList, ast);\n            }\n\n            ///////////////////////////////////////////////////////////\n            //TODO: Eventually, we want to remove \"minChar\" and \"limChar\" assignments here,\n            //      as they are sometimes not specific enough for each statement kind.\n            ast.minChar = minChar;\n            // Only update \"limChar\" if it is not better than \"lastTokenLimChar()\"\n            var scannerLimChar = this.scanner.lastTokenLimChar();\n            ast.limChar = (ast.limChar > scannerLimChar ? ast.limChar : scannerLimChar);\n            //\n            ///////////////////////////////////////////////////////////\n\n            ast.preComments = preComments;\n            if (this.ambientModule && (!this.okAmbientModuleMember(ast))) {\n                this.reportParseError(\"statement not permitted within ambient module\");\n            }\n            ast.flags |= ASTFlags.IsStatement;\n            return ast;\n        }\n\n        property okAmbientModuleMember(ast: AST) {\n            var nt = ast.nodeType;\n            return (nt == NodeType.Class) || (nt == NodeType.ES6Class) || (nt == NodeType.Import) || (nt == NodeType.Interface) || (nt == NodeType.Module) ||\n                ((nt == NodeType.VarDecl) && (hasFlag((<VarDecl>ast).varFlags, VarFlags.Property) || hasFlag((<VarDecl>ast).varFlags, VarFlags.Exported))) ||\n                ((nt == NodeType.FuncDecl) && ((<FuncDecl>ast).isMethod()));\n        }\n\n        property parseStmtList(errorRecoverySet: ErrorRecoverySet, stmts: ASTList, sourceElms: bool, noLeadingCase: bool,\n            allowedElements: AllowedElements, parentModifiers: Modifiers): void {\n            var directivePrologue = sourceElms;\n            stmts.minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var innerStmts = (allowedElements & AllowedElements.ModuleDecls) == AllowedElements.None;\n            var classNope = (allowedElements & AllowedElements.ClassDecls) == AllowedElements.None;\n\n            errorRecoverySet |= ErrorRecoverySet.StradaS;\n\n            this.state = ParseState.StartStmtList;\n            var oldStrictMode = this.strictMode;\n            this.nestingLevel++;\n            for (; ;) {\n                if ((this.tok.tokenId == TokenID.RCurly) ||\n                    (noLeadingCase && ((this.tok.tokenId == TokenID.CASE) || (this.tok.tokenId == TokenID.DEFAULT))) ||\n                    (innerStmts && (this.tok.tokenId == TokenID.EXPORT)) ||\n                    (classNope && (this.tok.tokenId == TokenID.CLASS)) || (classNope && (this.tok.tokenId == TokenID.OLDCLASS)) ||\n                    (this.tok.tokenId == TokenID.EOF)) {\n                    this.state = ParseState.EndStmtList;\n                    stmts.limChar = limChar;\n                    if (stmts.members.length == 0) {\n                        stmts.preComments = this.parseComments();\n                    }\n                    else {\n                        stmts.postComments = this.parseComments();\n                    }\n                    this.strictMode = oldStrictMode;\n                    this.nestingLevel--;\n                    return;\n                }\n\n                var stmt = this.parseStatement(errorRecoverySet &\n                                        (~(ErrorRecoverySet.Else | ErrorRecoverySet.RParen |\n                                           ErrorRecoverySet.Catch | ErrorRecoverySet.Colon)),\n                                        allowedElements, parentModifiers);\n\n\n                if (stmt != null) {\n                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    stmts.append(stmt);\n                    limChar = stmt.limChar;\n                    if (directivePrologue) {\n                        if (stmt.nodeType == NodeType.QString) {\n                            var qstring = <StringLiteral>stmt;\n                            if (qstring.text == \"use strict\") {\n                                stmts.flags |= ASTFlags.StrictMode;\n                                this.strictMode = true;\n                            }\n                            else {\n                                directivePrologue = false;\n                            }\n                        }\n                        else {\n                            directivePrologue = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        property fname = \"\";\n\n        property parseError = false;\n\n        property quickParse(sourceText: ISourceText, filename: string, unitIndex: number): QuickParseResult {\n            //TODO: REVIEW: We set this to avoid adding a \"module\" decl in the resulting script (see parse() method)\n            var svGenTarget = Tools.moduleGenTarget;\n            try {\n                Tools.moduleGenTarget = Tools.ModuleGenTarget.Local;\n                var script = this.parse(sourceText, filename, unitIndex, AllowedElements.QuickParse);\n                return new QuickParseResult(script, this.scanner.lexState);\n            }\n            finally {\n                Tools.moduleGenTarget = svGenTarget;\n            }\n        }\n\n        property parse(sourceText: ISourceText, filename: string, unitIndex: number, allowedElements = AllowedElements.Global): Script {\n            this.ambientModule = false;\n            this.topLevel = true;\n            this.parseError = false;\n            this.hasTopLevelImportOrExport = false;\n            this.fname = filename;\n            this.currentUnitIndex = unitIndex;\n\n            this.scanner.resetComments();\n            this.scanner.setSourceText(sourceText, LexMode.File);\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var minChar = this.scanner.pos;\n            this.tok = this.scanner.scan();\n            this.pushDeclLists();\n            var bod = new ASTList();\n            bod.minChar = minChar;\n\n            this.state = ParseState.StartScript;\n            this.parsingDeclareFile = filename.length > 6 && filename.substring(filename.length - 6, filename.length) == \".d.str\";\n\n            this.parseStmtList(ErrorRecoverySet.EOF | ErrorRecoverySet.Func,\n                            bod, true, false, allowedElements, Modifiers.None);\n            if (this.tok.tokenId != TokenID.EOF) {\n                var badToken: TokenInfo = tokenTable[this.tok.tokenId];\n                this.reportParseError(\"Unexpected statement block terminator \'\" + badToken.text + \"\'\");\n            }\n            this.state = ParseState.EndScript;\n\n            bod.limChar = this.scanner.pos;\n\n            var topLevelMod: ModuleDecl = null;\n            if (moduleGenTarget != ModuleGenTarget.Local && this.hasTopLevelImportOrExport) {\n                var correctedFileName = switchToForwardSlashes(filename);\n                var id: Identifier = new Identifier(correctedFileName);\n                topLevelMod = new ModuleDecl(id, bod, this.topVarList(), this.topScopeList());\n\n                topLevelMod.modFlags |= ModuleFlags.IsDynamic;\n                topLevelMod.modFlags |= ModuleFlags.IsWholeFile;\n                topLevelMod.modFlags |= ModuleFlags.Exported;\n\n                if (this.parsingDeclareFile) {\n                    topLevelMod.modFlags |= ModuleFlags.Ambient;\n                }\n\n                topLevelMod.minChar = minChar;\n                topLevelMod.limChar = this.scanner.pos;\n                topLevelMod.prettyName = getPrettyName(correctedFileName);\n\n                topLevelMod.amdDependencies = this.amdDependencies;\n\n                bod = new ASTList();\n                bod.minChar = topLevelMod.minChar;\n                bod.limChar = topLevelMod.limChar;\n                bod.append(topLevelMod);\n            }\n\n            var script = new Script(this.topVarList(), this.topScopeList());\n            script.bod = bod;\n            this.popDeclLists();\n            script.minChar = minChar;\n            script.limChar = this.scanner.pos;\n            script.locationInfo = new LocationInfo(filename, this.scanner.lineMap, unitIndex);\n            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            script.isDeclareFile = this.parsingDeclareFile;\n            script.topLevelMod = topLevelMod;\n            return script;\n        }\n    }\n\n    export function quickParse(logger: Tools.ILogger, scopeStartAST: AST, sourceText: ISourceText, minChar: number, limChar: number,\n        errorCapture: (minChar: number, charLen: number, message: string, unitIndex: number) => void ): QuickParseResult {\n\n        var fragment = sourceText.getText(minChar, limChar);\n        logger.log(\"Quick parse range (\" + minChar + \",\" + limChar + \"): \\\"\" + Tools.stringToLiteral(fragment, 100) + \"\\\"\");\n\n        var quickParser = new Parser();\n        quickParser.setErrorRecovery(null, -1, -1);\n        quickParser.errorCallback = errorCapture;\n\n        // REVIEW: use enclosing scope to determine this\n        var quickClassDecl = new TypeDecl(NodeType.Class, null, null, null, null, null);\n        quickParser.currentClassDecl = quickClassDecl;\n        //if (scopeStartAST.nodeType == NodeType.Class) {\n        //    quickParser.currentClassDecl = scopeStartAST;\n        //}\n        var result = quickParser.quickParse(new StringSourceText(fragment), \"\", 0);\n        return result;\n    }\n}\n\n\nmodule Tools {\n\n    // We need to catch both left and right quotes\n    // (depending on your editor\'s font, this may not be clear...)    \n    export function stripQuotes(str: string) {\n        return str.replace(\"\\\"\", \"\").replace(\"\'\", \"\").replace(\"\'\", \"\").replace(\"\\\"\", \"\")\n    }\n\n    export function isQuoted(str: string) {\n        return str.indexOf(\"\\\"\") != -1 || str.indexOf(\"\'\") != -1 || str.indexOf(\"\'\") != -1 || str.indexOf(\"\\\"\") != -1;\n    }\n\n    export function quoteStr(str: string) {\n        return \"\\\"\" + str + \"\\\"\";\n    }\n\n    export function swapQuotes(str: string) {\n\n        if (str.indexOf(\"\\\"\") != -1) {\n            str = str.replace(\"\\\"\", \"\'\");\n            str = str.replace(\"\\\"\", \"\'\");\n        }\n        else {\n            str = str.replace(\"\'\", \"\\\"\");\n            str = str.replace(\"\'\", \"\\\"\");\n        }\n\n        return str;\n    }\n\n    export function switchToForwardSlashes(path: string) {\n        return path.replace(/\\\\/g, \"/\");\n    }\n\n    export function trimModName(modName: string) {\n        if (modName.length > 4 && modName.substring(modName.length - 4, modName.length) == \".str\") {\n            modName = modName.substring(0, modName.length - 4);\n        }\n\n        // in case\'s it\'s a declare file...\n        if (modName.length > 2 && modName.substring(modName.length - 2, modName.length) == \".d\") {\n            modName = modName.substring(0, modName.length - 2);\n        }\n\n        return modName;\n    }\n\n    export function getPrettyName(modPath: string, quote?=true, treatAsFileName?=false) { \n        var modName = treatAsFileName ? modPath : trimModName(stripQuotes(modPath));\n        var components = modName.split(\"/\");\n        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;\n    }\n\n    export function quoteBaseName(modPath: string) {\n        var modName = trimModName(stripQuotes(modPath));\n        var path = getRootFilePath(modName);\n        if (path == \"\") {\n            return modPath;\n        }\n        else {\n            var components = modName.split(path);\n            var fileIndex = components.length > 1 ? 1 : 0;\n            return quoteStr(components[fileIndex]);\n        }\n    }\n\n    export function changePathToSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + \".str\";\n    }\n\n    export function changePathToDSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + \".d.str\";\n    }\n\n    export function isRelative(path: string) {\n        return path.charAt(0) == \".\";\n    }\n    export function isRooted(path: string) {\n        return path.charAt(0) == \"\\\\\" || path.charAt(0) == \"/\" || (path.indexOf(\":\\\\\") != -1) || (path.indexOf(\":/\") != -1);\n    }\n\n    export function getRootFilePath(outFname: string) {\n        if (outFname == \"\") {\n            return outFname;\n        }\n        else {\n            var isPath = outFname.indexOf(\"/\") != -1;\n            return isPath ? filePath(outFname) : \"\";\n        }\n    }\n\n    export function  filePath(fullPath: string) {\n        fullPath = switchToForwardSlashes(fullPath);\n        var components = fullPath.split(\"/\");\n        var path: string[] = components.slice(0, components.length - 1);\n        return path.join(\"/\") + \"/\";\n    }\n\n    export function normalizeURL(url: string): string {\n        var hostDomainAndPortRegex = /^(https?:\\/\\/[\\-\\w\\.]+(:\\d+)?\\/)(.*)$/i;\n        var matches = hostDomainAndPortRegex.exec(url);\n        if (matches) {\n            var hostDomainAndPort = matches[1];\n            var actualPath = matches[3];\n            return hostDomainAndPort + normalizePath(actualPath);\n        }\n        return normalizePath(url);\n    }\n\n    export var pathNormalizeRegExp = /\\//g;\n\n    export function normalizePath(path: string): string {\n        path = switchToForwardSlashes(path);\n        var startedWithSep = path.charAt(0) === \"/\";\n        var parts = path.split(\"/\");\n        for (var i = 0; i < parts.length; i++) {\n            if (parts[i] === \".\" || parts[i] === \"\") {\n                parts.splice(i, 1);\n                i--;\n            }\n            if (i > 0 && parts[i] === \"..\" && parts[i - 1] !== \"..\") {\n                parts.splice(i - 1, 2);\n                i -= 2;\n            }\n        }\n        return (startedWithSep ? \"/\" : \"\") + parts.join(\"/\");\n    }\n\n    export function normalizeImportPath(path: string): string {\n        return normalizePath(path);\n    }\n}\n\n\nmodule Tools {\n\n    ///\n    /// Compiler settings\n    ///\n\n    export oldclass StyleSettings() {\n        // bitwise operations not permitted\n        property bitwise = false;  \n        // disallow non-block statements as bodies of compound statements\n        property blockInCompoundStmt = false;\n        // disallow == and !=\n        property eqeqeq = false;\n        // require body of for in loop to start with a filter\n        property forin = false;\n        // empty blocks permitted\n        property emptyBlocks = true;\n        // require result of new expression to be used (no new just for side-effects)\n        property newMustBeUsed = false;\n        // require semicolons to terminate statements\n        property requireSemi = false;\n        // no top-level assignment in conditionals if (a=b) { ...\n        property assignmentInCond = false;\n        // no == null or != null\n        property eqnull = false;\n        // permit eval\n        property evalOK = true;\n        // permit var use if decl in inner scope as in if (c) { var v=10; } v=11;\n        property innerScopeDeclEscape = true;\n        // permit functions in loops\n        property funcInLoop = true;\n        // permit re-declaration of local variable \n        property reDeclareLocal = true;\n        // permit obj[\'x\'] in addition to obj.x\n        property literalSubscript = true;\n        // flag implicit \'any\'\n        property implicitAny = false;\n\n        property setOption(opt: string, val: bool): bool {\n            var optExists = this[opt];\n            if (optExists !== undefined) {\n                this[opt] = val;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        \n        property parseOptions(str: string) {\n            var opts=str.split(\";\");\n            for (var i = 0, len = opts.length; i < len; i++) {\n                var opt = opts[i];\n                var val = true;\n                var colonIndex=opt.lastIndexOf(\":\");\n                if (colonIndex >= 0) {\n                    var valStr = opt.substring(colonIndex+1);\n                    opt = opt.substring(0, colonIndex);\n                    if (valStr == \"off\") {\n                        val = false;\n                    }\n                }\n                if (!this.setOption(opt, val)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    export oldclass CompilationSettings() {\n        property styleSettings = new StyleSettings();\n        property emitTypes = false;\n        property propagateConstants = false;\n        property minWhitespace = false;\n        property parseOnly = false;\n        property outputMany = true;\n        property errorRecovery = false;\n        property emitComments = false;\n        property watch = false;\n        property exec = false;\n        property resolve = true;\n        property controlFlow = false;\n        property printControlFlow = false;\n        property controlFlowUseDef = false;\n        property errorOnWith = true;\n        property preprocess = true;\n        property propertiesRequireThis = true;\n\n        property inferPropertiesFromThisAssignment = false;\n\n        property codeGenTarget = CodeGenTarget.ES5;\n        property moduleGenTarget = ModuleGenTarget.Asynchronous;\n        property outputFileName: string = \"\";\n        property errorFileName: string = \"\";\n        property mapSourceFiles = false;\n\n        property setStyleOptions(str: string) {\n            this.styleSettings.parseOptions(str);\n        }\n        \n        property outputOne(outFile: string) {\n            this.outputFileName = outFile;\n            this.outputMany = false;\n        }\n    }\n\n    ///\n    /// Preprocessing\n    ///\n    export interface IPreProcessedFileInfo {\n        settings: CompilationSettings;\n        referencedFiles: IFileReference[];\n        importedFiles: IFileReference[];\n        isLibFile: bool;\n    }\n\n    function getFileReferenceFromReferencePath(comment: string): IFileReference {\n        var referencesRegEx = /^(\\/\\/\\/\\s*<reference\\s+path=)(\'|\")(.+?)\\2\\s*(static=(\'|\")(.+?)\\2\\s*)*\\/>/gim;\n        var match = referencesRegEx.exec(comment);\n\n        if (match != null) {\n            var path: string = normalizePath(match[3]);\n            var adjustedPath = normalizePath(path);\n    \n            var isResident = match.length >= 7 && match[6] == \"true\";\n            if (isResident) {\n                CompilerDiagnostics.debugPrint(path + \" is resident\");\n            }\n            return { minChar: 0, limChar: 0, path: switchToForwardSlashes(adjustedPath), isResident: isResident };\n        }\n        else {\n            return null;\n        }\n    }\n\n    // used in the parser, but kept here in case we want to reintegrate it with preprocessing\n    export function getAdditionalDependencyPath(comment: string): string {\n        var referencesRegEx = /^(\\/\\/\\/\\s*<amd-dependency\\s+path=)(\'|\")(.+?)\\2\\s*(static=(\'|\")(.+?)\\2\\s*)*\\/>/gim;\n        var match = referencesRegEx.exec(comment);\n\n        if (match != null) {\n            var path: string = match[3];\n            return path;\n        }\n        else {\n            return null;\n        }\n    }\n\n    export function getStyleSettings(comment: string, styleSettings: StyleSettings) {\n        var styleRegEx = /^(\\/\\/\\/\\s*<style\\s+)(([a-zA-Z])+=(\'|\").+(\'|\"))\\s*\\/>/gim;\n\n        var settings = styleRegEx.exec(comment);\n\n        if (settings) {\n            var settingsRegEx = /^([a-zA-Z]+=[\'\"]on[\'|\"])/gim;\n            settings = settingsRegEx.exec(settings[2]);\n                \n            if (settings) {\n                for (var i = 0; i < settings.length; i++) {\n                    var setting = (<string>settings[i]).split(\"=\");\n                    var on = \"\\\"on\\\"\";\n\n                    switch (setting[0]) {\n                        case \"blockInCompoundStmt\": styleSettings.blockInCompoundStmt = setting[1] == on; break;\n                        case \"eqeqeq\": styleSettings.eqeqeq = setting[1] == on; break;\n                        case \"forin\": styleSettings.forin = setting[1] == on; break;\n                        case \"emptyBlocks\": styleSettings.emptyBlocks = setting[1] == on; break;\n                        case \"newMustBeUsed\": styleSettings.newMustBeUsed = setting[1] == on; break;\n                        case \"requireSemi\": styleSettings.requireSemi = setting[1] == on; break;\n                        case \"assignmentInCond\": styleSettings.assignmentInCond = setting[1] == on; break;\n                        case \"eqnull\": styleSettings.eqnull = setting[1] == on; break;\n                        case \"evalOK\": styleSettings.evalOK = setting[1] == on; break;\n                        case \"innerScopeDeclEscape\": styleSettings.innerScopeDeclEscape = setting[1] == on; break;\n                        case \"funcInLoop\": styleSettings.funcInLoop = setting[1] == on; break;\n                        case \"reDeclareLocal\": styleSettings.reDeclareLocal = setting[1] == on; break;\n                        case \"literalSubscript\": styleSettings.literalSubscript = setting[1] == on; break;\n                        case \"implicitAny\": styleSettings.implicitAny = setting[1] == on; break;                               \n                    }\n                }\n            }\n        }\n    }\n\n    export function preProcessFile(sourceText: ISourceText, options=new CompilationSettings()): IPreProcessedFileInfo {\n        var scanner = new Scanner();\n        scanner.resetComments();\n        scanner.setSourceText(sourceText, LexMode.File);\n\n        var tok: Token = scanner.scan();\n        var comments: CommentToken[] = [];\n        var comment: CommentToken = null;\n        var leftCurlies: Token[] = [];\n\n        var settings: CompilationSettings = options;\n        var referencedFiles: IFileReference[] = [];\n        var importedFiles: IFileReference[] = [];\n        var isLibFile: bool = false;\n\n        // only search out dynamic mods\n        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies\n\n        while (tok.tokenId != TokenID.EOF) {\n\n            if (tok.tokenId == TokenID.IMPORT) {\n\n                tok = scanner.scan();\n\n                if (tok.tokenId == TokenID.ID || convertTokToID(tok, false)) {\n                    tok = scanner.scan();\n\n                    if (tok.tokenId == TokenID.Asg) {\n                        tok = scanner.scan();\n\n                        if (tok.tokenId == TokenID.MODULE) {\n                            tok = scanner.scan();\n                            if (tok.tokenId == TokenID.LParen) {\n                                tok = scanner.scan();\n\n                                // import foo = module(\"foo\")\n                                if (tok.tokenId == TokenID.QString) {\n                                    var ref = { minChar: scanner.startPos, limChar: scanner.pos, path: stripQuotes(switchToForwardSlashes(tok.getText())), isResident: false };\n                                    importedFiles.push(ref);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (tok.tokenId == TokenID.LCurly) {\n                leftCurlies.push(tok);\n            }\n\n            if (tok.tokenId == TokenID.RCurly) {\n                leftCurlies.pop();\n            }\n\n            tok = scanner.scan();\n        }\n\n        // deal with comment references, amd dependencies and style settings\n        // REVIEW: We could potentially do this inline with the above, if we\n        // set Scanner::scanComments to \'true\'\n        comments = scanner.getComments();\n\n        for (var iComment = 0; iComment < comments.length; iComment++) {\n            comment = comments[iComment];\n            \n            if (!comment.isBlock) {\n                var referencedCode = getFileReferenceFromReferencePath(comment.getText());\n                if (referencedCode != null) {\n                    referencedCode.minChar = comment.startPos;\n                    referencedCode.limChar = referencedCode.minChar + comment.value.length;\n                    referencedFiles.push(referencedCode);\n                }\n\n                getStyleSettings(comment.getText(), settings.styleSettings);\n\n                // is it a lib file?\n                var isNoLibRegex = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib=)(\'|\")(.+?)\\2\\s*\\/>/gim;\n                var isNoLibMatch: any = isNoLibRegex.exec(comment.getText());\n                isLibFile = isNoLibMatch != null && isNoLibMatch[3] == \"true\";\n            }\n        }\n\n        return { settings: settings, referencedFiles: referencedFiles, importedFiles: importedFiles, isLibFile: isLibFile };\n    }\n\n} // Tools\n\n\nmodule Tools {\n    // TODO: refactor indent logic for use in emit\n    export oldclass PrintContext(property outfile: ITextWriter, property parser: Parser) extends BaseWalkContext {\n        property builder = \"\";\n        property indent1 = \"  \";\n        property indentStrings: string[] = [];\n        property indentAmt = 0;\n\n        property increaseIndent() {\n            this.indentAmt++;\n        }\n\n        property decreaseIndent() {\n            this.indentAmt--;\n        }\n\n        property startLine() {\n            if (this.builder.length > 0) {\n                CompilerDiagnostics.Alert(this.builder);\n            }\n            var indentString = this.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = \"\";\n                for (var i = 0; i < this.indentAmt; i++) {\n                    indentString += this.indent1;\n                }\n                this.indentStrings[this.indentAmt] = indentString;\n            }\n            this.builder += indentString;\n        }\n\n        property write(s) {\n            this.builder += s;\n        }\n\n        property writeLine(s) {\n            this.builder += s;\n            this.outfile.WriteLine(this.builder);\n            this.builder = \"\";\n        }\n\n    }\n\n    export function prePrintAST(ast: AST, parent: AST, context: IWalkContext) {\n        var pc: PrintContext = context;\n        ast.print(pc);\n        pc.increaseIndent();\n        return ast;\n    }\n\n    export function postPrintAST(ast: AST, parent: AST, context: IWalkContext) {\n        var pc: PrintContext = context;\n        pc.decreaseIndent();\n        return ast;\n    }\n}\n\n\nmodule Tools {\n\n    export interface IResolvedFile {\n        content: string;\n        path: string;\n    }\n\n    ///\n    /// This class acts as a convenience class to store path and content information in places\n    /// where we need an ISourceText object\n    ///\n    export class SourceUnit implements ISourceText, IResolvedFile {\n        constructor(public path: string, public content: string) {\n        }\n\n        public getText(start: number, end: number): string { return this.content.substring(start, end); }\n        public getLength(): number { return this.content.length; }\n    }\n\n    export interface IFileReference {\n        minChar: number;\n        limChar: number;\n        path: string;\n        isResident: bool;\n    }\n\n    /// Limited API for file system manipulation\n    export interface IFileSystemObject {\n        resolvePath(path: string): string;\n        readFile(path: string): string;\n        findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n        dirName(path: string): string;\n    }\n\n    export oldclass CompilationEnvironment(property compilationSettings: CompilationSettings, property ioHost: IFileSystemObject) {\n        property residentCode: SourceUnit[] = [];\n        property code: SourceUnit[] = [];\n    }\n\n    export interface IResolutionDispatcher {\n        postResolutionError(errorFile: string, errorMessage: string, errorObject: any): void;\n        postResolution(path: string, source: ISourceText): void;\n    }\n\n    export interface ICodeResolver {\n        resolveCode(referencePath: string, rootPath: string, performSearch:bool, state: IResolutionDispatcher): void;\n    }\n\n    export interface IResolverHost {\n        resolveCompilationEnvironment(preEnvironment: CompilationEnvironment, resolver: ICodeResolver, traceDependencies: bool): CompilationEnvironment;\n    }\n\n    export oldclass CodeResolver(property environment: CompilationEnvironment) implements Tools.ICodeResolver {\n\n        property visited: any = { };\n\n        property resolveCode(referencePath: string, parentPath: string, performSearch: bool, resolutionDispatcher: Tools.IResolutionDispatcher): void {\n            \n            var resolvedFile = {content: \"\", path: referencePath };\n            \n            var ioHost = this.environment.ioHost;\n            \n            // If the path is relative, normalize it, based on the root\n            var isRelativePath = Tools.isRelative(referencePath);\n            var isRootedPath = isRelativePath ? false : isRooted(referencePath);\n            var normalizedPath: string = \n                isRelativePath ? ioHost.resolvePath(parentPath + \"/\" + referencePath) : \n                // we only follow the second clause if the path is a non-rooted triple-slash reference path\n                (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + \"/\" + referencePath);\n            if (normalizedPath.substring(normalizedPath.length - 4, normalizedPath.length) != \".str\") {\n                normalizedPath += \".str\";\n            }\n\n            normalizedPath = switchToForwardSlashes(stripQuotes(normalizedPath));\n\n            // read the file contents - if it doesn\'t exist, trigger a resolution error\n            if (!this.visited[normalizedPath]) {\n\n                // if the path is relative, or came from a reference tag, we don\'t perform a search\n                if (isRelativePath || isRootedPath || !performSearch) {\n                    try {\n                        CompilerDiagnostics.debugPrint(\"   Reading code from \" + normalizedPath);\n                            \n                        // Look for the .str first - if not present, use the .d.str\n                        try {\n                            resolvedFile.content = ioHost.readFile(normalizedPath);\n                        }\n                        catch (err) {\n                            normalizedPath = changePathToDSTR(normalizedPath);\n                            CompilerDiagnostics.debugPrint(\"   Reading code from \" + normalizedPath);\n\n                            resolvedFile.content = ioHost.readFile(normalizedPath);\n                        }\n                        CompilerDiagnostics.debugPrint(\"   Found code at \" + normalizedPath);\n\n                        resolvedFile.path = normalizedPath;\n                        this.visited[resolvedFile.path] = true;\n                    }\n                    catch (err) {\n                        CompilerDiagnostics.debugPrint(\"   Did not find code for \" + referencePath);\n                    }\n                }\n                else {\n\n                    // if the path is non-relative, we should attempt to search on the relative path\n                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n\n                    if (!resolvedFile) {\n                        normalizedPath = changePathToDSTR(normalizedPath);\n                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                    }\n\n                    if (resolvedFile) {\n                        resolvedFile.path = switchToForwardSlashes(Tools.stripQuotes(resolvedFile.path));\n                        CompilerDiagnostics.debugPrint(referencePath + \" resolved to: \" + resolvedFile.path);\n                        resolvedFile.content = resolvedFile.content;\n                        this.visited[resolvedFile.path] = true;\n                    }\n                    else {\n                        CompilerDiagnostics.debugPrint(\"Could not find \" + referencePath);\n                    }\n                }\n\n                if (resolvedFile && resolvedFile.content) {\n                    // preprocess the file, to gather dependencies\n                    var rootDir = ioHost.dirName(resolvedFile.path);\n                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);\n                    var preProcessedFileInfo = preProcessFile(sourceUnit, this.environment.compilationSettings);\n\n                    // resolve explicit references\n                    for (var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {\n                        var referencedFile = preProcessedFileInfo.referencedFiles[i];\n                        var normalizedPath = isRooted(referencedFile.path) ? referencedFile.path : rootDir + \"/\" + referencedFile.path;\n                        normalizedPath = ioHost.resolvePath(normalizedPath);\n                        if (referencePath == normalizedPath) {\n                            resolutionDispatcher.postResolutionError(normalizedPath, \"File contains reference to itself\", null);\n                            continue;\n                        }\n                        this.resolveCode(referencedFile.path, rootDir, false, resolutionDispatcher);\n                    }\n                    \n                    // resolve imports\n                    for (var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {\n                        this.resolveCode(preProcessedFileInfo.importedFiles[i].path, rootDir, true, resolutionDispatcher);\n                    }\n\n                    // add the file to the appropriate code list\n                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);\n                }\n            }\n        }\n    }\n}\n\n\nmodule Tools {\n\n    export var LexEOF = (-1);\n\n    export var LexCodeNWL = 0x0A;\n    export var LexCodeRET = 0x0D;\n    export var LexCodeTAB = 0x09;\n    export var LexCodeVTAB = 0x0B;\n    export var LexCode_e = \'e\'.charCodeAt(0);\n    export var LexCode_E = \'E\'.charCodeAt(0);\n    export var LexCode_x = \'x\'.charCodeAt(0);\n    export var LexCode_X = \'X\'.charCodeAt(0);\n    export var LexCode_a = \'a\'.charCodeAt(0);\n    export var LexCode_A = \'A\'.charCodeAt(0);\n    export var LexCode_f = \'f\'.charCodeAt(0);\n    export var LexCode_F = \'F\'.charCodeAt(0);\n\n    export var LexCode_g = \'g\'.charCodeAt(0);\n    export var LexCode_m = \'m\'.charCodeAt(0);\n    export var LexCode_i = \'i\'.charCodeAt(0);\n\n    export var LexCode_0 = \'0\'.charCodeAt(0);\n    export var LexCode_9 = \'9\'.charCodeAt(0);\n    export var LexCode_8 = \'8\'.charCodeAt(0);\n    export var LexCode_7 = \'7\'.charCodeAt(0);\n\n    export var LexCodeBSL = \'\\\\\'.charCodeAt(0);\n    export var LexCodeSHP = \'#\'.charCodeAt(0);\n    export var LexCodeBNG = \'!\'.charCodeAt(0);\n    export var LexCodeQUO = \'\"\'.charCodeAt(0);\n    export var LexCodeAPO = \'\\\'\'.charCodeAt(0);\n    export var LexCodePCT = \'%\'.charCodeAt(0);\n    export var LexCodeAMP = \'&\'.charCodeAt(0);\n    export var LexCodeLPR = \'(\'.charCodeAt(0);\n    export var LexCodeRPR = \')\'.charCodeAt(0);\n    export var LexCodePLS = \'+\'.charCodeAt(0);\n    export var LexCodeMIN = \'-\'.charCodeAt(0);\n    export var LexCodeMUL = \'*\'.charCodeAt(0);\n    export var LexCodeSLH = \'/\'.charCodeAt(0);\n    export var LexCodeXOR = \'^\'.charCodeAt(0);\n    export var LexCodeCMA = \',\'.charCodeAt(0);\n    export var LexCodeDOT = \'.\'.charCodeAt(0);\n    export var LexCodeLT = \'<\'.charCodeAt(0);\n    export var LexCodeEQ = \'=\'.charCodeAt(0);\n    export var LexCodeGT = \'>\'.charCodeAt(0);\n    export var LexCodeQUE = \'?\'.charCodeAt(0);\n    export var LexCodeLBR = \'[\'.charCodeAt(0);\n    export var LexCodeRBR = \']\'.charCodeAt(0);\n    export var LexCodeUSC = \'_\'.charCodeAt(0);\n    export var LexCodeLC = \'{\'.charCodeAt(0);\n    export var LexCodeRC = \'}\'.charCodeAt(0);\n    export var LexCodeBAR = \'|\'.charCodeAt(0);\n    export var LexCodeTIL = \'~\'.charCodeAt(0);\n    export var LexCodeCOL = \':\'.charCodeAt(0);\n    export var LexCodeSMC = \';\'.charCodeAt(0);\n    export var LexCodeUnderscore = \'_\'.charCodeAt(0);\n    export var LexCodeDollar = \'$\'.charCodeAt(0);\n    export var LexCodeSpace = 32;\n\n    export var LexKeywordTable = undefined;\n    // TODO: use new Token[128];\n    var autoToken: Token[] = new Array(128);\n    var lexIdStartTable: bool[] = new Array(128);\n\n    export function LexInitialize() {\n        initializeStaticTokens();\n        autoToken[LexCodeLPR] = staticTokens[TokenID.LParen];\n        autoToken[LexCodeRPR] = staticTokens[TokenID.RParen];\n        autoToken[LexCodeCMA] = staticTokens[TokenID.Comma];\n        autoToken[LexCodeSMC] = staticTokens[TokenID.SColon];\n        autoToken[LexCodeLBR] = staticTokens[TokenID.LBrack];\n        autoToken[LexCodeRBR] = staticTokens[TokenID.RBrack];\n        autoToken[LexCodeTIL] = staticTokens[TokenID.Tilde];\n        autoToken[LexCodeQUE] = staticTokens[TokenID.QMark];\n        autoToken[LexCodeLC] = staticTokens[TokenID.LCurly];\n        autoToken[LexCodeRC] = staticTokens[TokenID.RCurly];\n        autoToken[LexCodeCOL] = staticTokens[TokenID.Colon];\n        LexKeywordTable = new StringHashTable();\n        for (var i in (<any>TokenID)._map) {\n            if (i <= TokenID.LimKeyword) {\n                LexKeywordTable.add((<any>TokenID)._map[i].toLowerCase(), i);\n            }\n        }\n        for (var j = 0; j < 128; j++) {\n            if (LexIsIdentifierStartChar(j)) {\n                lexIdStartTable[j] = true;\n            }\n            else {\n                lexIdStartTable[j] = false;\n            }\n        }\n    }\n\n    export function LexAdjustIndent(code, indentAmt) {\n        if ((code == LexCodeLBR) || (code == LexCodeLC) || (code == LexCodeLPR)) {\n            return indentAmt + 1;\n        }\n        else if ((code == LexCodeRBR) || (code == LexCodeRC) || (code == LexCodeRPR)) {\n            return indentAmt - 1;\n        }\n        else return indentAmt;\n    }\n\n    export function LexIsIdentifierStartChar(code): bool {\n        return (((code >= 97) && (code <= 122)) ||\n                ((code >= 65) && (code <= 90)) ||\n                (code == LexCodeDollar) ||\n                (code == LexCodeUnderscore));\n    }\n\n    export function LexIsDigit(code): bool {\n        return ((code >= 48) && (code <= 57));\n    }\n\n    export function LexIsIdentifierChar(code) {\n        return lexIdStartTable[code] || LexIsDigit(code);\n    }\n\n    export function LexMatchingOpen(code) {\n        if (code == LexCodeRBR)\n            return LexCodeLBR;\n        else if (code == LexCodeRC)\n            return LexCodeLC;\n        else if (code == LexCodeRPR)\n            return LexCodeLPR;\n        else return 0;\n    }\n\n    export enum NumberScanState {\n        Start,\n        InFraction,\n        InExponent\n    }\n\n    export enum LexState {\n        Start,\n        InMultilineComment,\n    }\n\n    export enum LexMode {\n        Line,\n        File,\n    }\n\n    export enum CommentStyle {\n        Line,\n        Block\n    }\n\n    // Represent a piece of source code which can be read in multiple segments\n    export interface ISourceText {\n        getText(start: number, end: number): string;\n        getLength(): number;\n    }\n\n    // Implementation on top of a contiguous string\n    export oldclass StringSourceText(property text: string) implements ISourceText {\n        property getText(start: number, end: number): string {\n            return this.text.substring(start, end);\n        }\n        property getLength(): number {\n            return this.text.length;\n        }\n    }\n\n    export class SourceTextSegment implements ISourceTextSegment {\n        constructor(public segmentStart: number,\n                    public segmentEnd: number,\n                    public segment: string) {\n        }\n\n        charCodeAt(index: number): number {\n            return this.segment.charCodeAt(index - this.segmentStart);\n        }\n\n        substring(start: number, end: number): string {\n            return this.segment.substring(start - this.segmentStart, end - this.segmentStart);\n        }\n    }\n\n    export oldclass AggerateSourceTextSegment(\n        property seg1: SourceTextSegment,\n        property seg2: SourceTextSegment) implements ISourceTextSegment {\n\n        property charCodeAt(index: number): number {\n            if (this.seg1.segmentStart <= index && index < this.seg1.segmentEnd)\n                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart);\n\n            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart);\n        }\n\n        property substring(start: number, end: number): string {\n            if (this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd)\n                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart);\n\n            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substring(0, end - this.seg1.segmentStart);\n        }\n    }\n\n    export interface ISourceTextSegment {\n        charCodeAt(index: number): number;\n        substring(start: number, end: number): string;\n    }\n\n    export oldclass ScannerTextStream(property sourceText: ISourceText) {\n        static emptySegment = new SourceTextSegment(0, 0, \"\");\n        property agg = new AggerateSourceTextSegment(emptySegment, emptySegment);\n        property len: number = this.sourceText.getLength();\n\n        property max(a: number, b: number): number {\n            return a >= b ? a : b;\n        }\n\n        property min(a: number, b: number): number {\n            return a <= b ? a : b;\n        }\n\n        property fetchSegment(start: number, end: number): ISourceTextSegment {\n            // Common case\n            if (this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg.seg1;\n\n            // Common overlap case\n            if (this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg;\n\n            // if overlapping outside of fetched segment(s), fetch a new segment\n            var prev = this.agg.seg1;\n\n            var s = prev.segmentEnd;\n            var e = max(s + 512, end); // ensure we move forward at least 512 characters or \"end\"\n            e = min(e, this.len);    // but don\'t go past the end of the source text\n\n            var src = this.sourceText.getText(s, e);\n            var newSeg = new SourceTextSegment(s, e, src);\n            this.agg.seg2 = prev;\n            this.agg.seg1 = newSeg;\n            return this.agg;\n        }\n\n        property charCodeAt(index: number): number {\n            return this.fetchSegment(index, index + 1).charCodeAt(index);\n        }\n\n        property substring(start: number, end: number) {\n            return this.fetchSegment(start, end).substring(start, end);\n        }\n    }\n\n    export interface IScanner {\n        startPos: number;\n        pos: number;\n        scan(): Token;\n        previousToken(): Token;\n        prevLine: number;\n        line: number;\n        col: number;\n        leftCurlyCount: number;\n        rightCurlyCount: number;\n        lastTokenLimChar(): number;\n        lastTokenHadNewline(): bool;\n        lexState: number;\n        getComments(): CommentToken[];\n        getCommentsForLine(line: number): CommentToken[];\n        resetComments();\n        lineMap: number[];\n        setSourceText(newSrc: ISourceText, textMode: number);\n    }\n\n    export oldclass SavedTokens() implements IScanner {\n        property prevToken: Token = null;\n        property curSavedToken: SavedToken = null;\n        property prevSavedToken: SavedToken = null;\n        property currentTokenIndex: number;\n        property currentTokens: SavedToken[];\n        property tokensByLine: SavedToken[][];\n        property lexStateByLine: LexState[];\n        private prevToken: SavedToken = null;\n        property previousToken(): Token { return this.prevToken; }\n        property currentToken = 0;\n        property tokens = new SavedToken[];\n        property startPos: number;\n        property pos: number;\n\n        property close() {\n            this.currentToken = 0;\n        }\n\n        property addToken(tok: Token, scanner: IScanner) {\n            this.tokens[this.currentToken++] = new SavedToken(tok, scanner.startPos, scanner.pos);\n        }\n\n        property scan(): Token {\n            // TODO: curly count\n            this.startLine = this.line;\n            this.startPos = this.col;\n            if (this.currentTokenIndex == this.currentTokens.length) {\n                if (this.line < this.lineMap.length) {\n                    this.line++;\n                    this.col = 0;\n                    this.currentTokenIndex = 0;\n                    this.currentTokens = this.tokensByLine[this.line];\n                }\n                else {\n                    return staticTokens[TokenID.EOF];\n                }\n            }\n            if (this.currentTokenIndex < this.currentTokens.length) {\n                this.prevToken = this.curSavedToken.tok;\n                this.prevSavedToken = this.curSavedToken;\n                this.curSavedToken = this.currentTokens[this.currentTokenIndex++];\n                var curToken = this.curSavedToken.tok;\n                this.pos = this.curSavedToken.limChar;\n                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar);\n                this.startPos = this.curSavedToken.minChar;\n                this.prevLine = this.line;\n                return curToken;\n            }\n            else {\n                return staticTokens[TokenID.EOF];\n            }\n        }\n        property startLine: number;\n        property prevLine = 1;\n        property line = 1;\n        property col = 0;\n        property leftCurlyCount: number;\n        property rightCurlyCount: number;\n\n        property syncToTok(offset: number): number {\n            this.line = getLineNumberFromPosition(this.lineMap, offset);\n            this.currentTokenIndex = 0;\n            var tmpCol = offset - this.lineMap[this.line];\n            while ((this.lexStateByLine[this.line] == LexState.InMultilineComment) && (this.line > 0)) {\n                this.line--;\n                tmpCol = 0;\n            }\n            var lenMin1 = this.lineMap.length - 1;\n            this.currentTokens = this.tokensByLine[this.line];\n            while ((this.currentTokens.length == 0) && (this.line < lenMin1)) {\n                this.line++;\n                this.currentTokens = this.tokensByLine[this.line];\n                tmpCol = 0;\n            }\n            if (this.line <= lenMin1) {\n                while ((this.currentTokenIndex < this.currentTokens.length) &&\n                       (tmpCol > this.currentTokens[this.currentTokenIndex].limChar)) {\n                    this.currentTokenIndex++;\n                }\n                if (this.currentTokenIndex < this.currentTokens.length) {\n                    this.col = this.currentTokens[this.currentTokenIndex].minChar;\n                    return this.col + this.lineMap[this.line];\n                }\n            }\n            return -1;\n        }\n\n        property lastTokenLimChar(): number {\n            if (this.prevSavedToken !== null) {\n                return this.prevSavedToken.limChar;\n            }\n            else {\n                return 0;\n            }\n        }\n\n        property lastTokenHadNewline(): bool {\n            return this.prevLine != this.startLine;\n        }\n\n        property lexState = LexState.Start;\n\n        property commentStack: CommentToken[] = new CommentToken[]\n\n        property pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        property getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        property getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        property resetComments() {\n            this.commentStack = [];\n        }\n\n        property lineMap: number[];\n        property setSourceText(newSrc: ISourceText, textMode: number) {\n        }\n    }\n\n    export oldclass Scanner() implements IScanner {\n        property prevLine = 1;\n        property line = 1;\n        property col = 0;\n        property pos = 0;\n        property startPos = 0;\n        property startCol = this.col;\n        property startLine = this.line;\n        property src: string;\n        property len = 0;\n        property lineMap: number[] = [];\n        this.lineMap[1] = 0;\n        property ch = LexEOF;\n        property lexState = LexState.Start;\n        property mode = LexMode.File;\n        property scanComments: bool = true;\n        public interveningWhitespace = false; // Was there a whitespace token between the last token and the current one?\n        private interveningWhitespacePos = 0; //  If yes, this contains the start position of the whitespace\n        property leftCurlyCount = 0;\n        property rightCurlyCount = 0;\n        property commentStack: CommentToken[] = new CommentToken[];\n        property saveScan: SavedTokens = null;\n\n        if (!LexKeywordTable) {\n            LexInitialize();\n        }\n        private prevTok = staticTokens[TokenID.EOF];\n        property previousToken() { return this.prevTok; }\n\n        property setSourceText(newSrc: ISourceText, textMode: number) {\n            this.mode = textMode;\n            this.scanComments = (this.mode === LexMode.Line);\n            this.pos = 0;\n            this.interveningWhitespacePos = 0;\n            this.startPos = 0;\n            this.line = 1;\n            this.col = 0;\n            this.startCol = this.col;\n            this.startLine = this.line;\n            this.len = 0;\n            this.src = newSrc.getText(0, newSrc.getLength());\n            this.len = this.src.length;\n            this.lineMap = [];\n            this.lineMap[1] = 0;\n            this.commentStack = [];\n            this.leftCurlyCount = 0;\n            this.rightCurlyCount = 0;\n        }\n\n        property setSaveScan(savedTokens: SavedTokens) {\n            this.saveScan = savedTokens;\n        }\n\n        property setText(newSrc: string, textMode: number) {\n            this.setSourceText(new StringSourceText(newSrc), textMode);\n        }\n\n        property setScanComments(value: bool) {\n            this.scanComments = value;\n        }\n\n        property getLexState(): number {\n            return this.lexState;\n        }\n\n        property scanLine(line: string, initialState: number): Token[]{\n            this.lexState = initialState;\n            var result: Token[] = new Token[];\n            this.setText(line, LexMode.Line);\n            var t: Token = this.scan();\n            while (t.tokenId != TokenID.EOF) {\n                result[result.length] = t;\n                t = this.scan();\n            }\n            return result;\n        }\n\n        property tokenStart() {\n            this.startPos = this.pos;\n            this.startLine = this.line;\n            this.startCol = this.col;\n            this.interveningWhitespace = false;\n        }\n\n        property peekChar(): number {\n            if (this.pos < this.len) {\n                return this.src.charCodeAt(this.pos);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        property peekCharAt(index: number): number {\n            if (index < this.len) {\n                return this.src.charCodeAt(index);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        property IsHexDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_9)) || ((c >= LexCode_A) && (c <= LexCode_F)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        property IsOctalDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_7)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        property scanHexDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsHexDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        property scanOctalDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsOctalDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        property scanDecimalNumber(state: number): Token {\n            var atLeastOneDigit = false;\n            var svPos = this.pos;\n            var svCol = this.col;\n            for (; ;) {\n                if (LexIsDigit(this.ch)) {\n                    atLeastOneDigit = true;\n                    this.nextChar();\n                }\n                else if (this.ch == LexCodeDOT) {\n                    if (state == NumberScanState.Start) {\n                        // DecimalDigit* .\n                        this.nextChar();\n                        state = NumberScanState.InFraction;\n                    }\n                    else {\n                        // dot not part of number\n                        if (atLeastOneDigit) {\n                            // DecimalDigit* . DecimalDigit+\n                            return new NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                } else if ((this.ch == LexCode_e) || (this.ch == LexCode_E)) {\n                    if (state == NumberScanState.Start) {\n                        if (atLeastOneDigit) {\n                            // DecimalDigit+ (. DecimalDigit+) [eE] [+-]DecimalDigit+\n                            atLeastOneDigit = false;\n                            this.nextChar();\n                            state = NumberScanState.InExponent;\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InFraction) {\n                        // DecimalDigit+ . DecimalDigit* [eE]\n                        this.nextChar();\n                        state = NumberScanState.InExponent;\n                        atLeastOneDigit = false;\n                    }\n                    else {\n                        // DecimalDigit+ . DecimalDigit* [eE] DecimalDigit+\n                        if (atLeastOneDigit) {\n                            return new NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                }\n                else if ((this.ch == LexCodePLS) || (this.ch == LexCodeMIN)) {\n                    if (state == NumberScanState.InExponent) {\n                        if (!atLeastOneDigit) {\n                            this.nextChar();\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InFraction) {\n                        return new NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        if (!atLeastOneDigit) {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                        else {\n                            return new NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                    }\n                }\n                else {\n                    if (!atLeastOneDigit) {\n                        this.pos = svPos;\n                        this.col = svCol;\n                        return null;\n                    }\n                    else {\n                        return new NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                    }\n                }\n            }\n        }\n\n        // 0 [xX] hexDigits\n        // 0 octalDigits\n        // 0 [89] decimalDigits\n        // decimalDigits? fraction? exponent?\n\n        property scanNumber(): Token {\n            if (this.peekChar() == LexCode_0) {\n                switch (this.peekCharAt(this.pos + 1)) {\n                    case LexCode_x:\n                    case LexCode_X:\n                        // Hex\n                        this.advanceChar(2);\n                        return this.scanHexDigits();\n                    case LexCode_8:\n                    case LexCode_9:\n                    case LexCodeDOT:\n                        return this.scanDecimalNumber(NumberScanState.Start);\n                    default:\n                        // Octal\n                        return this.scanOctalDigits();\n                }\n            }\n            else {\n                return this.scanDecimalNumber(NumberScanState.Start);\n            }\n        }\n\n        property scanFraction(): Token {\n            return this.scanDecimalNumber(NumberScanState.InFraction);\n        }\n\n        property newLine() {\n            this.col = 0;\n            if (this.mode == LexMode.File) {\n                this.line++;\n                this.lineMap[this.line] = this.pos + 1;\n            }\n        }\n\n        property finishMultilineComment(): bool {\n            var ch2: number;\n            this.lexState = LexState.InMultilineComment;\n            while (this.pos < this.len) {\n                if (this.ch == LexCodeMUL) {\n                    ch2 = this.peekCharAt(this.pos + 1);\n                    if (ch2 == LexCodeSLH) {\n                        this.advanceChar(2);\n                        if (this.mode == LexMode.File) {\n                            this.tokenStart();\n                        }\n                        this.lexState = LexState.Start;\n                        return true;\n                    }\n                }\n                else if (this.ch == LexCodeNWL) {\n                    this.newLine();\n                    if (this.mode == LexMode.Line) {\n                        this.nextChar();\n                        return false;\n                    }\n                }\n                this.nextChar();\n            }\n            return false;\n        }\n\n        property pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        property getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        property getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        property resetComments() {\n            this.commentStack = [];\n        }\n\n        property endsLine(c: number) {\n            return (c == LexCodeNWL) || (c == LexCodeRET) || (c == 0x2028) || (c == 0x2029);\n        }\n\n        property finishSinglelineComment() {\n            while (this.pos < this.len) {\n                if (this.endsLine(this.ch))\n                    break;\n                this.nextChar();\n            }\n\n            if (this.mode == LexMode.File) {\n                this.tokenStart();\n            }\n        }\n\n        property tokenText(): string {\n            return this.src.substring(this.startPos, this.pos);\n        }\n\n        property findClosingSLH() {\n            var index = this.pos;\n            var ch2 = this.src.charCodeAt(index);\n            var prevCh = 0;\n            var liveEsc = false;\n            while (!this.endsLine(ch2) && (index < this.len)) {\n                if ((ch2 == LexCodeSLH) && (!liveEsc)) {\n                    return index;\n                }\n                prevCh = ch2;\n                index++;\n                if (liveEsc) {\n                    liveEsc = false;\n                }\n                else {\n                    liveEsc = (prevCh == LexCodeBSL);\n                }\n\n                ch2 = this.src.charCodeAt(index);\n            }\n            return -1;\n        }\n\n        property speculateRegex(): Token {\n            if (noRegexTable[this.prevTok.tokenId] != undefined) {\n                return null;\n            }\n            var svPos = this.pos;\n            var svCol = this.col;\n            // first char is \'/\' and has been skipped\n            var index = this.findClosingSLH();\n            if (index > 0) {\n                // found closing /\n                var pattern = this.src.substring(svPos, index);\n                var flags = \"\";\n                this.pos = index + 1;\n                this.ch = this.peekChar();\n                var flagsStart = this.pos;\n                // TODO: check for duplicate flags\n                while ((this.ch == LexCode_i) || (this.ch == LexCode_g) || (this.ch == LexCode_m)) {\n                    this.nextChar();\n                }\n                if ((this.pos - flagsStart) > 3) {\n                    return null;\n                }\n                else {\n                    flags = this.src.substring(flagsStart, this.pos);\n                }\n                var regex = undefined;\n                try {\n                    regex = new RegExp(pattern, flags);\n                }\n                catch (regexException) {\n                }\n                if (regex) {\n                    // no line boundary in regex string\n                    this.col = svCol + (this.pos - this.startPos);\n                    return new RegexToken(regex);\n                }\n            }\n            this.pos = svPos;\n            this.col = svCol;\n            return null;\n        }\n\n        property lastTokenHadNewline() {\n            return this.prevLine != this.startLine;\n        }\n\n        property lastTokenLimChar() {\n            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;\n        }\n\n        // use only when known not to skip line terminators\n        property advanceChar(amt: number) {\n            this.pos += amt;\n            this.col += amt;\n            this.ch = this.peekChar();\n        }\n\n        property nextChar() {\n            this.pos++;\n            this.col++;\n            this.ch = this.peekChar();\n        }\n\n        property scan(): Token {\n            if ((this.lexState == LexState.InMultilineComment) && (this.scanComments)) {\n                this.ch = this.peekChar();\n                var commentLine = this.line;\n                this.finishMultilineComment();\n                if (this.startPos < this.pos) {\n                    var commentText = this.src.substring(this.startPos, this.pos);\n                    this.tokenStart();\n                    return new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, this.startPos, commentLine,/*endsLine*/true);\n                }\n                else {\n                    return staticTokens[TokenID.EOF];\n                }\n            }\n            this.prevLine = this.line;\n            this.prevTok = this.innerScan();\n            if (this.saveScan != null) {\n                this.saveScan.addToken(this.prevTok, this);\n            }\n            return this.prevTok;\n        }\n\n        property innerScan(): Token {\n            var rtok;\n            this.tokenStart();\n            this.ch = this.peekChar();\n\n            while (this.pos < this.len) {\n                if (lexIdStartTable[this.ch]) {\n                    // identifier or keyword (TODO: Unicode letters)\n                    do {\n                        this.nextChar();\n                    } while (lexIdStartTable[this.ch] || LexIsDigit(this.ch));\n                    var idText = this.src.substring(this.startPos, this.pos);\n                    var id;\n                    if ((id = LexKeywordTable.lookup(idText)) != null) {\n                        return staticTokens[id];\n                    }\n                    else {\n                        return new StringToken(TokenID.ID, idText);\n                    }\n                }\n                else if (this.ch == LexCodeSpace) {\n                    if (!this.interveningWhitespace) {\n                        this.interveningWhitespacePos = this.pos;\n                    }\n                    do {\n                        this.nextChar();\n                    } while (this.ch == LexCodeSpace);\n                    if (this.mode == LexMode.Line) {\n                        var whitespaceText = this.src.substring(this.startPos, this.pos);\n                        return new WhitespaceToken(TokenID.Whitespace, whitespaceText);\n                    }\n                    else {\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                    }\n                }\n                else if (this.ch == LexCodeSLH) {\n                    this.nextChar();\n                    var commentText;\n                    if (this.ch == LexCodeSLH) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.finishSinglelineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/false, commentStartPos, commentStartLine,/*endsLine*/false);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n\n                        this.interveningWhitespace = true;\n                    }\n                    else if (this.ch == LexCodeMUL) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.nextChar();  // Skip the \"*\"\n                        this.finishMultilineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var endsLine = this.peekChar() == LexCodeNWL || this.peekChar() == LexCodeRET;\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, commentStartPos, commentStartLine, endsLine);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n                        this.interveningWhitespace = true;\n                    }\n                    else {\n                        var regexTok = this.speculateRegex();\n                        if (regexTok != null) {\n                            return regexTok;\n                        }\n                        else {\n                            if (this.peekCharAt(this.pos) == LexCodeEQ) {\n                                this.nextChar();\n                                return staticTokens[TokenID.AsgDiv];\n                            }\n                            else {\n                                return staticTokens[TokenID.Div];\n                            }\n                        }\n                    }\n                }\n                else if (this.ch == LexCodeSMC) {\n                    this.nextChar();\n                    return staticTokens[TokenID.SColon];\n                }\n                else if ((this.ch == LexCodeAPO) || (this.ch == LexCodeQUO)) {\n                    var endCode = this.ch;\n                    var prevCh = 0;\n                    // accumulate with escape characters; convert to unescaped string\n                    // where necessary\n                    var liveEsc = false;\n                    do {\n                        prevCh = this.ch;\n                        if (liveEsc) {\n                            liveEsc = false;\n                        }\n                        else {\n                            liveEsc = (prevCh == LexCodeBSL);\n                        }\n                        this.nextChar();\n                    } while ((this.ch != LexEOF) && (liveEsc || (this.ch != endCode)));\n\n                    if (this.ch != LexEOF) {\n                        // skip past end code\n                        this.nextChar();\n                    }\n                    return new StringToken(TokenID.QString, this.src.substring(this.startPos, this.pos));\n                }\n                else if (autoToken[this.ch]) {\n                    var atok = autoToken[this.ch];\n                    if (atok.tokenId == TokenID.LCurly) {\n                        this.leftCurlyCount++;\n                    }\n                    else if (atok.tokenId == TokenID.RCurly) {\n                        this.rightCurlyCount++;\n                    }\n                    this.nextChar();\n                    return atok;\n                }\n                else if ((this.ch >= LexCode_0) && (this.ch <= LexCode_9)) {\n                    rtok = this.scanNumber();\n                    if (rtok != null) {\n                        return rtok;\n                    }\n                    else {\n                        this.nextChar();\n                        return staticTokens[TokenID.Error];\n                    }\n                }\n                else switch (this.ch) {\n                    // TAB\n                    case LexCodeTAB:\n                    case LexCodeVTAB:\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        if (this.mode == LexMode.Line) {\n                            do {\n                                this.nextChar();\n                            } while ((this.ch == LexCodeSpace) || (this.ch == 9));\n                            var wsText = this.src.substring(this.startPos, this.pos);\n                            return new WhitespaceToken(TokenID.Whitespace, wsText);\n                        }\n                        else {\n                            this.interveningWhitespace = true;\n                        }\n                    // Newlines and BOM\n                    case 0xFF: // UTF16 SEQUENCE\n                    case 0xFE:\n                    case 0xEF:    // UTF8 SEQUENCE\n                    case 0xBB:\n                    case 0xBF:\n                    case 0x2028:\n                    case 0x2029:\n                    case LexCodeNWL:\n                    case LexCodeRET:\n                        if (this.ch == LexCodeNWL) {\n                            this.newLine();\n                            if (this.mode == LexMode.Line) {\n                                return staticTokens[TokenID.EOF];\n                            }\n                        }\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        this.nextChar();\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                        break;\n                    case LexCodeDOT: {\n                        if (this.peekCharAt(this.pos + 1) == LexCodeDOT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeDOT) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.Ellipsis];\n                            }\n                            else {\n                                this.nextChar();\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            rtok = this.scanFraction();\n                            if (rtok != null) {\n                                return rtok;\n                            }\n                            else {\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        // break;\n                    }\n                    case LexCodeEQ:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.Eqv];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.EQ];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.Arrow];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Asg];\n                        }\n                    // break;\n                    case LexCodeBNG:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.NEqv];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.NE];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Bang];\n                        }\n                    // break;\n                    case LexCodePLS:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsgAdd];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodePLS) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.Inc];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Add];\n                        }\n                    // break;\n                    case LexCodeMIN:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsgSub];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeMIN) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.Dec];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Sub];\n                        }\n                    // break;\n                    case LexCodeMUL:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsgMul];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Mult];\n                        }\n                    // break;\n                    case LexCodePCT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsgMod];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Pct];\n                        }\n                    // break;\n                    case LexCodeLT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeLT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.AsgLsh];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.Lsh];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.LE];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.LT];\n                        }\n                    //  break;\n                    case LexCodeGT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.AsgRsh];\n                            }\n                            else if (this.peekCharAt(this.pos + 2) == LexCodeGT) {\n                                if (this.peekCharAt(this.pos + 3) == LexCodeEQ) {\n                                    this.advanceChar(4);\n                                    return staticTokens[TokenID.AsgRs2];\n                                }\n                                else {\n                                    this.advanceChar(3);\n                                    return staticTokens[TokenID.Rs2];\n                                }\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.Rsh];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.GE];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.GT];\n                        }\n                    // break;\n                    case LexCodeXOR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsgXor];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Xor];\n                        }\n                    //  break;\n                    case LexCodeBAR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsgOr];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeBAR) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.LogOr];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Or];\n                        }\n                    //  break;\n                    case LexCodeAMP:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsgAnd];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeAMP) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.LogAnd];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.And];\n                        }\n                    //  break;\n                    default:\n                        // TODO:report error\n                        return staticTokens[TokenID.EOF];\n                }\n            }\n            return staticTokens[TokenID.EOF];\n        }\n    }\n\n    // Reseverved words only apply to Identifiers, not IdentifierNames\n    export function convertTokToIDName(tok: Token): bool {\n        return convertTokToIDBase(tok, true, false);\n    }\n\n    export function convertTokToID(tok: Token, strictMode: bool): bool {\n        return convertTokToIDBase(tok, false, strictMode);\n    }\n\n    function convertTokToIDBase(tok: Token, identifierName: bool, strictMode: bool): bool {\n        if (tok.tokenId <= TokenID.LimKeyword) {\n            var tokInfo = lookupToken(tok.tokenId);\n            if (tokInfo != undefined) {\n                var resFlags = Reservation.Javascript | Reservation.JavascriptFuture;\n                if (strictMode) {\n                    resFlags |= Reservation.JavascriptFutureStrict;\n                }\n                if (identifierName || !hasFlag(tokInfo.reservation, resFlags)) {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    // Return the (1-based) line number from a character offset using the provided linemap.\n    export function getLineNumberFromPosition(lineMap: number[], position: number): number {\n        if (position === -1)\n            return 0;\n\n        // Binary search\n        var min = 0;\n        var max = lineMap.length - 1;\n        while (min < max) {\n            var med = (min + max) >> 1;\n            if (position < lineMap[med]) {\n                max = med - 1;\n            }\n            else if (position < lineMap[med + 1]) {\n                min = max = med; // found it\n            }\n            else {\n                min = med + 1;\n            }\n        }\n\n        return min;\n    }\n\n    /// Return the [line, column] data for a given offset and a lineMap.\n    /// Note that the returned line is 1-based, while the column is 0-based.\n    export function getSourceLineColFromMap(lineCol: ILineCol, minChar: number, lineMap: number[]): void {\n        var line = getLineNumberFromPosition(lineMap, minChar);\n\n        if (line > 0) {\n            lineCol.line = line;\n            lineCol.col = (minChar - lineMap[line]);\n        }\n    }\n\n    // Return the [line, column] (both 1 based) corresponding to a given position in a given script.\n    export function getLineColumnFromPosition(script: Tools.Script, position: number): ILineCol {\n        var result = { line: -1, col: -1 };\n        getSourceLineColFromMap(result, position, script.locationInfo.lineMap);\n        if (result.col >= 0) {\n            result.col++;   // Make it 1-based\n        }\n        return result;\n    }\n\n    //\n    // Return the position (offset) corresponding to a given [line, column] (both 1-based) in a given script.\n    //\n    export function getPositionFromLineColumn(script: Tools.Script, line: number, column: number): number {\n        return script.locationInfo.lineMap[line] + (column - 1);\n    }\n}\n\n\nmodule Tools {\n\n    export oldclass AssignScopeContext(property scopeChain: ScopeChain,\n                             property typeFlow: TypeFlow,\n                             property modDeclChain: ModuleDecl[]) extends BaseWalkContext {\n    }\n\n    export function pushAssignScope(scope: SymbolScope,\n        context: AssignScopeContext,\n        type: Type,\n        classType: Type,\n        fnc: FuncDecl) {\n\n        var chain = new ScopeChain(null, context.scopeChain, scope);\n        chain.thisType = type;\n        chain.classType = classType;\n        chain.fnc = fnc;\n        context.scopeChain = chain;\n    }\n\n    export function popAssignScope(context: AssignScopeContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function instanceCompare(a: Symbol, b: Symbol) {\n        if (((a == null) || (!a.isInstanceProperty()))) {\n            return b;\n        }\n        else {\n            return a;\n        }\n    }\n\n    export function instanceFilterStop(s: Symbol) => s.isInstanceProperty();\n\n    export oldclass ScopeSearchFilter(property select: (a: Symbol, b: Symbol) =>Symbol,\n                            property stop: (s: Symbol) =>bool) {\n        property result: Symbol = null;\n\n        property reset() {\n            this.result = null;\n    }\n\n        property update(b: Symbol): bool {\n            this.result = this.select(this.result, b);\n            if (this.result != null) {\n                return this.stop(this.result);\n    }\n    else {\n                return false;\n    }\n    }\n    }\n\n    export var instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);\n\n    export function preAssignModuleScopes(ast: AST, context: AssignScopeContext) {\n        var moduleDecl = <ModuleDecl>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (moduleDecl.name != null && moduleDecl.mod != null) {\n            moduleDecl.name.sym = moduleDecl.mod.symbol;\n        }\n\n        var mod = moduleDecl.mod;\n        memberScope = new SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);\n        mod.memberScope = memberScope;\n        if (moduleDecl.isAnonInnerMod && context.modDeclChain.length > 0) {\n            moduleDecl.anonParentMod = context.typeFlow.checker.currentModDecl;\n            moduleDecl.anonExportedSymbols = [];\n        }\n        context.modDeclChain.push(moduleDecl);\n        context.typeFlow.checker.currentModDecl = moduleDecl;\n        aggScope = new SymbolAggregateScope(mod.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        mod.containedScope = aggScope;\n        if (mod.symbol != null) {\n            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);\n        }\n    }\n\n    export function preAssignClassScopes(ast: AST, context: AssignScopeContext) {\n        var classDecl = <TypeDecl>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (classDecl.isOverload) {\n            return;\n        }\n\n        if (classDecl.name != null && classDecl.type != null) {\n            classDecl.name.sym = classDecl.type.symbol;\n        }\n\n        var classType = ast.type;\n        if (classType != null) {\n            var classSym = classType.symbol;\n            memberScope = context.typeFlow.checker.scopeOf(classType);\n            aggScope = new SymbolAggregateScope(classType.symbol);\n            aggScope.addParentScope(memberScope);\n            aggScope.addParentScope(context.scopeChain.scope);\n            classType.containedScope = aggScope;\n            classType.memberScope = memberScope;\n            var instanceType = classType.instanceType;\n            memberScope = context.typeFlow.checker.scopeOf(instanceType);\n            instanceType.memberScope = memberScope;\n            aggScope = new SymbolAggregateScope(instanceType.symbol);\n            if (context.typeFlow.checker.addMembersToClassScope) {\n                aggScope.addParentScope(memberScope);\n            }\n            aggScope.addParentScope(classType.containedScope);\n            pushAssignScope(aggScope, context, instanceType, classType, null);\n            instanceType.containedScope = aggScope;\n\n            if (context.typeFlow.checker.currentModDecl != null && context.typeFlow.checker.currentModDecl.isAnonInnerMod && hasFlag((<TypeDecl>ast).varFlags, VarFlags.Exported)) {\n                context.typeFlow.checker.currentModDecl.anonExportedSymbols.push(classSym);\n            }\n        }\n        else {\n            ast.type = context.typeFlow.anyType;\n        }\n    }\n\n    export function preAssignES6ClassScopes(ast: AST, context: AssignScopeContext) {\n        var classDecl = <TypeDecl>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (classDecl.name != null && classDecl.type != null) {\n            classDecl.name.sym = classDecl.type.symbol;\n        }\n\n        var classType = ast.type;\n\n        if (classType != null) {\n            var classSym = classType.symbol;\n            memberScope = context.typeFlow.checker.scopeOf(classType);\n\n            aggScope = new SymbolAggregateScope(classType.symbol);\n            aggScope.addParentScope(memberScope);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            classType.containedScope = aggScope;\n            classType.memberScope = memberScope;\n\n            var instanceType = classType.instanceType;\n            memberScope = context.typeFlow.checker.scopeOf(instanceType);\n            instanceType.memberScope = memberScope;\n\n            aggScope = new SymbolAggregateScope(instanceType.symbol);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            if (context.typeFlow.checker.addMembersToClassScope) {\n                aggScope.addParentScope(memberScope);\n            }\n\n            //aggScope.addParentScope(classType.containedScope);\n\n            pushAssignScope(aggScope, context, instanceType, classType, null);\n            instanceType.containedScope = aggScope;\n\n            //var funcTable = new StringHashTable();\n            //var funcMembers = new ScopedMembers(new DualStringHashTable(funcTable, new StringHashTable()));\n            //var ambientFuncTable = new StringHashTable();\n            //var ambientFuncMembers = new ScopedMembers(new DualStringHashTable(ambientFuncTable, new StringHashTable()));\n\n            //instanceType.constructorScope = new SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, aggScope, classSym);\n\n            if (context.typeFlow.checker.currentModDecl != null && context.typeFlow.checker.currentModDecl.isAnonInnerMod && hasFlag((<TypeDecl>ast).varFlags, VarFlags.Exported)) {\n                context.typeFlow.checker.currentModDecl.anonExportedSymbols.push(classSym);\n            }\n        }\n        else {\n            ast.type = context.typeFlow.anyType;\n        }\n    }\n\n    export function preAssignInterfaceScopes(ast: AST, context: AssignScopeContext) {\n        var interfaceDecl = <TypeDecl>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (interfaceDecl.name != null && interfaceDecl.type != null) {\n            interfaceDecl.name.sym = interfaceDecl.type.symbol;\n        }\n\n        var interfaceType = ast.type;\n        memberScope = context.typeFlow.checker.scopeOf(interfaceType);\n        interfaceType.memberScope = memberScope;\n        aggScope = new SymbolAggregateScope(interfaceType.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        interfaceType.containedScope = aggScope;\n    }\n\n    export function preAssignWithScopes(ast: AST, context: AssignScopeContext) {\n        var withStmt = <WithStatement>ast;\n        var withType = withStmt.type;\n\n        var members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        var ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        var withType = new Type();\n        var withSymbol = new WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType);\n        withType.members = members;\n        withType.ambientMembers = ambientMembers;\n        withType.symbol = withSymbol;\n        withType.setHasImplementation();\n        withStmt.type = withType;\n\n        var withScope = new Tools.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);\n\n        pushAssignScope(withScope, context, null, null, null);\n        withType.containedScope = withScope;\n    }\n\n    export function preAssignFuncDeclScopes(ast: AST, context: AssignScopeContext) {\n        var funcDecl = <FuncDecl>ast;\n\n        var container: Symbol = null;\n        var localContainer: Symbol = null;\n        if (funcDecl.type != null) {\n            localContainer = ast.type.symbol;\n        }\n\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isInnerStatic = isStatic && context.scopeChain.fnc != null;\n        // for inner static functions, use the parent\'s member scope, so local vars cannot be captured\n        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;\n\n        // if this is not a method, but enclosed by class, use constructor as\n        // the enclosing scope\n        // REVIEW: Some twisted logic here - this needs to be cleaned up once old classes are removed\n        //  - if it\'s ES6, always use the contained scope, since we initialize the constructor scope below\n        if ((context.scopeChain.thisType != null) &&\n            (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod))) {\n            var instType = context.scopeChain.thisType;\n\n            if (!instType.isES6Class && !hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)) {\n                if (!funcDecl.isMethod() || isStatic) {\n                    parentScope = instType.constructorScope;\n                }\n                else {\n                    // use constructor scope if a method as well\n                    parentScope = instType.containedScope;\n                }\n            }\n            else {\n                if (context.scopeChain.previous.scope.container &&\n                    context.scopeChain.previous.scope.container.declAST &&\n                    context.scopeChain.previous.scope.container.declAST.nodeType == NodeType.FuncDecl &&\n                    (<FuncDecl>context.scopeChain.previous.scope.container.declAST).isConstructor) {\n\n                        // if the parent is the es6 class constructor, use the constructor scope\n                    parentScope = instType.constructorScope;\n                }\n                else if (isStatic && context.scopeChain.classType) {\n                    parentScope = context.scopeChain.classType.containedScope;\n                }\n                else {\n                    // else, use the contained scope\n                    parentScope = instType.containedScope;\n                }\n            }\n            container = instType.symbol;\n        }\n        else if (funcDecl.isConstructor && (context.scopeChain.thisType != null)) {\n            // sets the container to the class type\'s symbol (which is shared by the instance type)\n            container = context.scopeChain.thisType.symbol;\n        }\n\n        if (funcDecl.type == null || hasFlag(funcDecl.type.symbol.flags, SymbolFlags.TypeSetDuringScopeAssignment)) {\n            if (context.scopeChain.fnc != null) {\n                container = context.scopeChain.fnc.type.symbol;\n            }\n\n            // TODO: review in case of module container\n            var funcScope = null;\n            var outerFnc: FuncDecl = context.scopeChain.fnc;\n            var nameText = funcDecl.name != null ? funcDecl.name.text : null;\n            var fgSym: TypeSymbol = null;\n\n            if (isStatic) {\n                // In the case of function-nested statics, no member list will have bee initialized for the function, so we need\n                // to copy it over.  We don\'t set this by default because having a non-null member list will throw off assignment\n                // compatibility tests                \n                if (outerFnc.type.members == null) {\n                    outerFnc.type.members = (<SymbolScopeBuilder>(<TypeSymbol>container).type.memberScope).valueMembers;\n                }\n                funcScope = context.scopeChain.fnc.type.memberScope;\n                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;\n            }\n            else {\n\n                if (!funcDecl.isConstructor &&\n                    container != null &&\n                    container.declAST != null &&\n                    container.declAST.nodeType == NodeType.FuncDecl &&\n                    (<FuncDecl>container.declAST).isConstructor &&\n                    !funcDecl.isMethod()) {\n                    funcScope = context.scopeChain.thisType.constructorScope;//locals;\n                }\n                else {\n                    funcScope = context.scopeChain.scope;\n                }\n            }\n\n            if (nameText != null && nameText != \"__missing\") {\n                if (isStatic) {\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n            }\n\n            // REVIEW: This is broken for overloads...\n            context.typeFlow.checker.createFunctionSignature(funcDecl, container,\n                                                            funcScope, fgSym, fgSym == null);\n\n            funcDecl.type.symbol.flags |= SymbolFlags.TypeSetDuringScopeAssignment;\n            //funcDecl.type.symbol.declAST = ast;        \n        }\n\n        // Set the symbol for functions and their overloads\n        if (funcDecl.name != null && funcDecl.type != null) {\n            funcDecl.name.sym = funcDecl.type.symbol;\n        }\n\n        // Overloads have no scope, so bail here\n        if (funcDecl.isOverload) {\n            return;\n        }\n\n        var funcTable = new StringHashTable();\n        var funcMembers = new ScopedMembers(new DualStringHashTable(funcTable, new StringHashTable()));\n        var ambientFuncTable = new StringHashTable();\n        var ambientFuncMembers = new ScopedMembers(new DualStringHashTable(ambientFuncTable, new StringHashTable()));\n        var funcStaticTable = new StringHashTable();\n        var funcStaticMembers = new ScopedMembers(new DualStringHashTable(funcStaticTable, new StringHashTable()));\n        var ambientFuncStaticTable = new StringHashTable();\n        var ambientFuncStaticMembers = new ScopedMembers(new DualStringHashTable(ambientFuncStaticTable, new StringHashTable()));\n\n        // REVIEW: Is it a problem that this is being set twice for properties and constructors?\n        funcDecl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex;\n\n        var locals = new SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);\n        var statics = new SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);\n\n        if (funcDecl.isConstructor /*&& !hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)*/ && context.scopeChain.thisType != null) {\n            context.scopeChain.thisType.constructorScope = locals;\n        }\n\n        // basically, there are two problems\n        // - Above, for es6 classes, we were overwriting the constructor scope with the containing scope.  This caused constructor params to be\n        // in scope everywhere\n        // - Below, we\'re setting the contained scope table to the same table we were overwriting the constructor scope with, which we need to\n        // fish lambda params, etc, out (see funcTable below)\n        //\n        // A good first approach to solving this would be to change addLocalsFromScope to take a scope instead of a table, and add to the\n        // constructor scope as appropriate\n\n        funcDecl.symbols = funcTable;\n\n        if (!funcDecl.isSpecialFn()) {\n            var group = funcDecl.type;\n            var signature = funcDecl.signature;\n\n            if (!funcDecl.isConstructor /*|| hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)*/) {\n                group.containedScope = locals;\n                locals.container = group.symbol;\n\n                group.memberScope = statics;\n                statics.container = group.symbol;\n            }\n            funcDecl.enclosingFnc = context.scopeChain.fnc;\n            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;\n            // for mapping when type checking\n            var fgSym = <TypeSymbol>ast.type.symbol;\n            if (((funcDecl.fncFlags & FncFlags.Signature) == FncFlags.None) &&\n                (funcDecl.vars != null)) {\n                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars,\n                                                    funcTable, false);\n                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics,\n                                                    funcStaticTable, false);\n            }\n            if (signature.parameters) {\n                var len = signature.parameters.length;\n                for (var i = 0; i < len; i++) {\n                    var paramSym: ParameterSymbol = signature.parameters[i];\n                    context.typeFlow.checker.resolveTypeLink(locals,\n                                                                paramSym.parameter.typeLink, true);\n                }\n            }\n            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType,\n                                                        funcDecl.isSignature());\n        }\n\n        if (context.typeFlow.checker.currentModDecl != null && context.typeFlow.checker.currentModDecl.isAnonInnerMod && hasFlag(funcDecl.fncFlags, FncFlags.Exported)) {\n            context.typeFlow.checker.currentModDecl.anonExportedSymbols.push(funcDecl.type.symbol);\n        }\n        if (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)) {\n            var thisType = (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)) ? context.scopeChain.thisType : null;\n            pushAssignScope(locals, context, thisType, null, funcDecl);\n        }\n    }\n\n    export function preAssignCatchScopes(ast: AST, context: AssignScopeContext) {\n        var catchBlock = <Catch>ast;\n        if (catchBlock.param != null) {\n            var catchTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable())); // REVIEW: Should we be allocating a public table instead of a private one?\n            var catchLocals = new SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope,\n                                                   context.scopeChain.scope.container);\n            catchBlock.containedScope = catchLocals;\n            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);\n        }\n    }\n\n    export function preAssignVarDeclScopes(ast: AST, context: AssignScopeContext) {\n        if (context.typeFlow.checker.currentModDecl != null &&\n            context.typeFlow.checker.currentModDecl.isAnonInnerMod &&\n            hasFlag((<VarDecl>ast).varFlags, VarFlags.Exported) &&\n            (<VarDecl>ast).sym != null) {\n            context.typeFlow.checker.currentModDecl.anonExportedSymbols.push((<VarDecl>ast).sym);\n        }\n    }\n\n\n    // TODO: rename thisType to classType to avoid confusion with instance type\n    export function preAssignScopes(ast: AST, parent: AST, iwContext: IWalkContext) {\n        var go = true;\n        var context = <AssignScopeContext>iwContext;\n\n        if (ast != null) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                list.enclosingScope = context.scopeChain.scope;\n            }\n            else if (ast.nodeType == NodeType.Module) {\n                preAssignModuleScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.Class) {\n                preAssignClassScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.ES6Class) {\n                preAssignES6ClassScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.Interface) {\n                preAssignInterfaceScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                preAssignWithScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                preAssignFuncDeclScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                preAssignCatchScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.TypeRef) {\n                go = false;\n            }\n            else if (ast.nodeType == NodeType.VarDecl) {\n                preAssignVarDeclScopes(ast, context);\n            }\n        }\n        context.goChildren = go;\n        return ast;\n    }\n\n    export function postAssignScopes(ast: AST, parent: AST, iwContext: IWalkContext) {\n        var context = <AssignScopeContext>iwContext;\n        var go = true;\n        if (ast != null) {\n            if (ast.nodeType == NodeType.Module) {\n                var prevModDecl = <ModuleDecl>ast;\n\n                popAssignScope(context);\n\n                context.modDeclChain.pop();\n                if (context.modDeclChain.length >= 1) {\n                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];\n                }\n\n                // if the module in question is an anonymous inner module, add its exported symbols to the containing module\'s member scope\n                if (prevModDecl.isAnonInnerMod) {\n                    var nExports = prevModDecl.anonExportedSymbols.length;\n                    var sym: Symbol = null;\n                    for (var i = 0; i < nExports; i++) {\n                        sym = prevModDecl.anonExportedSymbols[i];\n                        if (null != context.typeFlow.checker.currentModDecl.mod.members.allMembers.lookup(sym.name)) {\n                            context.typeFlow.checker.errorReporter.simpleError(sym.declAST, \"Anonymous module export \'\" + sym.name + \"\' conflicts with a symbol in the parent module\")\n                        }\n                        else {\n                            context.typeFlow.checker.currentModDecl.mod.members.publicMembers.add(sym.name, sym);\n                        }\n\n                        // classes and modules are added to both the type and value scopes\n                        // REVIEW: Should this be added to the private scope instead?\n                        if (sym.isType() && null != context.typeFlow.checker.currentModDecl.mod.enclosedTypes.allMembers.lookup(sym.name)) {\n                            context.typeFlow.checker.errorReporter.simpleError(sym.declAST, \"Anonymous module export \'\" + sym.name + \"\' conflicts with a symbol in the parent module\")\n                        }\n                        else {\n                            context.typeFlow.checker.currentModDecl.mod.enclosedTypes.publicMembers.add(sym.name, sym);\n                        }\n                    }\n                }\n\n            }\n            else if (ast.nodeType == NodeType.Class) {\n                if (!(<TypeDecl>ast).isOverload) {\n                    popAssignScope(context);\n                }\n            }\n            else if (ast.nodeType == NodeType.ES6Class) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.Interface) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>ast;\n                if ((!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)) && !funcDecl.isOverload) {\n                    popAssignScope(context);\n                }\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                var catchBlock = <Catch>ast;\n                if (catchBlock.param != null) {\n                    popAssignScope(context);\n                }\n            }\n            else {\n                go = false;\n            }\n        }\n        context.goChildren = go;\n        return ast;\n    }\n}\n\n\nmodule Tools {\n    export oldclass TypeCollectionContext(property scopeChain: ScopeChain,\n                                property checker: TypeChecker) extends BaseWalkContext {\n        property script: Script = null;\n    }\n\n    export oldclass MemberScopeContext(property flow: TypeFlow, property pos: number, property matchFlag: ASTFlags) extends BaseWalkContext() {\n        property type: Type = null;\n        property ast: AST = null;\n        property scope: SymbolScope;\n    }\n\n    export oldclass EnclosingScopeContext(\n        public logger: ILogger,\n        public script: Script,\n        public text: ISourceText,\n        public pos: number,\n        public isMemberCompletion: bool) extends BaseWalkContext() {\n\n        public scopeGetter: () => SymbolScope = null;\n        public scopeStartAST: AST = null;\n        public skipNextFuncDeclForClass = false;\n        public deepestModuleDecl: ModuleDecl = null;\n        public enclosingClassDecl: NamedType = null;\n        public publicsOnly = true;\n        private scriptFragment: Script;\n\n\n        public getScope(): SymbolScope {\n            return this.scopeGetter();\n        }\n\n        public getScopePosition() {\n            return this.scopeStartAST.minChar;\n        }\n\n        public getScriptFragment(): Script {\n            if (this.scriptFragment == null) {\n                var minChar = this.getScopePosition();\n                var limChar = (this.isMemberCompletion ? this.pos : this.pos + 1);\n                this.scriptFragment = Tools.quickParse(this.logger, this.scopeStartAST, this.text, minChar, limChar, null/*errorCapture*/).Script;\n            }\n            return this.scriptFragment;\n        }\n    }\n\n    export function preFindMemberScope(ast: AST, parent: AST, context: IWalkContext) {\n        var memScope = <MemberScopeContext>context;\n\n        // TODO: refine search method\n        if (hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {\n            memScope.ast = ast;\n            if ((ast.type == null) && (memScope.pos >= 0)) {\n                memScope.flow.inScopeTypeCheck(ast, memScope.scope);\n            }\n            memScope.type = ast.type;\n            memScope.goChildren = false;\n            memScope.goNextSibling = false;\n        }\n        return ast;\n    }\n\n    // moduleDecl non-null only for immediately enclosing module\n    export function pushTypeCollectionScope(container: Symbol,\n        valueMembers: ScopedMembers,\n        ambientValueMembers: ScopedMembers,\n        enclosedTypes: ScopedMembers,\n        ambientEnclosedTypes: ScopedMembers,\n        context: TypeCollectionContext,\n        thisType: Type,\n        classType: Type,\n        moduleDecl: ModuleDecl) {\n        var builder = new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);\n        var chain: ScopeChain = new ScopeChain(container, context.scopeChain, builder);\n        chain.thisType = thisType;\n        chain.classType = classType;\n        chain.moduleDecl = moduleDecl;\n        context.scopeChain = chain;\n    }\n\n    export function popTypeCollectionScope(context: TypeCollectionContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function preFindEnclosingScope(ast: AST, parent: AST, iwContext: IWalkContext) {\n        var context = <EnclosingScopeContext>iwContext;\n        var minChar = ast.minChar;\n        var limChar = ast.limChar;\n\n        // Account for the fact completion list may be called at the end of a file which\n        // is has not been fully re-parsed yet.\n        if (ast.nodeType == NodeType.Script && context.pos > limChar)\n            limChar = context.pos;\n\n        if ((minChar <= context.pos) &&\n            (limChar >= context.pos)) {\n            switch (ast.nodeType) {\n                case NodeType.Script:\n                    var script = <Script>ast;\n                    context.scopeGetter = function() {\n                        return script.bod === null ? null : script.bod.enclosingScope;\n                    };\n                    context.scopeStartAST = script;\n                    break;\n                case NodeType.ES6Class:\n                    context.scopeGetter = function() {\n                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    context.enclosingClassDecl = ast;\n                    break;\n                case NodeType.Class:\n                    context.scopeGetter = function() {\n                        return (ast.type === null || ast.type.instanceType.constructorScope === null) ? null : ast.type.instanceType.constructorScope;\n                    };\n                    context.scopeStartAST = ast;\n                    context.enclosingClassDecl = ast;\n                    context.skipNextFuncDeclForClass = true;\n                    break;\n                case NodeType.ObjectLit:\n                    // Only consider target-typed object literals\n                    if (ast.type != null && (<UnaryExpression>ast).acceptTargetType) {\n                        // fall through to function case...\n                    }\n                    else {\n                        break;\n                    }\n                case NodeType.Module:\n                    context.deepestModuleDecl = ast;\n                // no break here\n                case NodeType.Interface:\n                case NodeType.FuncDecl:\n                    if (context.skipNextFuncDeclForClass) {\n                        context.skipNextFuncDeclForClass = false;\n                        break;\n                    }\n\n                    context.scopeGetter = function() {\n                        return ast.type === null ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n            }\n            context.goChildren = true;\n        }\n        else {\n            context.goChildren = false;\n        }\n        return ast;\n    }\n\n    export function findEnclosingScopeAt(logger: ILogger, script: Script, text: ISourceText, pos: number, isMemberCompletion: bool): EnclosingScopeContext {\n        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);\n        script.walk(preFindEnclosingScope, null, null, context);\n        if (context.scopeStartAST === null)\n            return null;\n        return context;\n    }\n}\n\n\nmodule Tools {\n    export oldclass Signature {\n        property hasVariableArgList = false;\n        property returnType: TypeLink;\n        property parameters: ParameterSymbol[] = null;\n        property declAST: FuncDecl;\n        property typeCheckStatus = TypeCheckStatus.NotStarted;\n        property nonOptionalParameterCount = 0;\n\n        property specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Signature {\n            var result = new Signature();\n            if (this.hasVariableArgList) {\n                result.hasVariableArgList = true;\n            }\n            result.returnType = new TypeLink();\n            if (this.returnType.type != null) {\n                result.returnType.type =\n                    this.returnType.type.specializeType(pattern, replacement, checker, false);\n            }\n            else {\n                result.returnType.type = checker.anyType;\n            }\n\n            if (this.parameters != null) {\n                result.parameters = [];\n                for (var i = 0, len = this.parameters.length; i < len; i++) {\n                    var oldSym = this.parameters[i];\n                    var paramDef = new ValueLocation();\n                    var paramSym = new ParameterSymbol(oldSym.name, oldSym.location,\n                                                     checker.locationInfo.unitIndex,\n                                                     paramDef);\n\n                    paramSym.declAST = this.declAST;\n                    paramDef.symbol = paramSym;\n                    paramDef.typeLink = new TypeLink();\n                    result.parameters[i] = paramSym;\n                    var oldType = oldSym.getType();\n                    if (oldType != null) {\n                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);\n                        paramSym.declAST.type = paramDef.typeLink.type;\n                    }\n                    else {\n                        paramDef.typeLink.type = checker.anyType;\n                    }\n                }\n            }\n            return result;\n        }\n\n        property matchSingleArg(argType: Type, checker: TypeChecker): bool {\n            if (this.parameters.length == 1) {\n                return checker.contravariantMatches(this.parameters[0].parameter.typeLink.type,\n                                                    argType);\n            }\n            return false;\n        }\n\n        property matchParams(b: Signature, checker: TypeChecker) {\n            var len = this.parameters.length;\n            if (b.parameters.length == len) {\n                for (var i = 0; i < len; i++) {\n                    var paramA = this.parameters[i].parameter;\n                    var paramB = b.parameters[i].parameter;\n                    if (!checker.invariantMatches(paramA.typeLink.type,\n                                                      paramB.typeLink.type)) {\n                        return false;\n                    }\n                }\n            }\n            else {\n                return false;\n            }\n            return true;\n        }\n\n        property toString() {\n            return this.toStringHelper(false, false, null);\n        }\n\n        property toStringHelper(shortform: bool, brackets: bool, scope: SymbolScope) {\n            var builder: string;\n            if (brackets) {\n                builder = \"[\";\n            }\n            else {\n                builder = \"(\";\n            }\n            var len = this.parameters.length;\n            for (var i = 0; i < len; i++) {\n                builder += this.parameters[i].name + (this.parameters[i].isOptional() ? \"?\" : \"\") + \": \";\n                builder += this.parameters[i].getType().getScopedTypeName(scope);\n                if (i < len - 1) {\n                    builder += \",\";\n                }\n            }\n            if (shortform) {\n                if (brackets) {\n                    builder += \"] => \"\n                }\n                else {\n                    builder += \") => \"\n                }\n            }\n            else {\n                if (brackets) {\n                    builder += \"]: \";\n                }\n                else {\n                    builder += \"): \";\n                }\n            }\n\n            if (this.returnType.type != null) {\n                builder += this.returnType.type.getScopedTypeName(scope);\n            }\n            else {\n                builder += \"any\";\n            }\n            return builder;\n        }\n    }\n\n    export oldclass SignatureGroup {\n        property isMethod = true;\n        property isIndexer = false;\n        property signatures: Signature[] = [];\n        property hasImplementation = true;\n        property definitionSignature: Signature = null;\n        property hasBeenTypechecked = false;\n        property addSignature(signature: Signature) {\n            if (this.signatures == null) {\n                this.signatures = new Signature[];\n            }\n            this.signatures[this.signatures.length] = signature;\n            \n            // REVIEW: duplicates should be found within createFunctionSignature,\n            // so we won\'t check for them here\n            if (signature.declAST &&\n                !signature.declAST.isOverload &&\n                !signature.declAST.isSignature() && \n                !hasFlag(signature.declAST.fncFlags, FncFlags.Ambient) &&\n                hasFlag(signature.declAST.fncFlags, FncFlags.Definition)) {\n                this.definitionSignature = signature;\n            }\n        }\n\n        property toString() => this.signatures.toString();\n        property toStrings(prefix: string, shortform: bool, scope: SymbolScope): string[]{\n            var result: string[] = [];\n            var len = this.signatures.length;\n            if (len > 1) {\n                shortform = false;\n            }\n            for (var i = 0; i < len; i++) {\n                // the definition signature shouldn\'t be printed if there are overloads\n                if (len > 1 && this.signatures[i] == this.definitionSignature) {\n                    continue;\n                }\n                if (this.isIndexer) {\n                    result[i] = this.signatures[i].toStringHelper(shortform, true, scope);\n                }\n                else {\n                    result[i] = prefix + this.signatures[i].toStringHelper(shortform, false, scope);\n                }\n            }\n            return result;\n        }\n\n        property specializeType(pattern: Type, replacement: Type, checker: TypeChecker): SignatureGroup {\n            var result = new SignatureGroup();\n            if (this.signatures != null) {\n                for (var i = 0, len = this.signatures.length; i < len; i++) {\n                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));\n                }\n            }\n            return result;\n        }\n\n        property typeCheck(checker: TypeChecker, ast: AST, hasConstruct:bool) {\n            \n            if (this.hasBeenTypechecked) {\n                return;\n            }\n            \n            // set here to prevent us from recursively invoking typeCheck again\n            this.hasBeenTypechecked = true;\n            \n            var len = 0;\n            \n            // TODO: verify no signature pair with identical parameters\n            if ((this.signatures != null) && ((len = this.signatures.length) > 0)) {\n                \n                // first, typecheck each signature\n                for (var i = 0; i < len; i++) {\n\n                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Ambient)) {\n                        checker.errorReporter.simpleError(this.signatures[i].declAST, \"Overload declaration lacks definition\");\n                    }\n\n                    // If we\'re typechecking a constructor via one of its overloads, ensure that the outer class is typechecked, since we need to validate its inheritance properties\n                    // to properly check that \'super\' is being used correctly\n                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);\n                    }\n\n                    checker.typeFlow.typeCheck(this.signatures[i].declAST);\n                }\n                \n                for (i = 0; i < len; i++) {\n                    \n                    for (var j = i + 1; j < len; j++) {\n                        // next check for equivalence between overloads - no two can be exactly the same\n                        // REVIEW: Instead of invariant equivalence, should we use covariant equivalence?                        \n                        if (this.signatures[i].declAST && this.signatures[j].declAST &&\n                            (!hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Definition) && !hasFlag(this.signatures[j].declAST.fncFlags, FncFlags.Definition)) &&\n                            this.signatures[i].matchParams(this.signatures[j], checker) &&\n                            checker.invariantMatches(this.signatures[i].returnType.type, this.signatures[j].returnType.type)) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, \"Signature is duplicated\");\n                        }\n                    }\n                    \n                    // finally, ensure that each signature is compatible with the definition\n                    if (this.definitionSignature) {\n                        if (!checker.signatureAssignable(this.signatures[i], this.definitionSignature)) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, \"Overload signature is not compatible with function definition\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nmodule Tools {\n    export class SourceMapping {\n        public sourceStartLine: number;\n        public sourceStartColumn: number;\n        public sourceEndLine: number;\n        public sourceEndColumn: number;\n        public emittedStartLine: number;\n        public emittedStartColumn: number;\n        public emittedEndLine: number;\n        public emittedEndColumn: number;\n        public parent: number;\n        public firstChild: number;\n\n        constructor(ast : AST) {\n            this.parent = -1;\n            this.firstChild = -1;\n            //public this.__debugAST = ast;\n        }\n    }\n\n    export class SourceMapper {\n        static MapFileExtension = \".map\";\n        \n        public sourceMappings: SourceMapping[];\n        public currentMapping: number;\n\n        public jsFileName: string;\n        public strFileName: string;\n\n        constructor(strFileName: string, jsFileName: string, public jsFile: ITextWriter, public sourceMapOut: ITextWriter) {\n            this.sourceMappings = new SourceMapping[];\n            this.currentMapping = -1;\n\n            this.jsFileName = Tools.getPrettyName(jsFileName, false, true);\n            this.strFileName = Tools.getPrettyName(strFileName, false, true);\n        }\n        \n        static private CanEmitMapping(sourceMappings: SourceMapping[], currentMapping: SourceMapping) {\n            if (currentMapping.firstChild !== -1) {\n                var childMapping = sourceMappings[currentMapping.firstChild];\n                if (childMapping.emittedStartLine === currentMapping.emittedStartLine &&\n                    childMapping.emittedStartColumn === currentMapping.emittedStartColumn) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        // Generate source mapping\n        static EmitSourceMapping(allSourceMappers: SourceMapper[]) {\n\n            // At this point we know that there is alreast one source mapper present.\n            // If there are multiple source mappers, all correspond to same map file but different sources\n\n            // Output map file name into the js file\n            var sourceMapper = allSourceMappers[0];\n            sourceMapper.jsFile.WriteLine(\"//@ sourceMappingURL=\" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);\n\n            // Now output map file\n            var sourceMapOut = sourceMapper.sourceMapOut;\n            var mappingsString = \"\";\n            var strFiles: string[] = [];\n\n            var prevEmittedColumn = 0;\n            var prevEmittedLine = 0;\n            var prevSourceColumn = 0;\n            var prevSourceLine = 0;\n            var prevSourceIndex = 0;\n\n            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {\n                sourceMapper = allSourceMappers[sourceMapperIndex];\n\n                // If there are any mappings generated\n                if (sourceMapper.sourceMappings != null) {\n                    var currentSourceIndex = strFiles.length;\n                    strFiles.push(sourceMapper.strFileName);\n                    \n                    var sourceMappings = sourceMapper.sourceMappings;\n                    for (var i = 0, len = sourceMappings.length; i < len; i++) {\n                        var sourceMapping = sourceMappings[i];\n                        if (!SourceMapper.CanEmitMapping(sourceMappings, sourceMapping)) {\n                            continue;\n                        }\n\n                        if (prevEmittedLine !== sourceMapping.emittedStartLine) {\n                            prevEmittedColumn = 0;\n                            while (prevEmittedLine < sourceMapping.emittedStartLine) {\n                                mappingsString = mappingsString + \";\";\n                                prevEmittedLine++;\n                            }\n                        }\n                        else if (i > 0) {\n                            mappingsString = mappingsString + \",\";\n                        }\n\n                        // 1. Relative Column\n                        mappingsString = mappingsString + Base64VLQFormat.encode(sourceMapping.emittedStartColumn - prevEmittedColumn);\n                        prevEmittedColumn = sourceMapping.emittedStartColumn;\n\n                        // 2. Relative sourceIndex \n                        mappingsString = mappingsString + Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);\n                        prevSourceIndex = currentSourceIndex;\n\n                        // 3. Relative sourceLine 0 based\n                        mappingsString = mappingsString + Base64VLQFormat.encode(sourceMapping.sourceStartLine - 1 - prevSourceLine);\n                        prevSourceLine = sourceMapping.sourceStartLine - 1;\n\n                        // 4. Relative sourceColumn 0 based \n                        mappingsString = mappingsString + Base64VLQFormat.encode(sourceMapping.sourceStartColumn - prevSourceColumn);\n                        prevSourceColumn = sourceMapping.sourceStartColumn;\n\n                        // 5. Since no names , let it go for time being\n                    }\n                }\n            }\n\n            // Write the actual map file\n            if (mappingsString != \"\") {\n                sourceMapOut.Write(\'{\');\n                sourceMapOut.Write(\'\"version\":3,\');\n                sourceMapOut.Write(\'\"file\":\"\' + sourceMapper.jsFileName + \'\",\');\n                sourceMapOut.Write(\'\"sources\":[\"\' + strFiles.join(\'\",\"\') + \'\"],\');\n                sourceMapOut.Write(\'\"names\":[],\');\n                sourceMapOut.Write(\'\"mappings\":\"\' + mappingsString);\n                sourceMapOut.Write(\'\"\');\n                //sourceMapOut.Write(\'\"sourceRoot\":\"\"\'); // not needed since we arent generating it in the folder\n                sourceMapOut.Write(\'}\');\n            }\n\n            // Done, close the file\n            sourceMapOut.Close();\n        }\n    }\n}\n\n\nmodule Tools {\n\n    export enum UpdateUnitKind {\n        Unknown,\n        NoEdits,\n        EditsInsideSingleScope,\n    }\n\n    export oldclass ScriptEditRange(\n        public minChar: number,\n        public limChar: number,\n        public delta: number) {\n\n        static unknown(): ScriptEditRange {\n            return new ScriptEditRange(-1, -1, -1);\n        }\n\n        public isUnknown() {\n            return this.minChar === -1 && this.limChar === -1 && this.delta === -1;\n        }\n\n        public containsPosition(pos: number) {\n            return (this.minChar <= pos && pos < this.limChar)\n                || (this.minChar <= pos && pos < this.limChar + this.delta);\n        }\n\n        public toString(): string {\n            return \"editRange(minChar=\" + this.minChar + \", limChar=\" + this.limChar + \", delta=\" + this.delta + \")\";\n        }\n    }\n\n    export oldclass UpdateUnitResult(property kind: UpdateUnitKind, property unitIndex: number, property script1: Script, property script2: Script) {\n        property scope1: AST = null;\n        property scope2: AST = null;\n        property editRange: ScriptEditRange = null;\n        property parseErrors: ErrorEntry[] = [];\n\n        static noEdits(unitIndex: number) {\n            return new UpdateUnitResult(UpdateUnitKind.NoEdits, unitIndex, null, null);\n        }\n\n        static unknown(script1: Script, script2: Script, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.Unknown, script1.locationInfo.unitIndex, script1, script2);\n            result.parseErrors = parseErrors;\n            return result;\n        }\n\n        static editsInsideFunctionBody(script1: Script, script2: Script, scope1: AST, scope2: AST, editRange: ScriptEditRange, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope, script1.locationInfo.unitIndex, script1, script2);\n            result.scope1 = scope1;\n            result.scope2 = scope2;\n            result.editRange = editRange;\n            result.parseErrors = parseErrors;\n            return result;\n        }\n    }\n\n    export oldclass ErrorEntry(\n        property unitIndex: number,\n        property minChar: number,\n        property limChar: number,\n        property message: string) {\n    }\n\n    export var defaultSettings = new CompilationSettings();\n\n    export oldclass StradaCompiler(property outfile: ITextWriter, property errorOutput: ITextWriter, property logger: ILogger = new NullLogger(), property settings: CompilationSettings=defaultSettings) {\n        property parser = new Parser();\n        property typeChecker: TypeChecker\n        property typeFlow: TypeFlow = null;\n        property scripts = new ASTList();\n        property units: LocationInfo[] = new LocationInfo[];\n        property errorReporter = new ErrorReporter(this.outfile);\n\n        property persistentTypeState = new PersistentGlobalTypeState(this.errorReporter);\n\n        this.errorReporter.parser = this.parser;\n        this.initTypeChecker(this.errorOutput);\n\n        this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;\n        this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;\n        this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;\n\n        property emitSettings = { minWhitespace: this.settings.minWhitespace, propagateConstants: this.settings.propagateConstants, emitComments: this.settings.emitComments };\n\n        property timeFunction(funcDescription: string, func: () =>any): any {\n            return Tools.timeFunction(this.logger, funcDescription, func);\n        }\n\n        property initTypeChecker(errorOutput: ITextWriter) {\n            // The initial \"refresh\" initializes the persistent type state\n            this.persistentTypeState.refreshPersistentState();\n            this.typeChecker = new TypeChecker(this.persistentTypeState);\n            this.typeChecker.errorReporter = this.errorReporter;\n\n            // REVIEW: These properties should be moved out of the typeCheck object\n            // ideally, CF should be a separate pass, independent of control flow\n            this.typeChecker.checkControlFlow = this.settings.controlFlow;\n            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;\n            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;\n\n            this.typeChecker.errorsOnWith = this.settings.errorOnWith;\n            this.typeChecker.styleSettings = this.settings.styleSettings;\n            this.typeChecker.addMembersToClassScope = !this.settings.propertiesRequireThis;\n\n            this.errorReporter.checker = this.typeChecker;\n            this.setErrorOutput(this.errorOutput);\n        }\n\n        property setErrorOutput(outerr) {\n            this.errorOutput = outerr;\n            this.errorReporter.setErrOut(outerr);\n            this.parser.outfile = outerr;\n        }\n\n        property emitCommentsToOutput() {\n            this.emitSettings = { minWhitespace: this.settings.minWhitespace, propagateConstants: this.settings.propagateConstants, emitComments: this.settings.emitComments };\n        }\n\n        property setErrorCallback(fn: (minChar: number, charLen: number, message: string,\n            unitIndex: number) =>void ) {\n            this.parser.errorCallback = fn;\n        }\n\n        // REVIEW: Should we enable updates for resident files?\n        property updateUnit(prog: string, filename: string, setRecovery: bool) {\n            return this.updateSourceUnit(new StringSourceText(prog), filename, setRecovery);\n        }\n\n        property updateSourceUnit(sourceText: ISourceText, filename: string, setRecovery: bool): bool {\n            return this.timeFunction(\"updateSourceUnit(\" + filename + \")\", () => {\n                var updateResult = this.partialUpdateUnit(sourceText, filename, setRecovery);\n                return this.applyUpdateResult(updateResult);\n            });\n        }\n\n        // Apply changes to compiler state.\n        // Return \"false\" if the change is empty and nothing was updated.\n        property applyUpdateResult(updateResult: UpdateUnitResult): bool {\n            switch (updateResult.kind) {\n                case UpdateUnitKind.NoEdits:\n                    return false;\n\n                case UpdateUnitKind.Unknown:\n                    this.scripts.members[updateResult.unitIndex] = updateResult.script2;\n                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo;\n                    for (var i = 0, len = updateResult.parseErrors.length; i < len; i++) {\n                        var e = updateResult.parseErrors[i];\n                        if (this.parser.errorCallback != null) {\n                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex);\n                        }\n                    }\n                    return true;\n\n                case UpdateUnitKind.EditsInsideSingleScope:\n                    new IncrementalParser(this.logger).mergeTrees(updateResult);\n                    return true;\n            }\n        }\n\n        property partialUpdateUnit(sourceText: ISourceText, filename: string, setRecovery: bool): UpdateUnitResult {\n            return this.timeFunction(\"partialUpdateUnit(\" + filename + \")\", () => {\n                for (var i = 0, len = this.units.length; i < len; i++) {\n                    if (this.units[i].filename == filename) {\n                        if ((<Script>this.scripts.members[i]).isResident) {\n                            return UpdateUnitResult.noEdits(i);\n                        }\n\n                        if (setRecovery) {\n                            this.parser.setErrorRecovery(null, 0, 0);\n                        }\n\n                        var updateResult: UpdateUnitResult;\n\n                        // Capture parsing errors so that they are part of \"updateResult\"\n                        var parseErrors: ErrorEntry[] = [];\n                        var errorCapture = (minChar: number, charLen: number, message: string, unitIndex: number): void => {\n                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n                        };\n                        var svErrorCallback = this.parser.errorCallback;\n                        if (svErrorCallback != null)\n                            this.parser.errorCallback = errorCapture;\n\n                        var oldScript = <Script>this.scripts.members[i];\n                        var newScript = this.parser.parse(sourceText, filename, i);\n\n                        if (svErrorCallback != null)\n                            this.parser.errorCallback = svErrorCallback;\n\n                        updateResult = UpdateUnitResult.unknown(oldScript, newScript, parseErrors);\n\n                        return updateResult;\n                    }\n                }\n                throw new Error(\"Unknown file \\\"\" + filename + \"\\\"\");\n            });\n        }\n\n        property addUnit(prog: string, filename: string, keepResident ? = false): Script {\n            return this.addSourceUnit(new StringSourceText(prog), filename, keepResident);\n        }\n\n        property addSourceUnit(sourceText: ISourceText, filename: string, keepResident ? = false): Script {\n            return this.timeFunction(\"addSourceUnit(\" + filename + \", \" + keepResident + \")\", () => {\n                var script: Script = this.parser.parse(sourceText, filename, this.units.length, AllowedElements.Global);\n                script.isResident = keepResident;\n                this.persistentTypeState.setCollectionMode(keepResident ? TypeCheckCollectionMode.Resident : TypeCheckCollectionMode.Transient);\n                var index = this.units.length;\n                this.units[index] = script.locationInfo;\n                this.typeChecker.collectTypes(script);\n                this.scripts.append(script);\n                return script\n            });\n        }\n\n        property getInScopeNamesAndTypesFromPosition(enclosingScopeContext: EnclosingScopeContext) {\n            var members = enclosingScopeContext.isMemberCompletion;\n            var getTypeNamesForNames = function(allNames: string[], scope: SymbolScope) {\n                var typeNames: string[] = [];\n                var names: string[] = []\n                var enclosingScope = enclosingScopeContext.getScope();\n\n                for (var i = 0; i < allNames.length; i++) {\n                    try {\n                        var name = allNames[i];\n\n                        // Search for the id in the value space first\n                        // if we don\'t find it, search in the type space.\n                        // We don\'t want to search twice, because the first\n                        // search may insert the name in the symbol value table\n                        // if the scope is aggregate\n                        var publicsOnly = enclosingScopeContext.publicsOnly && members;\n                        var symbol = scope.find(name, publicsOnly, false);  // REVIEW: Should search public members only?\n                        if (symbol == null) {\n                            symbol = scope.find(name, publicsOnly, true);\n                        }\n                        // Do not add dynamic module names to the list, since they\'re not legal as identifiers\n                        if (/*symbol.visible(scope, this.typeChecker) && */!isQuoted(symbol.name) && !isRelative(symbol.name)) {\n                            var typeName = symbol.getType().getScopedTypeName(enclosingScope);\n                            names.push(name);\n                            typeNames.push(typeName);\n                        }\n                    } catch (e) {\n                        if (allNames[i] == \"true\" || allNames[i] == \"false\") {\n                            names.push(allNames[i]);\n                            typeNames.push(\"bool\");\n                        }\n                    }\n                }\n                return { names: names, types: typeNames };\n            }\n            var scope = enclosingScopeContext != null ?\n                            (members ?\n                                this.typeFlow.findMemberScopeAt(enclosingScopeContext) :\n                                enclosingScopeContext.getScope()) :\n                            <SymbolScope>null;\n\n            if (scope != null) {\n                if (enclosingScopeContext.scopeStartAST.nodeType == NodeType.ObjectLit) {\n                    scope = (<TypeSymbol>scope.container).type.memberScope;\n                }\n                var inScopeNames: IHashTable = new StringHashTable();\n                var allSymbolNames: string[] = scope.getAllSymbolNames(members);\n                var name = \"\";\n                var symbol = null;\n\n                // there may be duplicates between the type and value tables, so batch the symbols\n                // getTypeNamesForNames will prefer the entry in the value table\n                for (var i = 0; i < allSymbolNames.length; i++) {\n                    name = allSymbolNames[i];\n\n                    // Skip global/internal symbols that won\'t compile in user code\n                    if (name == globalId || name == \"_Core\" || name == \"_element\") {\n                        continue;\n                    }\n\n                    inScopeNames.add(name, \"\");\n                }\n\n                var svModuleDecl = this.typeChecker.currentModDecl;\n                this.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl;\n\n                var result = getTypeNamesForNames(inScopeNames.getAllKeys(), scope);\n\n                this.typeChecker.currentModDecl = svModuleDecl;\n                return result;\n            }\n            else {\n                return null;\n            }\n        }\n\n        property parseUnit(prog: string, filename: string) {\n            return this.parseSourceUnit(new StringSourceText(prog), filename);\n        }\n\n        property parseSourceUnit(sourceText: ISourceText, filename: string) {\n            this.parser.setErrorRecovery(this.outfile, -1, -1);\n            var script: Script = this.parser.parse(sourceText, filename, 0);\n            script.walk(prePrintAST, postPrintAST, null, new PrintContext(this.outfile, this.parser));\n        }\n\n        property typeCheck() {\n            return this.timeFunction(\"typeCheck()\", () => {\n                var binder = new Binder(this.typeChecker);\n                this.typeChecker.units = this.units;\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globalTypes);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobalTypes);\n                this.typeFlow = new TypeFlow(this.logger, this.typeChecker.globalScope, this.parser, this.typeChecker);\n                var i = 0;\n                var script: Script = null;\n                var len = this.scripts.members.length;\n\n\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Resident);\n                // first, typecheck resident \"lib\" scripts, if necessary\n                for (i = 0; i < len; i++) {\n                    script = this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.typeCheck(script);\n                    script.hasBeenTypeChecked = true;\n                }\n\n                // next typecheck scripts that may change\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                len = this.scripts.members.length;\n                for (i = 0; i < len; i++) {\n                    script = this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.typeCheck(script);\n                }\n\n                return null;\n            });\n        }\n\n        property cleanASTTypesForReTypeCheck(ast: AST) {\n            function cleanASTType(ast: AST, parent: AST, context: IWalkContext) {\n                ast.type = null;\n                if (ast.nodeType == NodeType.VarDecl) {\n                    var vardecl = <VarDecl>ast;\n                    vardecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.ArgDecl) {\n                    var argdecl = <ArgDecl>ast;\n                    argdecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.Name) {\n                    var name = <Identifier>ast;\n                    name.sym = null;\n                }\n                else if (ast.nodeType == NodeType.FuncDecl) {\n                    var funcdecl = <FuncDecl>ast;\n                    funcdecl.signature = null;\n                    funcdecl.freeVariables = new Symbol[]\n                    funcdecl.symbols = null;\n                    funcdecl.accessorSymbol = null;\n                }\n                else if (ast.nodeType == NodeType.Module) {\n                    var modDecl = <ModuleDecl>ast;\n                    modDecl.anonExportedSymbols = null;\n                    modDecl.mod = null;\n                }\n                else if (ast.nodeType == NodeType.With) {\n                    (<WithStatement>ast).withSym = null;\n                }\n                else if (ast.nodeType == NodeType.Catch) {\n                    (<Catch>ast).containedScope = null;\n                }\n                return ast;\n            }\n            ast.walk(cleanASTType, null, null, { goChildren: true, goNextSibling: true });\n        }\n\n        property cleanTypesForReTypeCheck() {\n            return this.timeFunction(\"cleanTypesForReTypeCheck()\", () => {\n                for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                    var script = this.scripts.members[i];\n                    if ((<Script>script).isResident) {\n                        continue;\n                    }\n                    this.cleanASTTypesForReTypeCheck(script);\n                    this.typeChecker.collectTypes(script);\n                }\n\n                return null;\n            });\n        }\n\n        //\n        // Return \"true\" if the incremental typecheck was successful\n        // Return \"false\" if incremental typecheck failed, requiring a full typecheck\n        //\n        property attemptIncrementalTypeCheck(updateResult: Tools.UpdateUnitResult): bool {\n            return this.timeFunction(\"attemptIncrementalTypeCheck()\", () => {\n                // updateResult.kind == editsInsideFunction\n                // updateResult.scope1 == old function\n                // updateResult.scope2 == new function\n                //TODO: What about typecheck errors? How do we replace the old ones with the new ones?\n                return false;\n            });\n        }\n\n        property reTypeCheck() {\n            return this.timeFunction(\"reTypeCheck()\", () => {\n                CompilerDiagnostics.analysisPass++;\n                this.initTypeChecker(this.errorOutput);\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                this.cleanTypesForReTypeCheck();\n                return this.typeCheck();\n            });\n        }\n\n        property emitTypes() {\n            var emitter = new Emitter(this.typeChecker, this.outfile, this.emitSettings);\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = this.scripts.members[i];\n                script.emitType(emitter);\n            }\n        }\n\n        property emit(outputMany: bool, createFile: (path: string) => ITextWriter) {\n            var emitter: Emitter = null;\n\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n\n                var script = <Script>this.scripts.members[i];\n                if (!script.emitRequired()) {\n                    continue;\n                }\n\n                var outf = this.outfile;\n                if (outputMany) {\n                    var fname = this.units[i].filename;\n                    var splitFname = fname.split(\".\");\n                    var outFname = \"\";\n                    for (var j = 0, splitLen = splitFname.length; j < splitLen - 1; j++) {\n                        outFname += (splitFname[j] + \".\");\n                    }\n                    outFname += \"js\";\n                    outf = createFile(outFname);\n                    emitter = new Emitter(this.typeChecker, outf, this.emitSettings);\n\n                    if (this.settings.mapSourceFiles) {\n                        emitter.setSourceMappings(new Tools.SourceMapper(fname, outFname, outf, createFile(outFname + SourceMapper.MapFileExtension)));\n                    }\n                }\n                else {\n                    if (emitter == null) {\n                        emitter = new Emitter(this.typeChecker, this.outfile, this.emitSettings);\n                        if (this.settings.mapSourceFiles) {\n                            emitter.setSourceMappings(new Tools.SourceMapper(script.locationInfo.filename, this.settings.outputFileName, this.outfile, createFile(this.settings.outputFileName + SourceMapper.MapFileExtension)));\n                        }\n                    }\n                    else if (this.settings.mapSourceFiles) {\n                        emitter.setSourceMappings(new Tools.SourceMapper(script.locationInfo.filename, emitter.sourceMapper.jsFileName, this.outfile, emitter.sourceMapper.sourceMapOut));\n                    }\n                }\n\n                this.typeChecker.locationInfo = script.locationInfo;\n                emitter.emitJavascript(script, TokenID.Comma, false);\n                if (outputMany) {\n                    if (this.settings.mapSourceFiles) {\n                        emitter.emitSourceMappings();\n                    }\n                    outf.Close();\n                }\n            }\n            if (!outputMany && this.settings.mapSourceFiles) {\n                emitter.emitSourceMappings();\n            }\n        }\n\n        property emitToOutfile() {\n            var emitter: Emitter = null;\n            if (this.settings.mapSourceFiles) {\n                throw Error(\"Outputing map not supported in this case because dont know how to createFile\");\n            }\n\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                if (emitter == null) {\n                    emitter = new Emitter(this.typeChecker, this.outfile, this.emitSettings);\n                }\n                var script = <Script>this.scripts.members[i];\n                this.typeChecker.locationInfo = script.locationInfo;\n                emitter.emitJavascript(script, TokenID.Comma, false);\n            }\n        }\n    }\n}\n\n\noldclass CommandLineHost() implements Tools.IResolverHost {\n\n    property resolveCompilationEnvironment(preEnv: Tools.CompilationEnvironment,\n        resolver: Tools.ICodeResolver,\n        traceDependencies: bool): Tools.CompilationEnvironment {\n        var resolvedEnv = new Tools.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);\n\n        var nCode = preEnv.code.length;\n        var nRCode = preEnv.residentCode.length;\n        var resolvedPaths: any = { };\n\n        var postResolutionError = \n            function (errorFile: string, errorMessage: string) {\n                Tools.CompilerDiagnostics.debugPrint(\"Could not resolve file \'\" + errorFile + \"\'\" + (errorMessage == \"\" ? \"\" : \": \" + errorMessage));\n            }\n\n        var resolutionDispatcher: Tools.IResolutionDispatcher = {\n            postResolutionError: postResolutionError,\n            postResolution: function(path: string, code: Tools.ISourceText) {\n                if (!resolvedPaths[path]) {\n                    resolvedEnv.code.push(code);\n                    resolvedPaths[path] = true;\n                }\n            }\n        };\n\n        var residentResolutionDispatcher: Tools.IResolutionDispatcher = {\n            postResolutionError: postResolutionError,\n            postResolution: function(path: string, code: Tools.ISourceText) {\n                if (!resolvedPaths[path]) {\n                    resolvedEnv.residentCode.push(code);\n                    resolvedPaths[path] = true;\n                }\n            }\n        };\n\n        for (var i = 0; i < nRCode; i++) {\n            resolver.resolveCode(Tools.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.residentCode[i].path)), \"\", false, residentResolutionDispatcher);\n        }\n\n        for (var i = 0; i < nCode; i++) {\n            resolver.resolveCode(Tools.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path)), \"\", false, resolutionDispatcher);\n        }\n\n        return resolvedEnv;\n    }\n}\n\noldclass Batch(ioHost: IIO) {\n    var compilationSettings = new Tools.CompilationSettings();\n    var compilationEnvironment = new Tools.CompilationEnvironment(compilationSettings, ioHost);\n    var commandLineHost = new CommandLineHost();\n    var resolvedEnvironment: Tools.CompilationEnvironment = null;\n\n    function resolve() {\n        var resolver = new Tools.CodeResolver(compilationEnvironment);\n        return commandLineHost.resolveCompilationEnvironment(compilationEnvironment, resolver, true);\n    }\n    \n    /// Do the actual compilation reading from input files and\n    /// writing to output file(s).\n    function compile() {\n        var outfile: ITextWriter = compilationSettings.outputFileName ? ioHost.createFile(compilationSettings.outputFileName) : null;\n        var compiler: Tools.StradaCompiler;\n        // initialize to avoid definite assignment warning\n        var errout: ITextWriter = null;\n\n        if (compilationSettings.errorFileName) {\n            errout = ioHost.createFile(compilationSettings.errorFileName);\n            compiler = new Tools.StradaCompiler(outfile, errout, new Tools.NullLogger(), compilationSettings);\n            compiler.setErrorOutput(errout);\n        } else {\n            compiler = new Tools.StradaCompiler(outfile, outfile, new Tools.NullLogger(), compilationSettings);\n            compiler.setErrorOutput(ioHost.stderr);\n            compiler.setErrorCallback(\n                function(minChar, charLen, message, unitIndex) {\n                    var fname = resolvedEnvironment.code[unitIndex].path;\n                    var msg = fname + \" (\" + compiler.parser.scanner.line + \",\" + compiler.parser.scanner.col + \"): \" + message;\n                    if (compilationSettings.errorRecovery) {\n                        ioHost.stderr.WriteLine(msg);\n                    } else {\n                        throw new SyntaxError(msg);\n                    }\n                });\n        }\n\n        if (compilationSettings.emitComments) {\n            compiler.emitCommentsToOutput();\n        }\n\n        function consumeUnit(code: Tools.SourceUnit, addAsResident: bool) {\n            try {\n                // if file resolving is disabled, the file\'s content will not yet be loaded\n\n                if (!compilationSettings.resolve) {\n                    code.content = ioHost.readFile(code.path);\n                }\n\n                if (code.content != null) {\n                    if (compilationSettings.parseOnly) {\n                        compiler.parseUnit(code.content, code.path);\n                    }\n                    else {\n                        if (compilationSettings.errorRecovery) {\n                            compiler.parser.setErrorRecovery(outfile, -1, -1);\n                        }\n                        compiler.addUnit(code.content, code.path, addAsResident);\n                    }\n                }\n            }\n            catch (err) {\n                // This includes syntax errors thrown from error callback if not in recovery mode\n                if (errout != null)\n                    errout.WriteLine(err.message)\n                else\n                    ioHost.stderr.WriteLine(err.message);\n            }\n\n        }\n\n        for (var iResCode = 0 ; iResCode < resolvedEnvironment.residentCode.length; iResCode++) {\n            if (!compilationSettings.parseOnly) {\n                consumeUnit(resolvedEnvironment.residentCode[iResCode], true);\n            }\n        }\n\n        for (var iCode = 0 ; iCode < resolvedEnvironment.code.length; iCode++) {\n            if (!compilationSettings.parseOnly || (iCode > 0)) {\n                consumeUnit(resolvedEnvironment.code[iCode], false);\n            }\n        }\n\n        if (!compilationSettings.parseOnly) {\n            compiler.typeCheck();\n            if (compilationSettings.emitTypes) {\n                compiler.emitTypes();\n            } else {\n                compiler.emit(compilationSettings.outputMany, ioHost.createFile);\n            }\n        }\n\n        if (outfile) {\n            outfile.Close();\n        }\n\n        if (errout) {\n            errout.Close();\n        }\n\n    }\n\n    // Execute the provided inputs\n    function run() {\n        for (var i = 0; i < compilationEnvironment.code.length; i++) {\n            var unit = compilationEnvironment.code[i];\n            \n            var outputFileName = unit.path.replace(/\\.str$/, \".js\");\n            if (ioHost.fileExists(outputFileName)) {\n                var unitRes = ioHost.readFile(outputFileName)\n                ioHost.run(unitRes, outputFileName);\n            }\n        }\n    }\n\n    /// Begin batch compilation\n    property batchCompile = function() {\n        Tools.CompilerDiagnostics.diagnosticWriter = { Alert: function(s: string) { ioHost.printLine(s); } }\n        var code: Tools.SourceUnit = null;\n\n        var opts = new OptionsParser(ioHost);\n\n        opts.option(\'out\', {\n            usage: \'File to create\',\n            type: \'file\',\n            set: function(str) => compilationSettings.outputOne(str)\n        });\n\n        opts.option(\'err\', {\n            usage: \'File to send error messages to\',\n            type: \'file\',\n            set: function(str) => compilationSettings.errorFileName = str\n        });\n\n        opts.option(\'style\', {\n            usage: \'Select style checking options (examples --style requireSemi:off or --style \"eqeqeq;bitwise:off\")\',\n            experimental: true,\n            set: function (str) {\n                compilationSettings.setStyleOptions(str);\n            }\n        });\n        opts.option(\'map\', {\n            usage: \'Generates corresponding .map file\',\n            set: function() => compilationSettings.mapSourceFiles = true\n        });\n\n        opts.option(\'reference\', {\n            usage: \'Add a reference to the compilation\',\n            type: \'file\',\n            set: function(str) {\n                code = new Tools.SourceUnit(str, null);\n                compilationEnvironment.residentCode.push(code);\n            }\n        }, \'r\');\n\n        opts.flag(\'watch\', {\n            usage: \'Watch output files\',\n            set: function() => compilationSettings.watch = true\n        }, \'w\');\n\n        opts.flag(\'exec\', {\n            usage: \'Execute the script after compilation\',\n            set: function() => compilationSettings.exec = true\n        }, \'e\');\n\n        opts.flag(\'parse\', {\n            usage: \'Parse only\',\n            set: function() => compilationSettings.parseOnly = true\n        });\n        \n        opts.flag(\'minw\', {\n            usage: \'Minimize whitespace\',\n            experimental: true,\n            set: function() => compilationSettings.minWhitespace = true\n        }, \'mw\');\n\n        opts.flag(\'const\', {\n            usage: \'Propagate constants to emitted code\',\n            experimental: true,\n            set: function() => compilationSettings.propagateConstants = true;\n        });\n\n        opts.flag(\'types\', {\n            usage: \'Emit types only\',\n            experimental: true,\n            set: function() => compilationSettings.emitTypes = true\n        }, \'t\');\n\n        opts.flag(\'errorrecovery\', {\n            usage: \'Enable error recovery\',\n            set: function() => compilationSettings.errorRecovery = true\n        }, \'er\');\n\n        opts.flag(\'comments\', {\n            usage: \'Emit comments to output\',\n            set: function() => compilationSettings.emitComments = true\n        }, \'c\');\n\n        opts.flag(\'cflow\', {\n            usage: \'Control flow\',\n            experimental: true,\n            set: function() => compilationSettings.controlFlow = true\n        });\n\n        opts.flag(\'cflowp\', {\n            usage: \'Print control flow\',\n            experimental: true,\n            set: function() {\n                compilationSettings.controlFlow = true;\n                compilationSettings.printControlFlow = true;\n            }\n        });\n\n        opts.flag(\'cflowu\', {\n            usage: \'Print Use Def control flow\',\n            experimental: true,\n            set: function() {\n                compilationSettings.controlFlow = true;\n                compilationSettings.controlFlowUseDef = true;\n            }\n        });\n\n        opts.flag(\'noerroronwith\', {\n            usage: \'Allow with statements\',\n            set: function() => compilationSettings.errorOnWith = false\n        });\n\n        opts.flag(\'noresolve\', {\n            usage: \'Skip resolution and preprocessing\',\n            set: function() {\n                compilationSettings.resolve = false;\n                compilationSettings.preprocess = false;\n            }\n        });\n\n        opts.flag(\'debug\', {\n            usage: \'Print debug output\',\n            experimental: true,\n            set: function() => Tools.CompilerDiagnostics.debug = true\n        });\n\n        opts.flag(\'nooptimizemodules\', {\n            usage: \'Do not optimize module codegen\',\n            set: function() => Tools.optimizeModuleCodeGen = false\n        });\n\n        opts.flag(\'inferProperties\', {\n            usage: \'Infer ES6 class properties from top-level assignments to \\\'this\\\'\',\n            experimental: true,\n            set: function() => compilationSettings.inferPropertiesFromThisAssignment = true\n        });\n\n        opts.option(\'target\', {\n            usage: \'Specify ES version target. \"ES3\", \"ES5\", and \"ES6\" are supported.\',\n            type: \'module\',\n            set: function(type) {\n                type = type.toLowerCase();\n\n                if (type === \'es3\') {\n                    Tools.codeGenTarget = Tools.CodeGenTarget.ES3;\n                } else if (type === \'es5\') {\n                    Tools.codeGenTarget = Tools.CodeGenTarget.ES5;\n                } else if (type === \'es6\') {\n                    Tools.codeGenTarget = Tools.CodeGenTarget.ES6;\n                } else {\n                    IO.printLine(\"Unknown codegen target - using default ES3 mode\");\n                }\n            }\n        });\n\n        opts.option(\'module\', {\n            usage: \'Specify module codegen. \"Node\", \"Amd\", and \"Local\" are supported.\',\n            type: \'module\',\n            set: function(type) {\n                type = type.toLowerCase();\n\n                if (type === \'node\') {\n                    Tools.moduleGenTarget = Tools.ModuleGenTarget.Synchronous;\n                } else if (type === \'amd\') {\n                    Tools.moduleGenTarget = Tools.ModuleGenTarget.Asynchronous;\n                } else if (type === \'local\') {\n                    Tools.moduleGenTarget = Tools.ModuleGenTarget.Local;\n                } else {\n                    IO.printLine(\"Unknown module\");\n                }\n            }\n        });\n\n        opts.flag(\'norequirethis\', {\n            usage: \'Do not require a \\\'this\\\' qualifier on all class member accesses\',\n            experimental: true,\n            set: function() {\n                compilationSettings.propertiesRequireThis = false;\n            }\n        });\n\n        opts.flag(\'help\', {\n            usage: \'Print this message\',\n            set: function(type) {\n                opts.printUsage();\n            }\n        }, \'h\')\n\n        opts.parse(ioHost.arguments);\n\n        for (var i = 0; i < opts.unnamed.length; i++) {\n            code = new Tools.SourceUnit(opts.unnamed[i], null);\n            compilationEnvironment.code.push(code);\n        }\n\n        if (compilationEnvironment.code.length == 0 && compilationEnvironment.residentCode.length == 0) {\n            ioHost.printLine(\"usage: strc [filename | option]*\");\n            return;\n        }\n\n        // resolve file dependencies, if requested\n        resolvedEnvironment = compilationSettings.resolve ? resolve() : compilationEnvironment;\n\n\n        // REVIEW: Update to use compilation settings / env\n        if (compilationSettings.watch) {\n            var files: string[] = []\n            for (var iResCode = 0 ; iResCode < resolvedEnvironment.residentCode.length; iResCode++) {\n                files.push(resolvedEnvironment.residentCode[iResCode].path);\n            }\n            for (var iCode = 0 ; iCode < resolvedEnvironment.code.length; iCode++) {\n                files.push(resolvedEnvironment.code[iCode].path);\n            }\n            var canWatch = ioHost.watchFiles(files, function() {\n                ioHost.printLine(\"Recompiling(\" + new Date() + \"): \" + files);\n                \n                compilationEnvironment.code = [];\n                for (var i = 0; i < opts.unnamed.length; i++) {\n                    code = new Tools.SourceUnit(opts.unnamed[i], null);\n                    compilationEnvironment.code.push(code);\n                }\n\n                // resolve file dependencies, if requested\n                resolvedEnvironment = compilationSettings.resolve ? resolve() : compilationEnvironment;\n                \n                compile();\n                if(compilationSettings.exec) {\n                    run();\n                }\n                ioHost.printLine(\"\");\n            });\n            if (!canWatch) {\n                ioHost.printLine(\"Error: Current host does not support -w[atch] option\");\n            }\n        } else {\n            compile();\n            if (compilationSettings.exec) {\n                run();\n            }\n        }\n\n    }\n}\n\n// Start the batch compilation using the current hosts IO\nvar batch = new Batch(IO);\nbatch.batchCompile();\n\n\nmodule Tools {\n\n    export enum TypeCheckStatus {\n        NotStarted,\n        Started,\n        Finished,\n    }\n\n    // todo: make these two functions library routines over { name:string }\n    export function uniqueSymbols(dup: Symbol[]): Symbol[]{\n        var a: Symbol[] = new Symbol[];\n        var l: number = dup.length;\n        var prevName = \"@\";\n        for (var i: number = 0; i < l; i++) {\n            if (prevName != dup[i].name) {\n                a[a.length] = dup[i];\n                prevName = dup[i].name;\n            }\n        }\n        return a;\n    }\n\n    export function symbolCompareByName(a: Symbol, b: Symbol): number {\n        if (a.name < b.name) {\n            return -1;\n        }\n        else if (a.name == b.name) {\n            return 0;\n        }\n        else {\n            return 1;\n        }\n    }\n\n    // For lexically-scoped constructs\n    // REVIEW: Expand for \"with\"\n    export function aLexicallyEnclosesB(a: Symbol, b: Symbol) {\n        if (a.declAST != null && b != null && b.declAST != null && a.declAST.nodeType == NodeType.FuncDecl) {\n            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;\n        }\n        else {\n            return false;\n        }\n    }\n\n    export function aEnclosesB(a: Symbol, b: Symbol) {\n        while (a.container != null) {\n            if (a == b || aLexicallyEnclosesB(a.container, b)) {\n                return true;\n            }\n            a = a.container;\n        }\n        return false;\n    }\n\n    export oldclass Symbol(property name: string, property location: number,\n                 property unitIndex: number) {\n        property bound = false;\n        property container: Symbol;\n        property instanceScope(): SymbolScope => null;\n        property isVariable() => false;\n        property isMember() => false;\n        property isInferenceSymbol() => false;\n        property isWith() => false;\n        property writeable() => false;\n        property isType(): bool => false;\n        property getType(): Type => null;\n        property flags: SymbolFlags = SymbolFlags.None;\n        property refs: Identifier[];\n        property isAccessor() => false;\n        property isObjectLitField = false;\n\n        property declAST: AST = null;\n        property declModule: ModuleDecl = null;  // if child of module, this is the module that declared it\n\n        // REVIEW: For diagnostics purposes\n        property passSymbolCreated: number = CompilerDiagnostics.analysisPass;\n\n        property isInstanceProperty() {\n            return hasFlag(this.flags, SymbolFlags.Property) && (!hasFlag(this.flags, SymbolFlags.ModuleMember));\n        }\n\n        property getTypeName(scope: SymbolScope): string {\n            return this.toString();\n        }\n\n        property pathToRoot() {\n            var path = new Symbol[];\n            var node = this;\n            while ((node != null) && (node.name != globalId)) {\n                path[path.length] = node;\n                node = node.container;\n            }\n            return path;\n        }\n\n        property findCommonAncestorPath(b: Symbol) {\n            if (this.container == null) {\n                return new Symbol[];\n            }\n            var aPath = this.container.pathToRoot();\n            var bPath: Symbol[];\n            if (b != null) {\n                bPath = b.pathToRoot();\n            }\n            else {\n                bPath = new Symbol[];\n            }\n            var commonNodeIndex = -1;\n            for (var i = 0, aLen = aPath.length; i < aLen; i++) {\n                var aNode = aPath[i];\n                for (var j = 0, bLen = bPath.length; j < bLen; j++) {\n                    var bNode = bPath[j];\n                    if (aNode == bNode) {\n                        commonNodeIndex = i;\n                        break;\n                    }\n                }\n                if (commonNodeIndex >= 0) {\n                    break;\n                }\n            }\n            if (commonNodeIndex >= 0) {\n                return aPath.slice(0, commonNodeIndex);\n            }\n            else {\n                return aPath;\n            }\n\n        }\n\n        property scopeRelativeName(scope: SymbolScope): string {\n            if (scope == null) {\n                return this.name;\n            }\n            var lca = this.findCommonAncestorPath(scope.container);\n            var builder = \"\";\n            for (var i = 0, len = lca.length; i < len; i++) {\n                builder = lca[i].name + \".\" + builder;\n            }\n            builder += this.name;\n            return builder;\n        }\n\n        property fullName(): string {\n            var builder = this.name;\n            var ancestor = this.container;\n            while ((ancestor != null) && (ancestor.name != globalId)) {\n                builder = ancestor.name + \".\" + builder;\n                ancestor = ancestor.container;\n            }\n            return builder;\n        }\n\n        property visible(scope: SymbolScope, checker: TypeChecker) {\n            if (checker == null || this.container == checker.gloMod) {\n                return true;\n            }\n\n            if (hasFlag(this.flags, SymbolFlags.ModuleMember)) {\n\n                if (hasFlag(this.flags, SymbolFlags.Exported)) {\n                    if (!hasFlag(this.flags, SymbolFlags.Private)) {\n                        return true;\n                    }\n                    else {\n                        return aEnclosesB(this, scope.container);\n                    }\n                }\n                else {\n                    // REVIEW:\n                    // Note that in the scope-assignment and binding phases,\n                    // currentModDecl will point to the \"master\" module decl,\n                    // and not necessarily the one that the symbol in question\n                    // was declared in.\n                    // That\'s ok - there\'s no harm done in attributing the symbol\n                    // to the master mod decl in either of those phases, so long\n                    // as we reference the actual module fragment of declaration\n                    // during typecheck.  Doing this also prevents us from printing\n                    // multiple error messages if the symbol is not visible.\n                    return checker != null && (checker.currentModDecl == this.declModule) ||\n                                                (checker.currentModDecl != null &&\n                                                    checker.currentModDecl.mod != null &&\n                                                    checker.currentModDecl.mod.symbol != null &&\n                                                    this.declModule != null &&\n                                                    this.declModule.mod != null &&\n                                                    this.declModule.mod.symbol != null &&\n                                                    aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));\n                }\n            }\n            else {\n                // field or method\n                var isFunction = this.declAST != null && this.declAST.nodeType == NodeType.FuncDecl;\n                var isMethod = isFunction && (<FuncDecl>this.declAST).isMethod();\n                var isStaticFunction = isFunction && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Static)\n                var isPrivateMethod = isMethod && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Private);\n                var isAlias = this.isType() && (<TypeSymbol>this).isAlias;\n\n                if (this.isMember() || isMethod || isStaticFunction || isAlias) {\n                    if (hasFlag(this.flags, SymbolFlags.Private) || isPrivateMethod) {\n                        if (scope.container == null && this.container != scope.container) {\n                            return false; // it\'s an inner member being accessed by the global scope\n                        }\n                        else {\n                            return this.container == null ? true : aEnclosesB(scope.container, this.container);\n                        }\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                else if (this.container != null) {\n                    return aEnclosesB(this, scope.container);\n                }\n                else {\n                    return true;\n                }\n            }\n        }\n\n        property addRef(identifier: Identifier) {\n            if (this.refs == null) {\n                this.refs = [];\n            }\n            this.refs[this.refs.length] = identifier;\n        }\n\n        property toString() {\n            if (this.name != null) {\n                return this.name;\n            }\n            else {\n                return \"_anonymous\";\n            }\n        }\n\n        property print(outfile) {\n            outfile.Write(this.toString());\n        }\n\n        property specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            throw new Error(\"please implement in derived class\");\n        }\n\n        property setType(type: Type) {\n            throw new Error(\"please implement in derived class\");\n        }\n\n        property kind(): SymbolKind {\n            throw new Error(\"please implement in derived class\");\n        }\n    }\n\n    export oldclass ValueLocation {\n        property symbol: Symbol;\n        property typeLink: TypeLink;\n    }\n\n    export oldclass InferenceSymbol(name: string, location: number, unitIndex: number) extends Symbol(name, location, unitIndex) {\n        property typeCheckStatus = TypeCheckStatus.NotStarted;\n        property isInferenceSymbol() => true;\n        property transferVarFlags(varFlags: VarFlags) {\n            if (hasFlag(varFlags, VarFlags.Ambient)) {\n                this.flags |= SymbolFlags.Ambient;\n            }\n            if (hasFlag(varFlags, VarFlags.Constant)) {\n                this.flags |= SymbolFlags.Constant;\n            }\n            if (hasFlag(varFlags, VarFlags.Static)) {\n                this.flags |= SymbolFlags.Static;\n            }\n            if (hasFlag(varFlags, VarFlags.Property)) {\n                this.flags |= SymbolFlags.Property;\n            }\n            if (hasFlag(varFlags, VarFlags.Private)) {\n                this.flags |= SymbolFlags.Private;\n            }\n            if (hasFlag(varFlags, VarFlags.Public)) {\n                this.flags |= SymbolFlags.Public;\n            }\n            if (hasFlag(varFlags, VarFlags.Readonly)) {\n                this.flags |= SymbolFlags.Readonly;\n            }\n            if (hasFlag(varFlags, VarFlags.Exported)) {\n                this.flags |= SymbolFlags.Exported;\n            }\n        }\n    }\n\n    export oldclass TypeSymbol(locName: string, location: number, unitIndex: number, property type: Type) extends InferenceSymbol(locName, location, unitIndex) {\n        property additionalLocations: number[];\n        property expansions: Type[] = []; // For types that may be \"split\", keep track of the subsequent definitions\n        property addLocation(loc: number) {\n            if (this.additionalLocations == null) {\n                this.additionalLocations = [];\n            }\n            this.additionalLocations[this.additionalLocations.length] = loc;\n        }\n        property isMethod = false;\n        property isAlias = false;\n        property kind() => SymbolKind.Type;\n        property isType(): bool => true;\n        property getType() => this.type;\n        property prettyName: string = this.name;\n        property onlyReferencedAsTypeRef = optimizeModuleCodeGen;\n\n        property getTypeName(scope: SymbolScope) {\n            return this.type.getMemberTypeName((this.name != null) ? this.name : \"\", false, false, scope);\n        }\n        property instanceScope(): SymbolScope {\n            // Don\'t use the constructor scope for an ES6 class body or methods - use the contained scope\n            if (!this.type.isES6Class && this.type.isClass()) {\n                return this.type.instanceType.constructorScope;\n            }\n            else {\n                return this.type.containedScope;\n            }\n        }\n        // corresponding instance type if this is a class\n        property instanceType: Type;\n\n        property toString() {\n            var result = this.type.getTypeName();\n            if (this.name != null) {\n                result = this.name + \":\" + result;\n            }\n            return result;\n        }\n\n        property isClass() => this.instanceType != null;\n        property specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            if (this.type == pattern) {\n                return replacement.symbol;\n            }\n            else {\n                var replType = this.type.specializeType(pattern, replacement, checker, false);\n                if (replType != this.type) {\n                    var result = new TypeSymbol(this.name, 0, -1, replType);\n                    return result;\n                }\n                else {\n                    return this;\n                }\n            }\n        }\n\n        property scopeRelativeName(scope: SymbolScope): string {\n            if (scope == null) {\n                return this.prettyName;\n            }\n            var lca = this.findCommonAncestorPath(scope.container);\n            var builder = \"\";\n            for (var i = 0, len = lca.length; i < len; i++) {\n                builder = lca[i].name + \".\" + builder;\n            }\n            builder += this.prettyName;\n            return builder;\n        }\n    }\n\n    export oldclass WithSymbol(location: number, unitIndex: number, withType: Type) extends TypeSymbol(\"with\", location, unitIndex, withType) {\n        property isWith() => true;\n    }\n\n    export oldclass FieldSymbol(property name: string, property location: number, unitIndex: number, property canWrite: bool,\n                      property field: ValueLocation) extends InferenceSymbol(this.name, this.location, unitIndex) {\n        property kind() => SymbolKind.Field;\n        property writeable() => this.isAccessor() ? this.setter != null : this.canWrite;\n        property getType() => this.field.typeLink.type;\n        property getTypeName(scope: SymbolScope) {\n            return this.name + \": \" + this.field.typeLink.type.getMemberTypeName(\"\", true, false, scope);\n        }\n        property isMember() => true;\n        property setType(type: Type) {\n            this.field.typeLink.type = type;\n        }\n\n        property getter: TypeSymbol = null;\n        property setter: TypeSymbol = null;\n        property hasBeenEmitted = false; // since getters and setters are emitted together, need to track if one has been emitted\n\n        property isAccessor() => this.getter != null || this.setter != null;\n\n        property isVariable() => true;\n        property toString() => this.name + \":\" + this.field.typeLink.type.getTypeName();\n        property specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (rType != this.field.typeLink.type) {\n                var fieldDef = new ValueLocation();\n                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                           this.canWrite, fieldDef);\n                result.flags = this.flags;\n                fieldDef.symbol = result;\n                fieldDef.typeLink = new TypeLink();\n                result.setType(rType);\n                result.typeCheckStatus = TypeCheckStatus.Finished;\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n    }\n\n    export oldclass ParameterSymbol(property name: string, property location: number, unitIndex: number,\n                          property parameter: ValueLocation) extends InferenceSymbol(this.name, this.location, unitIndex) {\n        property kind() => SymbolKind.Parameter;\n        property writeable() => true;\n        property getType() => this.parameter.typeLink.type;\n        property setType(type: Type) {\n            this.parameter.typeLink.type = type;\n        }\n        property isVariable() => true;\n        property argsOffset = (-1);\n        property isOptional() {\n            if (this.parameter != null && this.parameter.symbol != null && this.parameter.symbol.declAST != null) {\n                return (<ArgDecl>this.parameter.symbol.declAST).isOptional;\n            }\n            else {\n                return false;\n            }\n        }\n\n        property getTypeName(scope: SymbolScope) {\n            return this.name + (this.isOptional() ? \"?\" : \"\") + \":\" + this.getType().getMemberTypeName(\"\", false, false, scope);\n        }\n\n        property toString() => this.name + (this.isOptional() ? \"?\" : \"\") + \":\" + this.getType().getTypeName();\n\n        property specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (this.parameter.typeLink.type != rType) {\n                var paramDef = new ValueLocation();\n                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                               paramDef);\n                paramDef.symbol = result;\n                result.setType(rType);\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n    }\n\n    export oldclass VariableSymbol(name: string, location: number, unitIndex: number, property variable: ValueLocation) extends InferenceSymbol(name, location, unitIndex) {\n        property kind() => SymbolKind.Variable;\n        property writeable() => true;\n        property getType() => this.variable.typeLink.type;\n        property getTypeName(scope: SymbolScope) {\n            return this.name + \":\" + this.getType().getMemberTypeName(\"\", false, false, scope);\n        }\n\n        property setType(type: Type) {\n            this.variable.typeLink.type = type;\n        }\n        property isVariable() => true;\n    }\n}\n\n\nmodule Tools {\n\n    // private members are private to the scope\n    // public members are public to the scope\n    export oldclass ScopedMembers(public dualMembers: DualStringHashTable) {\n\n        public allMembers: IHashTable = this.dualMembers;\n\n        // get public members\n        public publicMembers: IHashTable = this.dualMembers.primaryTable;\n\n        // get private members\n        public privateMembers: IHashTable = this.dualMembers.secondaryTable;\n\n        // add a public member\n        public addPublicMember(key: string, data) { return this.dualMembers.primaryTable.add(key, data); }\n\n        // add a private member \n        public addPrivateMember(key: string, data) { return this.dualMembers.secondaryTable.add(key, data); }\n    }\n\n    export enum SymbolKind {\n        None,\n        Type,\n        Field,\n        Parameter,\n        Variable,\n    }\n\n    export oldclass SymbolScope(property container: Symbol) {\n        property printLabel() =>\"base\";\n        property getAllSymbolNames(members: bool): string[]{\n            return [\"please\", \"implement\", \"in\", \"derived\", \"classes\"];\n        }\n        property getAllTypeSymbolNames(members: bool): string[]{\n            return [\"please\", \"implement\", \"in\", \"derived\", \"classes\"];\n        }\n        property getAllValueSymbolNames(members: bool): string[]{\n            return [\"please\", \"implement\", \"in\", \"derived\", \"classes\"];\n        }\n        // advanced search using a filter\n        property search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool): Symbol => null;\n        // find in this immediate scope\n        property findLocal(name: string, publicOnly: bool, typespace: bool): Symbol => null;\n        // find in value namespace \n        property find(name: string, publicOnly: bool, typespace: bool): Symbol => null;\n        // find symbol that supplies an implementation\n        property findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol => null;\n        // restrict the search to ambient values\n        property findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol => null;\n        property print(outfile: ITextWriter) {\n            if (this.container != null) {\n                outfile.WriteLine(this.printLabel() + \" scope with container: \" + this.container.name + \"...\");\n            }\n            else {\n                outfile.WriteLine(this.printLabel() + \" scope...\");\n            }\n        }\n\n        property enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, publicOnly: bool,\n            typespace: bool, ambient: bool): void {\n            throw new Error(\"please implement in derived class\");\n        }\n\n        property getTable(): IHashTable {\n            throw new Error(\"please implement in derived class\");\n        }\n    }\n\n    function symbolCanBeUsed(sym: Symbol, publicOnly) {\n        return publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                            (sym.declAST != null && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                          : true;\n    }\n\n    export oldclass SymbolAggregateScope(property container: Symbol) extends SymbolScope(this.container) {\n        property printLabel() =>\"agg\";\n        property valueCache: IHashTable = null;\n        property valueImplCache: IHashTable = null;\n        property valueAmbientCache: IHashTable = null;\n        property typeCache: IHashTable = null;\n        property typeImplCache: IHashTable = null;\n        property typeAmbientCache: IHashTable = null;\n        property parents: SymbolScope[] = null;\n\n        property search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            if (this.parents != null) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);\n                    if (sym != null) {\n                        if (filter.update(sym)) {\n                            return sym;\n                        }\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        property getAllSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents != null) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllSymbolNames(members);\n                    if (parentResult != null) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        property getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents != null) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);\n                    if (parentResult != null) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        property getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents != null) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllValueSymbolNames(members);\n                    if (parentResult != null) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        property print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.parents != null) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    this.parents[i].print(outfile);\n                }\n            }\n        }\n\n        property findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var implCache = this.valueImplCache;\n\n            if (typespace) {\n                implCache = this.typeImplCache;\n            }\n            if ((implCache != null) &&\n                ((sym = implCache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST != null && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents != null) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);\n                    if (sym != null) {\n                        break;\n                    }\n                }\n            }\n            if (implCache == null) {\n                if (typespace) {\n                    this.typeImplCache = new StringHashTable();\n                    implCache = this.typeImplCache;\n                }\n                else {\n                    this.valueImplCache = new StringHashTable();\n                    implCache = this.valueImplCache;\n                }\n            }\n            implCache.add(name, sym);\n            return sym;\n        }\n\n        property find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueCache;\n\n            if (typespace) {\n                cache = this.typeCache;\n            }\n            if ((cache != null) &&\n                ((sym = cache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST != null && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents != null) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].find(name, publicOnly, typespace);\n                    if (sym != null) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeCache = new StringHashTable();\n                    cache = this.typeCache;\n                }\n                else {\n                    this.valueCache = new StringHashTable();\n                    cache = this.valueCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        property findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueAmbientCache;\n            if (typespace) {\n                cache = this.typeAmbientCache;\n            }\n            if ((cache != null) && ((sym = cache.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parents != null) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].findAmbient(name, publicOnly, typespace);\n                    if (sym != null) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeAmbientCache = new StringHashTable();\n                    cache = this.typeAmbientCache;\n                }\n                else {\n                    this.valueAmbientCache = new StringHashTable();\n                    cache = this.valueAmbientCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        property addParentScope(parent: SymbolScope): void {\n            if (this.parents == null) {\n                this.parents = new SymbolScope[];\n            }\n            this.parents[this.parents.length] = parent;\n        }\n    }\n\n    export oldclass SymbolTableScope(property valueMembers: ScopedMembers,\n                            property ambientValueMembers: ScopedMembers,\n                            property enclosedTypes: ScopedMembers,\n                            property ambientEnclosedTypes: ScopedMembers,\n                            property container: Symbol) extends SymbolScope(this.container) {\n        property printLabel() =>\"table\";\n\n        property getAllSymbolNames(members: bool): string[]{\n            var result = this.getAllTypeSymbolNames(members);\n\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        property getAllTypeSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientEnclosedTypes != null) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes != null) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        property getAllValueSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientValueMembers != null) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers != null) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        property search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym = this.find(name, publicOnly, typespace);\n            filter.update(sym);\n            return filter.result;\n        }\n\n        property find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var table: IHashTable = null;\n            var ambientTable: IHashTable = null;\n\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            else {\n                table = (this.valueMembers == null) ? null :\n                                publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n                ambientTable = (this.ambientValueMembers == null) ? null :\n                                    publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            }\n            if (ambientTable != null) {\n                var s = ambientTable.lookup(name);\n                if (s != null) { return s; }\n            }\n            if (table != null) {\n                var s = table.lookup(name);\n                if (s != null) { return s; }\n            }\n\n            return null;\n        }\n\n        property findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable != null) {\n                var s = ambientTable.lookup(name);\n                if (s != null) { return s; }\n            }\n\n            return null;\n        }\n\n        property print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers != null) {\n                this.ambientValueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine(\"  \" + key);\n                }, null);\n            }\n            if (this.valueMembers != null) {\n                this.valueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine(\"  \" + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes != null) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine(\"  \" + key);\n                }, null);\n            }\n            if (this.enclosedTypes != null) {\n                this.enclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine(\"  \" + key);\n                }, null);\n            }\n        }\n\n        property findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = this.find(name, publicOnly, typespace);\n            if (sym != null) {\n                if (sym.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>sym;\n                    if (!typeSym.type.hasImplementation()) {\n                        sym = null;\n                    }\n                }\n                else if (sym.container != null) {\n                    if (sym.container.kind() == SymbolKind.Type) {\n                        var ctypeSym = <TypeSymbol>sym.container;\n                        if (!ctypeSym.type.hasImplementation()) {\n                            sym = null;\n                        }\n                    }\n                }\n            }\n            return sym;\n        }\n\n        property getTable() {\n            return this.valueMembers.allMembers;\n        }\n    }\n\n\n    export oldclass SymbolScopeBuilder(property valueMembers: ScopedMembers,\n                                        property ambientValueMembers: ScopedMembers,\n                                        property enclosedTypes: ScopedMembers,\n                                        property ambientEnclosedTypes: ScopedMembers,\n                                        property parent: SymbolScope,\n        container: Symbol) extends SymbolScope(this.container) {\n        property printLabel() =>\"builder\";\n        property getAllSymbolNames(members: bool): string[]{\n            var result: string[] = this.getAllTypeSymbolNames(members);\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        property getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientEnclosedTypes != null) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes != null) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            if (!members && this.parent != null) {\n                var parentResult = this.parent.getAllTypeSymbolNames(members);\n                if (parentResult != null) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        property getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientValueMembers != null) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers != null) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            if (!members && this.parent != null) {\n                var parentResult = this.parent.getAllValueSymbolNames(members);\n                if (parentResult != null) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        property search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable != null) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            if (table != null) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            if (this.parent != null) {\n                sym = this.parent.search(filter, name, publicOnly, typespace);\n                if (sym != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        property print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers != null) {\n                this.ambientValueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine(\"  \" + key);\n                }, null);\n            }\n            if (this.valueMembers != null) {\n                this.valueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine(\"  \" + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes != null) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine(\"  \" + key);\n                }, null);\n            }\n            if (this.enclosedTypes != null) {\n                this.enclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine(\"  \" + key);\n                }, null);\n            }\n            if (this.parent != null) {\n                this.parent.print(outfile);\n            }\n        }\n\n        property find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if ((ambientTable != null) && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if ((table != null) && ((sym = table.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent != null) {\n                return this.parent.find(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        property findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if ((ambientTable != null) && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent != null) {\n                return this.parent.findAmbient(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        property findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (table != null) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (sym != null) { return sym; }\n                }\n            }\n            if (ambientTable != null) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (sym != null) { return sym; }\n                }\n            }\n            return null;\n        }\n\n        property enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, insertAsPublic: bool, typespace: bool, ambient: bool): void {\n            var table = null;\n\n            if (ambient) {\n                if (typespace) {\n                    table = (this.ambientEnclosedTypes == null) ? null :\n                                    insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.ambientValueMembers == null) ? null :\n                                insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;\n                }\n            }\n            else {\n                if (typespace) {\n                    table = (this.enclosedTypes == null) ? null :\n                                insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.valueMembers == null) ? null :\n                                insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;\n                }\n            }\n\n            if (table != null) {\n                if (!table.add(symbol.name, symbol)) {\n                    errorReporter.duplicateIdentifier(ast, symbol.name);\n                }\n            }\n            else {\n                CompilerDiagnostics.Alert(\"YYYYY\");\n            }\n            symbol.container = container;\n        }\n\n        property getTable() { return this.valueMembers.allMembers; }\n    }\n\n    export oldclass FilteredSymbolScope(property scope: SymbolScope, container: Symbol, property filter: ScopeSearchFilter) extends SymbolScope(container) {\n        property print(outfile: ITextWriter) {\n            this.scope.print(outfile);\n        }\n\n        property find(name: string, publicOnly: bool, typespace: bool) {\n            this.filter.reset();\n            return this.scope.search(this.filter, name, publicOnly, typespace);\n        }\n        property findLocal(name: string, publicOnly: bool, typespace: bool) => this.scope.findLocal(name, publicOnly, typespace);\n    }\n\n    export oldclass FilteredSymbolScopeBuilder(valueMembers: ScopedMembers, parent: SymbolScope, container: Symbol, property filter: (sym: Symbol) =>bool) extends SymbolScopeBuilder(valueMembers, null, null, null, parent, container) {\n        property findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym != null) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return sym;\n        }\n\n        property search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            throw new Error(\"please implement\");\n        }\n\n        property find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym != null) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return super.find(name, publicOnly, typespace);\n        }\n    }\n}\n\nmodule Tools {\n    export enum TokenID {\n        ANY,\n        BOOL,\n        BREAK,\n        CASE,\n        CATCH,\n        CLASS,\n        OLDCLASS,\n        CONST,\n        CONTINUE,\n        DEFAULT,\n        DELETE,\n        DO,\n        ELSE,\n        ENUM,\n        EXPORT,\n        EXTENDS,\n        DECLARE,\n        FALSE,\n        FINALLY,\n        FOR,\n        FUNCTION,\n        CONSTRUCTOR,\n        GET,\n        IF,\n        IMPLEMENTS,\n        IMPORT,\n        IN,\n        INSTANCEOF,\n        INTERFACE,\n        LET,\n        MODULE,\n        NEW,\n        NUMBER,\n        NULL,\n        PACKAGE,\n        PRIVATE,\n        PROPERTY,\n        PROTECTED,\n        PUBLIC,\n        RETURN,\n        SET,\n        STATIC,\n        STRING,\n        SUPER,\n        SWITCH,\n        THIS,\n        THROW,\n        TRUE,\n        TRY,\n        TYPEOF,\n        VAR,\n        VOID,\n        WITH,\n        WHILE,\n        YIELD,\n        SColon,\n        LParen,\n        RParen,\n        LBrack,\n        RBrack,\n        LCurly,\n        RCurly,\n        Comma,\n        Asg,\n        AsgAdd,\n        AsgSub,\n        AsgMul,\n        AsgDiv,\n        AsgMod,\n        AsgAnd,\n        AsgXor,\n        AsgOr,\n        AsgLsh,\n        AsgRsh,\n        AsgRs2,\n        QMark,\n        Colon,\n        LogOr,\n        LogAnd,\n        Or,\n        Xor,\n        And,\n        EQ,\n        NE,\n        Eqv,\n        NEqv,\n        LT,\n        LE,\n        GT,\n        GE,\n        Lsh,\n        Rsh,\n        Rs2,\n        Add,\n        Sub,\n        Mult,\n        Div,\n        Pct,\n        Tilde,\n        Bang,\n        Inc,\n        Dec,\n        Dot,\n        Ellipsis,\n        Error,\n        EOF,\n        Arrow,\n        ID,\n        QString,\n        Regex,\n        NumberLit,\n        Whitespace,\n        Comment,\n        Lim,\n        LimFixed = Arrow,\n        LimKeyword = YIELD,\n    }\n\n    export var tokenTable = new TokenInfo[];\n    export var nodeTypeTable = new string[];\n    export var nodeTypeToTokTable = new number[];\n    export var noRegexTable = new bool[];\n\n    noRegexTable[TokenID.ID] = true;\n    noRegexTable[TokenID.QString] = true;\n    noRegexTable[TokenID.NumberLit] = true;\n    noRegexTable[TokenID.Regex] = true;\n    noRegexTable[TokenID.THIS] = true;\n    noRegexTable[TokenID.Inc] = true;\n    noRegexTable[TokenID.Dec] = true;\n    noRegexTable[TokenID.RParen] = true;\n    noRegexTable[TokenID.RBrack] = true;\n    noRegexTable[TokenID.RCurly] = true;\n    noRegexTable[TokenID.TRUE] = true;\n    noRegexTable[TokenID.FALSE] = true;\n\n    export enum OperatorPrecedence {\n        No,\n        Cma,\n        Asg,\n        Que,\n        Lor,\n        Lan,\n        Bor,\n        Xor,\n        Ban,\n        Equ,\n        Cmp,\n        Shf,\n        Add,\n        Mul,\n        Uni,\n        Lim\n    }\n\n    export enum Reservation {\n        None = 0,\n        Javascript = 1,\n        JavascriptFuture = 2,\n        Strada = 4,\n        JavascriptFutureStrict = 8,\n        StradaAndJS = Javascript | Strada,\n        StradaAndJSFuture = JavascriptFuture | Strada,\n        StradaAndJSFutureStrict = JavascriptFutureStrict | Strada,\n    }\n\n    export oldclass TokenInfo(property tokenId: TokenID, property reservation: Reservation,\n                    property binopPrecedence: number, property binopNodeType: number,\n                    property unopPrecedence: number, property unopNodeType: number,\n                    property text: string, property ers: ErrorRecoverySet) {\n    }\n\n    function setTokenInfo(tokenId: TokenID, reservation: number, binopPrecedence: number,\n        binopNodeType: number, unopPrecedence: number, unopNodeType: number,\n        text: string, ers: ErrorRecoverySet) {\n        if (tokenId !== undefined) {\n            tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence,\n                                              binopNodeType, unopPrecedence, unopNodeType, text, ers);\n            if (binopNodeType != NodeType.None) {\n                nodeTypeTable[binopNodeType] = text;\n                nodeTypeToTokTable[binopNodeType] = tokenId;\n            }\n            if (unopNodeType != NodeType.None) {\n                nodeTypeTable[unopNodeType] = text;\n            }\n        }\n    }\n\n    setTokenInfo(TokenID.ANY, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"any\", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.BOOL, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"bool\", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.BREAK, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"break\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.CASE, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"case\", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.CATCH, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"catch\", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.CLASS, Reservation.StradaAndJSFuture, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"class\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.OLDCLASS, Reservation.StradaAndJSFuture, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"oldclass\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.CONST, Reservation.StradaAndJSFuture, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"const\", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.CONTINUE, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"continue\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.DEFAULT, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"default\", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.DELETE, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.Uni, NodeType.Delete, \"delete\", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.DO, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"do\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.ELSE, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"else\", ErrorRecoverySet.Else);\n    setTokenInfo(TokenID.ENUM, Reservation.StradaAndJSFuture, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"enum\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.EXPORT, Reservation.StradaAndJSFuture, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"export\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.EXTENDS, Reservation.StradaAndJSFuture, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"extends\", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.DECLARE, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"declare\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.FALSE, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"false\", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.FINALLY, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"finally\", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.FOR, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"for\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.FUNCTION, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"function\", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.CONSTRUCTOR, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"constructor\", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.GET, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"get\", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.SET, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"set\", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.IF, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"if\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.IMPLEMENTS, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"implements\", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.IMPORT, Reservation.StradaAndJSFuture, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"import\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.IN, Reservation.StradaAndJS, OperatorPrecedence.Cmp, NodeType.In, OperatorPrecedence.No, NodeType.None, \"in\", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.INSTANCEOF, Reservation.StradaAndJS, OperatorPrecedence.Cmp, NodeType.InstOf, OperatorPrecedence.No, NodeType.None, \"instanceof\", ErrorRecoverySet.BinOp);\n    setTokenInfo(TokenID.INTERFACE, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"interface\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.LET, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"let\", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.MODULE, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"module\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.NEW, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"new\", ErrorRecoverySet.PreOp);\n    setTokenInfo(TokenID.NUMBER, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"number\", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.NULL, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"null\", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.PACKAGE, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"package\", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.PRIVATE, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"private\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.PROPERTY, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"property\", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.PROTECTED, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"protected\", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.PUBLIC, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"public\", ErrorRecoverySet.StradaS);\n    setTokenInfo(TokenID.RETURN, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"return\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.STATIC, Reservation.StradaAndJSFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"static\", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.STRING, Reservation.Strada, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"string\", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.SUPER, Reservation.StradaAndJSFuture, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"super\", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.SWITCH, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"switch\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.THIS, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"this\", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.THROW, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"throw\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.TRUE, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"true\", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.TRY, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"try\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.TYPEOF, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.Uni, NodeType.Typeof, \"typeof\", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.VAR, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"var\", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.VOID, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.Uni, NodeType.Void, \"void\", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.WITH, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.With, \"with\", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.WHILE, Reservation.StradaAndJS, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"while\", ErrorRecoverySet.While);\n    setTokenInfo(TokenID.YIELD, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"yield\", ErrorRecoverySet.None);\n\n    setTokenInfo(TokenID.ID, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"identifier\", ErrorRecoverySet.ID);\n    setTokenInfo(TokenID.NumberLit, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"numberLiteral\", ErrorRecoverySet.Literal);\n    setTokenInfo(TokenID.Regex, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"regex\", ErrorRecoverySet.RegExp);\n    setTokenInfo(TokenID.QString, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"qstring\", ErrorRecoverySet.Literal);\n\n    // Non-operator non-identifier tokens\n    setTokenInfo(TokenID.SColon, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \";\", ErrorRecoverySet.SColon); // ;\n    setTokenInfo(TokenID.RParen, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \")\", ErrorRecoverySet.RParen); // )\n    setTokenInfo(TokenID.RBrack, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"]\", ErrorRecoverySet.RBrack); // ]\n    setTokenInfo(TokenID.LCurly, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"{\", ErrorRecoverySet.LCurly); // {\n    setTokenInfo(TokenID.RCurly, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"}\", ErrorRecoverySet.RCurly); // }\n    setTokenInfo(TokenID.Ellipsis, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"...\", ErrorRecoverySet.None); // ...\n\n    // Operator non-identifier tokens\n    setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Cma, NodeType.Comma, OperatorPrecedence.No, NodeType.None, \",\", ErrorRecoverySet.Comma); // ,\n    setTokenInfo(TokenID.Asg, Reservation.None, OperatorPrecedence.Asg, NodeType.Asg, OperatorPrecedence.No, NodeType.None, \"=\", ErrorRecoverySet.Asg); // =\n    setTokenInfo(TokenID.AsgAdd, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgAdd, OperatorPrecedence.No, NodeType.None, \"+=\", ErrorRecoverySet.BinOp); // +=\n    setTokenInfo(TokenID.AsgSub, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgSub, OperatorPrecedence.No, NodeType.None, \"-=\", ErrorRecoverySet.BinOp); // -=\n    setTokenInfo(TokenID.AsgMul, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgMul, OperatorPrecedence.No, NodeType.None, \"*=\", ErrorRecoverySet.BinOp); // *=\n\n\n\n    setTokenInfo(TokenID.AsgDiv, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgDiv, OperatorPrecedence.No, NodeType.None, \"/=\", ErrorRecoverySet.BinOp); // /=\n    setTokenInfo(TokenID.AsgMod, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgMod, OperatorPrecedence.No, NodeType.None, \"%=\", ErrorRecoverySet.BinOp); // %=\n    setTokenInfo(TokenID.AsgAnd, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgAnd, OperatorPrecedence.No, NodeType.None, \"&=\", ErrorRecoverySet.BinOp); // &=\n    setTokenInfo(TokenID.AsgXor, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgXor, OperatorPrecedence.No, NodeType.None, \"^=\", ErrorRecoverySet.BinOp); // ^=\n    setTokenInfo(TokenID.AsgOr, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgOr, OperatorPrecedence.No, NodeType.None, \"|=\", ErrorRecoverySet.BinOp); // |=\n    setTokenInfo(TokenID.AsgLsh, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgLsh, OperatorPrecedence.No, NodeType.None, \"<<=\", ErrorRecoverySet.BinOp); // <<=\n    setTokenInfo(TokenID.AsgRsh, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgRsh, OperatorPrecedence.No, NodeType.None, \">>=\", ErrorRecoverySet.BinOp); // >>=\n    setTokenInfo(TokenID.AsgRs2, Reservation.None, OperatorPrecedence.Asg, NodeType.AsgRs2, OperatorPrecedence.No, NodeType.None, \">>>=\", ErrorRecoverySet.BinOp); // >>>=\n    setTokenInfo(TokenID.QMark, Reservation.None, OperatorPrecedence.Que, NodeType.QMark, OperatorPrecedence.No, NodeType.None, \"?\", ErrorRecoverySet.BinOp); // ?\n    setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \":\", ErrorRecoverySet.Colon); // :\n    setTokenInfo(TokenID.LogOr, Reservation.None, OperatorPrecedence.Lor, NodeType.LogOr, OperatorPrecedence.No, NodeType.None, \"||\", ErrorRecoverySet.BinOp); // ||\n    setTokenInfo(TokenID.LogAnd, Reservation.None, OperatorPrecedence.Lan, NodeType.LogAnd, OperatorPrecedence.No, NodeType.None, \"&&\", ErrorRecoverySet.BinOp); // &&\n    setTokenInfo(TokenID.Or, Reservation.None, OperatorPrecedence.Bor, NodeType.Or, OperatorPrecedence.No, NodeType.None, \"|\", ErrorRecoverySet.BinOp); // |\n    setTokenInfo(TokenID.Xor, Reservation.None, OperatorPrecedence.Xor, NodeType.Xor, OperatorPrecedence.No, NodeType.None, \"^\", ErrorRecoverySet.BinOp); // ^\n    setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.Ban, NodeType.And, OperatorPrecedence.No, NodeType.None, \"&\", ErrorRecoverySet.BinOp); // &\n    setTokenInfo(TokenID.EQ, Reservation.None, OperatorPrecedence.Equ, NodeType.Eq, OperatorPrecedence.No, NodeType.None, \"==\", ErrorRecoverySet.BinOp); // ==\n    setTokenInfo(TokenID.NE, Reservation.None, OperatorPrecedence.Equ, NodeType.Ne, OperatorPrecedence.No, NodeType.None, \"!=\", ErrorRecoverySet.BinOp); // !=\n    setTokenInfo(TokenID.Eqv, Reservation.None, OperatorPrecedence.Equ, NodeType.Eqv, OperatorPrecedence.No, NodeType.None, \"===\", ErrorRecoverySet.BinOp); // ===\n    setTokenInfo(TokenID.NEqv, Reservation.None, OperatorPrecedence.Equ, NodeType.NEqv, OperatorPrecedence.No, NodeType.None, \"!==\", ErrorRecoverySet.BinOp); // !==\n    setTokenInfo(TokenID.LT, Reservation.None, OperatorPrecedence.Cmp, NodeType.Lt, OperatorPrecedence.No, NodeType.None, \"<\", ErrorRecoverySet.BinOp); // <\n    setTokenInfo(TokenID.LE, Reservation.None, OperatorPrecedence.Cmp, NodeType.Le, OperatorPrecedence.No, NodeType.None, \"<=\", ErrorRecoverySet.BinOp); // <=\n    setTokenInfo(TokenID.GT, Reservation.None, OperatorPrecedence.Cmp, NodeType.Gt, OperatorPrecedence.No, NodeType.None, \">\", ErrorRecoverySet.BinOp); // >\n    setTokenInfo(TokenID.GE, Reservation.None, OperatorPrecedence.Cmp, NodeType.Ge, OperatorPrecedence.No, NodeType.None, \">=\", ErrorRecoverySet.BinOp); // >=\n    setTokenInfo(TokenID.Lsh, Reservation.None, OperatorPrecedence.Shf, NodeType.Lsh, OperatorPrecedence.No, NodeType.None, \"<<\", ErrorRecoverySet.BinOp); // <<\n    setTokenInfo(TokenID.Rsh, Reservation.None, OperatorPrecedence.Shf, NodeType.Rsh, OperatorPrecedence.No, NodeType.None, \">>\", ErrorRecoverySet.BinOp); // >>\n    setTokenInfo(TokenID.Rs2, Reservation.None, OperatorPrecedence.Shf, NodeType.Rs2, OperatorPrecedence.No, NodeType.None, \">>>\", ErrorRecoverySet.BinOp); // >>>\n    setTokenInfo(TokenID.Add, Reservation.None, OperatorPrecedence.Add, NodeType.Add, OperatorPrecedence.Uni, NodeType.Pos, \"+\", ErrorRecoverySet.AddOp); // +\n    setTokenInfo(TokenID.Sub, Reservation.None, OperatorPrecedence.Add, NodeType.Sub, OperatorPrecedence.Uni, NodeType.Neg, \"-\", ErrorRecoverySet.AddOp); // -\n    setTokenInfo(TokenID.Mult, Reservation.None, OperatorPrecedence.Mul, NodeType.Mul, OperatorPrecedence.No, NodeType.None, \"*\", ErrorRecoverySet.BinOp); // *\n    setTokenInfo(TokenID.Div, Reservation.None, OperatorPrecedence.Mul, NodeType.Div, OperatorPrecedence.No, NodeType.None, \"/\", ErrorRecoverySet.BinOp); // /\n    setTokenInfo(TokenID.Pct, Reservation.None, OperatorPrecedence.Mul, NodeType.Mod, OperatorPrecedence.No, NodeType.None, \"%\", ErrorRecoverySet.BinOp); // %\n    setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.Uni, NodeType.Not, \"~\", ErrorRecoverySet.PreOp); // ~\n    setTokenInfo(TokenID.Bang, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.Uni, NodeType.LogNot, \"!\", ErrorRecoverySet.PreOp); // !\n    setTokenInfo(TokenID.Inc, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.Uni, NodeType.IncPre, \"++\", ErrorRecoverySet.PreOp); // ++\n    setTokenInfo(TokenID.Dec, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.Uni, NodeType.DecPre, \"--\", ErrorRecoverySet.PreOp); // --\n    setTokenInfo(TokenID.LParen, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"(\", ErrorRecoverySet.LParen); // (\n    setTokenInfo(TokenID.LBrack, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"[\", ErrorRecoverySet.LBrack); // [\n    setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Uni, NodeType.None, OperatorPrecedence.No, NodeType.None, \".\", ErrorRecoverySet.Dot); // .\n    setTokenInfo(TokenID.EOF, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"<EOF>\", ErrorRecoverySet.EOF); // EOF\n    setTokenInfo(TokenID.Arrow, Reservation.None, OperatorPrecedence.No, NodeType.None, OperatorPrecedence.No, NodeType.None, \"=>\", ErrorRecoverySet.None); // =>\n\n    export function lookupToken(tokenId: TokenID): TokenInfo {\n        return tokenTable[tokenId];\n    }\n\n    export enum TokenClass {\n        Punctuation,\n        Keyword,\n        Operator,\n        Comment,\n        Whitespace,\n        Identifier,\n        Literal,\n    }\n\n    export oldclass SavedToken(property tok: Token, property minChar: number, property limChar: number) {\n    }\n\n    export oldclass Token(property tokenId: TokenID) {\n        property toString() {\n            return \"token: \" + this.tokenId + \" \" + this.getText() + \" (\" + (<any>TokenID)._map[this.tokenId] + \")\";\n        }\n\n        property print(line: number, outfile) {\n            outfile.WriteLine(this.toString() + \",on line\" + line);\n        }\n\n        property getText(): string {\n            return tokenTable[this.tokenId].text;\n        }\n\n        property classification(): TokenClass {\n            if (this.tokenId <= TokenID.LimKeyword) {\n                return TokenClass.Keyword;\n            }\n            else {\n                var tokenInfo = lookupToken(this.tokenId);\n                if (tokenInfo != undefined) {\n                    if ((tokenInfo.unopNodeType != NodeType.None) ||\n                        (tokenInfo.binopNodeType != NodeType.None)) {\n                        return TokenClass.Operator;\n                    }\n                }\n            }\n            return TokenClass.Punctuation;\n        }\n    }\n\n    export oldclass NumberToken(property value: number) extends Token(TokenID.NumberLit) {\n        property getText(): string {\n            return this.value.toString();\n        }\n        property classification(): TokenClass {\n            return TokenClass.Literal;\n        }\n    }\n\n    export oldclass StringToken(property tokenId: TokenID, property value: string) extends Token(this.tokenId) {\n        property getText(): string {\n            return this.value;\n        }\n\n        property classification(): TokenClass {\n            if (this.tokenId == TokenID.ID) {\n                return TokenClass.Identifier;\n            }\n            else {\n                return TokenClass.Literal;\n            }\n        }\n    }\n\n    export oldclass WhitespaceToken(property tokenId: TokenID, property value: string) extends Token(this.tokenId) {\n        property getText(): string {\n            return this.value;\n        }\n\n        property classification(): TokenClass {\n            return TokenClass.Whitespace;\n        }\n    }\n\n    export oldclass CommentToken(property tokenID: TokenID, property value: string, property isBlock: bool, property startPos: number, property line: number, property endsLine: bool) extends Token(this.tokenID) {\n        property getText(): string {\n            return this.value;\n        }\n\n        property classification(): TokenClass {\n            return TokenClass.Comment;\n        }\n    }\n\n    export oldclass RegexToken(property regex) extends Token(TokenID.Regex) {\n        property getText(): string {\n            return this.regex.toString();\n        }\n\n        property classification(): TokenClass {\n            return TokenClass.Literal;\n        }\n    }\n\n    // TODO: new with length TokenID.LimFixed\n    export var staticTokens = new Token[];\n    export function initializeStaticTokens() {\n        for (var i = 0; i <= TokenID.LimFixed; i++) {\n            staticTokens[i] = new Token(i);\n        }\n    }\n}\n\n\nmodule Tools {\n    export oldclass ArrayCache() {\n        property arrayType: Type;\n        property arrayBase: Type = null;\n\n        property specialize(arrInstType: Type, checker: TypeChecker): Type {\n            if (this.arrayBase == null) {\n                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType,\n                                                   checker, true);\n            }\n            return this.arrayBase;\n        }\n    }\n\n    export enum TraceFlags {\n        None = 0,\n        Symbols = 1,\n    }\n\n    // ordered pair of types\n    export oldclass TypePair(property a: Type, property b: Type) {\n    }\n\n    export function hashTypePair(tp): number {\n        var typePair = <TypePair>tp;\n        var result = typePair.a.primitives ^ (typePair.b.primitives << 4);\n        if (typePair.a.members != null) {\n            result = result ^ ((typePair.a.members.allMembers.count()) << 7);\n        }\n        else if (typePair.a.construct != null) {\n            result = (result + 3) << 2;\n        }\n        else if (typePair.a.call != null) {\n            result = (result + 7) << 5;\n        }\n        else if (typePair.a.extendsList != null) {\n            result = (result + 11) << 9;\n        }\n        if (typePair.b.members != null) {\n            result = result ^ ((typePair.b.members.allMembers.count()) << 7);\n        }\n        else if (typePair.b.construct != null) {\n            result = (result + 3) << 2;\n        }\n        else if (typePair.b.call != null) {\n            result = (result + 7) << 5;\n        }\n        else if (typePair.b.extendsList != null) {\n            result = (result + 11) << 9;\n        }\n        return result;\n    }\n\n    export function equalsTypePair(a, b): bool {\n        var pairA = <TypePair>a;\n        var pairB = <TypePair>b;\n        return (pairA.a == pairB.a) && (pairA.b == pairB.b);\n    }\n\n    export interface SignatureData {\n        parameters: ParameterSymbol[];\n        nonOptionalParameterCount: number;\n    }\n\n    export enum TypeCheckCollectionMode {\n        Resident,\n        Transient\n    }\n\n    export oldclass PersistentGlobalTypeState(property errorReporter: ErrorReporter) {\n        property importedGlobalsTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        property importedGlobalsTypeTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        property importedGlobals: SymbolScopeBuilder = new SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);\n\n        // transient state\n        property globals: IHashTable = null;\n        property globalTypes: IHashTable = null;\n        property ambientGlobals: IHashTable = null;\n        property ambientGlobalTypes: IHashTable = null;\n\n        // resident state\n        property residentGlobalValues = new StringHashTable();\n        property residentGlobalTypes = new StringHashTable();\n        property residentGlobalAmbientValues = new StringHashTable();\n        property residentGlobalAmbientTypes = new StringHashTable();\n\n        // dual resident/transient state\n\n        // REVIEW: We shouldn\'t need to allocate private hash tables for these, since there\'s no private global scope\n        // REVIEW: In general, we should audit each instance of DualStringHashTable to ensure that both the primary\n        // and secondary tables are necessary.  If it\'s not necessary, we should sub in a constant sentinel value.\n        property dualGlobalValues = new DualStringHashTable(this.residentGlobalValues, new StringHashTable());\n        property dualGlobalTypes = new DualStringHashTable(this.residentGlobalTypes, new StringHashTable());\n        property dualAmbientGlobalValues = new DualStringHashTable(this.residentGlobalAmbientValues, new StringHashTable());\n        property dualAmbientGlobalTypes = new DualStringHashTable(this.residentGlobalAmbientTypes, new StringHashTable());\n\n        var dualGlobalScopedMembers = new ScopedMembers(new DualStringHashTable(this.dualGlobalValues, new StringHashTable()));\n        var dualGlobalScopedAmbientMembers = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalValues, new StringHashTable()));\n        var dualGlobalScopedEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualGlobalTypes, new StringHashTable()));\n        var dualGlobalScopedAmbientEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalTypes, new StringHashTable()));\n\n        property globalScope: SymbolScope = new SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);\n\n        property voidType: Type = this.enterPrimitive(Primitive.Void, \"void\");\n        property booleanType: Type = this.enterPrimitive(Primitive.Boolean, \"bool\");\n        property doubleType: Type = this.enterPrimitive(Primitive.Double, \"number\");\n        // number is synonym for double\n        this.importedGlobals.ambientEnclosedTypes.addPublicMember(\"number\", this.doubleType.symbol);\n        // TODO: string base from core (set in type flow constructor)\n        property stringType: Type = this.enterPrimitive(Primitive.String, \"string\");\n        property anyType: Type = this.enterPrimitive(Primitive.Any, \"any\");\n        property nullType: Type = this.enterPrimitive(Primitive.Null, \"null\");\n        property undefinedType: Type = this.enterPrimitive(Primitive.Undefined, \"undefined\");\n\n\n        // Use this flag to turn resident checking on and off\n        property residentTypeCheck: bool = true;\n\n        // TODO: make this var when constructor locals entered in earlier pass\n        property mod: ModuleType = null;\n        property gloMod: TypeSymbol = null;\n\n        property wildElm: TypeSymbol = null;\n\n        // shared global state is resident\n        this.setCollectionMode(TypeCheckCollectionMode.Resident);\n\n        this.wildElm = new TypeSymbol(\"_element\", 0, -1, new Type());\n        this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);\n\n        this.mod = new ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);\n        this.mod.members = dualGlobalScopedMembers;\n        this.mod.ambientMembers = dualGlobalScopedAmbientMembers;\n        this.mod.containedScope = this.globalScope;\n\n        this.gloMod = new TypeSymbol(globalId, 0, -1, this.mod);\n        this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);\n\n        this.defineGlobalValue(\"undefined\", this.undefinedType);\n\n        property enterPrimitive(flags: number, name: string) {\n            var primitive = new Type();\n            primitive.primitives = flags;\n            var symbol = new TypeSymbol(name, 0, -1, primitive);\n            symbol.typeCheckStatus = TypeCheckStatus.Finished;\n            primitive.symbol = symbol;\n            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);\n            return primitive;\n        }\n\n        property setCollectionMode(mode: TypeCheckCollectionMode) {\n            this.residentTypeCheck =\n                this.dualGlobalValues.insertPrimary =\n                    this.dualGlobalTypes.insertPrimary =\n                        this.dualAmbientGlobalValues.insertPrimary =\n                            this.dualAmbientGlobalTypes.insertPrimary = mode == TypeCheckCollectionMode.Resident;\n        }\n\n        property refreshPersistentState() {\n            this.globals = new StringHashTable();\n            this.globalTypes = new StringHashTable();\n            this.ambientGlobals = new StringHashTable();\n            this.ambientGlobalTypes = new StringHashTable();\n\n            this.dualGlobalValues.secondaryTable = this.globals;\n            this.dualGlobalTypes.secondaryTable = this.globalTypes;\n            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;\n            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;\n        }\n\n        property defineGlobalValue(name: string, type: Type) {\n            var valueLocation = new ValueLocation();\n            valueLocation.typeLink = new TypeLink();\n            var sym = new VariableSymbol(name, 0, -1, valueLocation);\n            sym.setType(type);\n            sym.typeCheckStatus = TypeCheckStatus.Finished;\n            sym.container = this.gloMod;\n            this.importedGlobalsTable.addPublicMember(name, sym);\n        }\n    }\n\n    export oldclass ContextualTypeContext(property targetType: Type) {\n        property targetSig: Signature = null;\n        property targetThis: Type = null;\n        property targetAccessorType: Type = null;\n    }\n\n    export oldclass ContextualTypingContext() {\n        private contextStack: ContextualTypeContext[] = []\n\n        public pushTargetType(type: Type) { this.contextStack.push(new ContextualTypeContext(type)); }\n        public popTargetType() { return this.contextStack.pop(); }\n\n        public targetType(): ContextualTypeContext { return (this.contextStack == [] ? null : this.contextStack[this.contextStack.length - 1]); }\n    }\n\n    export oldclass TypeChecker(property persistentState: PersistentGlobalTypeState) {\n        property errorReporter: ErrorReporter = null;\n\n        property checkControlFlow = false;\n        property printControlFlowGraph = false;\n        property checkControlFlowUseDef = false;\n        property styleSettings: StyleSettings = null;\n\n        property units: LocationInfo[] = null;\n\n        property voidType: Type = this.persistentState.voidType;\n        property booleanType: Type = this.persistentState.booleanType;\n        property doubleType: Type = this.persistentState.doubleType;\n        property stringType: Type = this.persistentState.stringType;\n        property anyType: Type = this.persistentState.anyType;\n        property nullType: Type = this.persistentState.nullType;\n        property undefinedType: Type = this.persistentState.undefinedType;\n\n        property anon = \"_anonymous\";\n\n        // TODO: make this var when constructor locals entered in earlier pass\n        property globals = this.persistentState.dualGlobalValues;\n        property globalTypes = this.persistentState.dualGlobalTypes;\n        property ambientGlobals = this.persistentState.dualAmbientGlobalValues;\n        property ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;\n        property mod = this.persistentState.mod;\n        property gloMod = this.persistentState.gloMod;\n        property wildElm = this.persistentState.wildElm;\n\n        property symTrack = false;\n        property traceFlags = TraceFlags.None;\n        property locationInfo: LocationInfo = null;\n        property typeFlow: TypeFlow = null;\n\n        property typeMatches = new HashTable(HashMediumSize, hashTypePair, equalsTypePair);\n\n        property currentCompareA: Symbol = null;\n        property currentCompareB: Symbol = null;\n\n        property currentModDecl: ModuleDecl = null;\n\n        property globalScope = this.persistentState.globalScope;\n        property inBind = false;\n        property inWith = false;\n        property errorsOnWith = true;\n\n        property addMembersToClassScope = true;\n        \n        // Contextual typing\n        property typingContext = new ContextualTypingContext();\n        property targetTypeContext: ContextualTypeContext = null;\n\n        property resolvingBases = false;\n\n        property setTargetType(type: Type) {\n            this.typingContext.pushTargetType(type);\n            this.targetTypeContext = this.typingContext.targetType();\n        }\n\n        property unsetTargetType() {\n            this.typingContext.popTargetType();\n            this.targetTypeContext = this.typingContext.targetType();\n        }\n\n        property typeCheckWithTargetType(contextType: Type, condition: bool, ast: AST) {\n            if (condition) {\n                this.setTargetType(contextType);\n            }\n            this.typeFlow.typeCheck(ast);\n            if (condition) {\n                this.unsetTargetType();\n            }\n        }\n\n        property setStyleOptions(style: StyleSettings) {\n            this.styleSettings = style;\n        }\n        \n        property resetTargetType() {\n            this.targetTypeContext = this.typingContext.targetType();\n        }\n\n        property killTargetType() => this.targetTypeContext = null;\n        property hasTargetType() => this.targetTypeContext != null && this.targetTypeContext.targetType != null;\n        property getTargetTypeContext() => this.targetTypeContext;\n\n        // type collection      \n        property collectTypes(ast: AST): void {\n            if (ast.nodeType == NodeType.Script) {\n                var script = <Script>ast;\n                this.locationInfo = script.locationInfo;\n            }\n            var globalChain = new ScopeChain(this.gloMod, null, this.globalScope);\n            var context = new TypeCollectionContext(globalChain, this);\n            ast.walk(preCollectTypes, postCollectTypes, null, context);\n        }\n\n        property makeArrayType(type: Type): Type {\n            if (type.arrayCache == null) {\n                type.arrayCache = new ArrayCache();\n                type.arrayCache.arrayType = new Type();\n                type.arrayCache.arrayType.elementType = type;\n                type.arrayCache.arrayType.symbol = type.symbol;\n            }\n            return type.arrayCache.arrayType;\n        }\n\n        property tryStartTypeMatch(a: Type, b: Type): bool {\n            a.checkDecl(this);\n            b.checkDecl(this);\n            var pair = new TypePair(a, b);\n            return this.typeMatches.add(pair, pair);\n        }\n\n        property endTypeMatch(a: Type, b: Type) {\n            var pair = new TypePair(a, b);\n            this.typeMatches.remove(pair);\n        }\n\n        property getParameterList(args: ASTList, container: Symbol): SignatureData {\n            var parameterTable = null;\n            var parameterBuilder = null;\n            var len = args.members.length;\n            var nonOptionalParams = 0;\n            var result: ParameterSymbol[] = [];\n\n            if (len > 0) {\n                parameterTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                parameterBuilder = new SymbolScopeBuilder(parameterTable, null, null, null, null, container);\n\n                for (var i = 0; i < len; i++) {\n                    var parameter: ArgDecl = args.members[i];\n                    var paramDef = new ValueLocation();\n                    var parameterSymbol = new ParameterSymbol(parameter.id.text, parameter.minChar,\n                                                            this.locationInfo.unitIndex, paramDef);\n                    parameterSymbol.declAST = parameter;\n                    parameter.id.sym = parameterSymbol;\n                    parameter.sym = parameterSymbol;\n                    paramDef.symbol = parameterSymbol;\n                    paramDef.typeLink = getTypeLink(parameter.typeExpr, this, false);\n                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false); // REVIEW: Should this be entered into the private scope?\n                    result[result.length] = parameterSymbol;\n                    if (!parameter.isOptionalArg()) {\n                        nonOptionalParams++;\n                    }\n                }\n            }\n            return { parameters: result, nonOptionalParameterCount: nonOptionalParams };\n        }\n\n        property createNewConstructGroupForType(type: Type) {\n            var signature = new Signature();\n            signature.returnType = new TypeLink();\n            signature.returnType.type = type.instanceType;\n            signature.parameters = [];\n\n            type.construct = new SignatureGroup();\n            type.construct.addSignature(signature);     \n        }\n\n        property cloneParentConstructGroupForChildType(child: Type, parent: Type) {\n            child.construct = new SignatureGroup();\n            var sig: Signature = null;\n\n            if (!parent.construct) {\n                this.createNewConstructGroupForType(parent);\n            }\n\n            for (var i = 0; i < parent.construct.signatures.length; i++) { \n                sig = new Signature();\n                sig.parameters = parent.construct.signatures[i].parameters;\n                sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;\n                sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;\n                sig.declAST = parent.construct.signatures[i].declAST;\n                sig.returnType = new TypeLink();\n                sig.returnType.type = child.instanceType;\n                child.construct.addSignature(sig);\n            }\n\n        }\n\n        // Create a signature for a function definition\n        //  (E.g., has a function body - function declarations, property declarations, lambdas)\n        // TODO: Investigate adding support for accessors\n        property createFunctionSignature(funcDecl: FuncDecl, container: Symbol, scope: SymbolScope, overloadGroupSym: Symbol, addToScope:bool): Signature {\n\n            var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported) ||  container == this.gloMod;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n            var isDefinition = hasFlag(funcDecl.fncFlags, FncFlags.Definition);\n            var isAmbient = hasFlag(funcDecl.fncFlags, FncFlags.Ambient);\n            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n            var isGlobal = container == this.gloMod;\n            \n            var signature: Signature = new Signature();\n            \n            // If a return type has been declared for the signature, set the type link.\n            // Otherwise:\n            //  if it\'s a signature, its type will be \'any\'\n            //  if it\'s a definition, the return type will be inferred  \n            if (funcDecl.returnTypeAnnotation != null || isDefinition) {\n                signature.returnType = getTypeLink(funcDecl.returnTypeAnnotation, this, false);\n            }\n            else {\n                signature.returnType = new TypeLink();\n                signature.returnType.type = this.anyType;\n            }\n                        \n            signature.hasVariableArgList = funcDecl.variableArgList;\n            \n            var sigData = this.getParameterList(funcDecl.args, container);\n            \n            signature.parameters = sigData.parameters;\n            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;\n            \n            funcDecl.signature = signature;\n            signature.declAST = funcDecl;\n            \n            var useOverloadGroupSym = \n                overloadGroupSym != null && \n                overloadGroupSym.getType() != null &&\n                !overloadGroupSym.isAccessor() &&\n                (funcDecl.isSignature() || (isAmbient == hasFlag(overloadGroupSym.flags, SymbolFlags.Ambient)));\n                \n            if (useOverloadGroupSym && isPrivate != hasFlag(overloadGroupSym.flags, SymbolFlags.Private)) {\n                this.errorReporter.simpleError(funcDecl, \"Public/Private visibility of overloads does not agree\");\n            }\n                \n            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new Type();              \n                \n            if (isConstructor) {\n                if (groupType.construct == null) {\n                    groupType.construct = new SignatureGroup();\n                }\n                groupType.construct.addSignature(signature);\n                groupType.construct.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.construct.hasImplementation) {\n                    groupType.setHasImplementation();\n                }                 \n            }\n            else if (funcDecl.isIndexerMember()) {\n                if (groupType.index == null) {\n                    groupType.index = new SignatureGroup();\n                    groupType.index.isIndexer = true;\n                }\n                                \n                groupType.index.addSignature(signature);\n                groupType.index.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.index.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else {\n                if (groupType.call == null) {\n                    groupType.call = new SignatureGroup();\n                }\n                groupType.call.addSignature(signature);            \n                \n                groupType.call.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.call.hasImplementation) {\n                    groupType.setHasImplementation();\n                }             \n            }\n            \n            var instanceType = groupType.instanceType;    \n            \n            if (instanceType != null) {\n                if (instanceType.call == null) {\n                    instanceType.call = groupType.call;\n                }\n                else if (groupType.call != null) {\n                    instanceType.call.signatures.concat(groupType.call.signatures);\n                }\n            }               \n                \n            // Ensure that the function\'s symbol is properly configured\n            // (If there were overloads, we\'ll already have a symbol, otherwise we need to create one)\n            var funcName: string = null;\n                \n            // Set the function\'s name:\n            //  In the case of anonymous or functions resulting from error\n            //  correction in the parser (isMissing() == true), we do not\n            //  want to set a function name, since they shouldn\'t be inserted\n            //  into the enclosing scope\n                \n            // usedHint prevents functions bound to object literal fields from being added to the\n            // enclosing scope\n            var usedHint = false;\n            if (funcDecl.name != null && !funcDecl.name.isMissing()) {\n                funcName = funcDecl.name.text;\n            }\n            else if (funcDecl.hint != null) {\n                funcName = funcDecl.hint;\n                usedHint = true;\n            }\n                \n            if (groupType.symbol == null) {\n                groupType.symbol =\n                    new TypeSymbol((funcName != null) ? funcName : this.anon,\n                                    funcDecl.minChar, this.locationInfo.unitIndex,\n                                    groupType);\n                if (!useOverloadGroupSym) {\n                    groupType.symbol.declAST = funcDecl;\n                }\n            }\n                \n            // REVIEW: Are we missing any other flags?\n            if (isStatic) {\n                groupType.symbol.flags |= SymbolFlags.Static;\n            }\n                \n            if (isAmbient) {\n                groupType.symbol.flags |= SymbolFlags.Ambient;\n            }\n            \n            if (isPrivate) {\n                groupType.symbol.flags |= SymbolFlags.Private;\n            }\n                \n            groupType.symbol.isMethod = funcDecl.isMethod();\n            if (groupType.symbol.isMethod) {\n                groupType.symbol.flags |= SymbolFlags.Property;\n            }\n\n            funcDecl.type = groupType;\n            \n            // Add the function symbol to the appropriate scope\n            // if the funcDecl is a constructor, it will be added to the enclosing scope as a class\n            if (!isConstructor) {\n                // Add the function\'s symbol to its enclosing scope\n                if (funcName != null && !funcDecl.isAccessor() && !usedHint) {\n\n                    // REVIEW: We\'re not setting the isDecl flags for fuctions bound to object literal properties\n                    // so removing the isDefiniton clause would break object literals\n                    if (addToScope) {  // REVIEW: If we combine this with createFunctionDeclarationSignature, we\'ll need to broaden this for both decls and defs                      \n                        // if it\'s a static method, enter directly into the container\'s scope\n                        if (funcDecl.isMethod() && isStatic) {\n\n                            // REVIEW: What about private statics?\n                            if (!(<TypeSymbol>container).type.members.publicMembers.add(funcName, groupType.symbol)) {\n                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);\n                            }\n\n                            groupType.symbol.container = container;\n                        } // REVIEW: Another check for overloads...\n                        else if (overloadGroupSym == null || (overloadGroupSym.declAST != null && !(<FuncDecl>overloadGroupSym.declAST).isOverload && (container.isType()))) {\n                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);\n                        }\n                    }\n                    else if (!funcDecl.isSpecialFn()) {\n                        groupType.symbol.container = container; // REVIEW: Set container for overloads or anonymous?\n                    }\n                }\n                else if (!funcDecl.isSpecialFn()) {\n                    groupType.symbol.container = container; // REVIEW: Set container for lambdas and accessors?\n                }\n            }\n          \n            // If, say, a call signature overload was declared before the class type was, we want to reuse\n            // the type that\'s already been instantiated for the class type, rather than allocate a new one\n            if (useOverloadGroupSym) {\n                var overloadGroupType = overloadGroupSym != null ? overloadGroupSym.getType() : null;\n                var classType = groupType;\n\n                if (classType != overloadGroupType) {\n                    if (classType.construct == null) {\n                        if (overloadGroupType != null && overloadGroupType.construct != null) {\n                            classType.construct = overloadGroupType.construct;\n                        }\n                        else {\n                            classType.construct = new SignatureGroup();\n                        }\n                    }\n                    else if (overloadGroupType != null) {\n                        if (overloadGroupType.construct != null) {\n                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);\n                        }\n                    }\n\n                    // sync call and index signatures as well, but don\'t allocate should they not\n                    // already exist\n                    if (overloadGroupType != null) {\n                        if (classType.call == null) {\n                            classType.call = overloadGroupType.call;\n                        }\n                        else if (overloadGroupType.call != null) {\n                            classType.call.signatures.concat(overloadGroupType.call.signatures);\n                        }\n\n                        // if the function is not static, we need to add any call overloads onto the\n                        // instance type\'s call signature list\n                        if (!isStatic) {\n\n                            if (classType.instanceType == null) {\n                                classType.instanceType = overloadGroupType.instanceType;\n                            }\n\n                            var instanceType = classType.instanceType;\n\n                            if (instanceType != null) {\n                                if (instanceType.call == null) {\n                                    instanceType.call = overloadGroupType.call;\n                                }\n                                else if (overloadGroupType.call != null) {\n                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);\n                                }\n                            }\n                        }\n\n                        if (classType.index == null) {\n                            classType.index = overloadGroupType.index;\n                        }\n                        else if (overloadGroupType.index != null) {\n                            classType.index.signatures.concat(overloadGroupType.index.signatures);\n                        }\n                    }\n                }\n            }\n            \n            return signature;\n        }\n        \n        // Creates a new symbol for an accessor property\n        // Note that funcDecl.type.symbol and fgSym may not be the same (E.g., in the case of type collection)\n        property createAccessorSymbol(funcDecl: FuncDecl, fgSym:Symbol, enclosingClass: Type, addToMembers:bool, isClassProperty:bool, scope: SymbolScope, container: Symbol) {\n            var accessorSym: FieldSymbol = null\n            var sig = funcDecl.signature;\n            var nameText = funcDecl.name.text;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n            \n            if (fgSym == null) {\n                var field = new ValueLocation();\n                accessorSym = new FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field);\n                field.symbol = accessorSym;\n                accessorSym.declAST = funcDecl; // REVIEW: need to reset for getters and setters\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                    if (accessorSym.getter != null) {\n                        this.errorReporter.simpleError(funcDecl, \"Redeclaration of property getter\");\n                    }                    \n                    accessorSym.getter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter != null) {\n                        this.errorReporter.simpleError(funcDecl, \"Redeclaration of property setter\");\n                    }                    \n                    accessorSym.setter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n\n                field.typeLink = getTypeLink(null, this, false);\n\n                // if it\'s static, enter it into the class\'s member list directly\n                if (addToMembers) {\n                    if (enclosingClass) {\n                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {\n                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);\n                        }\n                        accessorSym.container = enclosingClass.symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(funcDecl, \"Accessor property may not be added in this context\");\n                    }\n                }\n                else {\n                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);\n                }\n\n                // We set the flags here, instead of below, because the accessor symbol does not yet have a type\n                accessorSym.flags |= SymbolFlags.Exported;\n                if (isClassProperty) {\n                    accessorSym.flags |= SymbolFlags.Property;\n                }\n                if (isPrivate) {\n                    accessorSym.flags |= SymbolFlags.Private;\n                }\n                else {\n                    accessorSym.flags |= SymbolFlags.Public;\n                }\n            }\n            else {\n                accessorSym = <FieldSymbol>(<any>fgSym);\n\n                if (isPrivate != hasFlag(accessorSym.flags, SymbolFlags.Private)) {\n                    this.errorReporter.simpleError(funcDecl, \"Getter and setter accessors do not agree in visibility\");\n                }\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                    if (accessorSym.getter != null) {\n                        this.errorReporter.simpleError(funcDecl, \"Redeclaration of property getter\");\n                    }\n                    accessorSym.getter = <TypeSymbol>funcDecl.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter != null) {\n                        this.errorReporter.simpleError(funcDecl, \"Redeclaration of property setter\");\n                    }\n                    accessorSym.setter = <TypeSymbol>funcDecl.type.symbol;\n                }\n            }\n            \n            return accessorSym;   \n        }\n\n        property addBases(resultScope: SymbolAggregateScope, type: Type): void {\n            resultScope.addParentScope(new SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));\n            var i = 0;\n            var base: Type;\n            if (type.extendsList != null) {\n                for (var len = type.extendsList.length; i < len; i++) {\n                    base = type.extendsList[i];\n                    this.addBases(resultScope, base);\n                }\n            }\n        }\n\n        property scopeOf(type: Type): SymbolScope {\n            var resultScope = new SymbolAggregateScope(type.symbol);\n            this.addBases(resultScope, type);\n            return resultScope;\n        }\n\n        property lookupMemberType(containingType: Type, name: string): Type {\n            var symbol: Symbol = null;\n            if (containingType.containedScope != null) {\n                symbol = containingType.containedScope.find(name, false, true);\n            }\n            else if (containingType.members != null) {\n                symbol = containingType.members.allMembers.lookup(name);\n\n                if (symbol == null && containingType.ambientMembers != null) {\n                    symbol = containingType.ambientMembers.allMembers.lookup(name);\n                }\n            }\n            if (symbol == null) {\n                var typeMembers = containingType.getAllEnclosedTypes();\n                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();\n                if (typeMembers != null) {\n                    symbol = typeMembers.allMembers.lookup(name);\n\n                    if (symbol == null && ambientTypeMembers != null) {\n                        symbol = ambientTypeMembers.allMembers.lookup(name);\n                    }\n\n                }\n            }\n            if ((symbol != null) && (symbol.isType())) {\n                return symbol.getType();\n            }\n            else {\n                return null;\n            }\n        }\n\n        property resolveTypeMember(scope: SymbolScope, dotNode: BinaryExpression): Type {\n            var lhs = dotNode.operand1;\n            var rhs = dotNode.operand2;\n            var resultType = this.anyType;\n            var lhsType = this.anyType;\n\n            if ((lhs != null) && (rhs != null) && (rhs.nodeType == NodeType.Name)) {\n                if (lhs.nodeType == NodeType.Dot) {\n                    lhsType = this.resolveTypeMember(scope, lhs);\n                }\n                else if (lhs.nodeType == NodeType.Name) {\n                    var identifier = <Identifier>lhs;\n                    var symbol = scope.find(identifier.text, false, true);\n                    if (symbol == null) {\n                        this.errorReporter.unresolvedSymbol(identifier, identifier.text);\n                    }\n                    else if (symbol.isType()) {\n                        if (optimizeModuleCodeGen && symbol != null) {\n                            var symType = symbol.getType();\n                            // Once the type has been referenced outside of a type ref position, there\'s\n                            // no going back                        \n                            if (symType != null && (<TypeSymbol>symbol).isAlias && (<TypeSymbol>symbol).onlyReferencedAsTypeRef) {\n\n                                var modDecl = <ModuleDecl>symType.symbol.declAST;\n                                if (modDecl != null && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {\n                                    (<TypeSymbol>symbol).onlyReferencedAsTypeRef = !this.resolvingBases;\n                                }\n                            }\n                        }\n                        if (!symbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, \"symbol \'\" + identifier.text + \"\' not visible at this point\");\n                        }\n                        lhsType = symbol.getType();\n\n                        identifier.sym = symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(lhs, \"expected type\");\n                    }\n\n                }\n\n                // if the LHS type is a module alias, we won\'t be able to resolve it until\n                // typecheck type.  If this is called during binding, lhsType will be null\n                if (!lhsType) {\n                    lhsType = this.anyType;\n                }\n\n                if (lhsType != this.anyType) {\n                    var rhsIdentifier = <Identifier>rhs;\n                    resultType = this.lookupMemberType(lhsType, rhsIdentifier.text);\n                    if (resultType == null) {\n                        resultType = this.anyType;\n                        this.errorReporter.simpleError(dotNode, \"expected type\");\n                    }\n                    else {\n                        if (!resultType.symbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, \"symbol \'\" + (<Identifier>rhs).text + \"\' not visible at this point\");\n                        }\n                    }\n                    rhsIdentifier.sym = resultType.symbol;\n                }\n            }\n            if (resultType.isClass()) {\n                resultType = resultType.instanceType;\n            }\n            return resultType;\n        }\n\n        property resolveFuncDecl(funcDecl: FuncDecl, scope: SymbolScope,\n            fgSym: TypeSymbol): Symbol {\n            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;\n            var signatures: Signature[];\n            if (funcDecl.isConstructMember()) {\n                signatures = functionGroupSymbol.type.construct.signatures;\n            }\n            else if (funcDecl.isIndexerMember()) {\n                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;\n            }\n            else {\n                signatures = functionGroupSymbol.type.call.signatures;\n            }\n            // TODO: indexer\n            var signature = signatures[signatures.length - 1];\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var paramSym: ParameterSymbol = signature.parameters[i];\n                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);\n            }\n            this.resolveTypeLink(scope, signature.returnType,\n                            funcDecl.isSignature());\n            return functionGroupSymbol;\n        }\n\n        property resolveVarDecl(varDecl: VarDecl, scope: SymbolScope): Symbol {\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = varDecl;\n            field.typeLink = getTypeLink(varDecl.typeExpr, this, varDecl.init == null);\n            this.resolveTypeLink(scope, field.typeLink, true);\n            varDecl.sym = fieldSymbol;\n            varDecl.type = field.typeLink.type;\n            return fieldSymbol;\n        }\n\n        property resolveTypeLink(scope: SymbolScope, typeLink: TypeLink, supplyVar: bool): void {\n            var arrayCount = 0;\n            if (typeLink.type == null) {\n                var ast: AST = typeLink.ast;\n                if (ast != null) {\n                    while (typeLink.type == null) {\n                        switch (ast.nodeType) {\n                            case NodeType.Name:\n                                var identifier = <Identifier>ast;\n                                var symbol = scope.find(identifier.text, false, true);\n                                if (symbol == null) {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.unresolvedSymbol(identifier, identifier.text);\n                                }\n                                else if (symbol.isType()) {\n                                    if (!symbol.visible(scope, this)) {\n                                        this.errorReporter.simpleError(ast, \"symbol \'\" + identifier.text + \"\' not visible at this point\");\n                                    }\n                                    identifier.sym = symbol;\n                                    typeLink.type = symbol.getType();\n                                    if (typeLink.type) {\n                                        if (typeLink.type.isClass()) {\n                                            typeLink.type = typeLink.type.instanceType;\n                                        }\n                                    }\n                                    else {\n                                        typeLink.type = this.anyType;\n                                    }\n                                }\n                                else {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.simpleError(ast, \"expected type\");\n                                }\n                                break;\n                            case NodeType.Dot:\n                                typeLink.type = this.resolveTypeMember(scope, ast);\n                                break;\n                            case NodeType.TypeRef:\n                                var typeRef = <TypeReference>ast;\n                                arrayCount = typeRef.arrayCount;\n                                ast = typeRef.term;\n                                if (ast == null) {\n                                    typeLink.type = this.anyType;\n                                }\n                                break;\n                            case NodeType.Interface:\n                                var interfaceDecl = <TypeDecl>ast;\n                                var _interface = new Type();\n                                var interfaceSymbol = new TypeSymbol((<Identifier>interfaceDecl.name).text,\n                                                                   ast.minChar,\n                                                                   this.locationInfo.unitIndex,\n                                                                   _interface);\n                                _interface.symbol = interfaceSymbol;\n                                _interface.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                                // REVIEW: add IObject as base\n                                _interface.containedScope =\n                                new SymbolTableScope(_interface.members, null, null, null,\n                                                         interfaceSymbol);\n                                _interface.containedScope.container = interfaceSymbol;\n                                _interface.memberScope = _interface.containedScope;\n                                var memberList = <ASTList>interfaceDecl.members;\n                                var props: AST[] = memberList.members;\n                                var propsLen = props.length;\n                                for (var j = 0; j < propsLen; j++) {\n                                    var propDecl = props[j];\n                                    var propSym: Symbol = null;\n                                    var addMember = true;\n                                    if (propDecl.nodeType == NodeType.FuncDecl) {\n                                        var funcDecl = <FuncDecl>propDecl;\n                                        propSym = _interface.members.allMembers.lookup(funcDecl.getNameText());\n                                        addMember = (propSym == null);\n                                        if (funcDecl.isSpecialFn()) {\n                                            addMember = false;\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);\n                                        }\n                                        else {\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, propSym);\n                                        }\n                                        funcDecl.type = (<TypeSymbol>propSym).type;\n                                    }\n                                    else {\n                                        propSym = this.resolveVarDecl(<VarDecl>propDecl, scope);\n                                    }\n                                    if (addMember) {\n                                        if (!_interface.members.allMembers.add(propSym.name, propSym)) {\n                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);\n                                        }\n                                    }\n                                }\n                                ast.type = _interface;\n                                typeLink.type = _interface;\n                                break;\n                            case NodeType.FuncDecl:\n                                var tsym: TypeSymbol = this.resolveFuncDecl(<FuncDecl>ast, scope, null);\n                                typeLink.type = tsym.type;\n                                break;\n                            default:\n                                typeLink.type = this.anyType;\n                                this.errorReporter.simpleError(ast, \"expected type\");\n                                break;\n                        }\n                    }\n                }\n                for (var count = arrayCount; count > 0; count--) {\n                    typeLink.type = this.makeArrayType(typeLink.type);\n                }\n                if (supplyVar && (typeLink.type == null)) {\n                    typeLink.type = this.anyType;\n                }\n                if (typeLink.ast != null) {\n                    typeLink.ast.type = typeLink.type;\n                }\n            }\n            // else wait for type inference\n        }\n\n\n        property invariantMatches(a: Type, b: Type): bool {\n            return (a == null) || (b == null) || (a == b);\n        }\n\n        property covariantMatches(a: Type, b: Type) {\n            if (a != null) {\n                return a.subtype(b, this);\n            }\n            else {\n                return true;\n            }\n        }\n\n        property contravariantMatches(a: Type, b: Type) {\n            if (b != null) {\n                return b.subtype(a, this);\n            }\n            else {\n                return true;\n            }\n        }\n\n        property currentSymbolCompareError(msg: string, left: bool) {\n            if ((this.currentCompareA != null) && (this.currentCompareB != null)) {\n                var builder = \"Comparing \" + this.currentCompareA.fullName() + \" and \" + this.currentCompareB.fullName() + \", \";\n                var offendingSym = this.currentCompareA;\n                if (left) {\n                    builder += this.currentCompareA.fullName();\n                }\n                else {\n                    offendingSym = this.currentCompareB;\n                    builder += this.currentCompareB.fullName();\n                }\n                builder += \" \";\n                builder += msg;\n                this.errorReporter.simpleErrorFromSym(offendingSym, builder);\n            }\n        }\n\n        property signatureSubtype(a: Signature, b: Signature) {\n            if ((a.parameters != null) && (b.parameters == null)) {\n                return false;\n            }\n            if ((a.parameters == null) && (b.parameters != null)) {\n                return false;\n            }\n\n            if (a.parameters.length > b.parameters.length) {\n                return false;\n            }\n            var art = a.returnType.type;\n            var brt = b.returnType.type;\n            if (art == null) {\n                this.currentSymbolCompareError(\"return type unknown\", true);\n                art = this.anyType;\n            }\n            if (brt == null) {\n                this.currentSymbolCompareError(\"return type unknown\", false);\n                brt = this.anyType;\n            }\n\n            if ((art != this.voidType) && (brt != this.voidType)) {\n                if (!(art.subtype(brt, this))) {\n                    return false;\n                }\n            }\n            var len = a.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var paramA = (<ParameterSymbol>a.parameters[i]).parameter;\n                var paramB = (<ParameterSymbol>b.parameters[i]).parameter;\n                if (!(paramB.typeLink.type.subtype(paramA.typeLink.type, this))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        property signatureGroupSubtype(a: SignatureGroup, b: SignatureGroup) {\n            if (a == null) {\n                return (b == null);\n            }\n            else {\n                var sva = null;\n                if (b != null) {\n                    for (var i = 0, len = b.signatures.length; i < len; i++) {\n                        var sb = b.signatures[i];\n                        var ok = false;\n                        for (var j = 0, aLen = a.signatures.length; j < aLen; j++) {\n                            var sa = a.signatures[j];\n                            sva = sa;\n                            if (this.signatureSubtype(sa, sb)) {\n                                ok = true;\n                                break;\n                            }\n                        }\n                        if (!ok) {\n                            // REVIEW: This error message is really useful, but should be merged with the top-level \"does not implement\"\n                            // error\n                            // if (sva.declAST != null) {\n                            //     errorReporter.simpleError(sva.declAST, \"No subtype match found for signature \" + b.toString());\n                            // }\n                            return false;\n                        }\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        property signatureAssignable(a: Signature, b: Signature) {\n            if ((a.parameters != null) && (b.parameters == null)) {\n                return false;\n            }\n            if ((a.parameters == null) && (b.parameters != null)) {\n                return false;\n            }\n\n            if (a.parameters.length > b.parameters.length) {\n                return false;\n            }\n            var art = a.returnType.type;\n            var brt = b.returnType.type;\n            if (art == null) {\n                this.currentSymbolCompareError(\"return type unknown\", true);\n                art = this.anyType;\n            }\n            if (brt == null) {\n                this.currentSymbolCompareError(\"return type unknown\", false);\n                brt = this.anyType;\n            }\n\n            if (!(art == this.voidType && b.declAST != null && (b.declAST.isConstructor || hasFlag(b.declAST.fncFlags, FncFlags.ConstructMember)))) {\n                if ((art != this.voidType) && (brt != this.voidType)) {\n                    if (!(art.assignable(brt, this))) {\n                        return false;\n                    }\n                }\n                    // if either return type is \'void\', continue\n                else if (art != brt && (art != this.voidType && brt != this.voidType)) {\n                    return false;\n                }\n            }\n\n            var len = a.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var paramA = (<ParameterSymbol>a.parameters[i]).parameter;\n                var paramB = (<ParameterSymbol>b.parameters[i]).parameter;\n                if (!(paramB.typeLink.type.assignable(paramA.typeLink.type, this))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        property signatureGroupAssignable(a: SignatureGroup, b: SignatureGroup) {\n            if (a == null) {\n                return (b == null);\n            }\n            else {\n                var sva = null;\n                if (b != null) {\n                    for (var i = 0, len = b.signatures.length; i < len; i++) {\n                        var sb = b.signatures[i];\n                        var ok = false;\n                        for (var j = 0, aLen = a.signatures.length; j < aLen; j++) {\n                            var sa = a.signatures[j];\n                            sva = sa;\n                            if (this.signatureAssignable(sa, sb)) {\n                                ok = true;\n                                break;\n                            }\n                        }\n                        if (!ok) {\n                            return false;\n                        }\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        property symbolSubtype(a: Symbol, b: Symbol) {\n            if ((a == null) || (b == null)) { return false; }\n            if (a == b) { return true; }\n            if (a.name != b.name) {\n                return false;\n            }\n\n            var inf: InferenceSymbol = null;\n            // If a constructor body contains a call passing in \"this\",\n            // certain properties of the class may be checked for symbol\n            // equivalence with a parent type before they\'ve been typechecked\n            if (a.isInferenceSymbol()) {\n                inf = <InferenceSymbol>a;\n                if (inf.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                    this.typeFlow.typeCheck(a.declAST);\n                }\n            }\n            if (b.isInferenceSymbol()) {\n                inf = <InferenceSymbol>b;\n                if (inf.typeCheckStatus != TypeCheckStatus.NotStarted) {\n                    this.typeFlow.typeCheck(b.declAST);\n                }\n            }\n\n            var svCompareA = this.currentCompareA;\n            var svCompareB = this.currentCompareB;\n            this.currentCompareA = a;\n            this.currentCompareB = b;\n            var result = a.getType().subtype(b.getType(), this);\n            this.currentCompareA = svCompareA;\n            this.currentCompareB = svCompareB;\n            return result;\n        }\n\n        //  Two members, \'a\' and \'b\' are assignment compatible if, for either \'a\' or \'b\':\n        property symbolAssignable(a: Symbol, b: Symbol) {\n            if ((a == null) || (b == null)) { return false; }\n            if (a == b) { return true; }\n\n            var inf: InferenceSymbol = null;\n            // If a constructor body contains a call passing in \"this\",\n            // certain properties of the class may be checked for symbol\n            // equivalence with a parent type before they\'ve been typechecked\n            if (a.isInferenceSymbol()) {\n                inf = <InferenceSymbol>a;\n                if (inf.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                    this.typeFlow.typeCheck(a.declAST);\n                }\n            }\n            if (b.isInferenceSymbol()) {\n                inf = <InferenceSymbol>b;\n                if (inf.typeCheckStatus != TypeCheckStatus.NotStarted) {\n                    this.typeFlow.typeCheck(b.declAST);\n                }\n            }\n\n            // o   Both members are properties with the same name and assignment \n            //     compatible types.\n            var result = a.name == b.name && (a.getType().assignable(b.getType(), this) || b.getType().assignable(a.getType(), this));\n\n            return result;\n        }\n\n        property assignableTo(from: Type, to: Type) {\n            // identical types\n            if (from == to) { return true; }\n            if (from == this.voidType) { return false; }\n            // An error has already been reported in this case\n            if ((from == null) || (to == null)) { return true; }\n            if ((from == this.undefinedType) || (to == this.undefinedType)) { return true; }\n            // always assign to an instance type \n            to = to.getInstanceType();\n\n            if (to.assignable(from, this) || from.assignable(to, this)) {\n                return true;\n            }\n            return false;\n        }\n        \n        property getApplicableSignatures(signatures: Signature[], args: ASTList): Signature[] {\n            \n            var applicableSigs: Signature[] = [];\n            var memberType: Type = null;\n            \n            for (var i = 0; i < signatures.length; i++) {\n\n                for (var j = 0; j < args.members.length; j++) {\n                    if (j >= signatures[i].parameters.length) {\n                        continue;\n                    }\n                    memberType = signatures[i].parameters[j].getType();\n                    \n                    // account for varargs\n                    if ((j >= signatures[i].nonOptionalParameterCount ||\n                        (signatures[i].declAST.variableArgList && j >= signatures[i].nonOptionalParameterCount - 1)) && memberType.isArray()) {\n                        memberType = memberType.elementType;\n                    }\n                    \n                    if (memberType == this.anyType) {\n                        continue;\n                    }\n                    else if (args.members[j].nodeType == NodeType.FuncDecl) {\n                        if (!this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], true)) {\n                            // if it\'s just annotations that are blocking us, typecheck the function and add it to the list\n                            if (this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], false)) {\n                                this.typeFlow.typeCheck(args.members[j]);\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ObjectLit) {\n                        if (!this.canContextuallyTypeObjectLiteral(memberType, <UnaryExpression>args.members[j])) {\n                            if (this.objectLiteralIsSupersetOfContextualType(memberType, <UnaryExpression>args.members[j])) {\n                                this.typeFlow.typeCheck(args.members[j]);\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                    }\n                    // else, ok    \n                }\n                \n                if (j == args.members.length) {\n                    applicableSigs[applicableSigs.length] = signatures[i];\n                }\n                \n            }\n            \n            return applicableSigs;\n        }\n        \n        property getBetterConversion(sig1: Signature, sig2: Signature, args: Type[]): Signature {\n            \n            return null;\n        }\n\n        property canContextuallyTypeFunction(candidateType: Type, funcDecl: FuncDecl, beStringent:bool): bool {\n\n            // in these cases, we do not attempt to apply a contextual type\n            //  RE: isInlineCallLiteral - if the call target is a function literal, we don\'t want to apply the target type\n            //  to its body - instead, it should be applied to its return type\n            if (funcDecl.isParenthesized ||\n                funcDecl.isMethod() ||\n                (beStringent && funcDecl.returnTypeAnnotation != null) ||\n                funcDecl.isInlineCallLiteral) {\n                return false;\n            }\n\n            // At this point, if we\'re not being stringent, there\'s no need to check for multiple call sigs\n            // or count parameters - we just want to unblock typecheck\n            if (!beStringent) {\n                return true;\n            }\n\n            var signature = funcDecl.signature;\n            var paramLen = signature.parameters.length;\n\n            // Check that the argument declarations have no type annotations\n            for (var i = 0; i < paramLen; i++) {\n                var param = signature.parameters[i];\n                var symbol = <ParameterSymbol>param;\n                var argDecl = <ArgDecl>symbol.declAST;\n\n                // REVIEW: a valid typeExpr is a requirement for varargs,\n                // so we may want to revise our invariant\n                if (beStringent && (argDecl.init != null || argDecl.typeExpr != null)) {\n                    return false;\n                }\n            }\n\n            if (candidateType.construct != null && candidateType.call != null) {\n                return false;\n            }\n\n            var candidateSigs = candidateType.construct != null ? candidateType.construct : candidateType.call;\n\n            if (candidateSigs == null || candidateSigs.signatures.length > 1) {\n                return false;\n            }\n\n            // If the arity of the candidate is greater-than or equal-to the arity of\n            // the function, we have a subtype relationship\n            // (We\'ll check for agreement of return types when typechecking the body)\n            var candidateParams = candidateSigs.signatures[0].parameters;\n\n            // if the candidate type has fewer params than the funcDecl, we can\'t use it as the target type\n            if (candidateParams.length < funcDecl.args.members.length) {\n                return false;\n            }\n\n            // if we\'re here, the contextual type can be applied to the function\n            return true;\n        }\n\n        property canContextuallyTypeObjectLiteral(targetType: Type, objectLit: UnaryExpression): bool {\n\n            var memberDecls = <ASTList>objectLit.operand;\n\n            if (!(memberDecls && targetType.memberScope)) {\n                return false;\n            }\n\n            var id: AST = null;\n            var targetMember: Symbol = null;\n            var text = \"\";\n\n            for (var i = 0; i < memberDecls.members.length; i++) {\n                id = (<BinaryExpression>memberDecls.members[i]).operand1;\n\n                if (id.nodeType == NodeType.Name) {\n                    text = (<Identifier>id).text;\n                }\n                else if (id.nodeType == NodeType.QString) {\n                    // TODO: set text to unescaped string\n                    var idText = (<StringLiteral>id).text;\n                    text = idText.substring(1, idText.length - 1);\n                }\n                else {\n                    return false;\n                }\n\n                targetMember = targetType.memberScope.find(text, false, false);\n\n                if (!targetMember) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        property objectLiteralIsSupersetOfContextualType(targetType: Type, objectLit: UnaryExpression): bool {\n            \n            var memberDecls = <ASTList>objectLit.operand;\n\n            if (!(memberDecls && targetType.memberScope)) {\n                return false;\n            }\n\n            var id: AST = null;\n            var targetMember: Symbol = null;\n            var text = \"\";\n            var members = targetType.members.publicMembers.getAllKeys();\n\n            for (var i = 0; i < members.length; i++) {\n\n                for (var j = 0; j < memberDecls.members.length; j++) {\n                    id = (<BinaryExpression>memberDecls.members[j]).operand1;\n\n                    if (id.nodeType == NodeType.Name) {\n                        text = (<Identifier>id).text;\n                    }\n                    else if (id.nodeType == NodeType.QString) {\n                        // TODO: set text to unescaped string\n                        var idText = (<StringLiteral>id).text;\n                        text = idText.substring(1, idText.length - 1);\n                    }\n                    else {\n                        return false;\n                    }\n\n                    if (text == members[i]) {\n                        break;\n                    }\n                }\n\n                if (j == memberDecls.members.length) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n\n\nmodule Tools {\n    export oldclass Continuation(property normalBlock: number) {\n        property exceptionBlock = -1;\n    }\n\n    function getBaseTypeLinks(bases: ASTList, baseTypeLinks: TypeLink[]) {\n        if (bases != null) {\n            var len = bases.members.length;\n            if (baseTypeLinks == null) {\n                baseTypeLinks = new TypeLink[];\n            }\n            for (var i = 0; i < len; i++) {\n                var baseExpr = bases.members[i];\n                var name = baseExpr;\n                if (name.nodeType == NodeType.Call) {\n                    name = (<CallExpression>name).target;\n                }\n                var typeLink = new TypeLink();\n                typeLink.ast = name;\n                baseTypeLinks[baseTypeLinks.length] = typeLink;\n            }\n        }\n        return baseTypeLinks;\n    }\n\n    function getBases(type: Type, typeDecl: NamedType) {\n        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);\n        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);\n    }\n\n    function addPrototypeField(classType: Type, ast: AST, context: TypeCollectionContext) {\n        var field = new ValueLocation();\n        field.typeLink = new TypeLink();\n        field.typeLink.ast = ast;\n        field.typeLink.type = classType.instanceType;\n\n        var fieldSymbol =\n            new FieldSymbol(\"prototype\", ast.minChar,\n                            context.checker.locationInfo.unitIndex, true, field);\n        fieldSymbol.flags |= (SymbolFlags.Property | SymbolFlags.BuiltIn);\n        field.symbol = fieldSymbol;\n        fieldSymbol.declAST = ast;\n        classType.members.addPublicMember(\"prototype\", fieldSymbol);\n    }\n\n    export var globalId = \"__GLO\";\n\n    interface IAliasScopeContext {\n        topLevelScope: ScopeChain;\n        members: IHashTable;\n        tcContext: TypeCollectionContext;\n    }\n\n    function findTypeSymbolInScopeChain(name: string, scopeChain: ScopeChain): Symbol {\n        var symbol = scopeChain.scope.find(name, false, true);\n\n        if (symbol == null && scopeChain.previous != null) {\n            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);\n        }\n\n        return symbol;\n    }\n\n    function findSymbolFromAlias(alias: AST, context: IAliasScopeContext): Symbol {\n        var symbol: Symbol = null;\n        switch (alias.nodeType) {\n            case NodeType.Name:\n                var name = (<Identifier>alias).text;\n                var isDynamic = isQuoted(name);\n\n                if (isDynamic) {\n                    var path = getRootFilePath(context.tcContext.script.locationInfo.filename);\n                    var modName = switchToForwardSlashes(stripQuotes(name));\n                    name = normalizePath(path + modName + \".str\");\n                }\n\n                if (context.members != null) {\n                    symbol = context.members.lookup(name);\n                }\n                else {\n                    symbol = findTypeSymbolInScopeChain(name, context.topLevelScope);\n                }\n                break;\n\n            case NodeType.Dot:\n                var dottedExpr = <BinaryExpression>alias;\n                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);\n\n                if (op1Sym != null && op1Sym.getType() != null) {\n                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);\n                }\n\n                break;\n\n            default:\n                break;\n        }\n\n        if (symbol != null) {\n            var symType = symbol.getType();\n            if (symType) {\n                var members = symType.members;\n                if (members != null) {\n                    context.members = members.publicMembers;\n                }\n            }\n            else {\n                context.tcContext.checker.errorReporter.simpleError(alias, \"Potentially circular alias reference - could not obtain type of alias\");\n            }\n        }\n\n        return symbol;\n    }\n\n    export function preCollectImportTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        var importDecl = <ImportDecl>ast;\n        var isExported = hasFlag(importDecl.varFlags, VarFlags.Exported);\n\n        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, { topLevelScope: scopeChain, members: null, tcContext: context });\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        modType = null;  // REVIEW: initialized to silence error on use below\n        if (aliasedModSymbol != null) {\n            var aliasedModType = aliasedModSymbol.getType();\n\n            if (aliasedModType != null) {\n                modType = <ModuleType>aliasedModType;\n            }\n        }\n\n        typeSymbol = new TypeSymbol(importDecl.id.text, importDecl.minChar,\n                                    context.checker.locationInfo.unitIndex, modType);\n\n        typeSymbol.isAlias = true;\n\n        if (context.scopeChain.moduleDecl != null) {\n            typeSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n        typeSymbol.declAST = importDecl;\n        importDecl.id.sym = typeSymbol;\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isExported || isGlobal, true, false);\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isExported || isGlobal, false, false);\n        return true;\n    }\n\n    export function preCollectModuleTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        var moduleDecl: ModuleDecl = ast;\n\n        var isAmbient = hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient);\n        var isEnum = hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n        var modName = (<Identifier>moduleDecl.name).text;\n\n        var isDynamic = isQuoted(modName);\n\n        var symbol = scopeChain.scope.findLocal(modName, false, false);\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        if ((symbol == null) || (symbol.kind() != SymbolKind.Type)) {\n\n            if (modType == null) {\n                var enclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n                if (isEnum) {\n                    modType.typeFlags |= TypeFlags.IsEnum;\n                }\n                modType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.setHasImplementation();\n            }\n\n            typeSymbol = new TypeSymbol(modName, moduleDecl.minChar,\n                                        context.checker.locationInfo.unitIndex, modType);\n\n            if (context.scopeChain.moduleDecl != null) {\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n            typeSymbol.declAST = moduleDecl;\n            typeSymbol.prettyName = moduleDecl.prettyName;\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            modType.symbol = typeSymbol;\n        }\n        else {\n            if (symbol != null && symbol.declAST != null && symbol.declAST.nodeType != NodeType.Module) {\n                context.checker.errorReporter.simpleError(moduleDecl, \"Conflicting symbol name for module \'\" + modName + \"\'\");\n            }\n            typeSymbol = <TypeSymbol>symbol;\n\n            // initialize new private scope for the type\n            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;\n            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new StringHashTable() : publicEnclosedTypes;\n            var enclosedTypes = new ScopedMembers(new DualStringHashTable(publicEnclosedTypesTable, new StringHashTable()));\n\n            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;\n            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new StringHashTable() : publicEnclosedAmbientTypes;\n            var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(publicAmbientEnclosedTypesTable, new StringHashTable()));\n\n            var publicMembers = typeSymbol.type.members.publicMembers;\n            var publicMembersTable = (publicMembers == null) ? new StringHashTable() : publicMembers;\n            var members = new ScopedMembers(new DualStringHashTable(publicMembersTable, new StringHashTable()));\n\n            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;\n            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new StringHashTable() : publicAmbientMembers;\n            var ambientMembers = new ScopedMembers(new DualStringHashTable(publicAmbientMembersTable, new StringHashTable()));\n\n            modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n            if (isEnum) {\n                modType.typeFlags |= TypeFlags.IsEnum;\n            }\n            modType.members = members;\n            modType.ambientMembers = ambientMembers;\n            modType.setHasImplementation();\n            modType.symbol = typeSymbol;\n\n            typeSymbol.addLocation(moduleDecl.minChar);\n            typeSymbol.expansions.push(modType);\n\n        }\n        if (context.scopeChain.moduleDecl != null) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        // REVIEW: If multiple disparate module decls for the same module don\'t agree\n        // in export privileges, how should we handle it?\n        if (isExported) {\n            typeSymbol.flags |= SymbolFlags.Exported;\n        }\n        if ((context.scopeChain.moduleDecl != null) ||\n            (context.scopeChain.container == context.checker.gloMod)) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        moduleDecl.mod = modType;\n        pushTypeCollectionScope(typeSymbol, modType.members,\n                                modType.ambientMembers,\n                                modType.enclosedTypes,\n                                modType.ambientEnclosedTypes,\n                                context, null, null, moduleDecl);\n\n        return true;\n    }\n\n    export function preCollectClassTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var classDecl: TypeDecl = ast;\n\n        var classType: Type;\n        var instanceType: Type;\n        var typeSymbol: TypeSymbol = null;\n        var className = (<Identifier>classDecl.name).text;\n        var alreadyInScope = false;\n        var isAmbient = hasFlag(classDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(classDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var containerMod = <TypeSymbol>scopeChain.container;\n        var foundValSymbol = false;\n\n        typeSymbol = scopeChain.scope.findLocal(className, false, true);\n        \n        // check the value space, since an override may have been declared with the type\'s name\n        // REVIEW-CLASSES\n        if (typeSymbol == null) {\n            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);\n            \n            if (valTypeSymbol != null &&\n                valTypeSymbol.isType() &&\n                valTypeSymbol.declAST != null &&\n                valTypeSymbol.declAST.nodeType == NodeType.FuncDecl &&\n                (<FuncDecl>valTypeSymbol.declAST).isSignature()) {\n                \n                typeSymbol = valTypeSymbol;\n                foundValSymbol = true;\n                \n                if (isExported) {\n                    typeSymbol.flags |= SymbolFlags.Exported;\n                }\n            \n                if (isAmbient) {\n                    typeSymbol.flags |= SymbolFlags.Ambient;\n                }                \n                \n                // the class was never entered into type space, so add it\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);                \n            }\n        }\n\n        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl) && !(<TypeDecl>typeSymbol.declAST).isOverload && !classDecl.isOverload) {\n            // we\'ll get the dupe error message later\n            typeSymbol = null;\n        }\n\n        if (typeSymbol == null) {\n            var valueSymbol = scopeChain.scope.findLocal(className, false, false);\n            classType = new Type();\n            classType.setHasImplementation();\n            instanceType = new Type();\n            instanceType.setHasImplementation();\n            classType.instanceType = instanceType;\n            classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            addPrototypeField(classType, classDecl, context);\n            instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            typeSymbol = new TypeSymbol(className, classDecl.minChar,\n                                        context.checker.locationInfo.unitIndex, classType);\n            typeSymbol.declAST = classDecl;\n            typeSymbol.instanceType = instanceType;\n            classType.symbol = typeSymbol;\n            instanceType.symbol = typeSymbol;\n\n            if (context.scopeChain.moduleDecl != null) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n                typeSymbol.flags |= SymbolFlags.ModuleMember;\n            }\n\n            if (isExported) {\n                typeSymbol.flags |= SymbolFlags.Exported;\n            }\n            \n            if (isAmbient) {\n                typeSymbol.flags |= SymbolFlags.Ambient;\n            }\n\n            ast.type = classType;\n\n            // class in both name spaces (type for instance type; constructor representative in value space)\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n\n            if (valueSymbol == null) {\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            }\n        }\n        else {                                        \n            classType = typeSymbol.type;\n            \n            // If the instance type is null, a call overload was likely declared before the class constructor\n            if (classType.instanceType == null) {\n                classType.instanceType = new Type();\n                classType.instanceType.setHasImplementation();\n                classType.instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.instanceType.symbol = classType.symbol\n            }\n            \n            instanceType = classType.instanceType;\n            ast.type = classType;\n        }\n\n        if (!classDecl.isOverload) {\n            getBases(instanceType, classDecl);\n            pushTypeCollectionScope(typeSymbol, instanceType.members, null, null, null,\n                                    context, instanceType, classType, null);\n        }\n        return true;\n    }\n\n    export function preCollectES6ClassTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var classDecl: ES6ClassDecl = ast;\n\n        var classType: Type;\n        var instanceType: Type;\n        var typeSymbol: TypeSymbol = null;\n        var className = (<Identifier>classDecl.name).text;\n        var alreadyInScope = false;\n        var isAmbient = hasFlag(classDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(classDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var containerMod = <TypeSymbol>scopeChain.container;\n        var foundValSymbol = false;\n\n        typeSymbol = scopeChain.scope.findLocal(className, false, true);\n        \n        // check the value space, since an override may have been declared with the type\'s name\n        // REVIEW-CLASSES\n        if (typeSymbol == null) {\n            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);\n            \n            if (valTypeSymbol != null &&\n                valTypeSymbol.isType() &&\n                valTypeSymbol.declAST != null &&\n                valTypeSymbol.declAST.nodeType == NodeType.FuncDecl &&\n                (<FuncDecl>valTypeSymbol.declAST).isSignature()) {\n                \n                typeSymbol = valTypeSymbol;\n                foundValSymbol = true;\n                \n                if (isExported) {\n                    typeSymbol.flags |= SymbolFlags.Exported;\n                }\n            \n                if (isAmbient) {\n                    typeSymbol.flags |= SymbolFlags.Ambient;\n                }                \n                \n                // the class was never entered into type space, so add it\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);                \n            }\n        }\n        \n        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl) && !(<TypeDecl>typeSymbol.declAST).isOverload) {\n            typeSymbol = null;\n        }\n\n        if (typeSymbol == null) {\n            var valueSymbol = scopeChain.scope.findLocal(className, false, false);\n            classType = new Type();\n            classType.setHasImplementation();\n            instanceType = new Type();\n            instanceType.setHasImplementation();\n            classType.instanceType = instanceType;\n            classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            addPrototypeField(classType, classDecl, context);\n            instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            instanceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            typeSymbol = new TypeSymbol(className, classDecl.minChar,\n                                        context.checker.locationInfo.unitIndex, classType);\n            typeSymbol.declAST = classDecl;\n            typeSymbol.instanceType = instanceType;\n            classType.symbol = typeSymbol;\n            instanceType.symbol = typeSymbol;\n\n            if (context.scopeChain.moduleDecl != null) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n                typeSymbol.flags |= SymbolFlags.ModuleMember;\n            }\n\n            if (isExported) {\n                typeSymbol.flags |= SymbolFlags.Exported;\n            }\n            \n            if (isAmbient) {\n                typeSymbol.flags |= SymbolFlags.Ambient;\n            }\n\n            ast.type = classType;\n\n            // class in both name spaces (type for instance type; constructor representative in value space)\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n\n            if (valueSymbol == null) {\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            }\n        }\n        else {                            \n            classType = typeSymbol.type;\n            \n            // If the instance type is null, a call overload was likely declared before the class constructor\n            if (classType.instanceType == null) {\n                classType.instanceType = new Type();\n                classType.instanceType.setHasImplementation();\n                classType.instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.instanceType.symbol = classType.symbol;\n            }\n            \n            instanceType = classType.instanceType;\n            ast.type = classType;\n        }\n\n        classType.isES6Class = true;\n        instanceType.isES6Class = true;\n\n        getBases(instanceType, classDecl);\n        pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null,\n                                context, instanceType, classType, null);\n        return true;\n    }\n\n    export function preCollectInterfaceTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var interfaceDecl: TypeDecl = ast;\n        var interfaceSymbol: TypeSymbol = null;\n        var interfaceType: Type = null;\n        var isExported = hasFlag(interfaceDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var alreadyInScope = true;\n\n        alreadyInScope = false;\n        var interfaceName = (<Identifier>interfaceDecl.name).text;\n        interfaceSymbol = scopeChain.scope.findLocal(interfaceName, false, true);\n        if (interfaceSymbol == null) {\n            interfaceType = new Type();\n            interfaceSymbol = new TypeSymbol(interfaceName,\n                                        ast.minChar,\n                                        context.checker.locationInfo.unitIndex,\n                                        interfaceType);\n            interfaceType.symbol = interfaceSymbol;\n            // REVIEW: Shouldn\'t allocate another table for interface privates\n            interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            // TODO: with partial interfaces, we should merge instead of storing the first one only\n            interfaceSymbol.declAST = interfaceDecl;\n            interfaceSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n        else {\n            alreadyInScope = true;\n            interfaceType = interfaceSymbol.type;\n        }\n\n        ast.type = interfaceType;\n        // TODO: with partial interfaces, the next lines need to do a merge of some sort\n        getBases(interfaceType, interfaceDecl);\n\n        if (isExported) {\n            interfaceSymbol.flags |= SymbolFlags.Exported;\n        }\n\n        if (context.scopeChain.moduleDecl != null) {\n            interfaceSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        if (!alreadyInScope) {\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false); // REVIEW: Technically, interfaces should be ambient\n        }\n        pushTypeCollectionScope(interfaceSymbol, interfaceType.members, null, null, null,\n                                context, interfaceType, null, null);\n        return true;\n    }\n\n    export function preCollectArgDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var argDecl: ArgDecl = ast;\n        if (hasFlag(argDecl.varFlags, VarFlags.Public | VarFlags.Private)) {\n            var field = new ValueLocation();\n            var isPrivate = hasFlag(argDecl.varFlags, VarFlags.Private);\n            // TODO: visibility\n            var fieldSymbol =\n                new FieldSymbol(argDecl.id.text, argDecl.minChar,\n                                context.checker.locationInfo.unitIndex,\n                                !hasFlag(argDecl.varFlags, VarFlags.Readonly),\n                                field);\n            fieldSymbol.transferVarFlags(argDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);\n\n            field.typeLink = getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null);\n            argDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectVarDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var varDecl = <VarDecl>ast;\n        var isAmbient = hasFlag(varDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(varDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isProperty = hasFlag(varDecl.varFlags, VarFlags.Property);\n        var isStatic = hasFlag(varDecl.varFlags, VarFlags.Static);\n        var isPrivate = hasFlag(varDecl.varFlags, VarFlags.Private);\n\n        if (context.scopeChain.moduleDecl != null) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        if (isProperty ||\n            isExported ||\n            (context.scopeChain.container == context.checker.gloMod) ||\n            (context.scopeChain.moduleDecl != null)) {\n            if (isAmbient) {\n                var existingSym =\n                    <FieldSymbol>scopeChain.scope.findLocal(varDecl.id.text, false, false);\n                if (existingSym != null) {\n                    varDecl.sym = existingSym;\n                    return false; // early exit from case\n                }\n            }\n\n                // Defensive error detection...\n            if (varDecl.id == null) {\n                context.checker.errorReporter.simpleError(varDecl, \"Expected variable identifier at this location\");\n                return false;\n            }\n            var field = new ValueLocation();\n                // TODO: visibility\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.minChar,\n                                context.checker.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            if ((context.scopeChain.moduleDecl != null) ||\n                (context.scopeChain.container == context.checker.gloMod)) {\n                fieldSymbol.flags |= SymbolFlags.ModuleMember;\n                fieldSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n\n                // if it\'s static, enter it into the class\'s member list directly\n            if (hasFlag(varDecl.varFlags, VarFlags.Property) && isStatic) {\n                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {\n                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);\n                }\n                fieldSymbol.container = context.scopeChain.classType.symbol;\n            }\n            else {\n                context.scopeChain.scope.enter(context.scopeChain.container,\n                                                ast,\n                                                fieldSymbol,\n                                                context.checker.errorReporter,\n                                                !isPrivate && (isProperty || isExported || isGlobal || isStatic),\n                                                false,\n                                                isAmbient);\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {\n                fieldSymbol.flags |= SymbolFlags.Exported;\n            }\n\n            field.typeLink = getTypeLink(varDecl.typeExpr, context.checker,\n                                        varDecl.init == null);\n            varDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectFuncDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        // REVIEW: This will have to change when we move to \"export\"\n        if (context.scopeChain.moduleDecl != null) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n\n        var funcDecl: FuncDecl = ast;\n        var fgSym: TypeSymbol = null;\n        var nameText = funcDecl.getNameText();\n        var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported);\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n        var containerSym:TypeSymbol = <TypeSymbol> ((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor() ? context.scopeChain.classType.symbol : context.scopeChain.container);\n        var containerScope: SymbolScope = context.scopeChain.scope;\n        var isGlobal = containerSym == context.checker.gloMod;\n        var go = false;\n        var foundSymbol = false; \n\n        // If this is an ES6 constructor, the \"container\" is actually the class declaration\n        if (isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)) {\n            containerSym = containerSym.container;\n            containerScope = scopeChain.previous.scope;\n        }\n\n        funcDecl.unitIndex = context.checker.locationInfo.unitIndex;\n        \n        // If the parent is the constructor, and this isn\'t an instance method, skip it.\n        // That way, we\'ll set the type during scope assignment, and can be sure that the\n        // function will be placed in the constructor-local scope\n        if (!funcDecl.isConstructor &&\n            containerSym != null &&\n            containerSym.declAST != null &&\n            containerSym.declAST.nodeType == NodeType.FuncDecl &&\n            (<FuncDecl>containerSym.declAST).isConstructor &&\n            !funcDecl.isMethod()) {\n            return go;\n        }        \n\n        // Interfaces and overloads\n        if (hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {\n            var instType = context.scopeChain.thisType;                       \n\n            // If the function is static, search in the class type\'s\n            if (nameText != null && nameText != \"__missing\") {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = containerScope.findLocal(nameText, false, false);\n                    \n                    // If we could not find the function symbol in the value context, look\n                    // in the type context.\n                    // This would be the case, for example, if a class constructor override\n                    // were declared before a call override for a given class\n                    if (fgSym == null) {\n                        fgSym = containerScope.findLocal(nameText, false, true);\n                    }\n                }\n                \n                if (fgSym != null) {\n                    foundSymbol = true;\n                    \n                    // We\'ll combine ambient and non-ambient funcdecls during typecheck (for contextual typing).,\n                    // So, if they don\'t agree, don\'t use the symbol we\'ve found                    \n                    if (!funcDecl.isSignature() && (hasFlag(funcDecl.fncFlags, FncFlags.Ambient) != hasFlag(fgSym.flags, SymbolFlags.Ambient))) {\n                       fgSym = null;\n                    }\n                }                \n            }\n            \n            // a function with this symbol has not yet been declared in this scope\n            // REVIEW: In the code below, we need to ensure that only function overloads are considered\n            //  (E.g., if a vardecl has the same id as a function or class, we may use the vardecl symbol\n            //  as the overload.)  Defensively, however, the vardecl won\'t have a type yet, so it should\n            //  suffice to just check for a null type when considering the overload symbol in\n            //  createFunctionSignature\n            if (fgSym == null) {\n                if (!(funcDecl.isSpecialFn())) {                    \n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;\n                }\n                else {\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;                                                                         \n                }\n                \n                // set the symbol\'s declAST, which will point back to the first declaration (symbol or otherwise)\n                // related to this symbol\n                fgSym.declAST = ast;\n            }\n            else { // there exists a symbol with this name\n                \n                if ((fgSym.kind() == SymbolKind.Type)) {\n\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;\n                }\n                else {\n                    context.checker.errorReporter.simpleError(funcDecl, \"Function or method \'\" + funcDecl.name + \"\' already declared as a property\");\n                }\n            }\n         \n            if (funcDecl.isSpecialFn()) {\n                funcDecl.type = instType != null ? instType : fgSym.type; \n            }\n            else {\n                funcDecl.type = fgSym.type;\n            }            \n        }\n        else {\n            // declarations\n            \n            if (nameText != null) {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // in the constructor case, we want to check the parent scope for overloads\n                    if (funcDecl.isConstructor && context.scopeChain.previous != null) {\n                        fgSym = context.scopeChain.previous.scope.findLocal(nameText, false, false);\n                    }\n                    \n                    if (fgSym == null) {\n                        fgSym = containerScope.findLocal(nameText, false, false);\n                    }\n                }\n                if (fgSym != null) {\n                    foundSymbol = true;\n                    \n                    if (!isConstructor && fgSym.declAST.nodeType == NodeType.FuncDecl && !(<FuncDecl>fgSym.declAST).isAccessor() && !(<FuncDecl>fgSym.declAST).isSignature()) {\n                        fgSym = null;\n                        foundSymbol = false;\n                    }\n                }                \n            }\n\n            // REVIEW: Move this check into the typecheck phase?  It\'s only being run over properties...\n            if (fgSym != null &&\n                !fgSym.isAccessor() &&\n                fgSym.type != null &&\n                fgSym.type.construct != null &&\n                fgSym.type.construct.signatures != [] &&\n                (fgSym.type.construct.signatures[0].declAST == null ||\n                    !hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, FncFlags.Ambient)) &&\n                !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, \"Functions may not have class overloads\");\n            }\n\n            var sig = context.checker.createFunctionSignature(funcDecl, containerSym,\n                                                containerScope, fgSym, !foundSymbol);\n\n            // it\'s a getter or setter function                                   \n            if (((fgSym == null || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym != null && fgSym.isAccessor())) {\n                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);\n            }\n\n            funcDecl.type.symbol.declAST = ast;\n            if (funcDecl.isConstructor) {\n                go = true;\n            };\n        }\n        if (isExported) {\n            if (funcDecl.type.call != null) {\n                funcDecl.type.symbol.flags |= SymbolFlags.Exported;\n            }\n            \n            // Accessors are set to \'exported\' above\n            if (fgSym != null && !fgSym.isAccessor() && fgSym.type.call != null) {\n                fgSym.flags |= SymbolFlags.Exported;\n            }\n        }\n        if ((context.scopeChain.moduleDecl != null) && (!funcDecl.isSpecialFn())) {\n            funcDecl.type.symbol.flags |= SymbolFlags.ModuleMember;\n            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;\n        }\n        return go;\n    }\n\n    export function preCollectTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var go = false;\n        var scopeChain = context.scopeChain;\n\n        if (ast.nodeType == NodeType.Script) {\n            var script: Script = <Script>ast;\n            context.script = script;\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.List) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.Import) {\n            go = preCollectImportTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.With) {\n            go = false;\n        }\n        else if (ast.nodeType == NodeType.Module) {\n            go = preCollectModuleTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.Class) {\n            go = preCollectClassTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.ES6Class) {\n            go = preCollectES6ClassTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.Block) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.Interface) {\n            go = preCollectInterfaceTypes(ast, parent, context);\n        }\n            // will be constructor arg because this pass only traverses\n            // constructor arg lists\n        else if (ast.nodeType == NodeType.ArgDecl) {\n            go = preCollectArgDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.VarDecl) {\n            go = preCollectVarDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.FuncDecl) {\n            go = preCollectFuncDeclTypes(ast, parent, context);\n        }\n        else {\n            if (ast.isStatementOrExpression() && context.scopeChain.moduleDecl != null) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n            }\n        }\n        context.goChildren = go;\n        return ast;\n    }\n\n    export function postCollectTypes(ast: AST, parent: AST, iwContext: IWalkContext) {\n        var context: TypeCollectionContext = iwContext;\n        if (ast.nodeType == NodeType.Module) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.Class) {\n            if (!(<TypeDecl>ast).isOverload) {\n                popTypeCollectionScope(context);\n            }\n        }\n        else if (ast.nodeType == NodeType.ES6Class) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.Interface) {\n            popTypeCollectionScope(context);\n        }\n        return ast;\n    }\n\n}\n\n\nmodule Tools {\n    export oldclass ScopeChain(property container: Symbol, property previous: ScopeChain,\n                     property scope: SymbolScope) {\n        property thisType: Type; // the instance type\n        property classType: Type;\n        property fnc: FuncDecl;\n        property moduleDecl: ModuleDecl;\n    }\n\n    export oldclass BBUseDefInfo(property bb: BasicBlock) {\n        property defsBySymbol = new bool[];\n        property gen: BitVector;\n        property kill: BitVector;\n        property top: BitVector;\n        // use lists by symbol \n        property useIndexBySymbol = new number[][];\n\n        property updateTop() {\n            var temp = new BitVector(this.top.bitCount);\n            for (var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {\n                var succ = this.bb.successors[i];\n                if (succ.useDef) {\n                    temp.union(succ.useDef.top);\n                }\n            }\n            temp.difference(this.kill);\n            temp.union(this.gen);\n            var changed = temp.notEq(this.top);\n            this.top = temp;\n            return changed;\n        }\n\n\n        property initialize(useDefContext: UseDefContext) {\n            var defSym = (sym: Symbol, context: UseDefContext) => {\n                if (context.isLocalSym(sym)) {\n                    var index = context.getSymbolIndex(sym);\n                    // clear pending uses\n                    this.useIndexBySymbol[index] = new number[];\n                    this.defsBySymbol[index] = true;\n                }\n            }\n\n            var useSym = (sym: Symbol, context: UseDefContext, ast: AST) => {\n                if (context.isLocalSym(sym)) {\n                    var symIndex = context.getSymbolIndex(sym);\n                    if (this.useIndexBySymbol[symIndex] == undefined) {\n                        this.useIndexBySymbol[symIndex] = new number[];\n                    }\n                    var symUses = this.useIndexBySymbol[symIndex];\n                    var astIndex = context.getUseIndex(ast);\n                    context.addUse(symIndex, astIndex);\n                    symUses.push(astIndex);\n                }\n            }\n\n            function initUseDefPre(cur: AST, parent: AST, context: UseDefContext) {\n                if (cur.nodeType == NodeType.VarDecl) {\n                    var varDecl = <BoundDecl>cur;\n                    if ((varDecl.init != null) || (hasFlag(varDecl.varFlags, VarFlags.AutoInit))) {\n                        defSym(varDecl.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.Name) {\n                    // use\n                    if (parent != null) {\n                        if (parent.nodeType == NodeType.Asg) {\n                            var asg = <BinaryExpression>parent;\n                            if (asg.operand1 == cur) {\n                                return;\n                            }\n                        }\n                        else if (parent.nodeType == NodeType.VarDecl) {\n                            var parentDecl = <BoundDecl>parent;\n                            if (parentDecl.id == cur) {\n                                return;\n                            }\n                        }\n                    }\n                    var id = <Identifier>cur;\n                    useSym(id.sym, context, cur);\n                }\n                else if ((cur.nodeType >= NodeType.Asg) && (cur.nodeType <= NodeType.LastAsg)) {\n                    // def\n                    var asg = <BinaryExpression>cur;\n                    if ((asg.operand1 != null) && (asg.operand1.nodeType == NodeType.Name)) {\n                        var id = <Identifier>asg.operand1;\n                        defSym(id.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.FuncDecl) {\n                    context.goChildren = false;\n                }\n            }\n\n            this.bb.content.walk(initUseDefPre, null, null, useDefContext);\n        }\n\n        property initializeGen(useDefContext: UseDefContext) {\n            var symbolLen = this.useIndexBySymbol.length;\n            var bitCount = useDefContext.uses.length;\n            this.gen = new BitVector(bitCount);\n            for (var s = 0; s < symbolLen; s++) {\n                var symUses = this.useIndexBySymbol[s];\n                if ((symUses != undefined) && (symUses.length > 0)) {\n                    for (var u = 0, uLen = symUses.length; u < uLen; u++) {\n                        this.gen.set(symUses[u], true);\n                    }\n                }\n            }\n            this.top = this.gen;\n        }\n\n        property initializeKill(useDefContext: UseDefContext) {\n            this.kill = new BitVector(this.gen.bitCount);\n            for (var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {\n                if (this.defsBySymbol[s]) {\n                    var globalSymUses = useDefContext.useIndexBySymbol[s];\n                    if (globalSymUses) {\n                        for (var u = 0, useLen = globalSymUses.length; u < useLen; u++) {\n                            this.kill.set(globalSymUses[u], true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    export oldclass UseDefContext extends BaseWalkContext {\n        // global use lists by symbol\n        property useIndexBySymbol = new number[][];\n        // global list of uses (flat)\n        property uses = new AST[];\n        property symbols = new VariableSymbol[];\n        property symbolMap = new StringHashTable();\n        property symbolCount = 0;\n        property func: Symbol;\n\n        // traverse ASTs in reverse order of execution (to match uses with preceding defs)\n        this.reverseSiblings = true;\n\n        property getSymbolIndex(sym: Symbol) {\n            var name = sym.name;\n            var index = <number>(this.symbolMap.lookup(name));\n            if (index == null) {\n                index = this.symbolCount++;\n                this.symbols[index] = sym;\n                this.symbolMap.add(name, index);\n            }\n            return index;\n        }\n\n        property addUse(symIndex: number, astIndex: number) {\n            var useBySym = this.useIndexBySymbol[symIndex];\n            if (useBySym == undefined) {\n                useBySym = new number[];\n                this.useIndexBySymbol[symIndex] = useBySym;\n            }\n            useBySym[useBySym.length] = astIndex;\n        }\n\n        property getUseIndex(ast: AST) {\n            this.uses[this.uses.length] = ast;\n            return this.uses.length - 1;\n        }\n\n        property isLocalSym(sym: Symbol) =>((sym != null) && (sym.container == this.func) && (sym.kind() == SymbolKind.Variable));\n\n        property killSymbol(sym: VariableSymbol, bbUses: BitVector) {\n            var index = this.symbolMap.lookup(sym.name);\n            var usesOfSym = this.useIndexBySymbol[index];\n            for (var k = 0, len = usesOfSym.length; k < len; k++) {\n                bbUses.set(usesOfSym[k], true);\n            }\n        }\n    }\n\n    export oldclass BitVector(property bitCount: number) {\n        static packBits = 30;\n        property firstBits = 0;\n        property restOfBits: number[] = null;\n        if (this.bitCount > packBits) {\n            this.restOfBits = new number[];\n            var len = Math.floor(this.bitCount / packBits);\n            for (var i = 0; i < len; i++) {\n                this.restOfBits[i] = 0;\n            }\n        }\n\n        property set(bitIndex: number, value: bool) {\n            if (bitIndex < packBits) {\n                if (value) {\n                    this.firstBits |= (1 << bitIndex);\n                }\n                else {\n                    this.firstBits &= (~(1 << bitIndex));\n                }\n            }\n            else {\n                var offset = Math.floor(bitIndex / packBits) - 1;\n                var localIndex = bitIndex % packBits;\n                if (value) {\n                    this.restOfBits[offset] |= (1 << localIndex);\n                }\n                else {\n                    this.restOfBits[offset] &= (~(1 << localIndex));\n                }\n            }\n        }\n\n        property map(fn: (index: number) =>any) {\n            var k: number;\n            for (k = 0; k < packBits; k++) {\n                if (k == this.bitCount) {\n                    return;\n                }\n                if (((1 << k) & this.firstBits) != 0) {\n                    fn(k);\n                }\n            }\n            if (this.restOfBits != null) {\n                var len: number;\n                var cumu = packBits;\n                for (k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    for (var j = 0; j < packBits; j++) {\n                        if (((1 << j) & myBits) != 0) {\n                            fn(cumu);\n                        }\n                        cumu++;\n                        if (cumu == this.bitCount) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        // assume conforming sizes\n        property union(b: BitVector) {\n            this.firstBits |= b.firstBits;\n            if (this.restOfBits != null) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits | bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        property intersection(b: BitVector) {\n            this.firstBits &= b.firstBits;\n            if (this.restOfBits != null) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits & bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        property notEq(b: BitVector) {\n            if (this.firstBits != b.firstBits) {\n                return true;\n            }\n            if (this.restOfBits != null) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    if (myBits != bBits) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        property difference(b: BitVector) {\n            var oldFirstBits = this.firstBits;\n            this.firstBits &= (~b.firstBits);\n            if (this.restOfBits != null) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] &= (~bBits);\n                }\n            }\n        }\n    }\n\n    export oldclass BasicBlock() {\n        // blocks that branch to the block after this one\n        property predecessors = new BasicBlock[];\n        property index = -1;\n        property markValue = 0;\n        property marked(markBase: number) => this.markValue > markBase;\n        property mark() {\n            this.markValue++;\n        }\n        property successors = new BasicBlock[];\n        property useDef: BBUseDefInfo = null;\n        property content = new ASTList();\n        property addSuccessor(successor: BasicBlock): void {\n            this.successors[this.successors.length] = successor;\n            successor.predecessors[successor.predecessors.length] = this;\n        }\n    }\n\n    export interface ITargetInfo {\n        stmt: AST;\n        continueBB: BasicBlock;\n        breakBB: BasicBlock;\n    }\n\n    export oldclass ControlFlowContext(property current: BasicBlock, property exit: BasicBlock,\n        property pre: (cur: AST, parent: AST, context: IWalkContext) =>AST) extends BaseWalkContext {\n        property entry = this.current;\n        // first unreachable ast for each unreachable code segment\n        property unreachable: AST[] = null;\n        property noContinuation = false;\n        // statements enclosing the current statement\n        property statementStack = new ITargetInfo[];\n        property currentSwitch = new BasicBlock[];\n\n        property pushSwitch(bb: BasicBlock) {\n            this.currentSwitch.push(bb);\n        }\n\n        property popSwitch() {\n            return this.currentSwitch.pop();\n        }\n\n        property reportUnreachable(er: ErrorReporter) {\n            if ((this.unreachable != null) && (this.unreachable.length > 0)) {\n                var len = this.unreachable.length;\n                for (var i = 0; i < len; i++) {\n                    var unreachableAST = this.unreachable[i];\n                    if (unreachableAST.nodeType != NodeType.EndCode) {\n                        er.simpleError(unreachableAST, \"unreachable code\");\n                    }\n                }\n            }\n        }\n\n        private printAST(ast: AST, outfile: ITextWriter) {\n            var printContext = new PrintContext(outfile, null);\n            printContext.increaseIndent();\n            ast.walk(prePrintAST, postPrintAST, null, printContext);\n            printContext.decreaseIndent();\n        }\n\n        private printBlockContent(bb: BasicBlock, outfile: ITextWriter) {\n            var content = bb.content;\n            for (var i = 0, len = content.members.length; i < len; i++) {\n                var ast = content.members[i];\n                this.printAST(ast, outfile);\n            }\n        }\n\n        property markBase = 0;\n\n        property bfs(nodeFunc: (bb: BasicBlock) =>void , edgeFunc: (node1: BasicBlock, node2: BasicBlock) =>void ,\n            preEdges: () =>void , postEdges: () =>void ) {\n            var markValue = this.markBase++;\n            var q = new BasicBlock[];\n            q[q.length] = this.entry;\n\n            while (q.length > 0) {\n                var bb = q.pop();\n                if (!(bb.marked(markValue))) {\n                    bb.mark();\n                    if (nodeFunc != null) {\n                        nodeFunc(bb);\n                    }\n                    var succLen = bb.successors.length;\n                    if (succLen > 0) {\n                        if (preEdges != null) {\n                            preEdges();\n                        }\n                        for (var j = succLen - 1; j >= 0; j--) {\n                            var successor = bb.successors[j];\n                            if (!(successor.marked(this.markBase))) {\n                                if (edgeFunc != null) {\n                                    edgeFunc(bb, successor);\n                                }\n                                q[q.length] = successor;\n                            }\n                        }\n                        if (postEdges != null) {\n                            postEdges();\n                        }\n                    }\n                }\n            }\n        }\n\n        property linearBBs = new BasicBlock[];\n\n        property useDef(er: ErrorReporter, funcSym: Symbol) {\n            var useDefContext = new UseDefContext();\n            useDefContext.func = funcSym;\n            var useDefInit = (bb: BasicBlock) => {\n                bb.useDef = new BBUseDefInfo(bb);\n                bb.useDef.initialize(useDefContext);\n                this.linearBBs[this.linearBBs.length] = bb;\n            }\n            this.bfs(useDefInit, null, null, null);\n            var i, bbLen;\n            for (i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {\n                this.linearBBs[i].useDef.initializeGen(useDefContext);\n                this.linearBBs[i].useDef.initializeKill(useDefContext);\n            }\n            var changed = true;\n\n            while (changed) {\n                changed = false;\n                for (i = 0; i < bbLen; i++) {\n                    changed = this.linearBBs[i].useDef.updateTop() || changed;\n                }\n            }\n\n            var top = this.entry.useDef.top;\n            top.map((index) => {\n                var ast = <Identifier>useDefContext.uses[index];\n                er.simpleError(ast, \"use of variable \'\" + ast.text + \"\' that is not definitely assigned\");\n            });\n        }\n\n        property print(outfile: ITextWriter) {\n            var index = 0;\n            var node = (bb: BasicBlock) => {\n                if (bb.index < 0) {\n                    bb.index = index++;\n                }\n                if (bb == this.exit) {\n                    outfile.WriteLine(\"Exit block with index \" + bb.index);\n                }\n                else {\n                    outfile.WriteLine(\"Basic block with index \" + bb.index);\n                    this.printBlockContent(bb, outfile);\n                }\n            }\n\n            function preEdges() {\n                outfile.Write(\"  Branches to \");\n            }\n\n            function postEdges() {\n                outfile.WriteLine(\"\");\n            }\n\n            function edge(node1: BasicBlock, node2: BasicBlock) {\n                if (node2.index < 0) {\n                    node2.index = index++;\n                }\n                outfile.Write(node2.index + \" \");\n            }\n\n            this.bfs(node, edge, preEdges, postEdges);\n            if (this.unreachable != null) {\n                for (var i = 0, len = this.unreachable.length; i < len; i++) {\n                    outfile.WriteLine(\"Unreachable basic block ...\");\n                    this.printAST(this.unreachable[i], outfile);\n                }\n            }\n        }\n\n        property pushStatement(stmt: Statement, continueBB: BasicBlock, breakBB: BasicBlock) {\n            this.statementStack.push({ stmt: stmt, continueBB: continueBB, breakBB: breakBB });\n        }\n\n        property popStatement() => this.statementStack.pop();\n\n        property returnStmt() {\n            // TODO: make successor finally block if return stmt inside of try/finally \n            this.current.addSuccessor(this.exit);\n            this.setUnreachable();\n        }\n\n        property setUnreachable() {\n            this.current = null;\n            this.noContinuation = true;\n        }\n\n        property addUnreachable(ast: AST) {\n            if (this.unreachable === null) {\n                this.unreachable = new AST[];\n            }\n            this.unreachable[this.unreachable.length] = ast;\n        }\n\n        property unconditionalBranch(target: AST, isContinue: bool) {\n            var targetBB = null;\n            for (var i = 0, len = this.statementStack.length; i < len; i++) {\n                var targetInfo = this.statementStack[i];\n                if (targetInfo.stmt == target) {\n                    if (isContinue) {\n                        targetBB = targetInfo.continueBB;\n                    }\n                    else {\n                        targetBB = targetInfo.breakBB;\n                    }\n                    break;\n                }\n            }\n            if (targetBB != null) {\n                this.current.addSuccessor(targetBB);\n            }\n            this.setUnreachable();\n        }\n\n        property addContent(ast: AST): void {\n            if (this.current != null) {\n                this.current.content.append(ast);\n            }\n        }\n    }\n\n    interface IResolutionData {\n        actuals: Type[];\n        exactCandidates: Signature[];\n        conversionCandidates: Signature[];\n        id: number;\n    }\n\n    oldclass ResolutionDataCache() {\n        property cacheSize = 16;\n        property rdCache: IResolutionData[] = [];\n        property nextUp: number = 0;\n\n        for (var i = 0; i < this.cacheSize; i++) {\n            this.rdCache[i] = {\n                actuals: new Type[],\n                exactCandidates: new Signature[],\n                conversionCandidates: new Signature[],\n                id: i\n            };\n        }\n\n        property getResolutionData(): IResolutionData {\n            var rd: IResolutionData = null;\n\n            if (this.nextUp < this.cacheSize) {\n                rd = this.rdCache[this.nextUp];\n            }\n\n            if (rd == null) {\n                this.cacheSize++;\n                rd = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: this.cacheSize\n                };\n                this.rdCache[this.cacheSize] = rd;\n            }\n\n            // cache operates as a stack - RD is always served up in-order\n            this.nextUp++;\n\n            return rd;\n        }\n\n        property returnResolutionData(rd: IResolutionData) {\n            // Pop to save on array allocations, which are a bottleneck\n            // REVIEW: Chakra bug: Array.pop doesn\'t always pop the last value in the array\n            rd.actuals.length = 0;\n            rd.exactCandidates.length = 0;\n            rd.conversionCandidates.length = 0;\n            /*\n            for (var i = 0; i < rd.actuals.length; i++) {\n                delete rd.actuals[i];\n            }\n            for (i = 0; i < rd.exactCandidates.length; i++) {\n                delete rd.exactCandidates[i];\n            }\n            for (i = 0; i < rd.conversionCandidates.length; i++) {\n                delete rd.conversionCandidates[i];\n            }\n            */\n            this.nextUp = rd.id;\n        }\n    }\n\n    export oldclass TypeFlow(property logger: ILogger, property initScope: SymbolScope, property parser: Parser,\n                   property checker: TypeChecker) {\n        property scope = this.initScope;\n        property globalScope = this.initScope;\n\n        property thisType: Type;\n        property thisFnc: FuncDecl = null;\n        property thisClassNode: NamedType = null;\n        property enclosingFncIsMethod = false;\n\n        property doubleType = this.checker.doubleType;\n        property booleanType = this.checker.booleanType;\n        property stringType = this.checker.stringType;\n        property anyType = this.checker.anyType;\n        property regexType = this.anyType;\n        property nullType = this.checker.nullType;\n        property voidType = this.checker.voidType;\n        property arrayAnyType = this.checker.makeArrayType(this.anyType);\n        property _toString = new Identifier(\"_toString\");\n        property coreModule: TypeSymbol;\n        property coreScope: SymbolScope;\n        property arrayInstanceType: Type = null;\n        property stringInstanceType: Type = null;\n        property objectInstanceType: Type = null;\n        property functionInstanceType: Type = null;\n        property currentScript: Script = null;\n        property inNewTargetTypeCheck = false;\n        property inImportTypeCheck = false;\n        property inTypeRefTypeCheck = false;\n        property inArrayElementTypeCheck = false;\n        property resolutionDataCache = new ResolutionDataCache();\n        property nestingLevel = 0;\n\n\n        this.checker.typeFlow = this;\n        property initLibs() {\n            if (this.coreModule == null) {\n                this.coreModule = this.globalScope.find(\"_Core\", false, true);\n                if (this.coreModule != null) {\n                    this.coreScope = this.coreModule.instanceScope();\n                    if (this.coreScope != null) {\n                        this.arrayInstanceType = (<TypeSymbol>this.coreScope.find(\"Array\", false, true)).type;\n                    }\n                }\n            }\n            var stringSym = this.globalScope.find(\"String\", false, true);\n            if ((stringSym != null) && (stringSym.kind() == SymbolKind.Type)) {\n                this.stringInstanceType = (<TypeSymbol>stringSym).type.instanceType;\n            }\n            var objectSym = this.globalScope.find(\"Object\", false, true);\n            if ((objectSym != null) && (objectSym.kind() == SymbolKind.Type)) {\n                this.objectInstanceType = (<TypeSymbol>objectSym).type.instanceType;\n            }\n            var fnSym = this.globalScope.find(\"Function\", false, true);\n            if ((fnSym != null) && (fnSym.kind() == SymbolKind.Type)) {\n                this.functionInstanceType = (<TypeSymbol>fnSym).type.instanceType;\n            }\n        }\n\n        property checkAssignableTo(ast: AST, type: Type, op: string) {\n            if (!this.checker.assignableTo(ast.type, type)) {\n                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, op, this.scope);\n            }\n        }\n\n        property cast(ast: AST, type: Type): AST {\n            return this.castWithCoercion(ast, type, true);\n        }\n\n        property castWithCoercion(ast: AST, type: Type, applyCoercion: bool): AST {\n            if (this.checker.assignableTo(ast.type, type)) {\n                if (applyCoercion) {\n                    // TODO: any required conversion calls\n                    if (type == null) {\n                        ast.type = this.anyType;\n                    }\n                    else if (type.isClass()) {\n                        ast.type = type.instanceType;\n                    }\n                    else {\n                        ast.type = type;\n                    }\n                }\n                return ast;\n            }\n            else {\n                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type,\n                                                        \"cast\", this.scope);\n                return ast;\n            }\n        }\n\n        property inScopeTypeCheck(ast: AST, enclosingScope: SymbolScope): AST {\n            var prevScope = this.scope;\n            this.scope = enclosingScope;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var svCurrentModDecl = this.checker.currentModDecl;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var container = this.scope.container;\n            var fnc: FuncDecl = null;\n            while (container != null) {\n                if (container.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>container;\n                    var type = typeSym.type;\n                    if (type.call != null) {\n                        if (fnc == null) {\n                            // use innermost function\n                            this.enclosingFncIsMethod = typeSym.isMethod;\n                            fnc = container.declAST;\n                        }\n                    }\n                    if (type.isClass()) {\n                        this.thisType = type.instanceType;\n                        // use innermost class\n                        break;\n                    }\n                    if (type.isModuleType()) {\n                        this.checker.currentModDecl = typeSym.declAST;\n                        // use innermost module\n                        break;\n                    }\n                }\n                container = container.container;\n            }\n            this.thisFnc = fnc;\n            var updated = this.typeCheck(ast);\n\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.checker.currentModDecl = svCurrentModDecl;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.scope = prevScope;\n            return updated;\n        }\n\n        property typeCheck(ast: AST): AST {\n            if (ast != null) {\n                return ast.typeCheck(this);\n            }\n            else {\n                return null;\n            }\n        }\n\n        property inScopeTypeCheckDecl(ast: AST) {\n            if (ast.nodeType == NodeType.VarDecl || ast.nodeType == NodeType.ArgDecl) {\n                this.inScopeTypeCheckBoundDecl(<BoundDecl>ast);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n\n                var funcDecl = <FuncDecl>ast;\n\n                if (funcDecl.isAccessor()) {\n                    this.typeCheckFunction(funcDecl);\n                }\n                    // if the funcdecl is ambient, we\'ll pull its enclosing type during\n                    // binding\n                    // assum constructor\n                else if ((funcDecl.type.symbol.declModule == null) || (!(funcDecl.type.symbol.declModule.modFlags & ModuleFlags.Ambient))) {\n                    this.typeCheckClass(funcDecl.classDecl);\n                }\n            }\n        }\n\n        property inScopeTypeCheckBoundDecl(varDecl: BoundDecl) {\n            var sym = varDecl.sym;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevLocationInfo = this.checker.locationInfo;\n            if ((sym != null) && (sym.container != null)) {\n                var instanceScope = hasFlag(varDecl.varFlags, VarFlags.ES6ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope();\n                if (hasFlag(varDecl.varFlags, VarFlags.Property)) {\n                    this.thisFnc = sym.container.declAST;\n                }\n                if (instanceScope != null) {\n                    var prevScope = this.scope;\n                    this.scope = instanceScope;\n                    var container = sym.container;\n                    if ((this.checker.units != null) &&\n                        (sym.unitIndex >= 0) &&\n                        (sym.unitIndex < this.checker.units.length)) {\n                        this.checker.locationInfo = this.checker.units[sym.unitIndex];\n                    }\n                    else {\n                        this.checker.locationInfo = unknownLocationInfo;\n                    }\n                    // REVIEW: container linkage for function expressions\n                    while (container != null) {\n                        if (container.kind() == SymbolKind.Type) {\n                            var typeSym = <TypeSymbol>container;\n                            var type = typeSym.type;\n                            if (type.call != null) {\n                                this.enclosingFncIsMethod = typeSym.isMethod;\n                            }\n                            if (type.isClass()) {\n                                this.thisType = type.instanceType;\n                                break;\n                            }\n                        }\n                        container = container.container;\n                    }\n\n                    this.typeCheckBoundDecl(varDecl);\n                    this.scope = prevScope;\n                }\n            }\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.enclosingFncIsMethod = prevMethodStatus;\n        }\n\n        property resolveBoundDecl(varDecl: BoundDecl) {\n            if (varDecl.typeExpr != null) {\n                if (varDecl.typeExpr.type == null ||\n                    (varDecl.typeExpr.type != null && varDecl.typeExpr.type == this.anyType && this.scope != null) ||\n                    varDecl.typeExpr.type.symbol == null ||\n                    varDecl.typeExpr.type.symbol.typeCheckStatus != TypeCheckStatus.Finished) {\n                    this.typeCheck(varDecl.typeExpr);\n                }\n                varDecl.type = varDecl.typeExpr.type;\n                if (varDecl.sym != null) {\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n            else if (varDecl.init == null) {\n                if (this.checker.styleSettings.implicitAny) {\n                    this.checker.errorReporter.styleError(varDecl, \"type implicitly set to \'any\'\");\n                }\n                varDecl.type = this.anyType;\n                if (varDecl.sym != null) {\n                    if (varDecl.sym.isType()) {\n                        var tsym = <TypeSymbol>varDecl.sym;\n                        if (tsym.isMethod) {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind method group to variable.  (Did you mean to use \'declare function\' instead of \'declare var\'?)\");\n                            return;\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind type to variable\");\n                            return;\n                        }\n                    }\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n        }\n\n        property typeCheckBoundDecl(varDecl: BoundDecl): VarDecl {\n            // symbol has already been added to the scope\n            var infSym = <InferenceSymbol>varDecl.sym;\n            if (infSym == null) {\n                if (varDecl.init != null) {\n                    varDecl.init = this.typeCheck(varDecl.init);\n                    varDecl.type = varDecl.init.type;\n                }\n                else {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to \'any\'\");\n                    }\n                    varDecl.type = this.anyType;\n                }\n            }\n            else {\n                if (infSym.typeCheckStatus == TypeCheckStatus.Started) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to \'any\'\");\n                    }\n                    varDecl.type = this.anyType;\n                    infSym.setType(this.anyType);\n                }\n                else if (infSym.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                    infSym.typeCheckStatus = TypeCheckStatus.Started;\n                    var resolved = false;\n                    if (varDecl.type == null) {\n                        // propagate declared type\n                        if (varDecl.typeExpr != null) {\n                            this.resolveBoundDecl(varDecl);\n                            resolved = true;\n                            varDecl.type = varDecl.typeExpr.type;\n                            infSym.typeCheckStatus = TypeCheckStatus.Finished;\n                        }\n                    }\n\n                    if (varDecl.init != null) {\n                        if (hasFlag(varDecl.varFlags, VarFlags.Ambient)) {\n                            this.checker.errorReporter.simpleError(varDecl, \"ambient variable can not have an initializer\");\n                        }\n\n                        // if the bound decl is a function-local static, we need to set the\n                        // encapsulating scope to the function\'s member scope\n                        var isLocalStatic = hasFlag(varDecl.varFlags, VarFlags.LocalStatic);\n                        var prevScope = this.scope;\n                        var applyTargetType = !varDecl.init.isParenthesized;\n                        if (isLocalStatic) {\n                            this.scope = varDecl.sym.container.getType().memberScope;\n                        }\n\n                        this.checker.typeCheckWithTargetType(varDecl.type, applyTargetType, varDecl.init);\n\n                        this.scope = prevScope;\n                        if (varDecl.type != null) {\n                            // If the cast is to a target type, in the case of a funcdecl,\n                            // we may overwrite the init\'s type with one generated from a signature.\n                            // In that case, we need to preserve the contained scope of the actual decl\n                            var preserveScope = false;\n                            var preservedContainedScope = null;\n                            if (varDecl.init.type != null) {\n                                preservedContainedScope = varDecl.init.type.containedScope;\n                                preserveScope = true;\n                            }\n                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType);\n\n                            if (preserveScope && varDecl.init.type.containedScope == null) {\n                                varDecl.init.type.containedScope = preservedContainedScope;\n                            }\n                        }\n                        else {\n                            // type inference\n                            varDecl.type = varDecl.init.type == this.checker.undefinedType ? this.anyType : varDecl.init.type;\n                            if (varDecl.type == this.voidType) {\n                                this.checker.errorReporter.simpleError(varDecl, \"can not assign to variable \" + varDecl.id.text + \" a value of type void\");\n                                varDecl.type = this.anyType;\n                            }\n                            else if (varDecl.type == this.nullType) {\n                                //checker.errorReporter.simpleError(varDecl,\"Warning: inferred type any from assignment of null\");                                \n                                varDecl.type = this.anyType;\n                            }\n                        }\n                        infSym.setType(varDecl.type);\n                    }\n                    else {\n                        if (!resolved) {\n                            this.resolveBoundDecl(varDecl);\n                        }\n                    }\n                    infSym.typeCheckStatus = TypeCheckStatus.Finished;\n                }\n                else if ((infSym.typeCheckStatus == TypeCheckStatus.Finished) &&\n                         (infSym.declAST != varDecl)) {\n                    if (varDecl.init != null) {\n                        varDecl.init = this.typeCheck(varDecl.init);\n                        varDecl.type = infSym.getType();\n                        varDecl.init = this.cast(varDecl.init, varDecl.type);\n                    }\n                }\n            }\n            if (varDecl.id != null && varDecl.sym != null) {\n                varDecl.id.sym = varDecl.sym;\n            }\n            return varDecl;\n        }\n\n        property typeCheckSuper(ast: AST): AST {\n            if ((this.thisType != null) && (this.enclosingFncIsMethod) && (this.thisType.baseClass() != null)) {\n                ast.type = this.thisType.baseClass();\n            }\n            else {\n                ast.type = this.anyType;\n                this.checker.errorReporter.invalidSuperReference(ast);\n            }\n            return ast;\n        }\n\n        property typeCheckThis(ast: AST): AST {\n            if (this.thisFnc == null) {\n                // \'this\' in ES6 class bodies should bind to \'any\'\n                if (this.thisType != null) {\n                    if (this.thisClassNode && this.thisClassNode.nty == NodeType.ES6Class) {\n                        this.checker.errorReporter.simpleError(ast, \"Uses of \'this\' are illegal within the outer class body\");\n                        ast.type = this.anyType;\n                    }\n                    else {\n                        ast.type = this.thisType;\n                    }\n                }\n                else {\n                    ast.type = this.anyType;\n                }\n            }\n            else {\n                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor || this.thisFnc.isTargetTypedAsMethod) {\n                    if (this.thisType != null) {\n                        ast.type = this.thisType;\n                    }\n                    else {\n                        ast.type = this.anyType;\n                    }\n                }\n                else {\n                    ast.type = this.anyType;\n                }\n            }\n\n            // redirect \'this\' used within lambdas\n            if (!this.enclosingFncIsMethod &&\n                this.thisFnc != null && \n                hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n\n                // if the enclosing function was bound to a property,\n                // checkInitSelf would not have been able to mark the \n                // function for a self init\n                if (this.thisFnc.boundToProperty != null) {\n                    var container = this.thisFnc.boundToProperty.sym.container;\n                    if (container.declAST.nodeType == NodeType.FuncDecl) {\n                        (<FuncDecl>container.declAST).setHasSelfReference();\n                    }\n                }\n                else {\n                    var encFnc = this.thisFnc.enclosingFnc;\n                    var firstEncFnc = encFnc;\n                    var foundMeth = false;\n\n                    while (encFnc != null) {\n                        if (encFnc.isMethod()) {\n                            encFnc.setHasSelfReference();\n                            foundMeth = true;\n                            break;\n                        }\n                        encFnc = encFnc.enclosingFnc;\n                    }\n\n                    if (!foundMeth && firstEncFnc) {\n                        firstEncFnc.setHasSelfReference();\n                    }\n\n                    if (foundMeth && this.thisType) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n            return ast;\n        }\n\n        property typeCheckSelf(ast: AST): AST {\n            if (this.thisType == null) {\n                ast.type = this.anyType;\n                this.checker.errorReporter.simpleError(ast,\n                                                  \"reference to \'self\' outside of class scope\");\n            }\n            else {\n                ast.type = this.thisType;\n                if (!this.enclosingFncIsMethod) {\n                    if (this.thisFnc != null) {\n                        if (this.thisFnc.isConstructor || this.thisFnc.isMethod()) {\n                            this.thisFnc.setHasSelfReference();\n                        }\n                            // if the enclosing function was bound to a property,\n                            // checkInitSelf would not have been able to mark the \n                            // function for a self init\n                        else if (this.thisFnc.boundToProperty != null) {\n                            var container = this.thisFnc.boundToProperty.sym.container;\n                            if (container.declAST.nodeType == NodeType.FuncDecl) {\n                                (<FuncDecl>container.declAST).setHasSelfReference();\n                            }\n                        }\n                        else {\n                            var encFnc = this.thisFnc.enclosingFnc;\n                            while (encFnc != null) {\n                                if (encFnc.isMethod()) {\n                                    encFnc.setHasSelfReference();\n                                    break;\n                                }\n                                encFnc = encFnc.enclosingFnc;\n                            }\n                        }\n                    }\n                }\n            }\n            return ast;\n        }\n\n        property setTypeFromSymbol(ast: AST, symbol: Symbol): void {\n            if (symbol.isVariable()) {\n                if (symbol.isInferenceSymbol()) {\n                    var infSym = <InferenceSymbol>symbol;\n                    if ((infSym.declAST != null) &&\n                        (infSym.typeCheckStatus != TypeCheckStatus.Finished)) {\n                        this.inScopeTypeCheckDecl(infSym.declAST);\n                    }\n                    if (!this.checker.styleSettings.innerScopeDeclEscape) {\n                        if ((infSym.declAST != null) && (infSym.declAST.nodeType == NodeType.VarDecl)) {\n                            if (this.nestingLevel < (<VarDecl>infSym.declAST).nestingLevel) {\n                                this.checker.errorReporter.styleError(ast,\"reference to variable defined in more nested scope\"); \n                            }\n                        }\n                    }\n                }\n                ast.type = symbol.getType();\n                if (!symbol.writeable()) {\n                    ast.flags = ast.flags & (~(ASTFlags.Writeable));\n                }\n            }\n            else if (symbol.isType()) {\n                ast.type = symbol.getType();\n                ast.flags = ast.flags & (~(ASTFlags.Writeable));\n            }\n            else {\n                ast.type = this.anyType;\n                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);\n            }\n        }\n\n        property typeCheckName(ast: AST): AST {\n            var identifier = <Identifier>ast;\n\n            if (this.checker.inWith) {\n                identifier.type = this.anyType;\n            }\n            else {\n                var typespace = false;\n                var idText = identifier.text;\n                var originalIdText = idText;\n                var isDynamicModuleName = isQuoted(identifier.text);\n\n                var symbol = this.scope.find(idText, false, typespace);\n\n                // REVIEW: In the IDE case, we won\'t have a mod map to fall back on, so we need to assemble\n                // the mod name by hand                \n                if (symbol == null && isDynamicModuleName) {\n                    // perhaps it\'s a dynamic module?\n                    if (!symbol) {\n                        idText = swapQuotes(originalIdText);\n                        symbol = this.scope.find(idText, false, typespace);\n                    }\n\n                    // Check the literal path first\n                    if (!symbol) {\n                        idText = stripQuotes(originalIdText) + \".str\";\n                        symbol = this.scope.find(idText, false, typespace);\n                    }\n\n                    // Check check for .d.str\n                    if (!symbol) {\n                        idText = stripQuotes(originalIdText) + \".d.str\";\n                        symbol = this.scope.find(idText, false, typespace);\n                    }\n\n                    // If the literal path doesn\'t work, begin the search\n                    if (!symbol && !isRelative(originalIdText)) {\n                        // check the full path first, as this is the most likely scenario\n                        idText = originalIdText;\n                        \n                        var strippedIdText = stripQuotes(idText);\n                        var path = getRootFilePath(this.currentScript.locationInfo.filename);\n\n                        while (symbol == null && path != \"\" && path != \"/\") {\n                            idText = normalizePath(path + strippedIdText + \".str\");\n                            symbol = this.scope.find(idText, false, typespace);\n\n                            // check for .d.str\n                            if (symbol == null) {\n                                idText = changePathToDSTR(idText);\n                                symbol = this.scope.find(idText, false, typespace);\n                            }\n\n                            if (symbol == null) {\n                                path = normalizePath(path + \"..\"); \n                                path = path ? path + \"/\" : path;\n                            }\n                        }\n                    }\n                }\n\n                if (symbol == null) {\n                    if (!identifier.isMissing()) {\n                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);\n                    }\n                    identifier.type = this.anyType;\n                }\n                else {\n                    if (this.inNewTargetTypeCheck && symbol.isInferenceSymbol() && (<InferenceSymbol>symbol).typeCheckStatus != TypeCheckStatus.Finished) {\n                        this.checker.errorReporter.simpleError(ast, \"Symbol \'\" + identifier.text + \"\' is referenced before its declaration\");\n                    }\n\n                    if (optimizeModuleCodeGen && symbol != null && symbol.isType()) {\n                        var symType = symbol.getType();\n                        // Once the type has been referenced outside of a type ref position, there\'s\n                        // no going back                        \n                        if (symType != null && (<TypeSymbol>symbol).isAlias && (<TypeSymbol>symbol).onlyReferencedAsTypeRef) {\n\n                            var modDecl = <ModuleDecl>symType.symbol.declAST;\n                            if (modDecl != null && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {\n                                (<TypeSymbol>symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;\n                            }\n                        }\n                    }\n\n                    this.setTypeFromSymbol(ast, symbol);\n                    identifier.sym = symbol;\n                    if (this.thisFnc != null) {\n                        if (this.thisFnc.type != null && symbol.container != this.thisFnc.type.symbol) {\n                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;\n                        }\n                    }\n                    if (this.checker.symTrack) {\n                        if (this.thisFnc != null) {\n                            if (((symbol.kind() == SymbolKind.Variable) ||\n                                 (symbol.kind() == SymbolKind.Parameter)) &&\n                                (symbol.container != this.thisFnc.type.symbol) &&\n                                (symbol.container != this.checker.gloMod)) {\n                                if (hasFlag(this.checker.traceFlags, TraceFlags.Symbols)) {\n                                    this.checker.errorReporter.simpleError(identifier,\n                                                                      \"clo ref \" + symbol.name);\n                                }\n                                identifier.cloId = this.thisFnc.addCloRef(identifier, symbol);\n                            }\n                        }\n                        if (hasFlag(this.checker.traceFlags, TraceFlags.Symbols)) {\n                            this.checker.errorReporter.showRef(identifier, identifier.text,\n                                                          identifier.sym);\n                        }\n                        symbol.addRef(ast);\n                    }\n                }\n            }\n            return ast;\n        }\n\n        property typeCheckScript(script: Script): Script {\n            this.checker.locationInfo = script.locationInfo;\n            this.scope = this.checker.globalScope;\n\n            // if it\'s a top-level module, the globals have already been added to the implicit\n            // module decl\n            if (!script.topLevelMod) {\n                this.addLocalsFromScope(this.scope, this.checker.gloMod,\n                                   script.vars, this.checker.globals, true);\n            }\n\n            this.currentScript = script;\n            script.bod = this.typeCheck(script.bod);\n            this.currentScript = null;\n            return script;\n        }\n\n        property typeCheckBitNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return unex;\n        }\n\n        property typeCheckUnaryNumberOperator(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return ast;\n        }\n\n        property typeCheckLogNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.booleanType;\n            return unex;\n        }\n\n        property astIsWriteable(ast: AST): bool {\n            return hasFlag(ast.flags, ASTFlags.Writeable);\n        }\n\n        property typeCheckIncOrDec(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            var lval = unex.operand;\n            if (!this.astIsWriteable(unex)) {\n                this.checker.errorReporter.valueCannotBeModified(unex);\n                unex.type = this.doubleType;\n                return unex;\n            }\n            else {\n                return this.typeCheckUnaryNumberOperator(ast);\n            }\n        }\n\n        property typeCheckBitwiseOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            var resultType: Type = null;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            \n            if (this.checker.styleSettings.bitwise) {\n                this.checker.errorReporter.styleError(ast,\"use of \"+nodeTypeTable[binex.nodeType]);\n            }\n            \n            if (leftType.subtype(this.doubleType, this.checker) && (rightType.subtype(this.doubleType, this.checker))) {\n                resultType = this.doubleType;\n            }\n            else if ((leftType == this.booleanType) &&\n                     (rightType == this.booleanType)) {\n                resultType = this.booleanType;\n            }\n            else if (leftType == this.anyType) {\n                if ((rightType == this.anyType) ||\n                    (rightType == this.doubleType) ||\n                    (rightType == this.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            else if (rightType == this.anyType) {\n                if ((leftType == this.anyType) ||\n                    (leftType == this.doubleType) ||\n                    (leftType == this.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            if (resultType == null) {\n                resultType = this.anyType;\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                        binex.printLabel(), this.scope);\n            }\n            binex.type = resultType;\n            return binex;\n        }\n\n        property typeCheckArithmeticOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            \n            if (this.checker.styleSettings.bitwise &&\n                ((binex.nodeType == NodeType.And) ||\n                (binex.nodeType == NodeType.Or) ||\n                (binex.nodeType == NodeType.AsgAnd) ||\n                (binex.nodeType == NodeType.AsgOr))) {\n                this.checker.errorReporter.styleError(ast, \"use of \"+nodeTypeTable[binex.nodeType]);\n            }\n                \n            if (leftType == null || rightType == null) {\n                this.checker.errorReporter.simpleError(binex, \"Could not typecheck arithmetic operation.  Possible recursive typecheck error?\");\n                binex.type = this.anyType;\n                return binex;\n            }\n            var nodeType = binex.nodeType;\n            if (((nodeType == NodeType.Add) || (nodeType == NodeType.AsgAdd)) &&\n                ((leftType == this.stringType) || (rightType == this.stringType))) {\n                binex.type = this.stringType;\n            }\n            else if (leftType.subtype(this.doubleType, this.checker) && rightType.subtype(this.doubleType, this.checker)) {\n                binex.type = this.doubleType;\n            }\n            else if (((leftType == this.anyType) && ((rightType == this.anyType) || (rightType.subtype(this.doubleType, this.checker)))) ||\n                     ((rightType == this.anyType) && ((leftType == this.anyType) || (leftType.subtype(this.doubleType, this.checker))))) {\n                binex.type = this.anyType;\n            }\n            else {\n                binex.type = this.anyType;\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                        binex.printLabel(), this.scope);\n            }\n            return binex;\n        }\n\n        property typeCheckDotOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var leftIsFnc = false;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            var leftType = binex.operand1.type;\n            var leftScope: SymbolScope = null;\n            // REVIEW: replace with get member scope\n            if (leftType != null) {\n                if ((leftType == this.anyType) || leftType.isDouble()) {\n                    binex.type = this.anyType;\n                    return binex;\n                }\n                else if (leftType == this.stringType) {\n                    if (this.stringInstanceType != null) {\n                        leftScope = this.stringInstanceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (((leftType.call != null) || (leftType.construct != null)) && (leftType.members == null)) {\n                    if (this.functionInstanceType != null) {\n                        leftScope = this.functionInstanceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType.elementType != null) {\n                    if (this.arrayInstanceType != null) {\n                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInstanceType, this.checker);\n                        leftScope = arrInstType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else {\n                    leftScope = leftType.memberScope;\n                }\n            }\n            if (leftScope == null) {\n                if (leftType != this.nullType) {\n                    this.checker.errorReporter.expectedClassOrInterface(binex);\n                }\n                binex.type = this.anyType;\n            }\n            else {\n                var propertyName = <Identifier>binex.operand2;\n                var lhsIsEnclosingType = this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType;\n                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, false); // only search the public members, unless the rhs is a \'this\' pointer\n                if ((symbol == null) && (leftType != null)) {\n                    if (((leftType.call != null) || (leftType.construct != null)) &&\n                        (this.functionInstanceType != null)) {\n                        leftScope = this.functionInstanceType.memberScope;\n                    }\n                    else if (leftType.isReferenceType()) {\n                        if (this.objectInstanceType != null) {\n                            leftScope = this.objectInstanceType.memberScope;\n                            symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, false);\n                        }\n                    }\n                }\n                if ((symbol == null) || (!symbol.visible(leftScope, this.checker))) {\n                    binex.type = this.anyType;\n                    if ((leftType.call != null) && (!leftType.call.isMethod)) {\n                        // no error because non-method acts like any for properties\n                    }\n                    else {\n                        if (symbol == null) {\n                            this.checker.errorReporter.unresolvedSymbol(propertyName,\n                                                                   propertyName.text);\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(binex, propertyName.text + \" not visible\");\n                        }\n                    }\n                }\n                else {\n                    if (symbol.isVariable()) {\n                        if (symbol.isInferenceSymbol()) {\n                            var infSym = <InferenceSymbol>symbol;\n                            if (infSym.declAST != null && infSym.typeCheckStatus != TypeCheckStatus.Finished) {\n                                this.inScopeTypeCheckDecl(infSym.declAST);\n                            }\n                        }\n                    }\n                    propertyName.sym = symbol;\n                    binex.type = symbol.getType();\n                }\n            }\n            if (binex.type == null) {\n                binex.type = this.anyType;\n            }\n\n            return binex;\n        }\n\n        property typeCheckBooleanOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n            if ((!(this.checker.assignableTo(leftType, rightType))) &&\n                (!(this.checker.assignableTo(rightType, leftType)))) {\n                this.checker.errorReporter.valuesCannotBeCompared(binex, leftType, rightType);\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        property typeCheckAsgOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var applyTargetType = !binex.operand2.isParenthesized;\n            binex.operand1 = this.typeCheck(binex.operand1);\n\n            this.checker.typeCheckWithTargetType(binex.operand1.type, applyTargetType, binex.operand2);\n\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (!(this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            if (binex.operand1.nodeType == NodeType.Call) {\n                var callEx = <CallExpression>binex.operand1;\n            }\n            var preserveScope = false;\n            var preservedContainedScope = null;\n            if (binex.operand2.type != null) {\n                preservedContainedScope = binex.operand2.type.containedScope;\n                preserveScope = true;\n            }\n            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType);\n            if (preserveScope && binex.operand2.type.containedScope == null) {\n                binex.operand2.type.containedScope = preservedContainedScope;\n            }\n            binex.type = rightType;\n            return binex;\n        }\n\n        property typeCheckIndex(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            if (!this.checker.styleSettings.literalSubscript) {\n                if (binex.operand2.nodeType == NodeType.QString) {\n                    this.checker.errorReporter.styleError(ast,\"literal subscript (use \'.\' instead)\");\n                }\n            }\n            var collectionType = binex.operand1.type;\n            if (collectionType == this.anyType) {\n                binex.type = this.anyType;\n            }\n            else if (collectionType == this.stringType) {\n                binex.type = this.stringType;\n            }\n            else if (collectionType == null) {\n                // TODO: catch this upstream and infer the type\n                binex.type = this.anyType;\n            }\n            else if (collectionType.elementType != null) {\n                binex.type = collectionType.elementType;\n            }\n            else {\n                var itemType = collectionType.getItemType(binex.operand2.type, this.checker, binex.operand2);\n                if (itemType != null) {\n                    binex.type = itemType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.indexLHS(binex);\n                }\n            }\n            return binex;\n        }\n\n        property typeCheckInOperator(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        property typeCheckShift(binex: BinaryExpression, assignment: bool): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);\n            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);\n            if (assignment && (!(this.astIsWriteable(binex.operand1)))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            binex.type = this.doubleType;\n            return binex;\n        }\n\n        property typeCheckQMark(trinex: TrinaryExpression): TrinaryExpression {\n            trinex.operand1 = this.typeCheck(trinex.operand1);\n            trinex.operand2 = this.typeCheck(trinex.operand2);\n            trinex.operand3 = this.typeCheck(trinex.operand3);\n            var leftType = trinex.operand2.type;\n            var rightType = trinex.operand3.type;\n\n            if (leftType == rightType) {\n                trinex.type = leftType;\n            }\n            else if (this.checker.assignableTo(rightType, leftType)) {\n                trinex.operand3 = this.cast(trinex.operand3, leftType);\n            }\n            else if (this.checker.assignableTo(leftType, rightType)) {\n                trinex.operand2 = this.cast(trinex.operand2, rightType);\n            }\n            else {\n                trinex.type = this.anyType;\n                this.checker.errorReporter.qMarkIncompatibleTypes(trinex, leftType, rightType,\n                                                             this.scope);\n            }\n            if (trinex.type == null) {\n                trinex.type = this.anyType;\n            }\n            return trinex;\n        }\n\n        property addFormals(container: Symbol, signature: Signature,\n            table: IHashTable) {\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var symbol = <ParameterSymbol>signature.parameters[i];\n                symbol.container = container;\n                table.add(symbol.name, symbol);\n            }\n        }\n\n        // REVIEW: We use isModContainer instead of container.getType().isModuleType because container.type may be null at this\n        // juncture.\n        property addLocalsFromScope(scope: SymbolScope, container: Symbol, vars: ASTList, table: IHashTable, isModContainer: bool) {\n            var len = vars.members.length;\n            var hasArgsDef = false;\n            for (var i = 0; i < len; i++) {\n                var local: VarDecl = vars.members[i];\n                if (((local.sym == null) || (local.sym.kind() != SymbolKind.Field))) {\n                    var result: Symbol = null;\n                    if ((result = table.lookup(local.id.text)) == null) {\n                        var localVar: ValueLocation = new ValueLocation();\n                        localVar.typeLink = new TypeLink();\n                        var varSym = null;\n\n                        if (hasFlag(local.varFlags, VarFlags.Static)) {\n                            local.varFlags |= VarFlags.LocalStatic;\n                            varSym = new FieldSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      true, localVar);\n                        }\n                        else {\n                            varSym = new VariableSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      localVar);\n                        }\n                        varSym.transferVarFlags(local.varFlags);\n                        localVar.symbol = varSym;\n                        varSym.declAST = local;\n                        localVar.typeLink.ast = local.typeExpr;\n                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);\n                        if ((local.type == null) && (local.init == null)) {\n                            local.type = this.anyType;\n                        }\n                        localVar.typeLink.type = local.type;\n                        localVar.symbol.container = container;\n                        local.sym = localVar.symbol;\n                        table.add(local.id.text, varSym);\n                        if (local.id.text == \"arguments\") {\n                            hasArgsDef = true;\n                        }\n                    }\n                    else {\n                        local.type = result.getType();\n                        local.sym = result;\n                    }\n                }\n            }\n            if (!isModContainer) {\n                if (!hasArgsDef) {\n                    var argLoc = new ValueLocation();\n                    argLoc.typeLink = new TypeLink();\n                    var theArgSym = new VariableSymbol(\"arguments\", vars.minChar,\n                                                     this.checker.locationInfo.unitIndex,\n                                                     argLoc);\n                    argLoc.typeLink.ast = new Identifier(\"IArguments\");\n                    this.checker.resolveTypeLink(scope, argLoc.typeLink, false);\n                    table.add(\"arguments\", theArgSym);\n                }\n            }\n        }\n\n        property addConstructorLocalArgs(container: Symbol, args: ASTList, table: IHashTable): void {\n            if (args != null) {\n                var len = args.members.length;\n                for (var i = 0; i < len; i++) {\n                    var local: ArgDecl = args.members[i];\n                    if ((local.sym == null) ||\n                        (local.sym.kind() != SymbolKind.Field)) {\n                        var result: Symbol = null;\n                        if ((result = table.lookup(local.id.text)) == null) {\n                            this.resolveBoundDecl(local);\n                            var localVar: ValueLocation = new ValueLocation();\n                            localVar.typeLink = new TypeLink();\n                            var varSym = new ParameterSymbol(local.id.text, local.minChar,\n                                                           this.checker.locationInfo.unitIndex,\n                                                           localVar);\n                            varSym.declAST = local;\n                            localVar.symbol = varSym;\n                            localVar.typeLink.type = local.type;\n                            localVar.symbol.container = container;\n                            local.sym = localVar.symbol;\n                            table.add(local.id.text, varSym);\n                        }\n                        else {\n                            local.type = result.getType();\n                            local.sym = result;\n                        }\n                    }\n                }\n            }\n        }\n\n        property checkInitSelf(funcDecl: FuncDecl): bool {\n            if (!funcDecl.isMethod()) {\n                var freeVars = funcDecl.freeVariables;\n                for (var k = 0, len = freeVars.length; k < len; k++) {\n                    var sym = freeVars[k];\n                    if (sym.isInstanceProperty()) {\n                        return true;\n                    }\n                }\n            }\n            var fns = funcDecl.scopes;\n            var fnsLen = fns.members.length;\n\n            for (var j = 0; j < fnsLen; j++) {\n                var fn: FuncDecl = fns.members[j];\n                if (this.checkInitSelf(fn)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        property checkPromoteFreeVars(funcDecl: FuncDecl, constructorSym: Symbol): void {\n            var freeVars = funcDecl.freeVariables;\n            for (var k = 0, len = freeVars.length; k < len; k++) {\n                var sym = freeVars[k];\n                if ((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {\n                    instanceFilter.reset();\n                    if (this.scope.search(instanceFilter, sym.name, false, false) != null) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Constructor-local variable shadows class property \'\" + sym.name + \"\'. To access the class property, use \'self.\" + sym.name + \"\'\");\n                    }\n\n                    this.checker.errorReporter.simpleError(funcDecl, \"Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable \'\" + sym.name + \"\' to a class property\")\n                }\n            }\n        }\n\n        property allReturnsAreVoid(funcDecl: FuncDecl) {\n            // in the case of a function or method with no declared return type, walk the body to \n            // pre-emptively determine if the function has a return type of void\n            //\n            // REVIEW: Eventually, we\'ll want to perform exit graph analysis to determine\n            // if the function ever \"escapes\" without a return expression\n            // This would require moving some of this logic into the function\'s typecheck-proper,\n            // which would slow things down a fair bit, but would open up more analysis opportunities\n            var allReturnsAreVoid = true;\n\n            if (funcDecl.signature.returnType.type == null) {\n                var context = { goChildren: true, goNextSibling: true };\n\n                var preFindReturnExpressionTypes = function(ast: AST, parent: AST, context: IWalkContext) {\n                    var go = true;\n                    switch (ast.nodeType) {\n                        case NodeType.FuncDecl:\n                            // don\'t recurse into a function decl - we don\'t want to confuse a nested\n                            // return type with the top-level function\'s return type\n                            go = false;\n                            break;\n                        case NodeType.Return:\n                            var returnStmt: ReturnStatement = <ReturnStatement>ast;\n\n                            if (returnStmt.returnExpression != null) {\n                                allReturnsAreVoid = false;\n                                go = false;\n                            }\n\n                        default:\n                            break;\n                    }\n                    context.goChildren = go;\n                    context.goNextSibling = go;\n                    return ast;\n                }\n\n                funcDecl.bod.walk(preFindReturnExpressionTypes, null, funcDecl, context);\n            }\n\n            return allReturnsAreVoid;\n        }\n\n        property es6ConstructorHasSuperCall(funcDecl: FuncDecl) {\n            var foundSuper = false;\n\n            var context = { goChildren: true, goNextSibling: true };\n\n            var preFindSuperCall = function(ast: AST, parent: AST, context: IWalkContext) {\n\n                var go = true;\n\n                switch (ast.nodeType) {\n                    case NodeType.FuncDecl:\n                        go = false;\n                        break;\n                    case NodeType.Call:\n                        var call: CallExpression = ast;\n\n                        if (call.target.nodeType == NodeType.Super) {\n                            go = false;\n                            foundSuper = true;\n                            break;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n\n                return ast;\n            }\n\n            funcDecl.bod.walk(preFindSuperCall, null, funcDecl, context);\n\n            return foundSuper;\n        }\n\n        property typeCheckFunction(funcDecl: FuncDecl): FuncDecl {\n            this.nestingLevel = 0;\n            var fnType = funcDecl.type;\n\n            var fgSym = fnType.symbol;\n            var signature = funcDecl.signature;\n\n            if (signature.typeCheckStatus == TypeCheckStatus.Finished) {\n                return funcDecl;\n            }\n            else if (signature.typeCheckStatus == TypeCheckStatus.Started) {\n                if (funcDecl.bod != null &&\n                       !funcDecl.isSignature() &&\n                       !(funcDecl.isConstructor) &&\n                       this.allReturnsAreVoid(funcDecl)) {\n\n                    signature.returnType.type = this.voidType;\n                    return funcDecl;\n                }\n                else {\n                    if (funcDecl.returnTypeAnnotation == null) {\n                        if (this.checker.styleSettings.implicitAny) {\n                            this.checker.errorReporter.styleError(funcDecl, \"type implicitly set to \'any\'\");\n                        }\n                        signature.returnType.type = this.anyType;\n                    }\n                    return funcDecl;\n                }\n            }\n\n            signature.typeCheckStatus = TypeCheckStatus.Started;\n            var prevScope = this.scope;\n            var prevFnc = this.thisFnc;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevClassNode = this.thisClassNode;\n            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;\n            this.thisFnc = funcDecl;\n            var container = funcDecl.type.symbol;\n            var prevThisType = this.thisType;\n            var prevLocationInfo = this.checker.locationInfo;\n            var funcTable: IHashTable = null;\n            var setNewTargetType = false;\n            var targetParams: ParameterSymbol[] = null;\n            var accessorType: Type = null;\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var prevModDecl = this.checker.currentModDecl;\n\n            if (funcDecl.isConstructor && !funcDecl.isOverload) {\n                if (fnType.instanceType == null) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Malformed function body\");\n                    return funcDecl;\n                }\n                \n                this.scope = fnType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                funcTable = ssb.valueMembers.allMembers;\n            }\n            else if (funcDecl.isSpecialFn() || funcDecl.isOverload) {\n                funcTable = funcDecl.symbols;\n                // if the function is static, we just want to use the \n                // current scope\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.Static)) {\n                    this.scope = fnType.containedScope;\n                }\n            }\n            else {\n                if (funcDecl.bod) {\n                    this.scope = fnType.containedScope;\n                }\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // If it is null, it\'s an ambient declaration with no body, so it doesn\'t strictly matter\n                // if funcTable is not set\n                if (ssb != null && ssb.valueMembers != null) {\n                    funcTable = ssb.valueMembers.allMembers;\n                }\n            }\n\n            // If it\'s an ES6-style class constructor, we need to check for the presence (or absense) of calls\n            // to the \'super\' constructor\n            //\n            // A super constructor call must exist if:\n            //  - the class has a base class\n            //\n            // A super constructor call must be the first statement in the function body if:\n            //  - the constructor has parameter properties or\n            //  - the class body has initialized property decls\n            //\n            // A super constructor call may not exist if:\n            //  - The class has no base type, or inherits directly from \'Object\'\n            if (funcDecl.isConstructor && funcDecl.bod && hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)) {\n\n                var hasBaseType = hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseType);\n                var noSuperCallAllowed = !hasBaseType || hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n                var superCallMustBeFirst = hasFlag((<ES6ClassDecl>funcDecl.classDecl).varFlags, VarFlags.ES6ClassSuperMustBeFirstCallInConstructor);\n\n                if (noSuperCallAllowed && this.es6ConstructorHasSuperCall(funcDecl)) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Calls to \'super\' constructor are not allowed in classes that either inherit directly from \'Object\' or have no base class\");\n                }\n                else if (hasBaseType) {\n                    if (superCallMustBeFirst) {\n                        if (!funcDecl.bod ||\n                            !funcDecl.bod.members.length ||\n                            !(funcDecl.bod.members[0].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[0]).target.nodeType == NodeType.Super)) {\n                            this.checker.errorReporter.simpleError(funcDecl, \"If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor\");\n                        }\n                    }\n                    else if (!this.es6ConstructorHasSuperCall(funcDecl)) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Constructors for derived classes must contain a call to the class\'s \'super\' constructor\");\n                    }\n                }\n            }\n\n            // If we\'ve typechecked this method \"out of order\" (not by walking the class, but through a method call somewhere else),\n            // we need to reset the current class node in question, so that visibility checks on class members don\'t fail\n            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {\n\n                var enclosingClassNode: NamedType = null;\n\n                if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    enclosingClassNode = (<FuncDecl>funcDecl.type.enclosingType.symbol.declAST).classDecl;\n                }\n                else if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.ES6Class) {\n                    enclosingClassNode = funcDecl.type.enclosingType.symbol.declAST;\n                }\n                \n                if (enclosingClassNode) {\n                    this.thisClassNode = enclosingClassNode;\n                }\n            }\n\n            // if this function is contained in a module, we may be in the midst of a recursive typecheck operation\n            // should that be the case, we need to properly set the current module (for visibility tests)\n            if (fnType.enclosingType != null) {;\n                var enclosingSym = fnType.symbol.container;\n\n                // if the enclosing type is a class, grab the parent module\n                if (enclosingSym != null && enclosingSym.isType() && enclosingSym.getType().isClass()) {\n                    enclosingSym = enclosingSym.container;\n                }\n\n                if (enclosingSym != null && enclosingSym.declAST != null && enclosingSym.declAST.nodeType == NodeType.Module) {\n                    this.checker.currentModDecl = <ModuleDecl>enclosingSym.declAST;\n                }\n            }\n\n            if ((this.checker.units != null) && (funcDecl.unitIndex >= 0) &&\n                (funcDecl.unitIndex < this.checker.units.length)) {\n                this.checker.locationInfo = this.checker.units[funcDecl.unitIndex];\n            }\n            else {\n                this.checker.locationInfo = unknownLocationInfo;\n            }\n\n            if (fnType.enclosingType != null) {\n                this.thisType = fnType.enclosingType;\n            }\n            else {\n                this.thisType = prevThisType;\n            }\n\n            var paramLen = signature.parameters.length;\n\n            if ((!funcDecl.isConstructor) && (funcDecl.bod != null) && (!funcDecl.isSignature())) {\n                var tmpParamScope = this.scope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // Attempt to contextually type the function declaration             \n                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {\n\n                    // the funcDecl may be a candidate for target typing                 \n                    // REVIEW: prevScope will only be null in the case of an upstream error\n                    if (prevScope != null && funcDecl.name != null && !funcDecl.name.isMissing()) {\n                        // Go ahead and check for an ambient symbol\n                        var considerSym: Symbol = prevScope.findAmbient(funcDecl.name.text, false, false);\n\n                        if (considerSym != null && considerSym.declAST != null && considerSym.declAST.type != null) {\n                            // REVIEW: Ambients beget signatures, and signatures don\'t need to be typechecked\n                            //typeCheck(considerSym.declAST);\n                            this.checker.setTargetType(considerSym.declAST.type);\n                            setNewTargetType = true;\n                        }\n                    }\n\n                    if (this.checker.hasTargetType()) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var candidateType = candidateTypeContext.targetType;\n\n                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {\n\n                            // Safe to do this, since the indices and fields are guaranteed to be\n                            // non-null and valid by the above call to canContextuallyTypeFunction\n                            var candidateSigs = candidateType.construct != null ? candidateType.construct : candidateType.call;\n                            candidateTypeContext.targetSig = candidateSigs.signatures[0];\n                            var candidateParams = candidateTypeContext.targetSig.parameters;\n\n                            // the target type has been accepted\n                            targetParams = candidateParams;\n\n                            // Set \"this\" if applicable\n                            if (candidateTypeContext.targetSig.declAST != null) {\n                                if (candidateTypeContext.targetSig.declAST.isConstructor) {\n                                    //candidateTypeContext.targetThis=candidateType.instanceType;\n                                    this.thisType = candidateType.instanceType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n                                }\n                                else if (candidateTypeContext.targetSig.declAST.isMethod()) {\n                                    //candidateTypeContext.targetThis=candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    this.thisType = candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n                                }\n                            }\n                            fgSym.type = candidateTypeContext.targetType;\n                        }\n                        else if (candidateType != null && funcDecl.isAccessor()) {\n                            accessorType = candidateType;\n                            candidateTypeContext.targetAccessorType = accessorType;\n                        }\n                        else {\n                            this.checker.killTargetType();\n                        }\n                    }\n                }\n\n                // typecheck parameters\n                // Add parameter symbols to current scope for typechecking (in case default params reference each other)\n                // Order matters here - default parameters can reference previously defined parameters\n                var paramTable = ssb.valueMembers;\n                this.scope = new SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);\n\n                for (var p = 0; p < paramLen; p++) {\n                    var param = signature.parameters[p];\n                    var symbol = <ParameterSymbol>param;\n                    var ast = <ArgDecl>symbol.declAST;\n\n                    if (this.checker.hasTargetType() && (targetParams != null || (isSetter && accessorType != null))) {\n                        ast.type = (isSetter && accessorType != null) ? accessorType : targetParams[p].getType();\n                        ast.sym.setType(ast.type);\n                        (<InferenceSymbol>ast.sym).typeCheckStatus = TypeCheckStatus.Finished;\n                    }\n                    else {\n                        this.typeCheck(ast);\n                    }\n                    symbol.container = container;\n                    paramTable.publicMembers.add(symbol.name, symbol);\n                }\n                this.scope = tmpParamScope;\n            }\n            else {\n                this.typeCheck(funcDecl.args)\n\n                // Because some terms were not yet type-checkable during binding, ensure that\n                // param symbols are updated with the proper argument types\n                for (var p = 0; p < paramLen; p++) {\n                    signature.parameters[p].parameter.typeLink.type = funcDecl.args.members[p].type;\n                }\n            }\n\n            // typecheck body\n            if ((funcDecl.bod != null) && (!funcDecl.isSignature())) {\n                if (!(funcDecl.isConstructor)) {\n                    this.addFormals(container, signature, funcTable);\n                }\n                else {\n                    if (!hasFlag(funcDecl.fncFlags, FncFlags.ES6ClassMethod)) {\n                        this.addConstructorLocalArgs(funcDecl.type.symbol, funcDecl.args, funcTable);\n                    }\n\n                    if ((this.thisClassNode != null) && (this.thisClassNode.extendsList != null)) {\n                        var tmpScope = this.scope;\n                        // TODO: arrange to see only the parameters\n                        var funcMembers = new ScopedMembers(funcTable);\n                        this.scope = new FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol,\n                                                             function (sym) {\n                                                                 return sym.kind() == SymbolKind.Parameter;\n                                                             });\n                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);\n                        this.scope = tmpScope;\n                    }\n                }\n\n                // Because this function may have been typechecked in a different visiblity context as its caller (e.g., this\n                // function is being typechecked as a result of a call, before the declaration could be typechecked), we need\n                // to set the enclosing module\n                var prevMod = this.checker.currentModDecl;\n                if (funcDecl.type != null &&\n                    funcDecl.type.symbol != null &&\n                    !funcDecl.isMethod() &&\n                    funcDecl.type.symbol.declModule != null) {\n                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;\n                }\n                this.typeCheck(funcDecl.bod);\n                this.checker.currentModDecl = prevMod;\n\n                if (this.checker.checkControlFlow) {\n                    var cfg = funcDecl.buildControlFlow();\n                    if (this.checker.printControlFlowGraph) {\n                        cfg.print(this.checker.errorReporter.outfile);\n                    }\n                    cfg.reportUnreachable(this.checker.errorReporter);\n                    if (this.checker.checkControlFlowUseDef) {\n                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);\n                    }\n                }\n                if (funcDecl.isConstructor) {\n                    // lift free variables and add _self init to funcs enclosing instance var refs\n                    var fns: ASTList = funcDecl.scopes;\n                    var fnsLen = fns.members.length;\n                    var freeVars: Symbol[];\n                    var sym: Symbol;\n                    var j = 0;\n                    for (; j < fnsLen; j++) {\n                        var fn: FuncDecl = fns.members[j];\n                        if (!fn.isSignature()) {\n                            if (hasFlag(fn.fncFlags, FncFlags.Method) && (!hasFlag(fn.fncFlags, FncFlags.Static))) {\n                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);\n                            }\n                        }\n                    }\n\n                    if (this.checker.addMembersToClassScope) {\n                        var initSelf = false;\n                        for (j = 0; j < fnsLen; j++) {\n                            var fn: FuncDecl = fns.members[j];\n                            if (!fn.isSignature()) {\n                                if (hasFlag(fn.fncFlags, FncFlags.Method)) {\n                                    if (this.checkInitSelf(fn)) {\n                                        fn.setHasSelfReference();\n                                    }\n                                }\n                                else {\n                                    if (this.checkInitSelf(fn)) {\n                                        initSelf = true;\n                                    }\n                                }\n                            }\n                        }\n                        if (initSelf) {\n                            funcDecl.setHasSelfReference();\n                        }\n                    }\n                }\n            }\n\n            this.scope = prevScope;\n            this.thisFnc = prevFnc;\n            this.thisClassNode = prevClassNode;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.thisType = prevThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.checker.currentModDecl = prevModDecl;\n\n            signature.typeCheckStatus = TypeCheckStatus.Finished;\n\n            if (funcDecl.returnTypeAnnotation) {\n                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);\n                \n                if (signature.returnType.type == null) {\n                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);\n                }\n            }\n\n            // If no return type annotation has been applied to the function declaration\n            // unify the return types from the given return statements\n\n            if (funcDecl.returnStatements.length > 0) {\n                var collection: ITypeCollection = {\n                    getLength: () => { return funcDecl.returnStatements.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { funcDecl.returnStatements[index].type = type; },\n                    getTypeAtIndex: (index: number) => { return funcDecl.returnStatements[index].type }\n                }\n\n                var bestCommonReturnType = funcDecl.returnStatements[0].type;\n                bestCommonReturnType = findBestCommonType(bestCommonReturnType, null, collection, this.checker);\n\n                if (bestCommonReturnType) {\n                    signature.returnType.type = bestCommonReturnType;\n                }\n                else {\n                    for (var i = 0; i < funcDecl.returnStatements.length; i++) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnStatements[i], \"Incompatible return type\");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n            }\n\n\n            if (signature.returnType.type == null) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.HasReturnValue)) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(funcDecl, \"type implicitly set to \'any\'\");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n                else {\n                    signature.returnType.type = this.voidType;\n                }\n            }\n            else if (signature.returnType.type == this.nullType) {\n                signature.returnType.type = this.anyType;\n            }\n            else if (signature.returnType.type != this.voidType && funcDecl.returnTypeAnnotation != null) {\n                // the signature declared a non-void type, but there\'s no return statement\n                if (!funcDecl.isSignature() &&\n                    !funcDecl.isConstructor &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnValue) &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        // relax the restriction if the method only contains a single \"throw\" statement\n                    var onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == NodeType.Throw)\n\n                    if (!onlyHasThrow) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Function declared a non-void return type, but has no return statement\");\n                    }\n                }\n            }\n\n            if (setNewTargetType) {\n                this.checker.unsetTargetType();\n            }\n\n            // if the function declaration is a getter or a setter, set the type of the associated getter/setter symbol\n            if (funcDecl.accessorSymbol != null) {\n                var accessorType = funcDecl.accessorSymbol.getType();\n                if (accessorType != null) {\n                    if ((hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && accessorType != signature.returnType.type) ||\n                        (funcDecl.args.members.length > 0 && accessorType != funcDecl.args.members[0].type)) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Getter and Setter types do not agree\");\n                    }\n                }\n                else {\n                    if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                        funcDecl.accessorSymbol.setType(signature.returnType.type);\n                    }\n                    else {\n                        if (funcDecl.args.members.length != 1) {\n                            this.checker.errorReporter.simpleError(funcDecl, \"Setters may have one and only one argument\");\n                        }\n                        else {\n                            funcDecl.accessorSymbol.setType(funcDecl.args.members[0].type);\n                        }\n                    }\n                }\n            }\n\n            this.typeCheckOverloadSignatures(fnType,funcDecl);            \n            return funcDecl;\n        }\n\n        property typeCheckBases(type: Type) {\n            var seenInterface = false;\n            var bases = type.extendsList;\n            if (bases != null) {\n                var len = bases.length;\n                this.inNewTargetTypeCheck = true;\n\n                if (len > 0) { \n                    type.typeFlags |= TypeFlags.HasBaseType;\n\n                    if (bases[0] == this.anyType) {\n\n                        for (var e = 0; e < len; e++) {\n                            type.extendsTypeLinks[e].type = null;\n                        }\n\n                        var binder = new Binder(this.checker);\n                        binder.resolveBases(this.scope, type);\n                        bases = type.extendsList;\n                        type.memberScope = this.checker.scopeOf(type);\n                    }\n                }\n\n                for (var i = 0; i < len; i++) {\n                    var base = bases[i];\n\n                    if (base.symbol && base.symbol.name == \"Object\") {\n                        type.typeFlags |= TypeFlags.HasBaseTypeOfObject;\n                    }\n\n                    if (base.isClassInstance()) {\n                        if (type.isClassInstance() &&\n                            (base.symbol.typeCheckStatus != TypeCheckStatus.Finished) &&\n                            (base.symbol.declAST != null)) {\n                            this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Base type \'\" + base.symbol.name + \"\' is referenced before its declaration\");\n                            this.typeCheckClass(<TypeDecl>base.symbol.declAST);\n                        }\n                        if (this.currentScript != null) {\n                            this.currentScript.requiresInherits = true;\n                        }\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Interface base type must be interface\");\n                        }\n                        else {\n                            if (seenInterface) {\n                                this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Class may not follow interface as base type\");\n                            }\n                            // TODO: mixins\n                        }\n                    }\n                    else if (base.members != null) {\n                        // interface\n                        if (!seenInterface) {\n                            seenInterface = true;\n                        }\n                    }\n                    else {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleErrorFromSym(base.symbol,\n                                                                     \"Interface base type must be interface\");\n                        }\n                        else {\n                            this.checker.errorReporter.simpleErrorFromSym(base.symbol,\n                                                                     \"Base type must be interface or class\");\n                        }\n                        break;\n                    }\n                }\n                this.inNewTargetTypeCheck = false;\n            }\n        }\n\n        property scopeImplementsInterface(scope: SymbolScope, interfaceType: Type, useImpl: bool) {\n            if (scope == null) {\n                return false;\n            }\n            if (interfaceType.members == null) {\n                return true;\n            }\n            return interfaceType.members.publicMembers.every(\n                function (key, s, context) {\n                    var sym = <Symbol>s;\n                    var scopeSymbol: Symbol = null;\n                    if (useImpl) {\n                        scopeSymbol = context.scope.findImplementation(sym.name);\n                    }\n                    else {\n                        scopeSymbol = context.scope.find(sym.name);\n                    }\n                    return (scopeSymbol != null) && !(scopeSymbol.flags & SymbolFlags.Private) &&\n                        context.checker.symbolSubtype(scopeSymbol, sym);\n                }, { scope: scope, checker: this.checker });\n        }\n\n        property checkMembersImplementInterface(instanceType: Type, _interface: Type,\n            classDecl: TypeDecl, requireImpl: bool,\n            requiringType: Type) {\n            var classScope = instanceType.memberScope;\n            if (!this.scopeImplementsInterface(classScope, _interface, requireImpl)) {\n                if (requiringType == null) {\n                    this.checker.errorReporter.interfaceDeclNotImpl(_interface, instanceType);\n                }\n                else {\n                    this.checker.errorReporter.simpleError(classDecl, \"mixin \" + requiringType.symbol.name + \" requires implementation of \" + _interface.symbol.name);\n                }\n            }\n        }\n\n        property checkMembersImplementInterfaces(_class: Type, classDecl: NamedType) {\n            var instanceType = _class.instanceType;\n            if (instanceType.implementsList != null) {\n                var len = instanceType.implementsList.length;\n                this.inNewTargetTypeCheck = true;\n                for (var i = 0; i < len; i++) {\n                    var base = instanceType.implementsList[i];\n                    var requireImpl = (!hasFlag((<any>classDecl).varFlags, VarFlags.Ambient));\n                    this.checkMembersImplementInterface(instanceType, base, classDecl, requireImpl, null);\n                }\n                this.inNewTargetTypeCheck = false;\n            }\n        }\n\n        property typeCheckBaseCalls(bases: ASTList) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.typeCheckNew(baseExpr);\n                }\n                // TODO: check that class constructor does not have parameters\n            }\n        }\n\n        property checkUniqueAndReq(names: IHashTable, type: Type, classDecl: TypeDecl, checkUnique: bool): void {\n            if (type != null) {\n                if (type.members != null) {\n                    type.members.publicMembers.map((key, s, c) => {\n                        var sym = <Symbol>s;\n                        var dup = names.lookup(sym.name);\n                        if (dup != null) {\n                            if (checkUnique) {\n                                this.checker.errorReporter.simpleError(classDecl,\n                                                                  \"duplicate member name in bases for \" + classDecl.name.text + \": \" + type.symbol.name + \" and \" + dup.container.name + \" both contain member with name \" + sym.name);\n                            }\n                        }\n                        else {\n                            names.add(sym.name, sym);\n                        }\n                    }, null);\n                }\n                if (type.extendsList != null) {\n                    var len = type.extendsList.length;\n                    for (var i = 0; i < len; i++) {\n                        this.checkUniqueAndReq(names, type.extendsList[i], classDecl, checkUnique);\n                    }\n                }\n            }\n        }\n\n        property checkLegalInheritance(_class: Type, classDecl: AST): void {\n            var instanceType = _class.instanceType;\n            if (instanceType.extendsList == null) {\n                return;\n            }\n\n            var len = instanceType.extendsList.length;\n            if (len > 0) {\n                // check unique names and requirements from bases\n                var names = new StringHashTable();\n                for (var i = 0; i < len; i++) {\n                    this.checkUniqueAndReq(names, instanceType.extendsList[i], classDecl, i > 0);\n                }\n                // check that any overrides are sub-types\n                if (instanceType.members != null) {\n                    instanceType.members.publicMembers.map((key, s, c) => {\n                        var sym = <Symbol>s;\n                        for (var j = 0; j < len; j++) {\n                            var base = instanceType.extendsList[j];\n                            if (base.memberScope == null) {\n                                this.checker.errorReporter.simpleError(classDecl, \"Base class \'\" + base.symbol.name + \"\' lacks an implementation.\")\n                            }\n                            else {\n                                var bSym = base.memberScope.find(sym.name, false, false);\n                                if (bSym != null) {\n                                    var aType = sym.getType();\n                                    var bType = bSym.getType();\n                                    if (!(aType.subtype(bType, this.checker))) {\n                                        this.checker.errorReporter.simpleError(classDecl,\n                                                                          \"type of overridden member \" + sym.name + \" is not subtype of original member defined by type \" + bSym.container.name);\n                                    }\n                                    else if ((sym.kind() == SymbolKind.Type) &&\n                                             (bSym.kind() == SymbolKind.Field)) {\n                                        this.checker.errorReporter.simpleError(classDecl,\n                                                                          \"can not override field (\" + sym.name + \") with method\");\n                                    }\n                                }\n                            }\n                        }\n                    }, null);\n                }\n            }\n        }\n\n        property typeCheckClass(classDecl: TypeDecl): TypeDecl {\n            var typeSymbol = <TypeSymbol>classDecl.type.symbol;\n            if (typeSymbol.typeCheckStatus == TypeCheckStatus.Finished) {\n                return classDecl;\n            }\n            else if (typeSymbol.typeCheckStatus == TypeCheckStatus.Started) {\n                // REVIEW: report this recursion\n                //checker.errorReporter.recursionRequiresTypeAnnotation(classDecl);\n                return classDecl;\n            }\n            else {\n                typeSymbol.typeCheckStatus = TypeCheckStatus.Started;\n            }\n\n            var prevScope = this.scope;\n            var svClassNode = this.thisClassNode;\n            this.thisClassNode = classDecl;\n            var classType = classDecl.type;\n            this.typeCheckBases(classType.instanceType);\n\n            var prevThisType = this.thisType;\n            this.thisType = classType.instanceType;\n            this.scope = classType.instanceType.containedScope;\n            // constructor\n            this.typeCheck(classDecl.members);\n            typeSymbol.typeCheckStatus = TypeCheckStatus.Finished;\n            this.checkLegalInheritance(classType, classDecl);\n            this.checkMembersImplementInterfaces(classType, classDecl);\n\n            this.typeCheckOverloadSignatures(classType,classDecl);\n            this.typeCheckOverloadSignatures(classType.instanceType,classDecl);\n            this.thisType = prevThisType;\n            this.thisClassNode = svClassNode;\n            this.scope = prevScope;\n            return classDecl;\n        }\n\n        property typeCheckES6Class(classDecl: ES6ClassDecl): ES6ClassDecl {\n            var typeSymbol = <TypeSymbol>classDecl.type.symbol;\n\n            if (typeSymbol.typeCheckStatus == TypeCheckStatus.Finished) {\n                return classDecl;\n            }\n            else if (typeSymbol.typeCheckStatus == TypeCheckStatus.Started) {\n                // REVIEW: report this recursion\n                //checker.errorReporter.recursionRequiresTypeAnnotation(classDecl);\n                return classDecl;\n            }\n            else {\n                typeSymbol.typeCheckStatus = TypeCheckStatus.Started;\n            }\n\n            var prevScope = this.scope;\n            var svClassNode = this.thisClassNode;\n            this.thisClassNode = classDecl;\n            var classType = classDecl.type;\n            this.typeCheckBases(classType.instanceType);\n\n            var prevThisType = this.thisType;\n            this.thisType = classType.instanceType;\n            this.scope = classType.instanceType.containedScope;\n\n            // Add the constructor locals, if necessary\n            if (classDecl.constructorDecl) {\n                var fnType = classDecl.constructorDecl.type;\n                this.scope = fnType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                var funcTable = ssb.valueMembers.allMembers;\n\n                this.addConstructorLocalArgs(classDecl.constructorDecl.type.symbol, classDecl.constructorDecl.args, funcTable);\n            }\n\n            this.typeCheck(classDecl.members);\n            typeSymbol.typeCheckStatus = TypeCheckStatus.Finished;\n            this.checkLegalInheritance(classType, classDecl);\n            this.checkMembersImplementInterfaces(classType, classDecl);\n\n            this.typeCheckOverloadSignatures(classType,classDecl);\n            this.typeCheckOverloadSignatures(classType.instanceType,classDecl);\n\n            // if the class has no declared constructor, either create a default signature or adapt \n            // it\'s base class\'s signature group\n            if (!classDecl.constructorDecl) {\n\n                // first, check the previous scope to see if there are any function declarations that share this class\n                // constructor\'s name\n                var funcSym = prevScope.find(classDecl.name.text, true, false);\n\n                if (funcSym && funcSym.declAST && funcSym.declAST.type && funcSym.declAST.type.call) {\n                    this.checker.errorReporter.duplicateIdentifier(funcSym.declAST, funcSym.name);\n                }\n\n                if (classDecl.baseClass && classDecl.baseClass.members.length && classDecl.baseClass.members[0].type.symbol.type.isClass()) {\n                    this.checker.cloneParentConstructGroupForChildType(classDecl.type, classDecl.baseClass.members[0].type.symbol.type);\n                }\n                else {\n                    this.checker.createNewConstructGroupForType(classDecl.type);               \n                }\n            }\n\n            this.thisType = prevThisType;\n            this.thisClassNode = svClassNode;\n            this.scope = prevScope;\n            return classDecl;\n        }\n\n        property typeCheckOverloadSignatures(type: Type, ast: AST) {\n            if (type.call != null) {\n                type.call.typeCheck(this.checker, ast, type.construct != null);\n            }\n            if (type.construct != null) {\n                type.construct.typeCheck(this.checker, ast, false);\n            }\n            if (type.index != null) {\n                type.index.typeCheck(this.checker, ast, false);\n            }\n            if (type.members != null) {\n                type.members.publicMembers.map(function(key, s, c) {\n                    var ch = <TypeChecker>c;\n                    var sym = <Symbol>s;\n                    if (sym.kind() == SymbolKind.Type) {\n                        var memberType = (<TypeSymbol>sym).type;\n                        if (memberType.call != null) {\n                            memberType.call.typeCheck(ch, ast, false);\n                        }\n                    }\n                }, this.checker);\n            }\n        }\n\n        property typeCheckInterface(interfaceDecl: TypeDecl): TypeDecl {\n            this.typeCheckOverloadSignatures(interfaceDecl.type, interfaceDecl);\n            this.typeCheckBases(interfaceDecl.type);\n            this.typeCheck(interfaceDecl.members);\n            return interfaceDecl;\n        }\n\n        property typeCheckImportDecl(importDecl: ImportDecl) {\n            var mod: ModuleType = <ModuleType>importDecl.alias.type;\n            var sym: TypeSymbol = null;\n            var prevInImportTC = this.inImportTypeCheck;\n            this.inImportTypeCheck = true;\n\n            this.typeCheck(importDecl.alias);\n            mod = <ModuleType>importDecl.alias.type;\n\n            if (mod == null) {\n                this.checker.errorReporter.simpleError(importDecl.alias, \"Could not resolve module alias \'\" + importDecl.id.text + \"\'\");\n                mod = this.checker.anyType;\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n            }\n\n            importDecl.id.type = mod;\n            sym = mod.symbol;\n\n            if (!mod.isModuleType()) {\n                this.checker.errorReporter.simpleError(importDecl.alias, \"A module cannot be aliased to a non-module type\");\n            }\n            else {\n                sym.type = mod;\n                if (this.checker.currentModDecl != null && this.checker.currentModDecl.mod != null) {\n                    this.checker.currentModDecl.mod.importedModules.push(importDecl);\n                }\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n\n                if (mod.symbol && mod.symbol.declAST) {\n                    (<ModuleDecl>mod.symbol.declAST).modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n                }\n                //importDecl.id.sym = sym;\n                // REVIEW: Uncomment when you can toggle module codegen targets from the language service\n                //else if (typeFlow.checker.currentModDecl == null && \n                //            hasFlag((<ModuleDecl>sym.declAST).modFlags,ModuleFlags.IsDynamic) &&\n                //            moduleGenTarget == ModuleGenTarget.Asynchronous) \n                //{\n                //    typeFlow.checker.errorReporter.simpleError(alias, \"In AMD codegen mode, dynamic modules may not be referenced from global scope.  (Wrap the file in a module declaration.)\");\n                //}\n            }\n            this.inImportTypeCheck = prevInImportTC;\n            return importDecl;\n        }\n\n        property typeCheckModule(moduleDecl: ModuleDecl): ModuleDecl {\n            if (this.currentScript != null) {\n                this.currentScript.requiresGlobal = true;\n            }\n            var mod = moduleDecl.mod;\n            var sym: TypeSymbol = null;\n\n            var prevScope = this.scope;\n            var prevThisType = this.thisType;\n            var prevCurrentModDecl = this.checker.currentModDecl;\n            this.checker.currentModDecl = moduleDecl;\n\n\n            if (!this.inImportTypeCheck && (prevCurrentModDecl != null) &&\n                hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic)) {\n                this.checker.errorReporter.simpleError(moduleDecl, \"Dynamic modules may not be nested within other modules\");\n            }\n\n            this.thisType = null;\n            this.scope = mod.containedScope;\n            this.typeCheck(moduleDecl.members);\n            sym = mod.symbol;\n\n            this.checker.currentModDecl = prevCurrentModDecl;\n            this.thisType = prevThisType;\n            this.scope = prevScope;\n\n            moduleDecl.type = mod;\n\n            if (sym != null) {\n                sym.typeCheckStatus = TypeCheckStatus.Finished;\n            }\n            return moduleDecl;\n        }\n\n        property typeCheckFor(forStmt: ForStatement): ForStatement {\n            forStmt.init = this.typeCheck(forStmt.init);\n            this.nestingLevel++;\n            forStmt.cond = this.typeCheck(forStmt.cond);\n            this.typeCheckCondExpr(forStmt.cond);\n            forStmt.incr = this.typeCheck(forStmt.incr);\n            this.nestingLevel--;\n            forStmt.body = this.typeCheck(forStmt.body);\n            this.typeCheckCompoundStmtBlock(forStmt.body,\"for statement\");\n            forStmt.type = this.voidType;\n            return forStmt;\n        }\n\n        property typeCheckWith(withStmt: WithStatement): WithStatement {\n            if (this.checker.errorsOnWith) {\n                this.checker.errorReporter.simpleError(withStmt.expr, \"All symbols within a \'with\' block will be typed as \'any\'\");\n            }\n            withStmt.expr = this.typeCheck(withStmt.expr);\n            this.checker.inWith = true;\n            withStmt.body = this.typeCheck(withStmt.body);\n            this.typeCheckCompoundStmtBlock(withStmt.body,\"with statement\");\n            this.checker.inWith = false;\n            return withStmt;\n        }\n\n        property typeCheckForIn(forInStmt: ForInStatement): ForInStatement {\n            forInStmt.obj = this.typeCheck(forInStmt.obj);\n            forInStmt.lval = this.typeCheck(forInStmt.lval);\n            forInStmt.body = this.typeCheck(forInStmt.body);\n            this.typeCheckCompoundStmtBlock(forInStmt.body,\"for in statement\");\n            return forInStmt;\n        }\n\n        property typeCheckWhile(whileStmt: WhileStatement): WhileStatement {\n            whileStmt.cond = this.typeCheck(whileStmt.cond);\n            this.typeCheckCondExpr(whileStmt.cond);\n            whileStmt.body = this.typeCheck(whileStmt.body);\n            this.typeCheckCompoundStmtBlock(whileStmt.body,\"while statement\");\n            whileStmt.type = this.voidType;\n            return whileStmt;\n        }\n\n        property typeCheckDoWhile(doWhileStmt: DoWhileStatement): DoWhileStatement {\n            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);\n            this.typeCheckCondExpr(doWhileStmt.cond);\n            doWhileStmt.body = this.typeCheck(doWhileStmt.body);\n            this.typeCheckCompoundStmtBlock(doWhileStmt.body,\"do while statement\");\n            doWhileStmt.type = this.voidType;\n            return doWhileStmt;\n        }\n\n        property typeCheckCondExpr(cond: AST) {\n            if (this.checker.styleSettings.assignmentInCond) {\n                if ((cond !== null) &&\n                    (cond.nodeType >= NodeType.Asg) &&\n                    (cond.nodeType <= NodeType.LastAsg)) {\n                    this.checker.errorReporter.simpleError(cond,\"top-level assignment statement in conditional expression\");\n                }\n            }\n        }\n        \n        property typeCheckCompoundStmtBlock(stmts: AST, stmtType: string) {\n            if (this.checker.styleSettings.blockInCompoundStmt&& (stmts != null)) {\n                if (stmts.nodeType != NodeType.Block) {\n                    this.checker.errorReporter.styleError(stmts, stmtType+\" requires a block\");\n                }\n            }\n        }\n        property typeCheckIf(ifStmt: IfStatement): IfStatement {\n            ifStmt.cond = this.typeCheck(ifStmt.cond);\n            this.typeCheckCondExpr(ifStmt.cond);\n            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);\n            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);\n            this.typeCheckCompoundStmtBlock(ifStmt.thenBod,\"if statement\");\n            this.typeCheckCompoundStmtBlock(ifStmt.elseBod,\"if statement\");\n            ifStmt.type = this.voidType;\n            return ifStmt;\n        }\n\n        property typeFromAccessorFuncDecl(funcDecl: FuncDecl) {\n            if (!funcDecl.isAccessor()) {\n                return null;\n            }\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                return funcDecl.type.call.signatures[0].returnType.type;\n            }\n            else {\n                return funcDecl.type.call.signatures[0].parameters[0].getType();\n            }\n        }\n\n        property typeCheckObjectLit(objectLit: UnaryExpression): void {\n            var resultType = new Type();\n            resultType.symbol = new TypeSymbol(this.checker.anon, objectLit.minChar,\n                                             this.checker.locationInfo.unitIndex,\n                                             resultType);\n            // TODO: customize size by member list size\n            resultType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            var memberDecls = <ASTList>objectLit.operand;\n            var prevThisType = this.thisType;\n            var acceptTargetType = false;\n            var targetType: Type = null;\n\n            if (this.checker.hasTargetType()) {\n                targetType = this.checker.getTargetTypeContext().targetType;\n\n                if (targetType != null && targetType.symbol != null && targetType.symbol.typeCheckStatus != TypeCheckStatus.Finished) {\n                    if (targetType.symbol.declAST != null) {\n                        this.typeCheck(targetType.symbol.declAST);\n                    }\n                }\n                acceptTargetType = this.checker.canContextuallyTypeObjectLiteral(targetType, objectLit);\n                //thisType = targetType; // REVIEW: should \'this\' in an object expression take the target type?\n            }\n\n            if (memberDecls != null) {\n                for (var i = 0, len = memberDecls.members.length; i < len; i++) {\n\n                    var binex: BinaryExpression = memberDecls.members[i];\n\n                    var id = binex.operand1;\n                    var text: string;\n                    var targetMember: Symbol = null;\n                    var fieldSymbol: FieldSymbol = null;\n\n                    if (id.nodeType == NodeType.Name) {\n                        text = (<Identifier>id).text;\n                    }\n                    else if (id.nodeType == NodeType.QString) {\n                        // TODO: set text to unescaped string\n                        var idText = (<StringLiteral>id).text;\n                        text = idText.substring(1, idText.length - 1);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(objectLit,\n                                                          \"malformed object literal\");\n                        resultType = this.anyType;\n                        break;\n                    }\n\n                    if (acceptTargetType) {\n                        targetMember = targetType.memberScope.find(text, false, false);\n                    }\n\n                    // before typechecking an accessor function member, we need to initialize its accessor symbol\n                    if (binex.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>binex.operand2).isAccessor()) {\n\n                        var funcDecl = <FuncDecl>binex.operand2;\n                        var accessorSym: FieldSymbol = resultType.members.publicMembers.lookup(text);\n\n                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, this.scope, null);\n                        funcDecl.accessorSymbol = accessorSym;\n                        fieldSymbol = accessorSym;\n                        if (id.nodeType == NodeType.Name) {\n                            (<Identifier>id).sym = accessorSym;\n                        }\n                    }\n\n                    this.checker.typeCheckWithTargetType(acceptTargetType ? targetMember.getType() : null, acceptTargetType, binex.operand2);\n\n                    if (acceptTargetType) {\n                        // Note that we accept \'any\' in place of a valid subtype                     \n                        if ((binex.operand2.type == this.anyType || binex.operand2.type.subtype(targetMember.getType(), this.checker)) ||\n                            (binex.operand2.nodeType == NodeType.FuncDecl &&\n                            (<FuncDecl>binex.operand2).isAccessor() &&\n                                this.typeFromAccessorFuncDecl(<FuncDecl>binex.operand2) == targetMember.getType())) {\n                                    // set the field type to the proper contextual type\n                                    // this is especially important in the \'any\' case, so that\n                                    // fields typed to \'any\' aren\'t accepted for contextual typing,\n                                    // but never properly set to the target type\n                            binex.operand1.type = targetMember.getType();\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(binex.operand1, \"type mismatch - could not apply contextual type\");\n                            acceptTargetType = false;\n                        }\n                    }\n                    else {\n                        // here we sub in \'any\' for \'undefined\' to account for field initialization to\n                        // \'undefined\'  \n                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type;\n                    }\n\n                    // the field symbol hasn\'t been set by a getter or setter\n                    if (fieldSymbol == null) {\n                        var memberType = binex.operand2.type;\n                        var field = new ValueLocation();\n                        fieldSymbol =\n                            new FieldSymbol(text, id.minChar,\n                                            this.checker.locationInfo.unitIndex,\n                                            true, field);\n                        fieldSymbol.flags |= SymbolFlags.Property;\n                        field.symbol = fieldSymbol;\n                        fieldSymbol.typeCheckStatus = TypeCheckStatus.Finished;\n                        field.typeLink = new TypeLink();\n                        field.typeLink.type = memberType;\n                        resultType.members.publicMembers.add(text, fieldSymbol);\n                    }\n                    fieldSymbol.isObjectLitField = true;\n                }\n            }\n\n            resultType.containedScope = new SymbolTableScope(resultType.members, null, null, null, null);\n            resultType.containedScope.container = resultType.symbol;\n            resultType.memberScope = acceptTargetType ? targetType.containedScope : resultType.containedScope;\n            this.thisType = prevThisType;\n            objectLit.type = acceptTargetType ? targetType : resultType;\n            objectLit.acceptTargetType = acceptTargetType;\n        }\n\n        property typeCheckArrayLit(arrayLit: UnaryExpression): void {\n            var elements: ASTList = arrayLit.operand;\n            var elementType = this.anyType;\n            var targetElementType: Type = null;\n\n            // if the target type is an array type, extract the element type\n            if (this.checker.hasTargetType()) {\n                var targetType = this.checker.getTargetTypeContext().targetType;\n                if (targetType.elementType != null) {\n                    targetElementType = targetType.elementType;\n                }\n            }\n\n            if (elements != null) {\n\n                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;\n\n                this.inArrayElementTypeCheck = true;\n                this.checker.typeCheckWithTargetType(targetElementType, targetElementType != null, elements);\n                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;\n\n                elementType = elements.members[0].type;\n\n                var collection: ITypeCollection = {\n                    getLength: () => { return elements.members.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { elements.members[index].type = type; },\n                    getTypeAtIndex: (index: number) => { return elements.members[index].type; }\n                }\n\n                elementType = findBestCommonType(elementType, targetElementType, collection, this.checker);\n\n                // if the array type is the undefined type, we should widen it to any\n                // if it\'s of the null type, only widen it if it\'s not in a nested array element, so as not to \n                // short-circuit any checks for the best common type\n                if (elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {\n                    elementType = this.anyType;\n                }\n            }\n            if (!elementType) {\n                this.checker.errorReporter.simpleError(arrayLit, \"incompatible types in array literal expression\");\n                elementType = this.anyType;\n            }\n            else if (targetElementType) {\n                // for the case of zero-length \'any\' arrays, we still want to set the contextual type, if\n                // need be\n                elementType = targetElementType;\n            }\n\n            arrayLit.type = this.checker.makeArrayType(elementType);\n\n        }\n\n        property checkForVoidConstructor(type: Type, ast: AST) {\n            if (type != null &&\n                type.construct != null &&\n                type.construct.signatures.length > 0) {\n\n                for (var i = 0; i < type.construct.signatures.length; i++) {\n                    if (type.construct.signatures[i].returnType.type == this.checker.voidType) {\n                        this.checker.errorReporter.simpleError(ast, \"Constructors may not have a return type of \'void\'\");\n                        break;\n                    }\n                }\n            }\n        }\n\n        // REVIEW: the code below could set the signature type of the function to the current return\n        // type, which would have a benefit of reducing the risk of a recursive typecheck error, but is\n        // is technically wrong - mergeOrdered will only work properly if the best common supertype\n        // comes before any sibling types.  This would mean that if a function, \"color()\", returned\n        // three types (in order) - \"Red\", \"Blue\", and \"IColor\", an \"Incompatible return type\" error \n        // would be triggered.  However, if \"color()\" returned (in order) \"Red\", \"IColor\" and \"Blue\"\n        // no error would be triggered, and the return type of the function would be \"IColor\"\n        property typeCheckReturn(returnStmt: ReturnStatement): ReturnStatement {\n\n            if (this.thisFnc != null) {\n                var targetType: Type = null;\n\n                // determine the target type\n                if (this.checker.hasTargetType()) {\n                    var tcContext = this.checker.getTargetTypeContext();\n                    var accessorType = tcContext.targetAccessorType;\n\n                    if (accessorType != null) {\n                        targetType = accessorType;\n                    }\n                    else {\n                        var targetSig = this.checker.getTargetTypeContext().targetSig;\n                        if (targetSig != null && targetSig.returnType.type != this.voidType) {\n                            targetType = targetSig.returnType.type;\n                        }\n                    }\n                }\n\n                if (returnStmt.returnExpression != null) {\n                    this.thisFnc.fncFlags |= FncFlags.HasReturnValue;\n\n                    if (targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {\n                        targetType = this.thisFnc.returnTypeAnnotation.type;\n                    }\n\n                    this.checker.typeCheckWithTargetType(targetType, targetType != null, returnStmt.returnExpression);\n\n                    var expectedReturnType: Type =\n                        (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ?\n                            this.thisFnc.returnTypeAnnotation.type :\n                            targetType;\n                    if (expectedReturnType) {\n                        if (expectedReturnType == this.voidType) {\n                            this.checker.errorReporter.simpleError(returnStmt,\n                                                              \"Return with value expression in void function\");\n\n                            // even though we\'ve raised an error, use the more specific type\n                            returnStmt.type = returnStmt.returnExpression.type;\n                        }\n                        else {\n                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);\n                            returnStmt.type = expectedReturnType;\n                        }\n                    }\n                    else {\n                        if (targetType != null) {\n                            if (returnStmt.returnExpression.type != this.voidType) {\n                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);\n                            }\n                            else {\n                                returnStmt.returnExpression.type = targetType;\n                            }\n                        }\n                        returnStmt.type = returnStmt.returnExpression.type;\n                    }\n                }\n                else {\n                    returnStmt.type = targetType == null ? this.voidType : targetType;\n                }\n                this.thisFnc.returnStatements[this.thisFnc.returnStatements.length] = returnStmt;\n            }\n\n            return returnStmt;\n        }\n\n        property typeCheckInstOf(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            // TODO: require right oper) and to be a type or var\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        property typeCheckCommaOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        property typeCheckLogOr(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (leftType.subtype(rightType, this.checker)) {\n                binex.type = rightType;\n            }\n            else if (rightType.subtype(leftType, this.checker)) {\n                binex.type = leftType;\n            }\n            else {\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, \"||\",\n                                                        this.scope);\n                binex.type = leftType;\n            }\n            return binex;\n        }\n\n        property typeCheckLogAnd(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        property tryAddCandidates(signature: Signature, actuals: Type[], exactCandidates: Signature[], conversionCandidates: Signature[]): void {\n            var lowerBound = signature.nonOptionalParameterCount; // required parameters\n            var upperBound = signature.parameters.length; // required and optional parameters\n            var formalLen = lowerBound;\n            var acceptable = false;\n\n\n            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {\n                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);\n                acceptable = true;\n            }\n\n            var repeatType: Type = null;\n\n\n            //if (((signature.parameters.length-formalOffset)==actuals.length)||signature.variableArgList) {\n            if (acceptable || signature.hasVariableArgList) {\n                // assumed structure here is checked when signature is formed\n                if (signature.hasVariableArgList) {\n                    formalLen -= 1;\n                    repeatType = (<ParameterSymbol>signature.parameters[formalLen]).parameter.typeLink.type;\n                    repeatType = repeatType.elementType;\n                    acceptable = actuals.length >= formalLen;\n                }\n                var len = actuals.length;\n\n                var exact = acceptable;\n                var convert = acceptable;\n                for (var i = 0; i < len; i++) {\n                    var typeA: Type;\n                    if (i < formalLen) {\n                        typeA =\n                            (<ParameterSymbol>signature.parameters[i]).parameter.typeLink.type;\n                    }\n                    else {\n                        typeA = repeatType;\n                    }\n\n                    var typeB = actuals[i];\n                    if (!typeA || !typeB || !(this.checker.invariantMatches(typeA, typeB))) {\n                        exact = false;\n                    }\n                    if (!this.checker.assignableTo(typeA, typeB)) {\n                        convert = false;\n                    }\n                    if (!(exact || convert)) {\n                        break;\n                    }\n                }\n                if (exact) {\n                    exactCandidates[exactCandidates.length] = signature;\n                }\n                else if (convert && (exactCandidates.length == 0)) {\n                    conversionCandidates[conversionCandidates.length] = signature;\n                }\n\n            }\n        }\n\n        property resolveOverload(callEx: CallExpression, group: SignatureGroup): Signature {\n            var rd = this.resolutionDataCache.getResolutionData();\n            var actuals = rd.actuals;\n            var exactCandidates = rd.exactCandidates;\n            var conversionCandidates = rd.conversionCandidates;\n            var candidate: Signature = null;\n\n            if (callEx.args != null) {\n                var len = callEx.args.members.length;\n                for (var i = 0; i < len; i++) {\n                    actuals[i] = callEx.args.members[i].type;\n                }\n            }\n\n            // TODO: different error message for single signature\n            for (var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {\n                var signature = group.signatures[j];\n                if ((signature.returnType.type == null) && (signature.declAST != null) &&\n                    (signature.typeCheckStatus != TypeCheckStatus.Finished)) {\n                        // here is the cross-AST check\n                    this.typeCheckFunction(signature.declAST);\n                }\n                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates);\n            }\n            if (exactCandidates.length == 0) {\n                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, callEx.args);\n                if (applicableCandidates.length > 0) {                    \n                    candidate = applicableCandidates[0];\n                }\n                else {\n                    this.checker.errorReporter.simpleError(callEx,\n                                                      \"supplied parameters do not match any signature of call target\");\n                }\n            }\n            else {\n                candidate = exactCandidates[0];\n            }\n\n            this.resolutionDataCache.returnResolutionData(rd);\n            return candidate;\n        }\n\n        property typeCheckNew(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n\n            callEx.target = this.typeCheck(callEx.target);\n            var target = callEx.target;\n            if (target.type.construct != null || target.type.call != null) {\n                this.preTypeCheckCallArgs(callEx.args);\n            }\n            else {\n                callEx.args = this.typeCheck(callEx.args);\n            }\n\n            if (target.type == this.anyType) {\n                callEx.type = this.anyType;\n                callEx.args = this.typeCheck(callEx.args);\n            }\n            else {\n                // all constructors return instance type\n                if (target.type.construct != null) {\n                    var signature = this.resolveOverload(callEx, target.type.construct);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if (signature.returnType.type == this.voidType) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else if (target.type.call != null) {\n                    var signature = this.resolveOverload(callEx, target.type.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if ((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(callEx.target,\n                           \"new expression only valid on constructors\");\n                    }\n                }\n                else if (target.type.elementType != null) {\n                    // array\n                    callEx.type = target.type;\n                }\n                else {\n                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType);\n                    callEx.type = this.anyType;\n                }\n            }\n            \n            this.postTypeCheckCallArgs(callEx);\n            \n            return callEx;\n        }\n        \n        // Typecheck all args that cannot be affected by contextual typing of overloads\n        property preTypeCheckCallArgs(args: ASTList) {\n            \n            if (!args) {\n                return;\n            }\n            \n            for (var i = 0; i < args.members.length; i++) {\n                switch (args.members[i].nodeType) {\n                    case NodeType.FuncDecl:\n                    case NodeType.ObjectLit:\n                    case NodeType.ArrayLit:\n                        continue;\n                    default:\n                        this.typeCheck(args.members[i]);\n                        break;\n                }\n            }\n        }\n\n        property postTypeCheckCallArgs(callEx: CallExpression) {\n            \n          \n            var acceptedTargetType = false;\n            var i = 0;\n\n            if (callEx.target &&\n                callEx.target.type &&\n                callEx.signature &&\n                callEx.args) {\n                var sig = callEx.signature;\n                \n                if (sig && callEx.args.members.length >= sig.nonOptionalParameterCount) {\n                    acceptedTargetType = true;\n                    var targetType: Type = null;\n                    var len = callEx.args.members.length < sig.parameters.length ? callEx.args.members.length : sig.parameters.length;\n\n                    for (i = 0; i < len; i++) {\n                        targetType = sig.parameters[i].getType();\n                        if (targetType != null && sig.hasVariableArgList && i >= sig.nonOptionalParameterCount) {\n                            targetType = targetType.elementType;\n                        }\n                        switch (callEx.args.members[i].nodeType) {\n                            case NodeType.FuncDecl:\n                            case NodeType.ObjectLit:\n                            case NodeType.ArrayLit:\n                                this.checker.typeCheckWithTargetType(targetType, !sig.parameters[i].declAST.isParenthesized, callEx.args.members[i]);\n                                break;\n                            default:\n                                continue;\n                        }                        \n                    }\n                }\n            }\n\n            if (!acceptedTargetType && callEx.args) {\n                this.checker.killTargetType();\n                \n                for (i = 0; i < callEx.args.members.length; i++) {\n                    switch (callEx.args.members[i].nodeType) {\n                        case NodeType.FuncDecl:\n                        case NodeType.ObjectLit:\n                        case NodeType.ArrayLit:\n                            this.typeCheck(callEx.args.members[i]);\n                            break;\n                        default:\n                            continue;\n                    }\n                }\n            }\n        }\n\n        property typeCheckCall(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType==NodeType.New)) {\n                if (hasFlag(ast.flags, ASTFlags.IsStatement)) {\n                    this.checker.errorReporter.styleError(ast, \"use of new expression as a statement\");\n                }\n            }\n            else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType == NodeType.Call)) {\n                if ((callEx.target.nodeType == NodeType.Name) && ((<Identifier>callEx.target).text==\"eval\")) {\n                    this.checker.errorReporter.styleError(callEx,\"eval not permitted\");\n                }\n            }\n\n            if (callEx.target.nodeType == NodeType.FuncDecl) {\n                (<FuncDecl>callEx.target).isInlineCallLiteral = true;\n            }\n\n            callEx.target = this.typeCheck(callEx.target);\n            this.preTypeCheckCallArgs(callEx.args);\n            \n            var target = callEx.target;\n            // TODO: error call to void function expecting result\n            if ((target.type == null) || (target.type == this.anyType)) {\n                callEx.type = this.anyType;\n            }\n            else {\n                var fnType = target.type;\n                if (fnType.call != null) {\n                    var signature = this.resolveOverload(callEx, fnType.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else {\n                    // track calls to ES6 class base class\n                    if (callEx.target.nodeType == NodeType.Super &&\n                        this.thisFnc &&\n                        this.thisFnc.isConstructor &&\n                        hasFlag(this.thisFnc.fncFlags, FncFlags.ES6ClassMethod)) {\n\n                        // Need to use the class type for the construct signature, not the instance type\n                        var signature = this.resolveOverload(callEx, fnType.symbol.type.construct);\n                        if (signature == null) {\n                            callEx.type = this.anyType;\n                        }\n                        else {\n                            (<ES6ClassDecl>this.thisClassNode).baseConstructorCall.members[0] = callEx;\n                            callEx.flags |= ASTFlags.ES6ClassBaseConstructorCall;\n                            callEx.type = signature.returnType.type;\n                            callEx.signature = signature;\n                        }\n                    }\n                    else {\n                        callEx.type = this.anyType;\n                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType);\n                    }\n                }\n            }\n            this.postTypeCheckCallArgs(callEx);\n            return callEx;\n        }\n\n        property assignScopes(ast: AST) {\n            var script = <Script>ast;\n            this.checker.locationInfo = script.locationInfo;\n            var globalChain = new ScopeChain(null, null, this.globalScope);\n            var context = new AssignScopeContext(globalChain, this, [this.checker.currentModDecl]);\n            ast.walk(preAssignScopes, postAssignScopes, null, context);\n        }\n\n        property findMemberScope(enclosingScopeContext: EnclosingScopeContext, matchFlag: ASTFlags) {\n            var enclosingScope = enclosingScopeContext.getScope();\n            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScopePosition();\n            var scriptFragment = enclosingScopeContext.getScriptFragment();\n\n            var memContext = new MemberScopeContext(this, pos, matchFlag);\n            memContext.scope = enclosingScope;\n            if (scriptFragment.nodeType == NodeType.Name) {\n                return scriptFragment.type.getMemberScope(this);\n            }\n            else {\n                scriptFragment.walk(preFindMemberScope, null, null, memContext);\n                if (memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                    enclosingScopeContext.publicsOnly = false;\n                }\n                if (memContext.type != null) {\n                    return memContext.type.getMemberScope(this);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n\n        property findMemberScopeAt(enclosingScopeContext: EnclosingScopeContext) {\n            return this.findMemberScope(enclosingScopeContext, ASTFlags.DotLHS);\n        }\n    }\n}\n\n\nmodule Tools {\n\n    export enum Primitive {\n        None = 0,\n        Void = 1,\n        Double = 2,\n        String = 4,\n        Boolean = 8,\n        Any = 16,\n        Null = 32,\n        Undefined = 64,\n    }\n\n    export function hasNominalSubtypeRelationship(a: Type, b: Type, depth: number): bool {\n        if (depth > 0) {\n            var impls: Type[] = a.implementsList;\n            var exnds: Type[] = a.extendsList;\n            var candidates: Type[] = null;\n            if (impls == null && exnds == null) {\n                return false;\n            }\n            else if (impls != null && exnds != null) {\n                candidates = impls.concat(exnds);\n            }\n            else {\n                candidates = impls != null ? impls : exnds;\n            }\n\n            var imp: Type = null;\n            var bbase: Type = null;\n            var impbase: Type = null;\n            for (var i = 0; i < candidates.length; i++) {\n                imp = candidates[i];\n                impbase = imp.baseClass();\n                bbase = b.baseClass();\n                // quickly check for a shallow parent relationship\n                if (b == impbase || bbase == imp) {\n                    return true;\n                }\n                if (bbase != null && impbase != null && bbase == impbase) {\n                    return true;\n                }\n                if (b == imp || hasNominalSubtypeRelationship(imp, b, depth - 1)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    var currentTypeID = -1;\n\n    export oldclass Type() {\n        property typeID = currentTypeID++;\n\n        property members: ScopedMembers;\n        property ambientMembers: ScopedMembers;\n\n        property construct: SignatureGroup = null;\n        property call: SignatureGroup = null;\n        property index: SignatureGroup = null;\n\n        // interface can only extend\n        property extendsList: Type[];\n        property extendsTypeLinks: TypeLink[];\n\n        // class can also implement\n        property implementsList: Type[];\n        property implementsTypeLinks: TypeLink[];\n        property isES6Class = false;\n\n        // REVIEW: For diagnostic purposes\n        property passTypeCreated: number = CompilerDiagnostics.analysisPass;\n\n        property baseClass(): Type {\n            if ((this.extendsList != null) && (this.extendsList.length > 0)) {\n                return this.extendsList[0];\n            }\n            else {\n                return null;\n            }\n        }\n\n        // array type\n        property elementType: Type;\n\n        property getArrayBase(arrInstType: Type, checker: TypeChecker): Type {\n            return this.arrayCache.specialize(arrInstType, checker);\n        }\n\n        property primitives: number = Primitive.None;\n\n        property constructorScope: SymbolScope;\n        property containedScope: SymbolScope;\n        property memberScope: SymbolScope;\n\n        property arrayCache: ArrayCache;\n\n        property typeFlags = TypeFlags.None;\n\n        property symbol: TypeSymbol;\n\n        property enclosingType: Type;\n        property instanceType: Type;\n\n        property isClass() => this.instanceType != null;\n        property isArray() => this.elementType != null;\n        property isClassInstance(): bool {\n            return ((this.symbol != null) && (this.elementType == null) && ((<TypeSymbol>this.symbol).type.isClass()));\n        }\n\n        property getInstanceType() {\n            if (this.isClass()) {\n                return this.instanceType;\n            }\n            else {\n                return this;\n            }\n        }\n\n        property hasImplementation() => hasFlag(this.typeFlags, TypeFlags.HasImplementation);\n        property setHasImplementation() { this.typeFlags |= TypeFlags.HasImplementation; }\n\n        property isDouble() => hasFlag(this.primitives, Primitive.Double);\n        property isString() => hasFlag(this.primitives, Primitive.String);\n        property isBoolean() => hasFlag(this.primitives, Primitive.Boolean);\n        property isNull() => hasFlag(this.primitives, Primitive.Null);\n\n        property subtypeMembers(b: Type, checker: TypeChecker): bool {\n            if (this.isBase(b)) {\n                return true;\n            }\n            if ((b.members != null) && (!b.hasImplementation())) {\n                return b.members.publicMembers.every(function (key, s, t) {\n                    var sym = <Symbol>s;\n                    var a = <Type>t;\n                    var memberScope = a.memberScope;\n                    // In the case of a target-typed expression, \n                    // the member scope may be null;\n                    if (memberScope == null) {\n                        return false;\n                    }\n                    else {\n                        var aSym = a.memberScope.find(sym.name, true, false);\n                        return checker.symbolSubtype(aSym, sym);\n                    }\n                }, this);\n            }\n            return true;\n        }\n\n        property assignableMembers(b: Type, checker: TypeChecker): bool {\n            if (this.isBase(b) || b.isBase(this)) {\n                return true;\n            }\n\n            if (this.members == b.members) {\n                return true;\n            }\n\n            if (this.members == null || b.members == null) {\n                return true;\n            }\n\n            // Two types are assignment-compatible if:\n            // 1.)  For every member in \'this\', there is a matching member\n            //      in \'b\'\n            var isAssignable = false;\n            if ((this.members != null) && (!this.hasImplementation())) {\n                isAssignable = this.members.publicMembers.every(function (key, s, t) {\n                    var sym = <Symbol>s;\n                    var bT = <Type>t;\n                    // In the case of a target-typed expression, \n                    // the member scope may be null;\n                    if (bT.memberScope == null) {\n                        return false;\n                    }\n                    else {\n                        var bSym = bT.memberScope.find(sym.name, true, false);\n                        return checker.symbolAssignable(sym, bSym);\n                    }\n                }, b);\n            }\n\n            if (!isAssignable) {\n                if ((b.members != null) && (!b.hasImplementation())) {\n                    isAssignable = b.members.publicMembers.every(function (key, s, t) {\n                        var sym = <Symbol>s;\n                        var a = <Type>t;\n                        var memberScope = a.memberScope;\n                        // In the case of a target-typed expression, \n                        // the member scope may be null;\n                        if (memberScope == null) {\n                            return false;\n                        }\n                        else {\n                            var aSym = a.memberScope.find(sym.name, true, false);\n                            return checker.symbolAssignable(aSym, sym);\n                        }\n                    }, this);\n                }\n            }\n\n            return isAssignable;\n        }\n\n        property getItemType(indexType: Type, checker: TypeChecker, ast: AST) {\n            if (this.elementType != null) {\n                return this.elementType;\n            }\n            if (this.memberScope == null) {\n                return null;\n            }\n            if (this.index != null) {\n                // REVEIW: can there be more than one signature\n                var signatures = this.index.signatures;\n                if (signatures.length > 0) {\n                    var signature = signatures[0];\n                    if (signature.matchSingleArg(indexType, checker) || indexType == checker.anyType) {\n                        return signature.returnType.type;\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            } else {\n                // for the default index implementation, string is the only acceptable index type\n                // [] : string -> any\n                if (!checker.contravariantMatches(checker.stringType, indexType)) {\n                    checker.errorReporter.simpleError(ast, \"Unless explicitly overloaded, index methods may only take string parameters\");\n                }\n                else {\n                    return checker.anyType;\n                }\n            }\n        }\n\n        property getTypeName(): string {\n            return this.getMemberTypeName(\"\", true, false, null);\n        }\n\n        property getScopedTypeName(scope: SymbolScope) {\n            return this.getMemberTypeName(\"\", true, false, scope);\n        }\n\n        property callCount() {\n            var total = 0;\n            if (this.call != null) {\n                total += this.call.signatures.length;\n            }\n            if (this.construct != null) {\n                total += this.construct.signatures.length;\n            }\n            if (this.index != null) {\n                total += this.index.signatures.length;\n            }\n            return total;\n        }\n\n        property getMemberTypeName(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): string {\n            if (this.elementType != null) {\n                return this.elementType.getMemberTypeName(prefix, false, true, scope) + \"[]\";\n            }\n            else if ((this.symbol != null) && (this.symbol.name != null) && (this.symbol.name != \"_anonymous\") &&\n                     (((this.call == null) && (this.construct == null) && (this.index == null)) ||\n                      (hasFlag(this.typeFlags, TypeFlags.BuildingName)) ||\n                      ((this.members != null) && (!this.isClass())))) {\n                return this.symbol.scopeRelativeName(scope);\n            }\n            else {\n                if ((this.members != null) || (this.call != null) || (this.construct != null)) {\n                    if (hasFlag(this.typeFlags, TypeFlags.BuildingName)) {\n                        return \"this\";\n                    }\n                    this.typeFlags |= TypeFlags.BuildingName;\n                    var builder = \"\";\n                    var curlies = isElementType;\n                    var delim = \"; \";\n                    var signatureCount = 0;\n                    var memCount = 0;\n                    if (this.members != null) {\n                        this.members.allMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                                builder += sym.getTypeName(scope);\n                                memCount++;\n                                if (sym.kind() == SymbolKind.Type) {\n                                    var memberType = (<TypeSymbol>sym).type;\n                                    if (memberType.callCount() > 1) {\n                                        curlies = true;\n                                    }\n                                }\n                                else {\n                                    builder += delim;\n                                    curlies = true;\n                                }\n                            }\n                        }, null);\n                    }\n                    var signatures: string[];\n                    var j: number;\n                    var len = 0;\n                    var shortform = (memCount == 0) && (this.callCount() == 1) && topLevel;\n                    if (this.call != null) {\n                        signatures = this.call.toStrings(prefix, shortform, scope);\n                        for (j = 0, len = signatures.length; j < len; j++) {\n                            builder += signatures[j];\n                            signatureCount++;\n                            if (!shortform) {\n                                builder += delim;\n                            }\n                        }\n                    }\n                    if (this.construct != null) {\n                        signatures = this.construct.toStrings(\"new\", shortform, scope);\n                        for (j = 0, len = signatures.length; j < len; j++) {\n                            builder += signatures[j];\n                            signatureCount++;\n                            if (!shortform) {\n                                builder += delim;\n                            }\n                        }\n                    }\n                    if (this.index != null) {\n                        signatures = this.index.toStrings(\"\", shortform, scope);\n                        for (j = 0, len = signatures.length; j < len; j++) {\n                            builder += signatures[j];\n                            signatureCount++;\n                            if (!shortform) {\n                                builder += delim;\n                            }\n                        }\n                    }\n                    // TODO: bases\n                    if ((curlies) || ((signatureCount > 1) && topLevel)) {\n                        builder = \"{ \" + builder + \"}\";\n                    }\n                    this.typeFlags &= (~TypeFlags.BuildingName);\n                    if ((signatureCount == 0) && (memCount == 0)) {\n                        return \"{}\";\n                    }\n                    else {\n                        return builder;\n                    }\n                }\n                else {\n                    return \"{}\";\n                }\n            }\n        }\n\n        property checkDecl(checker: TypeChecker) {\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST != null) {\n                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);\n                }\n            }\n        }\n\n        property tryStartMatch(b: Type, checker: TypeChecker): bool {\n            return checker.tryStartTypeMatch(this, b);\n        }\n\n        property endMatch(b: Type, checker: TypeChecker) {\n            return checker.endTypeMatch(this, b);\n        }\n\n        property getMemberScope(flow: TypeFlow) {\n            if (this == flow.anyType) {\n                if (flow.objectInstanceType != null) {\n                    return flow.objectInstanceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.isDouble()) {\n                // FIX: TODO: specialize for number\n                return null;\n            }\n            else if (this == flow.stringType) {\n                if (flow.stringInstanceType != null) {\n                    return flow.stringInstanceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.elementType != null) {\n                if (flow.arrayInstanceType != null) {\n                    var arrInstType = this.elementType.getArrayBase(flow.arrayInstanceType, flow.checker);\n                    return arrInstType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return this.memberScope;\n            }\n        }\n\n        property isReferenceType() {\n            return (this.members != null) || (this.extendsList != null) ||\n                (this.construct != null) || (this.call != null) || (this.index != null) ||\n                (this.elementType != null);\n        }\n\n        // this routine is narrowly focused; it is currently used only\n        // for array type specialization and is not a general substitution mechanism\n        // TODO: implement generics!\n        property specializeType(pattern: Type, replacement: Type, checker: TypeChecker, membersOnly: bool): Type {\n            if (pattern == this) {\n                return replacement;\n            }\n            var result = this;\n            if (membersOnly) {\n                // assume interface type without bases\n                if (this.isReferenceType()) {\n                    result = new Type();\n                    if (this.members != null) {\n                        result.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                        this.members.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.members.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    result.containedScope = checker.scopeOf(result);\n                    result.memberScope = result.containedScope;\n                }\n            }\n            else {\n                if (this.elementType != null) {\n                    if (this.elementType == pattern) {\n                        // pattern[]\n                        result = checker.makeArrayType(replacement);\n                    }\n                    else {\n                        if (this.elementType.elementType == pattern) {\n                            // pattern[][]\n                            result =\n                                checker.makeArrayType(checker.makeArrayType(replacement));\n                        }\n                    }\n                }\n                else if (this.call != null) {\n                    // call with pattern, pattern[], or pattern[][] as parameter\n                    result = new Type();\n                    result.call = this.call.specializeType(pattern, replacement, checker);\n                }\n            }\n            return result;\n        }\n\n        property isBase(b: Type): bool {\n            if (b == this) {\n                return true;\n            }\n            else {\n                if (this.extendsList != null) {\n                    for (var i = 0, len = this.extendsList.length; i < len; i++) {\n                        if (this.extendsList[i].isBase(b)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        // determines if this is a subtype of \'b\'\n        property subtype(b: Type, checker: TypeChecker): bool {\n            if ((this == b) || (b == null)) {\n                return true;\n            }\n            if (this == checker.nullType && b != checker.undefinedType) {\n                return true;\n            }\n            if (this == checker.undefinedType) {\n                return true;\n            }\n\n            if (b == checker.anyType) {\n                return true;\n            }\n            else if (b == checker.nullType) {\n                return false;\n            }\n            if (hasFlag(this.typeFlags, TypeFlags.IsEnum)) {\n                // enum is a subtype of number but nothing else\n                return (b == checker.doubleType);\n            }\n            if (hasFlag(b.typeFlags, TypeFlags.IsEnum)) {\n                return false;\n            }\n            // TODO: remove this when primitives are represented as classes\n            if (this.primitives != b.primitives) {\n                return false;\n            }\n            // class types are distinct (their instance types may have subtypes)\n            if (this.isClass() || b.isClass()) {\n                return false;\n            }\n\n            // array element type\n            if (this.elementType != null) {\n                if (b.elementType != null) {\n                    if (!this.elementType.subtype(b.elementType, checker)) {\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            else if (b.elementType != null) {\n                return false;\n            }\n\n            // brands are modeled using the hasImplementation bit\n            if (this.isClassInstance()) {\n                if (b.isClassInstance()) {\n                    // two classes; must have stipulated sub-type relationship\n                    return this.isBase(b);\n                }\n            }\n            else if (b.isClassInstance()) {\n                // interface can\'t be sub-type of class \n                return false;\n            }\n\n            // Shortcut: if one nominally implements the other, there\'s a subtype relationship\n            // REVIEW: the recursive depth of 4 seems suitable for most real-world code\n            // (E.g., Monaco), though we may want to parameterize it.            \n            if (hasNominalSubtypeRelationship(this, b, 4) ||\n                hasNominalSubtypeRelationship(b, this, 4)) {\n\n                return true;\n            }\n\n            if (!this.tryStartMatch(b, checker)) {\n                return true;\n            }\n\n            // constructor group\n            if (this.construct != null) {\n                if (b.construct != null) {\n                    if (!checker.signatureGroupSubtype(this.construct, b.construct)) {\n                        this.endMatch(b, checker);\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            // call group\n            if (this.call != null) {\n                if (b.call != null) {\n                    if (!checker.signatureGroupSubtype(this.call, b.call)) {\n                        this.endMatch(b, checker);\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            // index group\n            if (this.index != null) {\n                if (b.index != null) {\n                    if (!checker.signatureGroupSubtype(this.index, b.index)) {\n                        this.endMatch(b, checker);\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n\n            // properties \n            if (!this.subtypeMembers(b, checker)) {\n                this.endMatch(b, checker);\n                return false;\n            }\n            this.endMatch(b, checker);\n            return true;\n        }\n\n        // Determines if \'this\' is a subtype of \'b\'\n        // REVIEW: This method should really be symmetric over a and b\n        property assignable(b: Type, checker: TypeChecker): bool {\n            if ((this == b) || (b == null)) {\n                return true;\n            }\n            if (this == checker.nullType && b != checker.voidType) {\n                return true;\n            }\n            if (this == checker.anyType && b != checker.voidType) {\n                return true;\n            }\n            if (b == checker.anyType && this != checker.voidType) {\n                return true;\n            }\n            else if (b == checker.nullType && this != checker.voidType) {\n                return true;\n            }\n            if (hasFlag(this.typeFlags, TypeFlags.IsEnum)) {\n                // enum is a subtype of number but nothing else\n                return (b == checker.doubleType);\n            }\n            if (hasFlag(b.typeFlags, TypeFlags.IsEnum)) {\n                return false;\n            }\n            // TODO: remove this when primitives are represented as classes\n            if (this.primitives != b.primitives) {\n                return false;\n            }\n            // class types are distinct (their instance types may have subtypes)\n            if (this.isClass() || b.isClass()) {\n                return false;\n            }\n\n            // array element type\n            if (this.elementType != null) {\n                if (b.elementType != null) {\n                    return this.elementType.assignable(b.elementType, checker);\n                }\n                else {\n                    return false;\n                }\n            }\n            else if (b.elementType != null) {\n                return false;\n            }\n\n            // brands are modeled using the hasImplementation bit\n            if (this.isClassInstance()) {\n                if (b.isClassInstance()) {\n                    // two classes; must have stipulated sub-type relationship\n                    return this.isBase(b);\n                }\n            }\n            else if (b.isClassInstance()) {\n                // interface can\'t be sub-type of class \n                return false;\n            }\n\n            // Shortcut: if one nominally implements the other, there\'s a subtype relationship\n            // REVIEW: the recursive depth of 4 seems suitable for most real-world code\n            // (E.g., Monaco), though we may want to parameterize it.            \n            if (hasNominalSubtypeRelationship(this, b, 4) ||\n                hasNominalSubtypeRelationship(b, this, 4)) {\n\n                return true;\n            }\n\n            if (!this.tryStartMatch(b, checker)) {\n                return true;\n            }\n\n            // constructor group\n            if (this.construct != null) {\n                if (b.construct != null) {\n                    if (!checker.signatureGroupAssignable(this.construct, b.construct)) {\n                        this.endMatch(b, checker);\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            else if (b.construct != null) {\n                // From the spec:\n                //      \"One member is a call signature with a Void return type, the other \n                //      member is a constructor signature, and parameter positions that \n                //      are present in both signatures have assignment compatible types.\"\n                if (this.call != null) {\n                    return checker.signatureGroupAssignable(this.call, b.construct);\n                }\n                else {\n                    return false;\n                }\n            }\n\n            // call group\n            if (this.call != null) {\n                if (b.call != null) {\n                    if (!checker.signatureGroupAssignable(this.call, b.call)) {\n                        this.endMatch(b, checker);\n                        return false;\n                    }\n                }\n                    // From the spec:\n                    //      \"One member is a call signature with a Void return type, the other \n                    //      member is a constructor signature, and parameter positions that \n                    //      are present in both signatures have assignment compatible types.\"\n                else if (b.construct != null) {\n                    if (!checker.signatureGroupAssignable(this.call, b.construct)) {\n                        this.endMatch(b, checker);\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            else if (b.call != null) {\n                // From the spec:\n                //      \"One member is a call signature with a Void return type, the other \n                //      member is a constructor signature, and parameter positions that \n                //      are present in both signatures have assignment compatible types.\"\n                if (this.construct != null) {\n                    return checker.signatureGroupAssignable(this.construct, b.call);\n                }\n                else {\n                    return false;\n                }\n            }\n\n            // index group\n            if (this.index != null) {\n                if (b.index != null) {\n                    if (!checker.signatureGroupAssignable(this.index, b.index)) {\n                        this.endMatch(b, checker);\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            // Indexers DO NOT need to be symmetric!\n            // This allows you to have object literals map\n            // to indexers - E.g., \"{ 0: { id : \"a\" }, 1: { id : \"b\" } }\"\n\n            // properties \n            if (!this.assignableMembers(b, checker)) {\n                this.endMatch(b, checker);\n                return false;\n            }\n            this.endMatch(b, checker);\n            return true;\n        }\n\n        property mergeOrdered(b: Type, checker: TypeChecker): Type {\n            // only one any type\n            if ((this == checker.anyType) || (b == checker.anyType)) {\n                return checker.anyType;\n            }\n            else if (this == b) {\n                return this;\n            }\n            else if ((b == checker.nullType) && this != checker.nullType) {\n                return this;\n            }\n            else if ((this == checker.nullType) && (b != checker.nullType)) {\n                return b;\n            }\n            else if ((this.elementType != null) && (b.elementType != null)) {\n                if (this.elementType == b.elementType) {\n                    return this;\n                }\n                else {\n                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker);\n                    if (mergedET == null) {\n                        return checker.makeArrayType(checker.anyType);\n                    }\n                    else {\n                        return checker.makeArrayType(mergedET);\n                    }\n                }\n            }\n            else if (this.subtype(b, checker)) {\n                return b;\n            }\n            else if (b.subtype(this, checker)) {\n                return this;\n            }\n            else {\n                return null;\n            }\n        }\n\n        property isModuleType() => false;\n        property hasMembers() => this.members != null;\n        property getAllEnclosedTypes(): ScopedMembers => null;\n        property getAllAmbientEnclosedTypes(): ScopedMembers => null;\n        property getPublicEnclosedTypes(): ScopedMembers => null;\n        property getpublicAmbientEnclosedTypes(): ScopedMembers => null;\n    }\n\n    export interface ITypeCollection {\n        // returns null when types are exhausted\n        getLength(): number;\n        setTypeAtIndex(index: number, type: Type): void;\n        getTypeAtIndex(index: number): Type;\n    }\n\n    export function findBestCommonType(initialType: Type, targetType: Type, collection: ITypeCollection, checker: TypeChecker) {\n        var i = 0;\n        var len = collection.getLength();\n        var nlastChecked = 0;\n        var bestCommonType = initialType;\n\n        if (targetType) {\n            bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, checker) : targetType;\n        }\n\n        // it\'s important that we set the convergence type here, and not in the loop,\n        // since the first element considered may be the contextual type\n        var convergenceType: Type = bestCommonType;\n\n        while (nlastChecked < len) {\n\n            for (i = 0; i < len; i++) {\n\n                // no use in comparing a type against itself\n                if (i == nlastChecked) {\n                    continue;\n                }\n\n                if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), checker))) {\n                    convergenceType = bestCommonType;\n                }\n\n                if (bestCommonType == checker.anyType || bestCommonType == null) {\n                    break;\n                }\n                else if (targetType != null) { // set the element type to the target type\n                    collection.setTypeAtIndex(i, targetType);\n                }\n            }\n\n            // use the type if we\'ve agreed upon it\n            if (convergenceType != null && bestCommonType != null) {\n                break;\n            }\n\n            nlastChecked++;\n            if (nlastChecked < len) {\n                convergenceType = collection.getTypeAtIndex(nlastChecked);\n            }\n        }\n\n        return bestCommonType;\n    }\n\n\n    export oldclass ModuleType(property enclosedTypes: ScopedMembers,\n                            property ambientEnclosedTypes: ScopedMembers) extends Type() {\n\n        property isModuleType() => true;\n        property hasMembers() =>(this.members != null) || (this.enclosedTypes != null);\n        property getAllEnclosedTypes() => this.enclosedTypes;\n        property getAllAmbientEnclosedTypes() => this.ambientEnclosedTypes;\n        property getPublicEnclosedTypes(): ScopedMembers => null;\n        property getpublicAmbientEnclosedTypes(): ScopedMembers => null;\n        property importedModules: ImportDecl[] = [];\n    }\n\n    export oldclass TypeLink {\n        property type: Type = null;\n        property ast: AST = null;\n    }\n\n    export function getTypeLink(ast: AST, checker: TypeChecker, autoVar: bool): TypeLink {\n        var result = new TypeLink();\n        \n        result.ast = ast;\n        \n        if ((ast == null) && (autoVar)) {\n            result.type = checker.anyType;\n        }\n        else {\n            result.type = null;\n        }\n        \n        return result;\n    }    \n    \n}\n\n\n\n"; 
var BatchCompiler = (function () {
    function BatchCompiler() {}
    BatchCompiler.prototype.compile = function() {
        var outfile = new StringTextWriter(); 
        var errout = new StringTextWriter(); 
        var compiler; 
        compiler = new Tools.StradaCompiler(outfile, outfile, new Tools.NullLogger()); 
        compiler.setErrorOutput(errout); 
        compiler.setErrorCallback(function(minChar, charLen, message, unitIndex) {
            var fname = "error"; 
            var msg = (((((fname + " (") + compiler.parser.scanner.line) + ",") + compiler.parser.scanner.col) + "): ") + message; 
            throw new SyntaxError(msg);
        }); 
        compiler.addUnit(libString, "lib.str", true);
        
        var compilerStrStartTime = new Date();
        compiler.addUnit(compilerString, "compiler.str", false); 
        var compilerStrEndTime = new Date();
        
        var compilerTypeCheckStartTime = new Date();
        compiler.typeCheck(); 
        var compilerTypeCheckEndTime = new Date();

        var compilerEmitStartTime = new Date();
        compiler.emit(false, function(path) {
            return outfile; 
        });
        var compilerEmitEndTime = new Date();
        
	if(outfile) {
            outfile.Close(); 
        }
        if(errout) {
            errout.Close(); 
        }
        WScript.Echo("### Parse Time:", (compilerStrEndTime - compilerStrStartTime), "ms");
		WScript.Echo("### Type Check Time:", (compilerTypeCheckEndTime - compilerTypeCheckStartTime), "ms");
		WScript.Echo("### Emit Time:", (compilerEmitEndTime - compilerEmitStartTime), "ms");
    };
    return BatchCompiler;
})();

var batch = new BatchCompiler(); 
batch.compile(); 
