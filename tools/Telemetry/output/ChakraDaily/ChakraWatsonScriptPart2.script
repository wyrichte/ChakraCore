//Script GUID:428714fa-ace7-4d7d-8c40-fdf07f395cba
//Used for tracking history

REFERENCE @"/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/bin/Relevance.ScopeLib.dll";
RESOURCE @"/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/bin/Relevance.ScopeLib.pdb";
RESOURCE @"/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/bin/Relevance.ScopeLib.xml";
USING Microsoft.SegmentRelevance.ScopeLib;

#DECLARE startDate DateTime = IF("@@startDate@@".StartsWith("@@"), DateTime.UtcNow.Date.AddDays(-1), DateTime.Parse("@@startDate@@"));
#DECLARE streamDate DateTime = @startDate.AddDays(-3);// Just to keep it in sync with part1_part2 script


#DECLARE flattenedHits String = String.Format( "/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/Watson/Flat3/{0:yyyy}/{0:MM}/{0:dd}.ss", @streamDate );

flightingFactTableV3_TechPreview =
SELECT
	WuChildUpdateId, // Case-sensitive
	( WuChildUpdateId != null ? WuChildUpdateId.ToString("D") : "" ) AS WuChildUpdateIdString,
	Ring,
	FlightGroupName,
	Branch,
	BuildNumber,
	BuildString,
	Architecture,
	String.Concat( Branch, " - ", BuildNumber ) AS BuildString2,
	String.Concat( BuildNumber, " - ", Branch ) AS BuildString3
FROM
	( SSTREAM @"/shares/asimov.prod.data/Public/Processed/Flighting/FlightingFactTable/FlightingFactTableV3.ss" );

chakraHits =
SELECT
	*
FROM
	( SSTREAM @flattenedHits ) AS flattenedHitsSrc
	INNER JOIN flightingFactTableV3_TechPreview ON flightingFactTableV3_TechPreview.WuChildUpdateIdString == flattenedHitsSrc.osBuildFlightId2;

////////////////////////////////////
// By Flight

byFlight =
SELECT
	osBuildFlightId2, // `osBuildFlightId2` is the extracted GUID
	// Columns from FlightingFactTable can be extracted using FIRST instead of adding them to the GROUP BY.
	FIRST( FlightGroupName ) AS FlightGroupName, // Branch + Build Date thing + SKU
	FIRST( Branch ) AS Branch,
	FIRST( Ring ) AS Ring,
	FIRST( BuildNumber ) AS BuildNumber,
	FIRST( BuildString ) AS BuildString,
	FIRST( Architecture ) AS Architecture,
	FIRST( BuildString2 ) AS BuildString2,
	FIRST( BuildString3 ) AS BuildString3,
	COUNT(*) AS HitsAll,
	SUM( (watsonEventName ?? "").IndexOf("hang", StringComparison.OrdinalIgnoreCase) == -1 ? 1 : 0 ) AS HitsNonHang
FROM
	chakraHits
GROUP BY
	osBuildFlightId2
WHERE
	( watsonEventName ?? "" ).Length > 0;

// Do not unpivot this data. The ISCOPE query needs the HitsAll vs. HitsNonHang in separate columns.
//byFlightUnpivoted =
//PROCESS byFlight USING UnpivotProcessor("-valueCol", "Hits", "-pivotCol", "SeriesName", "-in", "HitsAll, HitsNonHang");

#DECLARE byFlightOutputFileName String = String.Format( "/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/Watson/ByFlightId5/{0:yyyy}/{0:MM}/{0:dd}.ss", @streamDate );

//OUTPUT byFlightUnpivoted TO SSTREAM @byFlightOutputFileName WITH STREAMEXPIRY "365";
OUTPUT byFlight TO SSTREAM @byFlightOutputFileName WITH STREAMEXPIRY "365";


////////////////////////////////////
// Failure Groups

byFailureGroup =
SELECT
	FailureInfo_FailureHash,
	Branch,
	Ring,
	FIRST( "Hits" ) AS SeriesName,
	FIRST( watsonEventName ) AS EventName,
	FIRST( FailureInfo_FailureBucketId ) AS GroupedByDisplay,
	COUNT(*) AS HitsAll,
	SUM( (watsonEventName ?? "").IndexOf("hang", StringComparison.OrdinalIgnoreCase) == -1 ? 1 : 0 ) AS HitsNonHang
FROM
	chakraHits
	
GROUP BY
	FailureInfo_FailureHash,
	Branch,
	Ring;

#DECLARE byFailureGroupOutputFileName String = String.Format( "/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/Watson/ByFailureGroup5/{0:yyyy}/{0:MM}/{0:dd}.ss", @streamDate );

OUTPUT byFailureGroup TO SSTREAM @byFailureGroupOutputFileName WITH STREAMEXPIRY "365";


////////////////////////////////////
// Hits, by module branch + version, but only Flighted builds.

byModuleVersion =
SELECT
	FIRST( String.Concat( osBuildBranch, " - ", FailureInfo_ModuleVersion ) ) AS GroupedByDisplay,
	FailureInfo_ModuleVersionBinary,
	osBuildBranch,
	Branch,
	Ring,
	COUNT(*) AS HitsAll,
	SUM( (watsonEventName ?? "").IndexOf("hang", StringComparison.OrdinalIgnoreCase) == -1 ? 1 : 0 ) AS HitsNonHang,

	COUNT( DISTINCT FailureInfo_FailureHash ) AS DistinctFailures,

	COUNT( DISTINCT (
		(watsonEventName ?? "").IndexOf("hang", StringComparison.OrdinalIgnoreCase) == -1 ?  FailureInfo_FailureHash : null
	) ) AS DistinctFailuresNonHang // NOTE: COUNT(DISTINCT) isn't as fast as COUNT GROUP BY, but given the cheapness of this script and small input data, I'll allow it.
FROM
	chakraHits
WHERE
	!String.IsNullOrEmpty( osBuildFlightId )
		
GROUP BY
	osBuildBranch,
	FailureInfo_ModuleVersionBinary,
	Branch,
	Ring;

byModuleVersionUnpivoted =
PROCESS byModuleVersion USING UnpivotProcessor("-valueCol", "Hits", "-pivotCol", "SeriesName", "-in", "HitsAll, HitsNonHang, DistinctFailures, DistinctFailuresNonHang");

#DECLARE byModuleVersionOutputFileName String = String.Format( "/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/Watson/ByModuleVersion6/{0:yyyy}/{0:MM}/{0:dd}.ss", @streamDate);

OUTPUT byModuleVersionUnpivoted TO SSTREAM @byModuleVersionOutputFileName WITH STREAMEXPIRY "365";


////////////////////////////////////
// Hits, by process (host binary) version.

byProcessVersion =
SELECT
	FIRST( String.Concat( AppScope_ProcessName, " ", AppScope_AppVersion ) ) AS GroupedByDisplay,
	AppScope_ProcessName,
	AppScope_AppVersionBinary,
	Branch,
	Ring,
	COUNT(*) AS HitsAll,
	SUM( (watsonEventName ?? "").IndexOf("hang", StringComparison.OrdinalIgnoreCase) == -1 ? 1 : 0 ) AS HitsNonHang,
	COUNT( DISTINCT FailureInfo_FailureHash ) AS DistinctFailures,

	COUNT( DISTINCT (
		(watsonEventName ?? "").IndexOf("hang", StringComparison.OrdinalIgnoreCase) == -1 ?  FailureInfo_FailureHash : null
	) ) AS DistinctFailuresNonHang
FROM
	chakraHits
		
GROUP BY
	AppScope_ProcessName,
	AppScope_AppVersionBinary,
	Branch,
	Ring;

byProcessVersionUnpivoted =
PROCESS byProcessVersion USING UnpivotProcessor("-valueCol", "Hits", "-pivotCol", "SeriesName", "-in", "HitsAll, HitsNonHang, DistinctFailures, DistinctFailuresNonHang");

#DECLARE byProcessVersionOutputFileName String = String.Format( "/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/Watson/ByProcessVersion5/{0:yyyy}/{0:MM}/{0:dd}.ss", @streamDate );

OUTPUT byProcessVersionUnpivoted TO SSTREAM @byProcessVersionOutputFileName WITH STREAMEXPIRY "365";


////////////////////////////////////
// New Failures by Day

// As this is the data for a single day, the job of identifying the first day a failure appears is ISCOPE's responsibility.
// So just get a simple (sorted?) list of Failure IDs for this day.

failureHashes =
SELECT
	DISTINCT FailureInfo_FailureHash,
	( watsonEventName ?? "" ).IndexOf("hang", StringComparison.OrdinalIgnoreCase) > -1 AS IsHang
FROM
	chakraHits;

#DECLARE failureHashesOutputFileName String = String.Format( "/shares/asimov.prod.data/PublicPartner/Processed/ChakraJavaScript/Watson/FailureHashes4/{0:yyyy}/{0:MM}/{0:dd}.ss", @streamDate );

OUTPUT failureHashes TO SSTREAM @failureHashesOutputFileName WITH STREAMEXPIRY "365";


