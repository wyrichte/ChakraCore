<?xml version="1.0" encoding="utf-8"?>
<!-- copy to %USERPROFILE%\My Documents\Visual Studio 2012\Visualizers\ to use-->
<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">
  <Type Name="Js::OpCode">
    <DisplayString Condition="_value &lt;= Js::OpCode::MaxByteSizedOpcodes">{Js::OpCodeUtil::OpCodeNames[_value],sub}</DisplayString>
    <DisplayString Condition="_value &gt; Js::OpCode::MaxByteSizedOpcodes &amp;&amp; _value &lt; Js::OpCode::ByteCodeLast">{Js::OpCodeUtil::ExtendedOpCodeNames[_value - Js::OpCode::MaxByteSizedOpcodes - 1],sub}</DisplayString>
    <DisplayString Condition="_value &gt; Js::OpCode::ByteCodeLast &amp;&amp; _value &lt; Js::OpCode::Count">{Js::OpCodeUtil::BackendOpCodeNames[_value - Js::OpCode::ByteCodeLast - 1],sub}</DisplayString>
    <DisplayString>Invalid Opcode {_value}</DisplayString>
  </Type>
  <Type Name="IR::Instr">
    <DisplayString Condition="m_dst == 0 &amp;&amp; m_src2 == 0">{m_opcode} {*m_src1}</DisplayString>
    <DisplayString Condition="m_dst == 0">{m_opcode} {*m_src1}, {*m_src2}</DisplayString>
    <DisplayString Condition="m_src2 == 0">{*m_dst} = {m_opcode} {*m_src1}</DisplayString>
    <DisplayString>{*m_dst} = {m_opcode} {*m_src1}, {*m_src2}</DisplayString>
  </Type>
  <Type Name="IR::LabelInstr">
    <DisplayString>$L{m_id,d}:</DisplayString>
  </Type>
  <Type Name="IR::BranchInstr">
    <DisplayString>{*(IR::Instr *)this,nd} => $L{m_branchTarget->m_id,d}</DisplayString>
  </Type>
  <Type Name="IR::PragmaInstr">
    <DisplayString>{*(IR::Instr *)this,nd} #{m_statementIndex,d}</DisplayString>
  </Type>
  <Type Name="IR::BailOutInstr">
    <DisplayString>{*(IR::Instr *)this,nd} #{bailOutInfo->bailOutOffset,d}</DisplayString>
  </Type>
  <Type Name="IR::BranchBailOutInstr">
    <DisplayString>{*(IR::Instr *)this,nd} #{bailOutInfo->bailOutOffset,d}</DisplayString>
  </Type>
  <Type Name="IR::ProfiledBailOutInstr">
    <DisplayString>{*(IR::Instr *)this,nd} #{bailOutInfo->bailOutOffset,d}</DisplayString>
  </Type>
  <Type Name="IR::Opnd">
    <DisplayString Condition="this == 0"></DisplayString>
    <DisplayString>{(void*)this}({m_kind})"</DisplayString>
  </Type>
  <Type Name="IR::IntConstOpnd">
    <DisplayString>{m_value}</DisplayString>
  </Type>
  <Type Name="IR::FloatConstOpnd">
    <DisplayString>{m_value}</DisplayString>
  </Type>
  <Type Name="IR::MemRefOpnd">
    <DisplayString>[{m_memLoc.x}]</DisplayString>
  </Type>
  <Type Name="IR::HelperCallOpnd">
    <DisplayString>{JnHelperMethodNames[m_fnHelper],su}</DisplayString>
  </Type>  
  <Type Name="IR::RegOpnd">
    <DisplayString Condition="m_sym == 0">{RegNames[m_reg],sb}</DisplayString>
    <DisplayString Condition="m_reg != 0">{*m_sym}({RegNames[m_reg],sb})</DisplayString>
    <DisplayString>{*m_sym}</DisplayString>
  </Type>
  <Type Name="IR::AddrOpnd">
    <DisplayString>{m_address,x}</DisplayString>
  </Type>
  <Type Name ="IR::SymOpnd">
    <DisplayString >{*m_sym}</DisplayString>
  </Type>
  <Type Name ="IR::PropertySymOpnd">
    <DisplayString >{*m_sym}</DisplayString>
  </Type>
  <Type Name="IR::IndirOpnd">
    <DisplayString Condition="m_offset &gt; 0 &amp;&amp; m_indexOpnd == 0">[{*m_baseOpnd}+{m_offset}]</DisplayString>
    <DisplayString Condition="m_offset &lt; 0 &amp;&amp; m_indexOpnd == 0">[{*m_baseOpnd}-{m_offset}]</DisplayString>
    <DisplayString Condition="m_offset &gt; 0 &amp;&amp; m_scale == 0">[{*m_baseOpnd}+{*m_indexOpnd}+{m_offset}]</DisplayString>
    <DisplayString Condition="m_offset &lt; 0 &amp;&amp; m_scale == 0">[{*m_baseOpnd}+{*m_indexOpnd}-{m_offset}]</DisplayString>
    <DisplayString Condition="m_offset &gt; 0">[{*m_baseOpnd}+{*m_indexOpnd}*{(int)m_scale}+{m_offset}]</DisplayString>
    <DisplayString Condition="m_offset &lt; 0">[{*m_baseOpnd}+{*m_indexOpnd}*{(int)m_scale}-{m_offset}]</DisplayString>
    <DisplayString Condition="m_indexOpnd == 0">[{*m_baseOpnd}]</DisplayString>
    <DisplayString Condition="m_scale == 0">[{*m_baseOpnd}+{*m_indexOpnd}]</DisplayString>
    <DisplayString>[{*m_baseOpnd}+{*m_indexOpnd}*{(int)m_scale}]</DisplayString>
  </Type>
  <Type Name="Sym">
    <DisplayString Condition="m_kind == SymKindStack">{*(StackSym *)this}</DisplayString>
    <DisplayString Condition="m_kind == SymKindProperty">{*(PropertySym *)this}</DisplayString>
  </Type>
  <Type Name="PropertySym">
    <DisplayString Condition="m_fieldKind == PropertyKindSlots || m_fieldKind == PropertyKindSlotArray">{*m_stackSym}[{m_propertyId,d}]</DisplayString>
    <DisplayString Condition="m_fieldKind == PropertyKindData">{*m_stackSym}->{*(Js::PropertyRecord *)(m_func->m_jnFunction->m_scriptContext.value->threadContext->propertyMap->entries[m_propertyId - Js::PropertyIds::_none].value)}</DisplayString>
    <DisplayString>p{m_id,d}</DisplayString>
  </Type>
  <Type Name="StackSym">
    <DisplayString>s{m_id,d}</DisplayString>
  </Type>
  <Type Name="Js::PropertyRecord">
    <DisplayString>{this + 1,sub} (id:{pid,d})</DisplayString>
  </Type>
  <Type Name="BasicBlock">
    <DisplayString>Block {number,d}</DisplayString>
  </Type>
  <Type Name="Js::ArgumentReader">
    <DisplayString>{(Js::Arguments*)this}</DisplayString>
    <Expand>
      <Item Name="Flags">Info.Flags</Item>
      <Item Name="Count">Info.Count</Item>
      <ArrayItems>
        <Size>Info.Count</Size>
        <ValuePointer>Values</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="Js::Arguments">
    <Expand>
      <Item Name="Flags">Info.Flags</Item>
      <Item Name="Count">Info.Count</Item>
      <ArrayItems>
        <Size>Info.Count</Size>
        <ValuePointer>Values</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="ValueType">
    <DisplayString LegacyAddin="chakratest.dll"
                   Export="NatVis_ValueType"/>
  </Type>
  <Type Name="BVSparseNode">
    <DisplayString LegacyAddin="chakratest.dll"
                   Export="NatVis_BVSparseNode"/>
  </Type>
  <Type Name="BVSparse&lt;JitArenaAllocator&gt;">
    <DisplayString LegacyAddin="chakratest.dll"
                   Export="NatVis_BVSparse_JitArenaAllocator"/>
  </Type>
  <Type Name="Js::FunctionBody">
    <DisplayString>{this->m_displayName.ptr,su} ({this->functionId})</DisplayString>  
  </Type>
  <Type Name="Func">
    <DisplayString Condition="this->m_workItem->type == JsLoopBodyWorkItemType">{this->m_jnFunction->m_displayName.ptr,su} Loop ({this->m_jnFunction->functionId})</DisplayString>
    <DisplayString>{this->m_jnFunction}</DisplayString>
  </Type>
  <Type Name="Js::Var">
    <DisplayString Condition="(((unsigned int)this) &amp; 0x1) == 0x1">{(((unsigned int)this) >> 1)}</DisplayString>
    <DisplayString>{(Js::RecyclableObject*)this}</DisplayString>
  </Type>
  <Type Name="Js::ScriptFunction">
    <DisplayString>{this->functionInfo}</DisplayString>
  </Type>
  <Type Name="Js::SparseArraySegmentBase">
    <Expand>
      <Item Name="length">length</Item>
      <Item Name="size">size</Item>
      <ArrayItems>
        <Size>length</Size>
        <ValuePointer>(void**)(this+1)</ValuePointer>
      </ArrayItems >
    </Expand>
  </Type>
</AutoVisualizer>
