// Snapshot of compiler sources on Thu Aug 28 2014 22:17:49 GMT-0700 (Pacific Daylight Time)
var compilerSources = "\r\n // file: src/compiler/diagnosticInformationMap.generated.ts\r\n// <auto-generated />\r\n/// <reference path=\"types.ts\" />\r\nmodule ts {\r\n    export var Diagnostics = {\r\n        Unterminated_string_literal: { code: 1002, category: DiagnosticCategory.Error, key: \"Unterminated string literal.\" },\r\n        Identifier_expected: { code: 1003, category: DiagnosticCategory.Error, key: \"Identifier expected.\" },\r\n        _0_expected: { code: 1005, category: DiagnosticCategory.Error, key: \"'{0}' expected.\" },\r\n        Trailing_comma_not_allowed: { code: 1009, category: DiagnosticCategory.Error, key: \"Trailing comma not allowed.\" },\r\n        Asterisk_Slash_expected: { code: 1010, category: DiagnosticCategory.Error, key: \"'*/' expected.\" },\r\n        Unexpected_token: { code: 1012, category: DiagnosticCategory.Error, key: \"Unexpected token.\" },\r\n        Catch_clause_parameter_cannot_have_a_type_annotation: { code: 1013, category: DiagnosticCategory.Error, key: \"Catch clause parameter cannot have a type annotation.\" },\r\n        A_rest_parameter_must_be_last_in_a_parameter_list: { code: 1014, category: DiagnosticCategory.Error, key: \"A rest parameter must be last in a parameter list.\" },\r\n        Parameter_cannot_have_question_mark_and_initializer: { code: 1015, category: DiagnosticCategory.Error, key: \"Parameter cannot have question mark and initializer.\" },\r\n        A_required_parameter_cannot_follow_an_optional_parameter: { code: 1016, category: DiagnosticCategory.Error, key: \"A required parameter cannot follow an optional parameter.\" },\r\n        An_index_signature_cannot_have_a_rest_parameter: { code: 1017, category: DiagnosticCategory.Error, key: \"An index signature cannot have a rest parameter.\" },\r\n        An_index_signature_parameter_cannot_have_an_accessibility_modifier: { code: 1018, category: DiagnosticCategory.Error, key: \"An index signature parameter cannot have an accessibility modifier.\" },\r\n        An_index_signature_parameter_cannot_have_a_question_mark: { code: 1019, category: DiagnosticCategory.Error, key: \"An index signature parameter cannot have a question mark.\" },\r\n        An_index_signature_parameter_cannot_have_an_initializer: { code: 1020, category: DiagnosticCategory.Error, key: \"An index signature parameter cannot have an initializer.\" },\r\n        An_index_signature_must_have_a_type_annotation: { code: 1021, category: DiagnosticCategory.Error, key: \"An index signature must have a type annotation.\" },\r\n        An_index_signature_parameter_must_have_a_type_annotation: { code: 1022, category: DiagnosticCategory.Error, key: \"An index signature parameter must have a type annotation.\" },\r\n        An_index_signature_parameter_type_must_be_string_or_number: { code: 1023, category: DiagnosticCategory.Error, key: \"An index signature parameter type must be 'string' or 'number'.\" },\r\n        A_class_or_interface_declaration_can_only_have_one_extends_clause: { code: 1024, category: DiagnosticCategory.Error, key: \"A class or interface declaration can only have one 'extends' clause.\" },\r\n        An_extends_clause_must_precede_an_implements_clause: { code: 1025, category: DiagnosticCategory.Error, key: \"An 'extends' clause must precede an 'implements' clause.\" },\r\n        A_class_can_only_extend_a_single_class: { code: 1026, category: DiagnosticCategory.Error, key: \"A class can only extend a single class.\" },\r\n        A_class_declaration_can_only_have_one_implements_clause: { code: 1027, category: DiagnosticCategory.Error, key: \"A class declaration can only have one 'implements' clause.\" },\r\n        Accessibility_modifier_already_seen: { code: 1028, category: DiagnosticCategory.Error, key: \"Accessibility modifier already seen.\" },\r\n        _0_modifier_must_precede_1_modifier: { code: 1029, category: DiagnosticCategory.Error, key: \"'{0}' modifier must precede '{1}' modifier.\" },\r\n        _0_modifier_already_seen: { code: 1030, category: DiagnosticCategory.Error, key: \"'{0}' modifier already seen.\" },\r\n        _0_modifier_cannot_appear_on_a_class_element: { code: 1031, category: DiagnosticCategory.Error, key: \"'{0}' modifier cannot appear on a class element.\" },\r\n        An_interface_declaration_cannot_have_an_implements_clause: { code: 1032, category: DiagnosticCategory.Error, key: \"An interface declaration cannot have an 'implements' clause.\" },\r\n        super_must_be_followed_by_an_argument_list_or_member_access: { code: 1034, category: DiagnosticCategory.Error, key: \"'super' must be followed by an argument list or member access.\" },\r\n        Only_ambient_modules_can_use_quoted_names: { code: 1035, category: DiagnosticCategory.Error, key: \"Only ambient modules can use quoted names.\" },\r\n        Statements_are_not_allowed_in_ambient_contexts: { code: 1036, category: DiagnosticCategory.Error, key: \"Statements are not allowed in ambient contexts.\" },\r\n        A_function_implementation_cannot_be_declared_in_an_ambient_context: { code: 1037, category: DiagnosticCategory.Error, key: \"A function implementation cannot be declared in an ambient context.\" },\r\n        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: { code: 1038, category: DiagnosticCategory.Error, key: \"A 'declare' modifier cannot be used in an already ambient context.\" },\r\n        Initializers_are_not_allowed_in_ambient_contexts: { code: 1039, category: DiagnosticCategory.Error, key: \"Initializers are not allowed in ambient contexts.\" },\r\n        _0_modifier_cannot_appear_on_a_module_element: { code: 1044, category: DiagnosticCategory.Error, key: \"'{0}' modifier cannot appear on a module element.\" },\r\n        A_declare_modifier_cannot_be_used_with_an_interface_declaration: { code: 1045, category: DiagnosticCategory.Error, key: \"A 'declare' modifier cannot be used with an interface declaration.\" },\r\n        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: { code: 1046, category: DiagnosticCategory.Error, key: \"A 'declare' modifier is required for a top level declaration in a .d.ts file.\" },\r\n        A_rest_parameter_cannot_be_optional: { code: 1047, category: DiagnosticCategory.Error, key: \"A rest parameter cannot be optional.\" },\r\n        A_rest_parameter_cannot_have_an_initializer: { code: 1048, category: DiagnosticCategory.Error, key: \"A rest parameter cannot have an initializer.\" },\r\n        A_set_accessor_must_have_exactly_one_parameter: { code: 1049, category: DiagnosticCategory.Error, key: \"A 'set' accessor must have exactly one parameter.\" },\r\n        A_set_accessor_cannot_have_an_optional_parameter: { code: 1051, category: DiagnosticCategory.Error, key: \"A 'set' accessor cannot have an optional parameter.\" },\r\n        A_set_accessor_parameter_cannot_have_an_initializer: { code: 1052, category: DiagnosticCategory.Error, key: \"A 'set' accessor parameter cannot have an initializer.\" },\r\n        A_set_accessor_cannot_have_rest_parameter: { code: 1053, category: DiagnosticCategory.Error, key: \"A 'set' accessor cannot have rest parameter.\" },\r\n        A_get_accessor_cannot_have_parameters: { code: 1054, category: DiagnosticCategory.Error, key: \"A 'get' accessor cannot have parameters.\" },\r\n        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: { code: 1056, category: DiagnosticCategory.Error, key: \"Accessors are only available when targeting ECMAScript 5 and higher.\" },\r\n        Enum_member_must_have_initializer: { code: 1061, category: DiagnosticCategory.Error, key: \"Enum member must have initializer.\" },\r\n        An_export_assignment_cannot_be_used_in_an_internal_module: { code: 1063, category: DiagnosticCategory.Error, key: \"An export assignment cannot be used in an internal module.\" },\r\n        Ambient_enum_elements_can_only_have_integer_literal_initializers: { code: 1066, category: DiagnosticCategory.Error, key: \"Ambient enum elements can only have integer literal initializers.\" },\r\n        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: { code: 1068, category: DiagnosticCategory.Error, key: \"Unexpected token. A constructor, method, accessor, or property was expected.\" },\r\n        A_declare_modifier_cannot_be_used_with_an_import_declaration: { code: 1079, category: DiagnosticCategory.Error, key: \"A 'declare' modifier cannot be used with an import declaration.\" },\r\n        Invalid_reference_directive_syntax: { code: 1084, category: DiagnosticCategory.Error, key: \"Invalid 'reference' directive syntax.\" },\r\n        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: { code: 1085, category: DiagnosticCategory.Error, key: \"Octal literals are not available when targeting ECMAScript 5 and higher.\" },\r\n        An_accessor_cannot_be_declared_in_an_ambient_context: { code: 1086, category: DiagnosticCategory.Error, key: \"An accessor cannot be declared in an ambient context.\" },\r\n        _0_modifier_cannot_appear_on_a_constructor_declaration: { code: 1089, category: DiagnosticCategory.Error, key: \"'{0}' modifier cannot appear on a constructor declaration.\" },\r\n        _0_modifier_cannot_appear_on_a_parameter: { code: 1090, category: DiagnosticCategory.Error, key: \"'{0}' modifier cannot appear on a parameter.\" },\r\n        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: { code: 1091, category: DiagnosticCategory.Error, key: \"Only a single variable declaration is allowed in a 'for...in' statement.\" },\r\n        Type_parameters_cannot_appear_on_a_constructor_declaration: { code: 1092, category: DiagnosticCategory.Error, key: \"Type parameters cannot appear on a constructor declaration.\" },\r\n        Type_annotation_cannot_appear_on_a_constructor_declaration: { code: 1093, category: DiagnosticCategory.Error, key: \"Type annotation cannot appear on a constructor declaration.\" },\r\n        An_accessor_cannot_have_type_parameters: { code: 1094, category: DiagnosticCategory.Error, key: \"An accessor cannot have type parameters.\" },\r\n        A_set_accessor_cannot_have_a_return_type_annotation: { code: 1095, category: DiagnosticCategory.Error, key: \"A 'set' accessor cannot have a return type annotation.\" },\r\n        An_index_signature_must_have_exactly_one_parameter: { code: 1096, category: DiagnosticCategory.Error, key: \"An index signature must have exactly one parameter.\" },\r\n        _0_list_cannot_be_empty: { code: 1097, category: DiagnosticCategory.Error, key: \"'{0}' list cannot be empty.\" },\r\n        Type_parameter_list_cannot_be_empty: { code: 1098, category: DiagnosticCategory.Error, key: \"Type parameter list cannot be empty.\" },\r\n        Type_argument_list_cannot_be_empty: { code: 1099, category: DiagnosticCategory.Error, key: \"Type argument list cannot be empty.\" },\r\n        Invalid_use_of_0_in_strict_mode: { code: 1100, category: DiagnosticCategory.Error, key: \"Invalid use of '{0}' in strict mode.\" },\r\n        with_statements_are_not_allowed_in_strict_mode: { code: 1101, category: DiagnosticCategory.Error, key: \"'with' statements are not allowed in strict mode.\" },\r\n        delete_cannot_be_called_on_an_identifier_in_strict_mode: { code: 1102, category: DiagnosticCategory.Error, key: \"'delete' cannot be called on an identifier in strict mode.\" },\r\n        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: { code: 1104, category: DiagnosticCategory.Error, key: \"A 'continue' statement can only be used within an enclosing iteration statement.\" },\r\n        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: { code: 1105, category: DiagnosticCategory.Error, key: \"A 'break' statement can only be used within an enclosing iteration or switch statement.\" },\r\n        Jump_target_cannot_cross_function_boundary: { code: 1107, category: DiagnosticCategory.Error, key: \"Jump target cannot cross function boundary.\" },\r\n        A_return_statement_can_only_be_used_within_a_function_body: { code: 1108, category: DiagnosticCategory.Error, key: \"A 'return' statement can only be used within a function body.\" },\r\n        Expression_expected: { code: 1109, category: DiagnosticCategory.Error, key: \"Expression expected.\" },\r\n        Type_expected: { code: 1110, category: DiagnosticCategory.Error, key: \"Type expected.\" },\r\n        A_constructor_implementation_cannot_be_declared_in_an_ambient_context: { code: 1111, category: DiagnosticCategory.Error, key: \"A constructor implementation cannot be declared in an ambient context.\" },\r\n        A_class_member_cannot_be_declared_optional: { code: 1112, category: DiagnosticCategory.Error, key: \"A class member cannot be declared optional.\" },\r\n        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: { code: 1113, category: DiagnosticCategory.Error, key: \"A 'default' clause cannot appear more than once in a 'switch' statement.\" },\r\n        Duplicate_label_0: { code: 1114, category: DiagnosticCategory.Error, key: \"Duplicate label '{0}'\" },\r\n        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: { code: 1115, category: DiagnosticCategory.Error, key: \"A 'continue' statement can only jump to a label of an enclosing iteration statement.\" },\r\n        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: { code: 1116, category: DiagnosticCategory.Error, key: \"A 'break' statement can only jump to a label of an enclosing statement.\" },\r\n        An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode: { code: 1117, category: DiagnosticCategory.Error, key: \"An object literal cannot have multiple properties with the same name in strict mode.\" },\r\n        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: { code: 1118, category: DiagnosticCategory.Error, key: \"An object literal cannot have multiple get/set accessors with the same name.\" },\r\n        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: { code: 1119, category: DiagnosticCategory.Error, key: \"An object literal cannot have property and accessor with the same name.\" },\r\n        An_export_assignment_cannot_have_modifiers: { code: 1120, category: DiagnosticCategory.Error, key: \"An export assignment cannot have modifiers.\" },\r\n        Octal_literals_are_not_allowed_in_strict_mode: { code: 1121, category: DiagnosticCategory.Error, key: \"Octal literals are not allowed in strict mode.\" },\r\n        Variable_declaration_list_cannot_be_empty: { code: 1123, category: DiagnosticCategory.Error, key: \"Variable declaration list cannot be empty.\" },\r\n        Digit_expected: { code: 1124, category: DiagnosticCategory.Error, key: \"Digit expected.\" },\r\n        Hexadecimal_digit_expected: { code: 1125, category: DiagnosticCategory.Error, key: \"Hexadecimal digit expected.\" },\r\n        Unexpected_end_of_text: { code: 1126, category: DiagnosticCategory.Error, key: \"Unexpected end of text.\" },\r\n        Invalid_character: { code: 1127, category: DiagnosticCategory.Error, key: \"Invalid character.\" },\r\n        Declaration_or_statement_expected: { code: 1128, category: DiagnosticCategory.Error, key: \"Declaration or statement expected.\" },\r\n        Statement_expected: { code: 1129, category: DiagnosticCategory.Error, key: \"Statement expected.\" },\r\n        case_or_default_expected: { code: 1130, category: DiagnosticCategory.Error, key: \"'case' or 'default' expected.\" },\r\n        Property_or_signature_expected: { code: 1131, category: DiagnosticCategory.Error, key: \"Property or signature expected.\" },\r\n        Enum_member_expected: { code: 1132, category: DiagnosticCategory.Error, key: \"Enum member expected.\" },\r\n        Type_reference_expected: { code: 1133, category: DiagnosticCategory.Error, key: \"Type reference expected.\" },\r\n        Variable_declaration_expected: { code: 1134, category: DiagnosticCategory.Error, key: \"Variable declaration expected.\" },\r\n        Argument_expression_expected: { code: 1135, category: DiagnosticCategory.Error, key: \"Argument expression expected.\" },\r\n        Property_assignment_expected: { code: 1136, category: DiagnosticCategory.Error, key: \"Property assignment expected.\" },\r\n        Expression_or_comma_expected: { code: 1137, category: DiagnosticCategory.Error, key: \"Expression or comma expected.\" },\r\n        Parameter_declaration_expected: { code: 1138, category: DiagnosticCategory.Error, key: \"Parameter declaration expected.\" },\r\n        Type_parameter_declaration_expected: { code: 1139, category: DiagnosticCategory.Error, key: \"Type parameter declaration expected.\" },\r\n        Type_argument_expected: { code: 1140, category: DiagnosticCategory.Error, key: \"Type argument expected.\" },\r\n        String_literal_expected: { code: 1141, category: DiagnosticCategory.Error, key: \"String literal expected.\" },\r\n        Line_break_not_permitted_here: { code: 1142, category: DiagnosticCategory.Error, key: \"Line break not permitted here.\" },\r\n        catch_or_finally_expected: { code: 1143, category: DiagnosticCategory.Error, key: \"'catch' or 'finally' expected.\" },\r\n        Block_or_expected: { code: 1144, category: DiagnosticCategory.Error, key: \"Block or ';' expected.\" },\r\n        Modifiers_not_permitted_on_index_signature_members: { code: 1145, category: DiagnosticCategory.Error, key: \"Modifiers not permitted on index signature members.\" },\r\n        Declaration_expected: { code: 1146, category: DiagnosticCategory.Error, key: \"Declaration expected.\" },\r\n        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: { code: 1147, category: DiagnosticCategory.Error, key: \"Import declarations in an internal module cannot reference an external module.\" },\r\n        Cannot_compile_external_modules_unless_the_module_flag_is_provided: { code: 1148, category: DiagnosticCategory.Error, key: \"Cannot compile external modules unless the '--module' flag is provided.\" },\r\n        Filename_0_differs_from_already_included_filename_1_only_in_casing: { code: 1149, category: DiagnosticCategory.Error, key: \"Filename '{0}' differs from already included filename '{1}' only in casing\" },\r\n        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: { code: 1150, category: DiagnosticCategory.Error, key: \"'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.\" },\r\n        Duplicate_identifier_0: { code: 2300, category: DiagnosticCategory.Error, key: \"Duplicate identifier '{0}'.\" },\r\n        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: { code: 2301, category: DiagnosticCategory.Error, key: \"Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.\" },\r\n        Static_members_cannot_reference_class_type_parameters: { code: 2302, category: DiagnosticCategory.Error, key: \"Static members cannot reference class type parameters.\" },\r\n        Circular_definition_of_import_alias_0: { code: 2303, category: DiagnosticCategory.Error, key: \"Circular definition of import alias '{0}'.\" },\r\n        Cannot_find_name_0: { code: 2304, category: DiagnosticCategory.Error, key: \"Cannot find name '{0}'.\" },\r\n        Module_0_has_no_exported_member_1: { code: 2305, category: DiagnosticCategory.Error, key: \"Module '{0}' has no exported member '{1}'.\" },\r\n        File_0_is_not_an_external_module: { code: 2306, category: DiagnosticCategory.Error, key: \"File '{0}' is not an external module.\" },\r\n        Cannot_find_external_module_0: { code: 2307, category: DiagnosticCategory.Error, key: \"Cannot find external module '{0}'.\" },\r\n        A_module_cannot_have_more_than_one_export_assignment: { code: 2308, category: DiagnosticCategory.Error, key: \"A module cannot have more than one export assignment.\" },\r\n        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: { code: 2309, category: DiagnosticCategory.Error, key: \"An export assignment cannot be used in a module with other exported elements.\" },\r\n        Type_0_recursively_references_itself_as_a_base_type: { code: 2310, category: DiagnosticCategory.Error, key: \"Type '{0}' recursively references itself as a base type.\" },\r\n        A_class_may_only_extend_another_class: { code: 2311, category: DiagnosticCategory.Error, key: \"A class may only extend another class.\" },\r\n        An_interface_may_only_extend_a_class_or_another_interface: { code: 2312, category: DiagnosticCategory.Error, key: \"An interface may only extend a class or another interface.\" },\r\n        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: { code: 2313, category: DiagnosticCategory.Error, key: \"Constraint of a type parameter cannot reference any type parameter from the same type parameter list.\" },\r\n        Generic_type_0_requires_1_type_argument_s: { code: 2314, category: DiagnosticCategory.Error, key: \"Generic type '{0}' requires {1} type argument(s).\" },\r\n        Type_0_is_not_generic: { code: 2315, category: DiagnosticCategory.Error, key: \"Type '{0}' is not generic.\" },\r\n        Global_type_0_must_be_a_class_or_interface_type: { code: 2316, category: DiagnosticCategory.Error, key: \"Global type '{0}' must be a class or interface type.\" },\r\n        Global_type_0_must_have_1_type_parameter_s: { code: 2317, category: DiagnosticCategory.Error, key: \"Global type '{0}' must have {1} type parameter(s).\" },\r\n        Cannot_find_global_type_0: { code: 2318, category: DiagnosticCategory.Error, key: \"Cannot find global type '{0}'.\" },\r\n        Named_properties_0_of_types_1_and_2_are_not_identical: { code: 2319, category: DiagnosticCategory.Error, key: \"Named properties '{0}' of types '{1}' and '{2}' are not identical.\" },\r\n        Interface_0_cannot_simultaneously_extend_types_1_and_2_Colon: { code: 2320, category: DiagnosticCategory.Error, key: \"Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':\" },\r\n        Excessive_stack_depth_comparing_types_0_and_1: { code: 2321, category: DiagnosticCategory.Error, key: \"Excessive stack depth comparing types '{0}' and '{1}'.\" },\r\n        Type_0_is_not_assignable_to_type_1_Colon: { code: 2322, category: DiagnosticCategory.Error, key: \"Type '{0}' is not assignable to type '{1}':\" },\r\n        Type_0_is_not_assignable_to_type_1: { code: 2323, category: DiagnosticCategory.Error, key: \"Type '{0}' is not assignable to type '{1}'.\" },\r\n        Property_0_is_missing_in_type_1: { code: 2324, category: DiagnosticCategory.Error, key: \"Property '{0}' is missing in type '{1}'.\" },\r\n        Private_property_0_cannot_be_reimplemented: { code: 2325, category: DiagnosticCategory.Error, key: \"Private property '{0}' cannot be reimplemented.\" },\r\n        Types_of_property_0_are_incompatible_Colon: { code: 2326, category: DiagnosticCategory.Error, key: \"Types of property '{0}' are incompatible:\" },\r\n        Required_property_0_cannot_be_reimplemented_with_optional_property_in_1: { code: 2327, category: DiagnosticCategory.Error, key: \"Required property '{0}' cannot be reimplemented with optional property in '{1}'.\" },\r\n        Types_of_parameters_0_and_1_are_incompatible_Colon: { code: 2328, category: DiagnosticCategory.Error, key: \"Types of parameters '{0}' and '{1}' are incompatible:\" },\r\n        Index_signature_is_missing_in_type_0: { code: 2329, category: DiagnosticCategory.Error, key: \"Index signature is missing in type '{0}'.\" },\r\n        Index_signatures_are_incompatible_Colon: { code: 2330, category: DiagnosticCategory.Error, key: \"Index signatures are incompatible:\" },\r\n        this_cannot_be_referenced_in_a_module_body: { code: 2331, category: DiagnosticCategory.Error, key: \"'this' cannot be referenced in a module body.\" },\r\n        this_cannot_be_referenced_in_current_location: { code: 2332, category: DiagnosticCategory.Error, key: \"'this' cannot be referenced in current location.\" },\r\n        this_cannot_be_referenced_in_constructor_arguments: { code: 2333, category: DiagnosticCategory.Error, key: \"'this' cannot be referenced in constructor arguments.\" },\r\n        this_cannot_be_referenced_in_a_static_property_initializer: { code: 2334, category: DiagnosticCategory.Error, key: \"'this' cannot be referenced in a static property initializer.\" },\r\n        super_can_only_be_referenced_in_a_derived_class: { code: 2335, category: DiagnosticCategory.Error, key: \"'super' can only be referenced in a derived class.\" },\r\n        super_cannot_be_referenced_in_constructor_arguments: { code: 2336, category: DiagnosticCategory.Error, key: \"'super' cannot be referenced in constructor arguments.\" },\r\n        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: { code: 2337, category: DiagnosticCategory.Error, key: \"Super calls are not permitted outside constructors or in nested functions inside constructors\" },\r\n        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: { code: 2338, category: DiagnosticCategory.Error, key: \"'super' property access is permitted only in a constructor, member function, or member accessor of a derived class\" },\r\n        Property_0_does_not_exist_on_type_1: { code: 2339, category: DiagnosticCategory.Error, key: \"Property '{0}' does not exist on type '{1}'.\" },\r\n        Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: { code: 2340, category: DiagnosticCategory.Error, key: \"Only public methods of the base class are accessible via the 'super' keyword\" },\r\n        Property_0_is_inaccessible: { code: 2341, category: DiagnosticCategory.Error, key: \"Property '{0}' is inaccessible.\" },\r\n        An_index_expression_argument_must_be_of_type_string_number_or_any: { code: 2342, category: DiagnosticCategory.Error, key: \"An index expression argument must be of type 'string', 'number', or 'any'.\" },\r\n        Type_0_does_not_satisfy_the_constraint_1_Colon: { code: 2343, category: DiagnosticCategory.Error, key: \"Type '{0}' does not satisfy the constraint '{1}':\" },\r\n        Type_0_does_not_satisfy_the_constraint_1: { code: 2344, category: DiagnosticCategory.Error, key: \"Type '{0}' does not satisfy the constraint '{1}'.\" },\r\n        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: { code: 2345, category: DiagnosticCategory.Error, key: \"Argument of type '{0}' is not assignable to parameter of type '{1}'.\" },\r\n        Supplied_parameters_do_not_match_any_signature_of_call_target: { code: 2346, category: DiagnosticCategory.Error, key: \"Supplied parameters do not match any signature of call target.\" },\r\n        Untyped_function_calls_may_not_accept_type_arguments: { code: 2347, category: DiagnosticCategory.Error, key: \"Untyped function calls may not accept type arguments.\" },\r\n        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: { code: 2348, category: DiagnosticCategory.Error, key: \"Value of type '{0}' is not callable. Did you mean to include 'new'?\" },\r\n        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: { code: 2349, category: DiagnosticCategory.Error, key: \"Cannot invoke an expression whose type lacks a call signature.\" },\r\n        Only_a_void_function_can_be_called_with_the_new_keyword: { code: 2350, category: DiagnosticCategory.Error, key: \"Only a void function can be called with the 'new' keyword.\" },\r\n        Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature: { code: 2351, category: DiagnosticCategory.Error, key: \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\" },\r\n        Neither_type_0_nor_type_1_is_assignable_to_the_other: { code: 2352, category: DiagnosticCategory.Error, key: \"Neither type '{0}' nor type '{1}' is assignable to the other.\" },\r\n        Neither_type_0_nor_type_1_is_assignable_to_the_other_Colon: { code: 2353, category: DiagnosticCategory.Error, key: \"Neither type '{0}' nor type '{1}' is assignable to the other:\" },\r\n        No_best_common_type_exists_among_return_expressions: { code: 2354, category: DiagnosticCategory.Error, key: \"No best common type exists among return expressions.\" },\r\n        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2355, category: DiagnosticCategory.Error, key: \"A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement.\" },\r\n        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: { code: 2356, category: DiagnosticCategory.Error, key: \"An arithmetic operand must be of type 'any', 'number' or an enum type.\" },\r\n        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: { code: 2357, category: DiagnosticCategory.Error, key: \"The operand of an increment or decrement operator must be a variable, property or indexer.\" },\r\n        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2358, category: DiagnosticCategory.Error, key: \"The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.\" },\r\n        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: { code: 2359, category: DiagnosticCategory.Error, key: \"The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.\" },\r\n        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: { code: 2360, category: DiagnosticCategory.Error, key: \"The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.\" },\r\n        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2361, category: DiagnosticCategory.Error, key: \"The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter\" },\r\n        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2362, category: DiagnosticCategory.Error, key: \"The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\" },\r\n        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2363, category: DiagnosticCategory.Error, key: \"The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\" },\r\n        Invalid_left_hand_side_of_assignment_expression: { code: 2364, category: DiagnosticCategory.Error, key: \"Invalid left-hand side of assignment expression.\" },\r\n        Operator_0_cannot_be_applied_to_types_1_and_2: { code: 2365, category: DiagnosticCategory.Error, key: \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\" },\r\n        No_best_common_type_exists_between_0_1_and_2: { code: 2366, category: DiagnosticCategory.Error, key: \"No best common type exists between '{0}', '{1}', and '{2}'.\" },\r\n        No_best_common_type_exists_between_0_and_1: { code: 2367, category: DiagnosticCategory.Error, key: \"No best common type exists between '{0}' and '{1}'.\" },\r\n        Type_parameter_name_cannot_be_0: { code: 2368, category: DiagnosticCategory.Error, key: \"Type parameter name cannot be '{0}'\" },\r\n        A_parameter_property_is_only_allowed_in_a_constructor_implementation: { code: 2369, category: DiagnosticCategory.Error, key: \"A parameter property is only allowed in a constructor implementation.\" },\r\n        A_rest_parameter_must_be_of_an_array_type: { code: 2370, category: DiagnosticCategory.Error, key: \"A rest parameter must be of an array type.\" },\r\n        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: { code: 2371, category: DiagnosticCategory.Error, key: \"A parameter initializer is only allowed in a function or constructor implementation.\" },\r\n        Parameter_0_cannot_be_referenced_in_its_initializer: { code: 2372, category: DiagnosticCategory.Error, key: \"Parameter '{0}' cannot be referenced in its initializer.\" },\r\n        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: { code: 2373, category: DiagnosticCategory.Error, key: \"Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.\" },\r\n        Duplicate_string_index_signature: { code: 2374, category: DiagnosticCategory.Error, key: \"Duplicate string index signature.\" },\r\n        Duplicate_number_index_signature: { code: 2375, category: DiagnosticCategory.Error, key: \"Duplicate number index signature.\" },\r\n        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: { code: 2376, category: DiagnosticCategory.Error, key: \"A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.\" },\r\n        Constructors_for_derived_classes_must_contain_a_super_call: { code: 2377, category: DiagnosticCategory.Error, key: \"Constructors for derived classes must contain a 'super' call.\" },\r\n        A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2378, category: DiagnosticCategory.Error, key: \"A 'get' accessor must return a value or consist of a single 'throw' statement.\" },\r\n        Getter_and_setter_accessors_do_not_agree_in_visibility: { code: 2379, category: DiagnosticCategory.Error, key: \"Getter and setter accessors do not agree in visibility.\" },\r\n        get_and_set_accessor_must_have_the_same_type: { code: 2380, category: DiagnosticCategory.Error, key: \"'get' and 'set' accessor must have the same type.\" },\r\n        A_signature_with_an_implementation_cannot_use_a_string_literal_type: { code: 2381, category: DiagnosticCategory.Error, key: \"A signature with an implementation cannot use a string literal type.\" },\r\n        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: { code: 2382, category: DiagnosticCategory.Error, key: \"Specialized overload signature is not assignable to any non-specialized signature.\" },\r\n        Overload_signatures_must_all_be_exported_or_not_exported: { code: 2383, category: DiagnosticCategory.Error, key: \"Overload signatures must all be exported or not exported.\" },\r\n        Overload_signatures_must_all_be_ambient_or_non_ambient: { code: 2384, category: DiagnosticCategory.Error, key: \"Overload signatures must all be ambient or non-ambient.\" },\r\n        Overload_signatures_must_all_be_public_or_private: { code: 2385, category: DiagnosticCategory.Error, key: \"Overload signatures must all be public or private.\" },\r\n        Overload_signatures_must_all_be_optional_or_required: { code: 2386, category: DiagnosticCategory.Error, key: \"Overload signatures must all be optional or required.\" },\r\n        Function_overload_must_be_static: { code: 2387, category: DiagnosticCategory.Error, key: \"Function overload must be static.\" },\r\n        Function_overload_must_not_be_static: { code: 2388, category: DiagnosticCategory.Error, key: \"Function overload must not be static.\" },\r\n        Function_implementation_name_must_be_0: { code: 2389, category: DiagnosticCategory.Error, key: \"Function implementation name must be '{0}'.\" },\r\n        Constructor_implementation_is_missing: { code: 2390, category: DiagnosticCategory.Error, key: \"Constructor implementation is missing.\" },\r\n        Function_implementation_is_missing_or_not_immediately_following_the_declaration: { code: 2391, category: DiagnosticCategory.Error, key: \"Function implementation is missing or not immediately following the declaration.\" },\r\n        Multiple_constructor_implementations_are_not_allowed: { code: 2392, category: DiagnosticCategory.Error, key: \"Multiple constructor implementations are not allowed.\" },\r\n        Duplicate_function_implementation: { code: 2393, category: DiagnosticCategory.Error, key: \"Duplicate function implementation.\" },\r\n        Overload_signature_is_not_compatible_with_function_implementation: { code: 2394, category: DiagnosticCategory.Error, key: \"Overload signature is not compatible with function implementation.\" },\r\n        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: { code: 2395, category: DiagnosticCategory.Error, key: \"Individual declarations in merged declaration {0} must be all exported or all local.\" },\r\n        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: { code: 2396, category: DiagnosticCategory.Error, key: \"Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.\" },\r\n        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: { code: 2397, category: DiagnosticCategory.Error, key: \"Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.\" },\r\n        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: { code: 2398, category: DiagnosticCategory.Error, key: \"Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.\" },\r\n        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: { code: 2399, category: DiagnosticCategory.Error, key: \"Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.\" },\r\n        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: { code: 2400, category: DiagnosticCategory.Error, key: \"Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.\" },\r\n        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: { code: 2401, category: DiagnosticCategory.Error, key: \"Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.\" },\r\n        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: { code: 2402, category: DiagnosticCategory.Error, key: \"Expression resolves to '_super' that compiler uses to capture base class reference.\" },\r\n        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: { code: 2403, category: DiagnosticCategory.Error, key: \"Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.\" },\r\n        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: { code: 2404, category: DiagnosticCategory.Error, key: \"The left-hand side of a 'for...in' statement cannot use a type annotation.\" },\r\n        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: { code: 2405, category: DiagnosticCategory.Error, key: \"The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.\" },\r\n        Invalid_left_hand_side_in_for_in_statement: { code: 2406, category: DiagnosticCategory.Error, key: \"Invalid left-hand side in 'for...in' statement.\" },\r\n        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2407, category: DiagnosticCategory.Error, key: \"The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.\" },\r\n        Setters_cannot_return_a_value: { code: 2408, category: DiagnosticCategory.Error, key: \"Setters cannot return a value.\" },\r\n        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: { code: 2409, category: DiagnosticCategory.Error, key: \"Return type of constructor signature must be assignable to the instance type of the class\" },\r\n        All_symbols_within_a_with_block_will_be_resolved_to_any: { code: 2410, category: DiagnosticCategory.Error, key: \"All symbols within a 'with' block will be resolved to 'any'.\" },\r\n        Property_0_of_type_1_is_not_assignable_to_string_index_type_2: { code: 2411, category: DiagnosticCategory.Error, key: \"Property '{0}' of type '{1}' is not assignable to string index type '{2}'.\" },\r\n        Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2: { code: 2412, category: DiagnosticCategory.Error, key: \"Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.\" },\r\n        Numeric_index_type_0_is_not_assignable_to_string_index_type_1: { code: 2413, category: DiagnosticCategory.Error, key: \"Numeric index type '{0}' is not assignable to string index type '{1}'.\" },\r\n        Class_name_cannot_be_0: { code: 2414, category: DiagnosticCategory.Error, key: \"Class name cannot be '{0}'\" },\r\n        Class_0_incorrectly_extends_base_class_1: { code: 2415, category: DiagnosticCategory.Error, key: \"Class '{0}' incorrectly extends base class '{1}'.\" },\r\n        Class_0_incorrectly_extends_base_class_1_Colon: { code: 2416, category: DiagnosticCategory.Error, key: \"Class '{0}' incorrectly extends base class '{1}':\" },\r\n        Class_static_side_0_incorrectly_extends_base_class_static_side_1: { code: 2417, category: DiagnosticCategory.Error, key: \"Class static side '{0}' incorrectly extends base class static side '{1}'.\" },\r\n        Class_static_side_0_incorrectly_extends_base_class_static_side_1_Colon: { code: 2418, category: DiagnosticCategory.Error, key: \"Class static side '{0}' incorrectly extends base class static side '{1}':\" },\r\n        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0: { code: 2419, category: DiagnosticCategory.Error, key: \"Type name '{0}' in extends clause does not reference constructor function for '{0}'.\" },\r\n        Class_0_incorrectly_implements_interface_1: { code: 2420, category: DiagnosticCategory.Error, key: \"Class '{0}' incorrectly implements interface '{1}'.\" },\r\n        Class_0_incorrectly_implements_interface_1_Colon: { code: 2421, category: DiagnosticCategory.Error, key: \"Class '{0}' incorrectly implements interface '{1}':\" },\r\n        A_class_may_only_implement_another_class_or_interface: { code: 2422, category: DiagnosticCategory.Error, key: \"A class may only implement another class or interface.\" },\r\n        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: { code: 2423, category: DiagnosticCategory.Error, key: \"Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.\" },\r\n        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: { code: 2424, category: DiagnosticCategory.Error, key: \"Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.\" },\r\n        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2425, category: DiagnosticCategory.Error, key: \"Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.\" },\r\n        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2426, category: DiagnosticCategory.Error, key: \"Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.\" },\r\n        Interface_name_cannot_be_0: { code: 2427, category: DiagnosticCategory.Error, key: \"Interface name cannot be '{0}'\" },\r\n        All_declarations_of_an_interface_must_have_identical_type_parameters: { code: 2428, category: DiagnosticCategory.Error, key: \"All declarations of an interface must have identical type parameters.\" },\r\n        Interface_0_incorrectly_extends_interface_1_Colon: { code: 2429, category: DiagnosticCategory.Error, key: \"Interface '{0}' incorrectly extends interface '{1}':\" },\r\n        Interface_0_incorrectly_extends_interface_1: { code: 2430, category: DiagnosticCategory.Error, key: \"Interface '{0}' incorrectly extends interface '{1}'.\" },\r\n        Enum_name_cannot_be_0: { code: 2431, category: DiagnosticCategory.Error, key: \"Enum name cannot be '{0}'\" },\r\n        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: { code: 2432, category: DiagnosticCategory.Error, key: \"In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.\" },\r\n        A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: { code: 2433, category: DiagnosticCategory.Error, key: \"A module declaration cannot be in a different file from a class or function with which it is merged\" },\r\n        A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: { code: 2434, category: DiagnosticCategory.Error, key: \"A module declaration cannot be located prior to a class or function with which it is merged\" },\r\n        Ambient_external_modules_cannot_be_nested_in_other_modules: { code: 2435, category: DiagnosticCategory.Error, key: \"Ambient external modules cannot be nested in other modules.\" },\r\n        Ambient_external_module_declaration_cannot_specify_relative_module_name: { code: 2436, category: DiagnosticCategory.Error, key: \"Ambient external module declaration cannot specify relative module name.\" },\r\n        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: { code: 2437, category: DiagnosticCategory.Error, key: \"Module '{0}' is hidden by a local declaration with the same name\" },\r\n        Import_name_cannot_be_0: { code: 2438, category: DiagnosticCategory.Error, key: \"Import name cannot be '{0}'\" },\r\n        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: { code: 2439, category: DiagnosticCategory.Error, key: \"Import declaration in an ambient external module declaration cannot reference external module through relative external module name.\" },\r\n        Import_declaration_conflicts_with_local_declaration_of_0: { code: 2440, category: DiagnosticCategory.Error, key: \"Import declaration conflicts with local declaration of '{0}'\" },\r\n        Import_declaration_0_is_using_private_name_1: { code: 4000, category: DiagnosticCategory.Error, key: \"Import declaration '{0}' is using private name '{1}'.\" },\r\n        Type_parameter_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4001, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: { code: 4002, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of exported class has or is using private name '{1}'.\" },\r\n        Type_parameter_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4003, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of exported interface has or is using name '{1}' from private module '{2}'.\" },\r\n        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4004, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of exported interface has or is using private name '{1}'.\" },\r\n        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4005, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.\" },\r\n        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4006, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.\" },\r\n        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4007, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.\" },\r\n        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4008, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.\" },\r\n        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4009, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4010, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.\" },\r\n        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4011, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4012, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of public method from exported class has or is using private name '{1}'.\" },\r\n        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4013, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.\" },\r\n        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4014, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of method from exported interface has or is using private name '{1}'.\" },\r\n        Type_parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4015, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.\" },\r\n        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4016, category: DiagnosticCategory.Error, key: \"Type parameter '{0}' of exported function has or is using private name '{1}'.\" },\r\n        Implements_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2: { code: 4017, category: DiagnosticCategory.Error, key: \"Implements clause of exported class '{0}' has or is using name '{1}' from private module '{2}'.\" },\r\n        Extends_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2: { code: 4018, category: DiagnosticCategory.Error, key: \"Extends clause of exported class '{0}' has or is using name '{1}' from private module '{2}'.\" },\r\n        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4019, category: DiagnosticCategory.Error, key: \"Implements clause of exported class '{0}' has or is using private name '{1}'.\" },\r\n        Extends_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4020, category: DiagnosticCategory.Error, key: \"Extends clause of exported class '{0}' has or is using private name '{1}'.\" },\r\n        Extends_clause_of_exported_interface_0_has_or_is_using_name_1_from_private_module_2: { code: 4021, category: DiagnosticCategory.Error, key: \"Extends clause of exported interface '{0}' has or is using name '{1}' from private module '{2}'.\" },\r\n        Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: { code: 4022, category: DiagnosticCategory.Error, key: \"Extends clause of exported interface '{0}' has or is using private name '{1}'.\" },\r\n        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4023, category: DiagnosticCategory.Error, key: \"Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.\" },\r\n        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: { code: 4024, category: DiagnosticCategory.Error, key: \"Exported variable '{0}' has or is using name '{1}' from private module '{2}'.\" },\r\n        Exported_variable_0_has_or_is_using_private_name_1: { code: 4025, category: DiagnosticCategory.Error, key: \"Exported variable '{0}' has or is using private name '{1}'.\" },\r\n        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4026, category: DiagnosticCategory.Error, key: \"Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\r\n        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4027, category: DiagnosticCategory.Error, key: \"Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4028, category: DiagnosticCategory.Error, key: \"Public static property '{0}' of exported class has or is using private name '{1}'.\" },\r\n        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4029, category: DiagnosticCategory.Error, key: \"Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\r\n        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4030, category: DiagnosticCategory.Error, key: \"Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Public_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4031, category: DiagnosticCategory.Error, key: \"Public property '{0}' of exported class has or is using private name '{1}'.\" },\r\n        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4032, category: DiagnosticCategory.Error, key: \"Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.\" },\r\n        Property_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4033, category: DiagnosticCategory.Error, key: \"Property '{0}' of exported interface has or is using private name '{1}'.\" },\r\n        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4034, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4035, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.\" },\r\n        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4036, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4037, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.\" },\r\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4038, category: DiagnosticCategory.Error, key: \"Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.\" },\r\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4039, category: DiagnosticCategory.Error, key: \"Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4040, category: DiagnosticCategory.Error, key: \"Return type of public static property getter from exported class has or is using private name '{0}'.\" },\r\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4041, category: DiagnosticCategory.Error, key: \"Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.\" },\r\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4042, category: DiagnosticCategory.Error, key: \"Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4043, category: DiagnosticCategory.Error, key: \"Return type of public property getter from exported class has or is using private name '{0}'.\" },\r\n        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4044, category: DiagnosticCategory.Error, key: \"Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4045, category: DiagnosticCategory.Error, key: \"Return type of constructor signature from exported interface has or is using private name '{0}'.\" },\r\n        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4046, category: DiagnosticCategory.Error, key: \"Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4047, category: DiagnosticCategory.Error, key: \"Return type of call signature from exported interface has or is using private name '{0}'.\" },\r\n        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4048, category: DiagnosticCategory.Error, key: \"Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4049, category: DiagnosticCategory.Error, key: \"Return type of index signature from exported interface has or is using private name '{0}'.\" },\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4050, category: DiagnosticCategory.Error, key: \"Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.\" },\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4051, category: DiagnosticCategory.Error, key: \"Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: { code: 4052, category: DiagnosticCategory.Error, key: \"Return type of public static method from exported class has or is using private name '{0}'.\" },\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4053, category: DiagnosticCategory.Error, key: \"Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.\" },\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4054, category: DiagnosticCategory.Error, key: \"Return type of public method from exported class has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: { code: 4055, category: DiagnosticCategory.Error, key: \"Return type of public method from exported class has or is using private name '{0}'.\" },\r\n        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4056, category: DiagnosticCategory.Error, key: \"Return type of method from exported interface has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: { code: 4057, category: DiagnosticCategory.Error, key: \"Return type of method from exported interface has or is using private name '{0}'.\" },\r\n        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4058, category: DiagnosticCategory.Error, key: \"Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.\" },\r\n        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: { code: 4059, category: DiagnosticCategory.Error, key: \"Return type of exported function has or is using name '{0}' from private module '{1}'.\" },\r\n        Return_type_of_exported_function_has_or_is_using_private_name_0: { code: 4060, category: DiagnosticCategory.Error, key: \"Return type of exported function has or is using private name '{0}'.\" },\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4061, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4062, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: { code: 4063, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of constructor from exported class has or is using private name '{1}'.\" },\r\n        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4064, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4065, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.\" },\r\n        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4066, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4067, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.\" },\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4068, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4069, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4070, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public static method from exported class has or is using private name '{1}'.\" },\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4071, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4072, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4073, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of public method from exported class has or is using private name '{1}'.\" },\r\n        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4074, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4075, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of method from exported interface has or is using private name '{1}'.\" },\r\n        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4076, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.\" },\r\n        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4077, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.\" },\r\n        Parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4078, category: DiagnosticCategory.Error, key: \"Parameter '{0}' of exported function has or is using private name '{1}'.\" },\r\n        The_current_host_does_not_support_the_0_option: { code: 5001, category: DiagnosticCategory.Error, key: \"The current host does not support the '{0}' option.\" },\r\n        Cannot_find_the_common_subdirectory_path_for_the_input_files: { code: 5009, category: DiagnosticCategory.Error, key: \"Cannot find the common subdirectory path for the input files.\" },\r\n        Cannot_read_file_0_Colon_1: { code: 5012, category: DiagnosticCategory.Error, key: \"Cannot read file '{0}': {1}\" },\r\n        Unsupported_file_encoding: { code: 5013, category: DiagnosticCategory.Error, key: \"Unsupported file encoding.\" },\r\n        Unknown_compiler_option_0: { code: 5023, category: DiagnosticCategory.Error, key: \"Unknown compiler option '{0}'.\" },\r\n        Could_not_write_file_0_Colon_1: { code: 5033, category: DiagnosticCategory.Error, key: \"Could not write file '{0}': {1}\" },\r\n        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5038, category: DiagnosticCategory.Error, key: \"Option mapRoot cannot be specified without specifying sourcemap option.\" },\r\n        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5039, category: DiagnosticCategory.Error, key: \"Option sourceRoot cannot be specified without specifying sourcemap option.\" },\r\n        Concatenate_and_emit_output_to_single_file: { code: 6001, category: DiagnosticCategory.Message, key: \"Concatenate and emit output to single file.\" },\r\n        Generates_corresponding_d_ts_file: { code: 6002, category: DiagnosticCategory.Message, key: \"Generates corresponding '.d.ts' file.\" },\r\n        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: { code: 6003, category: DiagnosticCategory.Message, key: \"Specifies the location where debugger should locate map files instead of generated locations.\" },\r\n        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: { code: 6004, category: DiagnosticCategory.Message, key: \"Specifies the location where debugger should locate TypeScript files instead of source locations.\" },\r\n        Watch_input_files: { code: 6005, category: DiagnosticCategory.Message, key: \"Watch input files.\" },\r\n        Redirect_output_structure_to_the_directory: { code: 6006, category: DiagnosticCategory.Message, key: \"Redirect output structure to the directory.\" },\r\n        Do_not_emit_comments_to_output: { code: 6009, category: DiagnosticCategory.Message, key: \"Do not emit comments to output.\" },\r\n        Specify_ECMAScript_target_version_Colon_ES3_default_or_ES5: { code: 6015, category: DiagnosticCategory.Message, key: \"Specify ECMAScript target version: 'ES3' (default), or 'ES5'\" },\r\n        Specify_module_code_generation_Colon_commonjs_or_amd: { code: 6016, category: DiagnosticCategory.Message, key: \"Specify module code generation: 'commonjs' or 'amd'\" },\r\n        Print_this_message: { code: 6017, category: DiagnosticCategory.Message, key: \"Print this message.\" },\r\n        Print_the_compiler_s_version: { code: 6019, category: DiagnosticCategory.Message, key: \"Print the compiler's version.\" },\r\n        Syntax_Colon_0: { code: 6023, category: DiagnosticCategory.Message, key: \"Syntax: {0}\" },\r\n        options: { code: 6024, category: DiagnosticCategory.Message, key: \"options\" },\r\n        file: { code: 6025, category: DiagnosticCategory.Message, key: \"file\" },\r\n        Examples_Colon_0: { code: 6026, category: DiagnosticCategory.Message, key: \"Examples: {0}\" },\r\n        Options_Colon: { code: 6027, category: DiagnosticCategory.Message, key: \"Options:\" },\r\n        Version_0: { code: 6029, category: DiagnosticCategory.Message, key: \"Version {0}\" },\r\n        Insert_command_line_options_and_files_from_a_file: { code: 6030, category: DiagnosticCategory.Message, key: \"Insert command line options and files from a file.\" },\r\n        File_change_detected_Compiling: { code: 6032, category: DiagnosticCategory.Message, key: \"File change detected. Compiling...\" },\r\n        KIND: { code: 6034, category: DiagnosticCategory.Message, key: \"KIND\" },\r\n        FILE: { code: 6035, category: DiagnosticCategory.Message, key: \"FILE\" },\r\n        VERSION: { code: 6036, category: DiagnosticCategory.Message, key: \"VERSION\" },\r\n        LOCATION: { code: 6037, category: DiagnosticCategory.Message, key: \"LOCATION\" },\r\n        DIRECTORY: { code: 6038, category: DiagnosticCategory.Message, key: \"DIRECTORY\" },\r\n        Compilation_complete_Watching_for_file_changes: { code: 6042, category: DiagnosticCategory.Message, key: \"Compilation complete. Watching for file changes.\" },\r\n        Generates_corresponding_map_file: { code: 6043, category: DiagnosticCategory.Message, key: \"Generates corresponding '.map' file.\" },\r\n        Compiler_option_0_expects_an_argument: { code: 6044, category: DiagnosticCategory.Error, key: \"Compiler option '{0}' expects an argument.\" },\r\n        Unterminated_quoted_string_in_response_file_0: { code: 6045, category: DiagnosticCategory.Error, key: \"Unterminated quoted string in response file '{0}'.\" },\r\n        Argument_for_module_option_must_be_commonjs_or_amd: { code: 6046, category: DiagnosticCategory.Error, key: \"Argument for '--module' option must be 'commonjs' or 'amd'.\" },\r\n        Argument_for_target_option_must_be_es3_or_es5: { code: 6047, category: DiagnosticCategory.Error, key: \"Argument for '--target' option must be 'es3' or 'es5'.\" },\r\n        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: { code: 6048, category: DiagnosticCategory.Error, key: \"Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.\" },\r\n        Unsupported_locale_0: { code: 6049, category: DiagnosticCategory.Error, key: \"Unsupported locale '{0}'.\" },\r\n        Unable_to_open_file_0: { code: 6050, category: DiagnosticCategory.Error, key: \"Unable to open file '{0}'.\" },\r\n        Corrupted_locale_file_0: { code: 6051, category: DiagnosticCategory.Error, key: \"Corrupted locale file {0}.\" },\r\n        Warn_on_expressions_and_declarations_with_an_implied_any_type: { code: 6052, category: DiagnosticCategory.Message, key: \"Warn on expressions and declarations with an implied 'any' type.\" },\r\n        File_0_not_found: { code: 6053, category: DiagnosticCategory.Error, key: \"File '{0}' not found.\" },\r\n        File_0_must_have_extension_ts_or_d_ts: { code: 6054, category: DiagnosticCategory.Error, key: \"File '{0}' must have extension '.ts' or '.d.ts'.\" },\r\n        Variable_0_implicitly_has_an_1_type: { code: 7005, category: DiagnosticCategory.Error, key: \"Variable '{0}' implicitly has an '{1}' type.\" },\r\n        Parameter_0_implicitly_has_an_1_type: { code: 7006, category: DiagnosticCategory.Error, key: \"Parameter '{0}' implicitly has an '{1}' type.\" },\r\n        Member_0_implicitly_has_an_1_type: { code: 7008, category: DiagnosticCategory.Error, key: \"Member '{0}' implicitly has an '{1}' type.\" },\r\n        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: { code: 7009, category: DiagnosticCategory.Error, key: \"'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.\" },\r\n        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: { code: 7010, category: DiagnosticCategory.Error, key: \"'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.\" },\r\n        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: { code: 7011, category: DiagnosticCategory.Error, key: \"Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.\" },\r\n        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7013, category: DiagnosticCategory.Error, key: \"Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.\" },\r\n        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation: { code: 7016, category: DiagnosticCategory.Error, key: \"Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation.\" },\r\n        Index_signature_of_object_type_implicitly_has_an_any_type: { code: 7017, category: DiagnosticCategory.Error, key: \"Index signature of object type implicitly has an 'any' type.\" },\r\n        Object_literal_s_property_0_implicitly_has_an_1_type: { code: 7018, category: DiagnosticCategory.Error, key: \"Object literal's property '{0}' implicitly has an '{1}' type.\" },\r\n        Rest_parameter_0_implicitly_has_an_any_type: { code: 7019, category: DiagnosticCategory.Error, key: \"Rest parameter '{0}' implicitly has an 'any[]' type.\" },\r\n        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7020, category: DiagnosticCategory.Error, key: \"Call signature, which lacks return-type annotation, implicitly has an 'any' return type.\" },\r\n        You_cannot_rename_this_element: { code: 8000, category: DiagnosticCategory.Error, key: \"You cannot rename this element.\" },\r\n    };\r\n}\r\n // file: src/compiler/scanner.ts\r\n/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"diagnosticInformationMap.generated.ts\"/>\r\n\r\nmodule ts {\r\n\r\n    export interface ErrorCallback {\r\n        (message: DiagnosticMessage): void;\r\n    }\r\n\r\n    export interface CommentCallback {\r\n        (pos: number, end: number): void;\r\n    }\r\n\r\n    export interface Scanner {\r\n        getStartPos(): number;\r\n        getToken(): SyntaxKind;\r\n        getTextPos(): number;\r\n        getTokenPos(): number;\r\n        getTokenText(): string;\r\n        getTokenValue(): string;\r\n        hasPrecedingLineBreak(): boolean;\r\n        isIdentifier(): boolean;\r\n        isReservedWord(): boolean;\r\n        reScanGreaterToken(): SyntaxKind;\r\n        reScanSlashToken(): SyntaxKind;\r\n        scan(): SyntaxKind;\r\n        setText(text: string): void;\r\n        setTextPos(textPos: number): void;\r\n        tryScan<T>(callback: () => T): T;\r\n    }\r\n\r\n    var textToToken: Map<SyntaxKind> = {\r\n        \"any\": SyntaxKind.AnyKeyword,\r\n        \"boolean\": SyntaxKind.BooleanKeyword,\r\n        \"break\": SyntaxKind.BreakKeyword,\r\n        \"case\": SyntaxKind.CaseKeyword,\r\n        \"catch\": SyntaxKind.CatchKeyword,\r\n        \"class\": SyntaxKind.ClassKeyword,\r\n        \"continue\": SyntaxKind.ContinueKeyword,\r\n        \"const\": SyntaxKind.ConstKeyword,\r\n        \"constructor\": SyntaxKind.ConstructorKeyword,\r\n        \"debugger\": SyntaxKind.DebuggerKeyword,\r\n        \"declare\": SyntaxKind.DeclareKeyword,\r\n        \"default\": SyntaxKind.DefaultKeyword,\r\n        \"delete\": SyntaxKind.DeleteKeyword,\r\n        \"do\": SyntaxKind.DoKeyword,\r\n        \"else\": SyntaxKind.ElseKeyword,\r\n        \"enum\": SyntaxKind.EnumKeyword,\r\n        \"export\": SyntaxKind.ExportKeyword,\r\n        \"extends\": SyntaxKind.ExtendsKeyword,\r\n        \"false\": SyntaxKind.FalseKeyword,\r\n        \"finally\": SyntaxKind.FinallyKeyword,\r\n        \"for\": SyntaxKind.ForKeyword,\r\n        \"function\": SyntaxKind.FunctionKeyword,\r\n        \"get\": SyntaxKind.GetKeyword,\r\n        \"if\": SyntaxKind.IfKeyword,\r\n        \"implements\": SyntaxKind.ImplementsKeyword,\r\n        \"import\": SyntaxKind.ImportKeyword,\r\n        \"in\": SyntaxKind.InKeyword,\r\n        \"instanceof\": SyntaxKind.InstanceOfKeyword,\r\n        \"interface\": SyntaxKind.InterfaceKeyword,\r\n        \"let\": SyntaxKind.LetKeyword,\r\n        \"module\": SyntaxKind.ModuleKeyword,\r\n        \"new\": SyntaxKind.NewKeyword,\r\n        \"null\": SyntaxKind.NullKeyword,\r\n        \"number\": SyntaxKind.NumberKeyword,\r\n        \"package\": SyntaxKind.PackageKeyword,\r\n        \"private\": SyntaxKind.PrivateKeyword,\r\n        \"protected\": SyntaxKind.ProtectedKeyword,\r\n        \"public\": SyntaxKind.PublicKeyword,\r\n        \"require\": SyntaxKind.RequireKeyword,\r\n        \"return\": SyntaxKind.ReturnKeyword,\r\n        \"set\": SyntaxKind.SetKeyword,\r\n        \"static\": SyntaxKind.StaticKeyword,\r\n        \"string\": SyntaxKind.StringKeyword,\r\n        \"super\": SyntaxKind.SuperKeyword,\r\n        \"switch\": SyntaxKind.SwitchKeyword,\r\n        \"this\": SyntaxKind.ThisKeyword,\r\n        \"throw\": SyntaxKind.ThrowKeyword,\r\n        \"true\": SyntaxKind.TrueKeyword,\r\n        \"try\": SyntaxKind.TryKeyword,\r\n        \"typeof\": SyntaxKind.TypeOfKeyword,\r\n        \"var\": SyntaxKind.VarKeyword,\r\n        \"void\": SyntaxKind.VoidKeyword,\r\n        \"while\": SyntaxKind.WhileKeyword,\r\n        \"with\": SyntaxKind.WithKeyword,\r\n        \"yield\": SyntaxKind.YieldKeyword,\r\n        \"{\": SyntaxKind.OpenBraceToken,\r\n        \"}\": SyntaxKind.CloseBraceToken,\r\n        \"(\": SyntaxKind.OpenParenToken,\r\n        \")\": SyntaxKind.CloseParenToken,\r\n        \"[\": SyntaxKind.OpenBracketToken,\r\n        \"]\": SyntaxKind.CloseBracketToken,\r\n        \".\": SyntaxKind.DotToken,\r\n        \"...\": SyntaxKind.DotDotDotToken,\r\n        \";\": SyntaxKind.SemicolonToken,\r\n        \",\": SyntaxKind.CommaToken,\r\n        \"<\": SyntaxKind.LessThanToken,\r\n        \">\": SyntaxKind.GreaterThanToken,\r\n        \"<=\": SyntaxKind.LessThanEqualsToken,\r\n        \">=\": SyntaxKind.GreaterThanEqualsToken,\r\n        \"==\": SyntaxKind.EqualsEqualsToken,\r\n        \"!=\": SyntaxKind.ExclamationEqualsToken,\r\n        \"===\": SyntaxKind.EqualsEqualsEqualsToken,\r\n        \"!==\": SyntaxKind.ExclamationEqualsEqualsToken,\r\n        \"=>\": SyntaxKind.EqualsGreaterThanToken,\r\n        \"+\": SyntaxKind.PlusToken,\r\n        \"-\": SyntaxKind.MinusToken,\r\n        \"*\": SyntaxKind.AsteriskToken,\r\n        \"/\": SyntaxKind.SlashToken,\r\n        \"%\": SyntaxKind.PercentToken,\r\n        \"++\": SyntaxKind.PlusPlusToken,\r\n        \"--\": SyntaxKind.MinusMinusToken,\r\n        \"<<\": SyntaxKind.LessThanLessThanToken,\r\n        \">>\": SyntaxKind.GreaterThanGreaterThanToken,\r\n        \">>>\": SyntaxKind.GreaterThanGreaterThanGreaterThanToken,\r\n        \"&\": SyntaxKind.AmpersandToken,\r\n        \"|\": SyntaxKind.BarToken,\r\n        \"^\": SyntaxKind.CaretToken,\r\n        \"!\": SyntaxKind.ExclamationToken,\r\n        \"~\": SyntaxKind.TildeToken,\r\n        \"&&\": SyntaxKind.AmpersandAmpersandToken,\r\n        \"||\": SyntaxKind.BarBarToken,\r\n        \"?\": SyntaxKind.QuestionToken,\r\n        \":\": SyntaxKind.ColonToken,\r\n        \"=\": SyntaxKind.EqualsToken,\r\n        \"+=\": SyntaxKind.PlusEqualsToken,\r\n        \"-=\": SyntaxKind.MinusEqualsToken,\r\n        \"*=\": SyntaxKind.AsteriskEqualsToken,\r\n        \"/=\": SyntaxKind.SlashEqualsToken,\r\n        \"%=\": SyntaxKind.PercentEqualsToken,\r\n        \"<<=\": SyntaxKind.LessThanLessThanEqualsToken,\r\n        \">>=\": SyntaxKind.GreaterThanGreaterThanEqualsToken,\r\n        \">>>=\": SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,\r\n        \"&=\": SyntaxKind.AmpersandEqualsToken,\r\n        \"|=\": SyntaxKind.BarEqualsToken,\r\n        \"^=\": SyntaxKind.CaretEqualsToken,\r\n    };\r\n\r\n    /*\r\n        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers\r\n        IdentifierStart ::\r\n            Can contain Unicode 3.0.0  categories:\r\n            Uppercase letter (Lu),\r\n            Lowercase letter (Ll),\r\n            Titlecase letter (Lt),\r\n            Modifier letter (Lm),\r\n            Other letter (Lo), or\r\n            Letter number (Nl).\r\n        IdentifierPart :: =\r\n            Can contain IdentifierStart + Unicode 3.0.0  categories:\r\n            Non-spacing mark (Mn),\r\n            Combining spacing mark (Mc),\r\n            Decimal number (Nd), or\r\n            Connector punctuation (Pc).\r\n\r\n        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:\r\n        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\r\n    */\r\n    var unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n    var unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n\r\n    /*\r\n        As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers\r\n        IdentifierStart ::\r\n            Can contain Unicode 6.2  categories:\r\n            Uppercase letter (Lu),\r\n            Lowercase letter (Ll),\r\n            Titlecase letter (Lt),\r\n            Modifier letter (Lm),\r\n            Other letter (Lo), or\r\n            Letter number (Nl).\r\n        IdentifierPart ::\r\n            Can contain IdentifierStart + Unicode 6.2  categories:\r\n            Non-spacing mark (Mn),\r\n            Combining spacing mark (Mc),\r\n            Decimal number (Nd),\r\n            Connector punctuation (Pc),\r\n            <ZWNJ>, or\r\n            <ZWJ>.\r\n\r\n        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:\r\n        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt\r\n    */\r\n    var unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n    var unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];\r\n\r\n    function lookupInUnicodeMap(code: number, map: number[]): boolean {\r\n        // Bail out quickly if it couldn't possibly be in the map.\r\n        if (code < map[0]) {\r\n            return false;\r\n        }\r\n\r\n        // Perform binary search in one of the unicode range maps\r\n        var lo: number = 0;\r\n        var hi: number = map.length;\r\n        var mid: number;\r\n\r\n        while (lo + 1 < hi) {\r\n            mid = lo + (hi - lo) / 2;\r\n            // mid has to be even to catch a range's beginning\r\n            mid -= mid % 2;\r\n            if (map[mid] <= code && code <= map[mid + 1]) {\r\n                return true;\r\n            }\r\n\r\n            if (code < map[mid]) {\r\n                hi = mid;\r\n            }\r\n            else {\r\n                lo = mid + 2;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isUnicodeIdentifierStart(code: number, languageVersion: ScriptTarget) {\r\n        return languageVersion === ScriptTarget.ES3 ?\r\n            lookupInUnicodeMap(code, unicodeES3IdentifierStart) :\r\n            lookupInUnicodeMap(code, unicodeES5IdentifierStart);\r\n    }\r\n\r\n    function isUnicodeIdentifierPart(code: number, languageVersion: ScriptTarget) {\r\n        return languageVersion === ScriptTarget.ES3 ?\r\n            lookupInUnicodeMap(code, unicodeES3IdentifierPart) :\r\n            lookupInUnicodeMap(code, unicodeES5IdentifierPart);\r\n    }\r\n\r\n    function makeReverseMap(source: Map<number>): string[] {\r\n        var result: string[] = [];\r\n        for (var name in source) {\r\n            if (source.hasOwnProperty(name)) {\r\n                result[source[name]] = name;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    var tokenStrings = makeReverseMap(textToToken);\r\n\r\n    export function tokenToString(t: SyntaxKind): string {\r\n        return tokenStrings[t];\r\n    }\r\n\r\n    export function getLineStarts(text: string): number[] {\r\n        var result: number[] = new Array();\r\n        var pos = 0;\r\n        var lineStart = 0;\r\n        while (pos < text.length) {\r\n            switch (text.charCodeAt(pos++)) {\r\n                case CharacterCodes.carriageReturn:\r\n                    if (text.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                        pos++;\r\n                    }\r\n                case CharacterCodes.lineFeed:\r\n                    result.push(lineStart);\r\n                    lineStart = pos;\r\n                    break;\r\n            }\r\n        }\r\n        result.push(lineStart);\r\n        return result;\r\n    }\r\n\r\n    export function getPositionFromLineAndCharacter(lineStarts: number[], line: number, character: number): number {\r\n        Debug.assert(line > 0);\r\n        return lineStarts[line - 1] + character - 1;\r\n    }\r\n\r\n    export function getLineAndCharacterOfPosition(lineStarts: number[], position: number) {\r\n        var lineNumber = binarySearch(lineStarts, position);\r\n        if (lineNumber < 0) {\r\n            // If the actual position was not found, \r\n            // the binary search returns the negative value of the next line start\r\n            // eg. if line starts at [5, 10, 23, 80] and position requested was 20 \r\n            // the search will return -2\r\n            lineNumber = (~lineNumber) - 1;\r\n        }\r\n        return {\r\n            line: lineNumber + 1,\r\n            character: position - lineStarts[lineNumber] + 1\r\n        };\r\n    }\r\n\r\n    export function positionToLineAndCharacter(text: string, pos: number) {\r\n        var lineStarts = getLineStarts(text);\r\n        return getLineAndCharacterOfPosition(lineStarts, pos);\r\n    }\r\n\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    export function isWhiteSpace(ch: number): boolean {\r\n        return ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\r\n            ch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\r\n            ch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\r\n    }\r\n\r\n    export function isLineBreak(ch: number): boolean {\r\n        return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\r\n    }\r\n\r\n    function isDigit(ch: number): boolean {\r\n        return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\r\n    }\r\n\r\n    export function isOctalDigit(ch: number): boolean {\r\n        return ch >= CharacterCodes._0 && ch <= CharacterCodes._7;\r\n    }\r\n\r\n    export function skipTrivia(text: string, pos: number, stopAfterLineBreak?: boolean): number {\r\n        while (true) {\r\n            var ch = text.charCodeAt(pos);\r\n            switch (ch) {\r\n                case CharacterCodes.carriageReturn:\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.lineFeed) pos++;\r\n                case CharacterCodes.lineFeed:\r\n                    pos++;\r\n                    if (stopAfterLineBreak) return pos;\r\n                    continue;\r\n                case CharacterCodes.tab:\r\n                case CharacterCodes.verticalTab:\r\n                case CharacterCodes.formFeed:\r\n                case CharacterCodes.space:\r\n                    pos++;\r\n                    continue;\r\n                case CharacterCodes.slash:\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                        pos += 2;\r\n                        while (pos < text.length) {\r\n                            if (isLineBreak(text.charCodeAt(pos))) {\r\n                                break;\r\n                            }\r\n                            pos++;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                        pos += 2;\r\n                        while (pos < text.length) {\r\n                            if (text.charCodeAt(pos) === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                pos += 2;\r\n                                break;\r\n                            }\r\n                            pos++;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (ch > CharacterCodes.maxAsciiCharacter && (isWhiteSpace(ch) || isLineBreak(ch))) {\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                    break;\r\n            }\r\n            return pos;\r\n        }\r\n    }\r\n\r\n    // Extract comments from the given source text starting at the given position. If trailing is false, whitespace is skipped until\r\n    // the first line break and comments between that location and the next token are returned. If trailing is true, comments occurring\r\n    // between the given position and the next line break are returned. The return value is an array containing a TextRange for each\r\n    // comment. Single-line comment ranges include the the beginning '//' characters but not the ending line break. Multi-line comment\r\n    // ranges include the beginning '/* and ending '*/' characters. The return value is undefined if no comments were found.\r\n    function getCommentRanges(text: string, pos: number, trailing: boolean): Comment[] {\r\n        var result: Comment[];\r\n        var collecting = trailing || pos === 0;\r\n        while (true) {\r\n            var ch = text.charCodeAt(pos);\r\n            switch (ch) {\r\n                case CharacterCodes.carriageReturn:\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.lineFeed) pos++;\r\n                case CharacterCodes.lineFeed:\r\n                    pos++;\r\n                    if (trailing) {\r\n                        return result;\r\n                    }\r\n                    collecting = true;\r\n                    if (result && result.length) {\r\n                        result[result.length - 1].hasTrailingNewLine = true;\r\n                    }\r\n                    continue;\r\n                case CharacterCodes.tab:\r\n                case CharacterCodes.verticalTab:\r\n                case CharacterCodes.formFeed:\r\n                case CharacterCodes.space:\r\n                    pos++;\r\n                    continue;\r\n                case CharacterCodes.slash:\r\n                    var nextChar = text.charCodeAt(pos + 1);\r\n                    var hasTrailingNewLine = false;\r\n                    if (nextChar === CharacterCodes.slash || nextChar === CharacterCodes.asterisk) {\r\n                        var startPos = pos;\r\n                        pos += 2;\r\n                        if (nextChar === CharacterCodes.slash) {\r\n                            while (pos < text.length) {\r\n                                if (isLineBreak(text.charCodeAt(pos))) {\r\n                                    hasTrailingNewLine = true;\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n                            }\r\n                        }\r\n                        else {\r\n                            while (pos < text.length) {\r\n                                if (text.charCodeAt(pos) === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                    pos += 2;\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n                            }\r\n                        }\r\n                        if (collecting) {\r\n                            if (!result) result = [];\r\n                            result.push({ pos: startPos, end: pos, hasTrailingNewLine: hasTrailingNewLine });\r\n                        }\r\n                        continue;\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (ch > CharacterCodes.maxAsciiCharacter && (isWhiteSpace(ch) || isLineBreak(ch))) {\r\n                        if (result && result.length && isLineBreak(ch)) {\r\n                            result[result.length - 1].hasTrailingNewLine = true;\r\n                        }\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                    break;\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    export function getLeadingComments(text: string, pos: number): Comment[] {\r\n        return getCommentRanges(text, pos, /*trailing*/ false);\r\n    }\r\n\r\n    export function getTrailingComments(text: string, pos: number): Comment[] {\r\n        return getCommentRanges(text, pos, /*trailing*/ true);\r\n    }\r\n\r\n    export function createScanner(languageVersion: ScriptTarget, text?: string, onError?: ErrorCallback, onComment?: CommentCallback): Scanner {\r\n        var pos: number;       // Current position (end position of text of current token)\r\n        var len: number;       // Length of text\r\n        var startPos: number;  // Start position of whitespace before current token\r\n        var tokenPos: number;  // Start position of text of current token\r\n        var token: number;\r\n        var tokenValue: string;\r\n        var precedingLineBreak: boolean;\r\n\r\n        function error(message: DiagnosticMessage): void {\r\n            if (onError) {\r\n                onError(message);\r\n            }\r\n        }\r\n\r\n        function isIdentifierStart(ch: number): boolean {\r\n            return ch >= CharacterCodes.A && ch <= CharacterCodes.Z || ch >= CharacterCodes.a && ch <= CharacterCodes.z ||\r\n                ch === CharacterCodes.$ || ch === CharacterCodes._ ||\r\n                ch > CharacterCodes.maxAsciiCharacter && isUnicodeIdentifierStart(ch, languageVersion);\r\n        }\r\n\r\n        function isIdentifierPart(ch: number): boolean {\r\n            return ch >= CharacterCodes.A && ch <= CharacterCodes.Z || ch >= CharacterCodes.a && ch <= CharacterCodes.z ||\r\n                ch >= CharacterCodes._0 && ch <= CharacterCodes._9 || ch === CharacterCodes.$ || ch === CharacterCodes._ ||\r\n                ch > CharacterCodes.maxAsciiCharacter && isUnicodeIdentifierPart(ch, languageVersion);\r\n        }\r\n\r\n        function scanNumber(): number {\r\n            var start = pos;\r\n            while (isDigit(text.charCodeAt(pos))) pos++;\r\n            if (text.charCodeAt(pos) === CharacterCodes.dot) {\r\n                pos++;\r\n                while (isDigit(text.charCodeAt(pos))) pos++;\r\n            }\r\n            var end = pos;\r\n            if (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e) {\r\n                pos++;\r\n                if (text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) pos++;\r\n                if (isDigit(text.charCodeAt(pos))) {\r\n                    pos++;\r\n                    while (isDigit(text.charCodeAt(pos))) pos++;\r\n                    end = pos;\r\n                }\r\n                else {\r\n                    error(Diagnostics.Digit_expected);\r\n                }\r\n            }\r\n            return +(text.substring(start, end));\r\n        }\r\n\r\n        function scanOctalDigits(): number {\r\n            var start = pos;\r\n            while (isOctalDigit(text.charCodeAt(pos))) {\r\n                pos++;\r\n            }\r\n            return +(text.substring(start, pos));\r\n        }\r\n\r\n        function scanHexDigits(count: number, exact?: boolean): number {\r\n            var digits = 0;\r\n            var value = 0;\r\n            while (digits < count || !exact) {\r\n                var ch = text.charCodeAt(pos);\r\n                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\r\n                    value = value * 16 + ch - CharacterCodes._0;\r\n                }\r\n                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\r\n                    value = value * 16 + ch - CharacterCodes.A + 10;\r\n                }\r\n                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\r\n                    value = value * 16 + ch - CharacterCodes.a + 10;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n                pos++;\r\n                digits++;\r\n            }\r\n            if (digits < count) {\r\n                value = -1;\r\n            }\r\n            return value;\r\n        }\r\n\r\n        function scanString(): string {\r\n            var quote = text.charCodeAt(pos++);\r\n            var result = \"\";\r\n            var start = pos;\r\n            while (true) {\r\n                if (pos >= len) {\r\n                    result += text.substring(start, pos);\r\n                    error(Diagnostics.Unexpected_end_of_text);\r\n                    break;\r\n                }\r\n                var ch = text.charCodeAt(pos);\r\n                if (ch === quote) {\r\n                    result += text.substring(start, pos);\r\n                    pos++;\r\n                    break;\r\n                }\r\n                if (ch === CharacterCodes.backslash) {\r\n                    result += text.substring(start, pos);\r\n                    pos++;\r\n                    if (pos >= len) {\r\n                        error(Diagnostics.Unexpected_end_of_text);\r\n                        break;\r\n                    }\r\n                    ch = text.charCodeAt(pos++);\r\n                    switch (ch) {\r\n                        case CharacterCodes._0:\r\n                            result += \"\\0\";\r\n                            break;\r\n                        case CharacterCodes.b:\r\n                            result += \"\\b\";\r\n                            break;\r\n                        case CharacterCodes.t:\r\n                            result += \"\\t\";\r\n                            break;\r\n                        case CharacterCodes.n:\r\n                            result += \"\\n\";\r\n                            break;\r\n                        case CharacterCodes.v:\r\n                            result += \"\\v\";\r\n                            break;\r\n                        case CharacterCodes.f:\r\n                            result += \"\\f\";\r\n                            break;\r\n                        case CharacterCodes.r:\r\n                            result += \"\\r\";\r\n                            break;\r\n                        case CharacterCodes.singleQuote:\r\n                            result += \"\\'\";\r\n                            break;\r\n                        case CharacterCodes.doubleQuote:\r\n                            result += \"\\\"\";\r\n                            break;\r\n                        case CharacterCodes.x:\r\n                        case CharacterCodes.u:\r\n                            var ch = scanHexDigits(ch === CharacterCodes.x ? 2 : 4, true);\r\n                            if (ch >= 0) {\r\n                                result += String.fromCharCode(ch);\r\n                            }\r\n                            else {\r\n                                error(Diagnostics.Hexadecimal_digit_expected);\r\n                            }\r\n                            break;\r\n                        case CharacterCodes.carriageReturn:\r\n                            if (pos < len && text.charCodeAt(pos) === CharacterCodes.lineFeed) pos++;\r\n                            break;\r\n                        case CharacterCodes.lineFeed:\r\n                        case CharacterCodes.lineSeparator:\r\n                        case CharacterCodes.paragraphSeparator:\r\n                            break;\r\n                        default:\r\n                            result += String.fromCharCode(ch);\r\n                    }\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n                if (isLineBreak(ch)) {\r\n                    result += text.substring(start, pos);\r\n                    error(Diagnostics.Unterminated_string_literal);\r\n                    break;\r\n                }\r\n                pos++;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Current character is known to be a backslash. Check for Unicode escape of the form '\\uXXXX'\r\n        // and return code point value if valid Unicode escape is found. Otherwise return -1.\r\n        function peekUnicodeEscape(): number {\r\n            if (pos + 5 < len && text.charCodeAt(pos + 1) === CharacterCodes.u) {\r\n                var start = pos;\r\n                pos += 2;\r\n                var value = scanHexDigits(4, true);\r\n                pos = start;\r\n                return value;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        function scanIdentifierParts(): string {\r\n            var result = \"\";\r\n            var start = pos;\r\n            while (pos < len) {\r\n                var ch = text.charCodeAt(pos);\r\n                if (isIdentifierPart(ch)) {\r\n                    pos++;\r\n                }\r\n                else if (ch === CharacterCodes.backslash) {\r\n                    ch = peekUnicodeEscape();\r\n                    if (!(ch >= 0 && isIdentifierPart(ch))) {\r\n                        break;\r\n                    }\r\n                    result += text.substring(start, pos);\r\n                    result += String.fromCharCode(ch);\r\n                    // Valid Unicode escape is always six characters\r\n                    pos += 6;\r\n                    start = pos;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            result += text.substring(start, pos);\r\n            return result;\r\n        }\r\n\r\n        function getIdentifierToken(): SyntaxKind {\r\n            // Reserved words are between 2 and 11 characters long and start with a lowercase letter\r\n            var len = tokenValue.length;\r\n            if (len >= 2 && len <= 11) {\r\n                var ch = tokenValue.charCodeAt(0);\r\n                if (ch >= CharacterCodes.a && ch <= CharacterCodes.z && hasOwnProperty.call(textToToken, tokenValue)) {\r\n                    return token = textToToken[tokenValue];\r\n                }\r\n            }\r\n            return token = SyntaxKind.Identifier;\r\n        }\r\n\r\n        function scan(): SyntaxKind {\r\n            startPos = pos;\r\n            precedingLineBreak = false;\r\n            while (true) {\r\n                tokenPos = pos;\r\n                if (pos >= len) {\r\n                    return token = SyntaxKind.EndOfFileToken;\r\n                }\r\n                var ch = text.charCodeAt(pos);\r\n                switch (ch) {\r\n                    case CharacterCodes.lineFeed:\r\n                    case CharacterCodes.carriageReturn:\r\n                        precedingLineBreak = true;\r\n                    case CharacterCodes.tab:\r\n                    case CharacterCodes.verticalTab:\r\n                    case CharacterCodes.formFeed:\r\n                    case CharacterCodes.space:\r\n                        pos++;\r\n                        continue;\r\n                    case CharacterCodes.exclamation:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.ExclamationEqualsEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.ExclamationEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.ExclamationToken;\r\n                    case CharacterCodes.doubleQuote:\r\n                    case CharacterCodes.singleQuote:\r\n                        tokenValue = scanString();\r\n                        return token = SyntaxKind.StringLiteral;\r\n                    case CharacterCodes.percent:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.PercentEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.PercentToken;\r\n                    case CharacterCodes.ampersand:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.ampersand) {\r\n                            return pos += 2, token = SyntaxKind.AmpersandAmpersandToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.AmpersandEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.AmpersandToken;\r\n                    case CharacterCodes.openParen:\r\n                        return pos++, token = SyntaxKind.OpenParenToken;\r\n                    case CharacterCodes.closeParen:\r\n                        return pos++, token = SyntaxKind.CloseParenToken;\r\n                    case CharacterCodes.asterisk:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.AsteriskEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.AsteriskToken;\r\n                    case CharacterCodes.plus:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.plus) {\r\n                            return pos += 2, token = SyntaxKind.PlusPlusToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.PlusEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.PlusToken;\r\n                    case CharacterCodes.comma:\r\n                        return pos++, token = SyntaxKind.CommaToken;\r\n                    case CharacterCodes.minus:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.minus) {\r\n                            return pos += 2, token = SyntaxKind.MinusMinusToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.MinusEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.MinusToken;\r\n                    case CharacterCodes.dot:\r\n                        if (isDigit(text.charCodeAt(pos + 1))) {\r\n                            tokenValue = \"\" + scanNumber();\r\n                            return token = SyntaxKind.NumericLiteral;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.dot && text.charCodeAt(pos + 2) === CharacterCodes.dot) {\r\n                            return pos += 3, token = SyntaxKind.DotDotDotToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.DotToken;\r\n                    case CharacterCodes.slash:\r\n                        // Single-line comment\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                            pos += 2;\r\n\r\n                            while (pos < len) {\r\n                                if (isLineBreak(text.charCodeAt(pos))) {\r\n                                    break;\r\n                                }\r\n                                pos++;\r\n\r\n                            }\r\n                            if (onComment) {\r\n                                onComment(tokenPos, pos);\r\n                            }\r\n                            continue;\r\n                        }\r\n                        // Multi-line comment\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                            pos += 2;\r\n\r\n                            var commentClosed = false;\r\n                            while (pos < len) {\r\n                                var ch = text.charCodeAt(pos);\r\n\r\n                                if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                    pos += 2;\r\n                                    commentClosed = true;\r\n                                    break;\r\n                                }\r\n\r\n                                if (isLineBreak(ch)) {\r\n                                    precedingLineBreak = true;\r\n                                }\r\n                                pos++;\r\n                            }\r\n\r\n                            if (!commentClosed) {\r\n                                error(Diagnostics.Asterisk_Slash_expected);\r\n                            }\r\n\r\n                            if (onComment) {\r\n                                onComment(tokenPos, pos);\r\n                            }\r\n\r\n                            continue;\r\n                        }\r\n\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.SlashEqualsToken;\r\n                        }\r\n\r\n                        return pos++, token = SyntaxKind.SlashToken;\r\n\r\n                    case CharacterCodes._0:\r\n                        if (pos + 2 < len && (text.charCodeAt(pos + 1) === CharacterCodes.X || text.charCodeAt(pos + 1) === CharacterCodes.x)) {\r\n                            pos += 2;\r\n                            var value = scanHexDigits(1, false);\r\n                            if (value < 0) {\r\n                                error(Diagnostics.Hexadecimal_digit_expected);\r\n                                value = 0;\r\n                            }\r\n                            tokenValue = \"\" + value;\r\n                            return SyntaxKind.NumericLiteral;\r\n                        }\r\n                        // Try to parse as an octal\r\n                        if (pos + 1 < len && isOctalDigit(text.charCodeAt(pos + 1))) {\r\n                            tokenValue = \"\" + scanOctalDigits();\r\n                            return SyntaxKind.NumericLiteral;\r\n                        }\r\n                        // This fall-through is a deviation from the EcmaScript grammar. The grammar says that a leading zero\r\n                        // can only be followed by an octal digit, a dot, or the end of the number literal. However, we are being\r\n                        // permissive and allowing decimal digits of the form 08* and 09* (which many browsers also do).\r\n                    case CharacterCodes._1:\r\n                    case CharacterCodes._2:\r\n                    case CharacterCodes._3:\r\n                    case CharacterCodes._4:\r\n                    case CharacterCodes._5:\r\n                    case CharacterCodes._6:\r\n                    case CharacterCodes._7:\r\n                    case CharacterCodes._8:\r\n                    case CharacterCodes._9:\r\n                        tokenValue = \"\" + scanNumber();\r\n                        return token = SyntaxKind.NumericLiteral;\r\n                    case CharacterCodes.colon:\r\n                        return pos++, token = SyntaxKind.ColonToken;\r\n                    case CharacterCodes.semicolon:\r\n                        return pos++, token = SyntaxKind.SemicolonToken;\r\n                    case CharacterCodes.lessThan:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.lessThan) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.LessThanLessThanEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.LessThanLessThanToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.LessThanEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.LessThanToken;\r\n                    case CharacterCodes.equals:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                                return pos += 3, token = SyntaxKind.EqualsEqualsEqualsToken;\r\n                            }\r\n                            return pos += 2, token = SyntaxKind.EqualsEqualsToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.greaterThan) {\r\n                            return pos += 2, token = SyntaxKind.EqualsGreaterThanToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.EqualsToken;\r\n                    case CharacterCodes.greaterThan:\r\n                        return pos++, token = SyntaxKind.GreaterThanToken;\r\n                    case CharacterCodes.question:\r\n                        return pos++, token = SyntaxKind.QuestionToken;\r\n                    case CharacterCodes.openBracket:\r\n                        return pos++, token = SyntaxKind.OpenBracketToken;\r\n                    case CharacterCodes.closeBracket:\r\n                        return pos++, token = SyntaxKind.CloseBracketToken;\r\n                    case CharacterCodes.caret:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.CaretEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.CaretToken;\r\n                    case CharacterCodes.openBrace:\r\n                        return pos++, token = SyntaxKind.OpenBraceToken;\r\n                    case CharacterCodes.bar:\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.bar) {\r\n                            return pos += 2, token = SyntaxKind.BarBarToken;\r\n                        }\r\n                        if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                            return pos += 2, token = SyntaxKind.BarEqualsToken;\r\n                        }\r\n                        return pos++, token = SyntaxKind.BarToken;\r\n                    case CharacterCodes.closeBrace:\r\n                        return pos++, token = SyntaxKind.CloseBraceToken;\r\n                    case CharacterCodes.tilde:\r\n                        return pos++, token = SyntaxKind.TildeToken;\r\n                    case CharacterCodes.backslash:\r\n                        var ch = peekUnicodeEscape();\r\n                        if (ch >= 0 && isIdentifierStart(ch)) {\r\n                            pos += 6;\r\n                            tokenValue = String.fromCharCode(ch) + scanIdentifierParts();\r\n                            return token = getIdentifierToken();\r\n                        }\r\n                        error(Diagnostics.Invalid_character);\r\n                        return pos++, token = SyntaxKind.Unknown;\r\n                    default:\r\n                        if (isIdentifierStart(ch)) {\r\n                            pos++;\r\n                            while (pos < len && isIdentifierPart(ch = text.charCodeAt(pos))) pos++;\r\n                            tokenValue = text.substring(tokenPos, pos);\r\n                            if (ch === CharacterCodes.backslash) {\r\n                                tokenValue += scanIdentifierParts();\r\n                            }\r\n                            return token = getIdentifierToken();\r\n                        }\r\n                        else if (isWhiteSpace(ch)) {\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        else if (isLineBreak(ch)) {\r\n                            precedingLineBreak = true;\r\n                            pos++;\r\n                            continue;\r\n                        }\r\n                        error(Diagnostics.Invalid_character);\r\n                        return pos++, token = SyntaxKind.Unknown;\r\n                }\r\n            }\r\n        }\r\n\r\n        function reScanGreaterToken(): SyntaxKind {\r\n            if (token === SyntaxKind.GreaterThanToken) {\r\n                if (text.charCodeAt(pos) === CharacterCodes.greaterThan) {\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.greaterThan) {\r\n                        if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {\r\n                            return pos += 3, token = SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken;\r\n                        }\r\n                        return pos += 2, token = SyntaxKind.GreaterThanGreaterThanGreaterThanToken;\r\n                    }\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {\r\n                        return pos += 2, token = SyntaxKind.GreaterThanGreaterThanEqualsToken;\r\n                    }\r\n                    return pos++, token = SyntaxKind.GreaterThanGreaterThanToken;\r\n                }\r\n                if (text.charCodeAt(pos) === CharacterCodes.equals) {\r\n                    return pos++, token = SyntaxKind.GreaterThanEqualsToken;\r\n                }\r\n            }\r\n            return token;\r\n        }\r\n\r\n        function reScanSlashToken(): SyntaxKind {\r\n            if (token === SyntaxKind.SlashToken || token === SyntaxKind.SlashEqualsToken) {\r\n                var p = tokenPos + 1;\r\n                var inEscape = false;\r\n                var inCharacterClass = false;\r\n                while (true) {\r\n                    // If we've hit EOF without closing off the regex,\r\n                    // simply return the token we originally parsed.\r\n                    if (p >= len) {\r\n                        return token;\r\n                    }\r\n\r\n                    var ch = text.charCodeAt(p);\r\n\r\n                    // Line breaks are not permissible in the middle of a RegExp.\r\n                    if (isLineBreak(ch)) {\r\n                        return token;\r\n                    }\r\n                    \r\n                    if (inEscape) {\r\n                        // Parsing an escape character;\r\n                        // reset the flag and just advance to the next char.\r\n                        inEscape = false;\r\n                    }\r\n                    else if (ch === CharacterCodes.slash && !inCharacterClass) {\r\n                        // A slash within a character class is permissible,\r\n                        // but in general it signals the end of the regexp literal.\r\n                        break;\r\n                    }\r\n                    else if (ch === CharacterCodes.openBracket) {\r\n                        inCharacterClass = true;\r\n                    }\r\n                    else if (ch === CharacterCodes.backslash) {\r\n                        inEscape = true;\r\n                    }\r\n                    else if (ch === CharacterCodes.closeBracket) {\r\n                        inCharacterClass = false;\r\n                    }\r\n                    p++;\r\n                }\r\n                p++;\r\n                while (isIdentifierPart(text.charCodeAt(p))) {\r\n                    p++;\r\n                }\r\n                pos = p;\r\n                tokenValue = text.substring(tokenPos, pos);\r\n                token = SyntaxKind.RegularExpressionLiteral;\r\n            }\r\n            return token;\r\n        }\r\n\r\n        function tryScan<T>(callback: () => T): T {\r\n            var savePos = pos;\r\n            var saveStartPos = startPos;\r\n            var saveTokenPos = tokenPos;\r\n            var saveToken = token;\r\n            var saveTokenValue = tokenValue;\r\n            var savePrecedingLineBreak = precedingLineBreak;\r\n            var result = callback();\r\n            if (!result) {\r\n                pos = savePos;\r\n                startPos = saveStartPos;\r\n                tokenPos = saveTokenPos;\r\n                token = saveToken;\r\n                tokenValue = saveTokenValue;\r\n                precedingLineBreak = savePrecedingLineBreak;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function setText(newText: string) {\r\n            text = newText || \"\";\r\n            len = text.length;\r\n            setTextPos(0);\r\n        }\r\n\r\n        function setTextPos(textPos: number) {\r\n            pos = textPos;\r\n            startPos = textPos;\r\n            tokenPos = textPos;\r\n            token = SyntaxKind.Unknown;\r\n            precedingLineBreak = false;\r\n        }\r\n\r\n        setText(text);\r\n\r\n\r\n        return {\r\n            getStartPos: () => startPos,\r\n            getTextPos: () => pos,\r\n            getToken: () => token,\r\n            getTokenPos: () => tokenPos,\r\n            getTokenText: () => text.substring(tokenPos, pos),\r\n            getTokenValue: () => tokenValue,\r\n            hasPrecedingLineBreak: () => precedingLineBreak,\r\n            isIdentifier: () => token === SyntaxKind.Identifier || token > SyntaxKind.LastReservedWord,\r\n            isReservedWord: () => token >= SyntaxKind.FirstReservedWord && token <= SyntaxKind.LastReservedWord,\r\n            reScanGreaterToken: reScanGreaterToken,\r\n            reScanSlashToken: reScanSlashToken,\r\n            scan: scan,\r\n            setText: setText,\r\n            setTextPos: setTextPos,\r\n            tryScan: tryScan\r\n        };\r\n    }\r\n}\r\n\r\n // file: src/compiler/types.ts\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"scanner.ts\"/>\r\n\r\nmodule ts {\r\n\r\n    export interface TextRange {\r\n        pos: number;\r\n        end: number;\r\n    }\r\n\r\n    // token > SyntaxKind.Identifer => token is a keyword\r\n    export enum SyntaxKind {\r\n        Unknown,\r\n        EndOfFileToken,\r\n        // Literals\r\n        NumericLiteral,\r\n        StringLiteral,\r\n        RegularExpressionLiteral,\r\n        // Punctuation\r\n        OpenBraceToken,\r\n        CloseBraceToken,\r\n        OpenParenToken,\r\n        CloseParenToken,\r\n        OpenBracketToken,\r\n        CloseBracketToken,\r\n        DotToken,\r\n        DotDotDotToken,\r\n        SemicolonToken,\r\n        CommaToken,\r\n        LessThanToken,\r\n        GreaterThanToken,\r\n        LessThanEqualsToken,\r\n        GreaterThanEqualsToken,\r\n        EqualsEqualsToken,\r\n        ExclamationEqualsToken,\r\n        EqualsEqualsEqualsToken,\r\n        ExclamationEqualsEqualsToken,\r\n        EqualsGreaterThanToken,\r\n        PlusToken,\r\n        MinusToken,\r\n        AsteriskToken,\r\n        SlashToken,\r\n        PercentToken,\r\n        PlusPlusToken,\r\n        MinusMinusToken,\r\n        LessThanLessThanToken,\r\n        GreaterThanGreaterThanToken,\r\n        GreaterThanGreaterThanGreaterThanToken,\r\n        AmpersandToken,\r\n        BarToken,\r\n        CaretToken,\r\n        ExclamationToken,\r\n        TildeToken,\r\n        AmpersandAmpersandToken,\r\n        BarBarToken,\r\n        QuestionToken,\r\n        ColonToken,\r\n        // Assignments\r\n        EqualsToken,\r\n        PlusEqualsToken,\r\n        MinusEqualsToken,\r\n        AsteriskEqualsToken,\r\n        SlashEqualsToken,\r\n        PercentEqualsToken,\r\n        LessThanLessThanEqualsToken,\r\n        GreaterThanGreaterThanEqualsToken,\r\n        GreaterThanGreaterThanGreaterThanEqualsToken,\r\n        AmpersandEqualsToken,\r\n        BarEqualsToken,\r\n        CaretEqualsToken,\r\n        // Identifiers\r\n        Identifier,\r\n        // Reserved words\r\n        BreakKeyword,\r\n        CaseKeyword,\r\n        CatchKeyword,\r\n        ClassKeyword,\r\n        ConstKeyword,\r\n        ContinueKeyword,\r\n        DebuggerKeyword,\r\n        DefaultKeyword,\r\n        DeleteKeyword,\r\n        DoKeyword,\r\n        ElseKeyword,\r\n        EnumKeyword,\r\n        ExportKeyword,\r\n        ExtendsKeyword,\r\n        FalseKeyword,\r\n        FinallyKeyword,\r\n        ForKeyword,\r\n        FunctionKeyword,\r\n        IfKeyword,\r\n        ImportKeyword,\r\n        InKeyword,\r\n        InstanceOfKeyword,\r\n        NewKeyword,\r\n        NullKeyword,\r\n        ReturnKeyword,\r\n        SuperKeyword,\r\n        SwitchKeyword,\r\n        ThisKeyword,\r\n        ThrowKeyword,\r\n        TrueKeyword,\r\n        TryKeyword,\r\n        TypeOfKeyword,\r\n        VarKeyword,\r\n        VoidKeyword,\r\n        WhileKeyword,\r\n        WithKeyword,\r\n        // Strict mode reserved words\r\n        ImplementsKeyword,\r\n        InterfaceKeyword,\r\n        LetKeyword,\r\n        PackageKeyword,\r\n        PrivateKeyword,\r\n        ProtectedKeyword,\r\n        PublicKeyword,\r\n        StaticKeyword,\r\n        YieldKeyword,\r\n        // TypeScript keywords\r\n        AnyKeyword,\r\n        BooleanKeyword,\r\n        ConstructorKeyword,\r\n        DeclareKeyword,\r\n        GetKeyword,\r\n        ModuleKeyword,\r\n        RequireKeyword,\r\n        NumberKeyword,\r\n        SetKeyword,\r\n        StringKeyword,\r\n        // Parse tree nodes\r\n        Missing,\r\n        // Names\r\n        QualifiedName,\r\n        // Signature elements\r\n        TypeParameter,\r\n        Parameter,\r\n        // TypeMember\r\n        Property,\r\n        Method,\r\n        Constructor,\r\n        GetAccessor,\r\n        SetAccessor,\r\n        CallSignature,\r\n        ConstructSignature,\r\n        IndexSignature,\r\n        // Type\r\n        TypeReference,\r\n        TypeQuery,\r\n        TypeLiteral,\r\n        ArrayType,\r\n        // Expression\r\n        ArrayLiteral,\r\n        ObjectLiteral,\r\n        PropertyAssignment,\r\n        PropertyAccess,\r\n        IndexedAccess,\r\n        CallExpression,\r\n        NewExpression,\r\n        TypeAssertion,\r\n        ParenExpression,\r\n        FunctionExpression,\r\n        ArrowFunction,\r\n        PrefixOperator,\r\n        PostfixOperator,\r\n        BinaryExpression,\r\n        ConditionalExpression,\r\n        OmittedExpression,\r\n        // Element\r\n        Block,\r\n        VariableStatement,\r\n        EmptyStatement,\r\n        ExpressionStatement,\r\n        IfStatement,\r\n        DoStatement,\r\n        WhileStatement,\r\n        ForStatement,\r\n        ForInStatement,\r\n        ContinueStatement,\r\n        BreakStatement,\r\n        ReturnStatement,\r\n        WithStatement,\r\n        SwitchStatement,\r\n        CaseClause,\r\n        DefaultClause,\r\n        LabelledStatement,\r\n        ThrowStatement,\r\n        TryStatement,\r\n        TryBlock,\r\n        CatchBlock,\r\n        FinallyBlock,\r\n        DebuggerStatement,\r\n        VariableDeclaration,\r\n        FunctionDeclaration,\r\n        FunctionBlock,\r\n        ClassDeclaration,\r\n        InterfaceDeclaration,\r\n        EnumDeclaration,\r\n        ModuleDeclaration,\r\n        ModuleBlock,\r\n        ImportDeclaration,\r\n        ExportAssignment,\r\n        // Enum\r\n        EnumMember,\r\n        // Top-level nodes\r\n        SourceFile,\r\n        Program,\r\n        // Synthesized list\r\n        SyntaxList,\r\n        // Enum value count\r\n        Count,\r\n        // Markers\r\n        FirstAssignment = EqualsToken,\r\n        LastAssignment = CaretEqualsToken,\r\n        FirstReservedWord = BreakKeyword,\r\n        LastReservedWord = WithKeyword,\r\n        FirstKeyword = BreakKeyword,\r\n        LastKeyword = StringKeyword,\r\n        FirstFutureReservedWord = ImplementsKeyword,\r\n        LastFutureReservedWord = YieldKeyword,\r\n        FirstTypeNode = TypeReference,\r\n        LastTypeNode = ArrayType,\r\n        FirstPunctuation= OpenBraceToken,\r\n        LastPunctuation = CaretEqualsToken\r\n    }\r\n\r\n    export enum NodeFlags {\r\n        Export           = 0x00000001,  // Declarations\r\n        Ambient          = 0x00000002,  // Declarations\r\n        QuestionMark     = 0x00000004,  // Parameter/Property/Method\r\n        Rest             = 0x00000008,  // Parameter\r\n        Public           = 0x00000010,  // Property/Method\r\n        Private          = 0x00000020,  // Property/Method\r\n        Static           = 0x00000040,  // Property/Method\r\n        MultiLine        = 0x00000080,  // Multi-line array or object literal\r\n        Synthetic        = 0x00000100,  // Synthetic node (for full fidelity)\r\n        DeclarationFile  = 0x00000200,  // Node is a .d.ts file\r\n\r\n        Modifier = Export | Ambient | Public | Private | Static\r\n    }\r\n\r\n    export interface Node extends TextRange {\r\n        kind: SyntaxKind;\r\n        flags: NodeFlags;\r\n        id?: number;                  // Unique id (used to look up NodeLinks)\r\n        parent?: Node;                // Parent node (initialized by binding)\r\n        symbol?: Symbol;              // Symbol declared by node (initialized by binding)\r\n        locals?: SymbolTable;         // Locals associated with node (initialized by binding)\r\n        nextContainer?: Node;         // Next container in declaration order (initialized by binding)\r\n        localSymbol?: Symbol;         // Local symbol declared by node (initialized by binding only for exported nodes)\r\n    }\r\n\r\n    export interface NodeArray<T> extends Array<T>, TextRange { }\r\n\r\n    export interface Identifier extends Node {\r\n        text: string;                 // Text of identifier (with escapes converted to characters)\r\n    }\r\n\r\n    export interface QualifiedName extends Node {\r\n        // Must have same layout as PropertyAccess\r\n        left: EntityName;\r\n        right: Identifier;\r\n    }\r\n\r\n    export interface EntityName extends Node {\r\n        // Identifier, QualifiedName, or Missing\r\n    }\r\n\r\n    export interface ParsedSignature {\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        parameters: NodeArray<ParameterDeclaration>;\r\n        type?: TypeNode;\r\n    }\r\n\r\n    export interface Declaration extends Node {\r\n        name?: Identifier;\r\n    }\r\n\r\n    export interface TypeParameterDeclaration extends Declaration {\r\n        constraint?: TypeNode;\r\n    }\r\n\r\n    export interface SignatureDeclaration extends Declaration, ParsedSignature { }\r\n\r\n    export interface VariableDeclaration extends Declaration {\r\n        type?: TypeNode;\r\n        initializer?: Expression;\r\n    }\r\n\r\n    export interface PropertyDeclaration extends VariableDeclaration { }\r\n\r\n    export interface ParameterDeclaration extends VariableDeclaration { }\r\n\r\n    export interface FunctionDeclaration extends Declaration, ParsedSignature {\r\n        body?: Node;  // Block or Expression\r\n    }\r\n\r\n    export interface MethodDeclaration extends FunctionDeclaration { }\r\n\r\n    export interface ConstructorDeclaration extends FunctionDeclaration { }\r\n\r\n    export interface AccessorDeclaration extends FunctionDeclaration { }\r\n\r\n    export interface TypeNode extends Node { }\r\n\r\n    export interface TypeReferenceNode extends TypeNode {\r\n        typeName: EntityName;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n    }\r\n\r\n    export interface TypeQueryNode extends TypeNode {\r\n        exprName: EntityName;\r\n    }\r\n\r\n    export interface TypeLiteralNode extends TypeNode {\r\n        members: NodeArray<Node>;\r\n    }\r\n\r\n    export interface ArrayTypeNode extends TypeNode {\r\n        elementType: TypeNode;\r\n    }\r\n\r\n    export interface StringLiteralTypeNode extends TypeNode {\r\n        text: string;\r\n    }\r\n\r\n    export interface Expression extends Node {\r\n        contextualType?: Type;  // Used to temporarily assign a contextual type during overload resolution\r\n    }\r\n\r\n    export interface UnaryExpression extends Expression {\r\n        operator: SyntaxKind;\r\n        operand: Expression;\r\n    }\r\n\r\n    export interface BinaryExpression extends Expression {\r\n        left: Expression;\r\n        operator: SyntaxKind;\r\n        right: Expression;\r\n    }\r\n\r\n    export interface ConditionalExpression extends Expression {\r\n        condition: Expression;\r\n        whenTrue: Expression;\r\n        whenFalse: Expression;\r\n    }\r\n\r\n    export interface FunctionExpression extends Expression, FunctionDeclaration {\r\n        body: Node; // Required, whereas the member inherited from FunctionDeclaration is optional\r\n    }\r\n\r\n    // The text property of a LiteralExpression stores the interpreted value of the literal in text form. For a StringLiteral\r\n    // this means quotes have been removed and escapes have been converted to actual characters. For a NumericLiteral, the\r\n    // stored value is the toString() representation of the number. For example 1, 1.00, and 1e0 are all stored as just \"1\".\r\n    export interface LiteralExpression extends Expression {\r\n        text: string;\r\n    }\r\n\r\n    export interface ParenExpression extends Expression {\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface ArrayLiteral extends Expression {\r\n        elements: NodeArray<Expression>;\r\n    }\r\n\r\n    export interface ObjectLiteral extends Expression {\r\n        properties: NodeArray<Node>;\r\n    }\r\n\r\n    export interface PropertyAccess extends Expression {\r\n        left: Expression;\r\n        right: Identifier;\r\n    }\r\n\r\n    export interface IndexedAccess extends Expression {\r\n        object: Expression;\r\n        index: Expression;\r\n    }\r\n\r\n    export interface CallExpression extends Expression {\r\n        func: Expression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        arguments: NodeArray<Expression>;\r\n    }\r\n\r\n    export interface NewExpression extends CallExpression { }\r\n\r\n    export interface TypeAssertion extends Expression {\r\n        type: TypeNode;\r\n        operand: Expression;\r\n    }\r\n\r\n    export interface Statement extends Node { }\r\n\r\n    export interface Block extends Statement {\r\n        statements: NodeArray<Statement>;\r\n    }\r\n\r\n    export interface VariableStatement extends Statement {\r\n        declarations: NodeArray<VariableDeclaration>;\r\n    }\r\n\r\n    export interface ExpressionStatement extends Statement {\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface IfStatement extends Statement {\r\n        expression: Expression;\r\n        thenStatement: Statement;\r\n        elseStatement?: Statement;\r\n    }\r\n\r\n    export interface IterationStatement extends Statement {\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface DoStatement extends IterationStatement {\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface WhileStatement extends IterationStatement {\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface ForStatement extends IterationStatement {\r\n        declarations?: NodeArray<VariableDeclaration>;\r\n        initializer?: Expression;\r\n        condition?: Expression;\r\n        iterator?: Expression;\r\n    }\r\n\r\n    export interface ForInStatement extends IterationStatement {\r\n        declaration?: VariableDeclaration;\r\n        variable?: Expression;\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface BreakOrContinueStatement extends Statement {\r\n        label?: Identifier;\r\n    }\r\n\r\n    export interface ReturnStatement extends Statement {\r\n        expression?: Expression;\r\n    }\r\n\r\n    export interface WithStatement extends Statement {\r\n        expression: Expression;\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface SwitchStatement extends Statement {\r\n        expression: Expression;\r\n        clauses: NodeArray<CaseOrDefaultClause>;\r\n    }\r\n\r\n    export interface CaseOrDefaultClause extends Node {\r\n        expression?: Expression;\r\n        statements: NodeArray<Statement>;\r\n    }\r\n\r\n    export interface LabelledStatement extends Statement {\r\n        label: Identifier;\r\n        statement: Statement;\r\n    }\r\n\r\n    export interface ThrowStatement extends Statement {\r\n        expression: Expression;\r\n    }\r\n\r\n    export interface TryStatement extends Statement {\r\n        tryBlock: Block;\r\n        catchBlock?: CatchBlock;\r\n        finallyBlock?: Block;\r\n    }\r\n\r\n    export interface CatchBlock extends Block {\r\n        variable: Identifier;\r\n    }\r\n\r\n    export interface ClassDeclaration extends Declaration {\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        baseType?: TypeReferenceNode;\r\n        implementedTypes?: NodeArray<TypeReferenceNode>;\r\n        members: NodeArray<Node>;\r\n    }\r\n\r\n    export interface InterfaceDeclaration extends Declaration {\r\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\r\n        baseTypes?: NodeArray<TypeReferenceNode>;\r\n        members: NodeArray<Node>;\r\n    }\r\n\r\n    export interface EnumMember extends Declaration {\r\n        initializer?: Expression;\r\n    }\r\n\r\n    export interface EnumDeclaration extends Declaration {\r\n        members: NodeArray<EnumMember>;\r\n    }\r\n\r\n    export interface ModuleDeclaration extends Declaration {\r\n        body: Node;  // Block or ModuleDeclaration\r\n    }\r\n\r\n    export interface ImportDeclaration extends Declaration {\r\n        entityName?: EntityName;\r\n        externalModuleName?: LiteralExpression;\r\n    }\r\n\r\n    export interface ExportAssignment extends Statement {\r\n        exportName: Identifier;\r\n    }\r\n\r\n    export interface FileReference extends TextRange {\r\n        filename: string;\r\n    }\r\n\r\n    export interface Comment extends TextRange {\r\n        hasTrailingNewLine?: boolean;\r\n    }\r\n\r\n    export interface SourceFile extends Block {\r\n        filename: string;\r\n        text: string;\r\n        getLineAndCharacterFromPosition(position: number): { line: number; character: number };\r\n        getPositionFromLineAndCharacter(line: number, character: number): number;\r\n        amdDependencies: string[];\r\n        referencedFiles: FileReference[];\r\n        syntacticErrors: Diagnostic[];\r\n        semanticErrors: Diagnostic[];\r\n        hasNoDefaultLib: boolean;\r\n        externalModuleIndicator: Node; // The first node that causes this file to be an external module\r\n        nodeCount: number;\r\n        identifierCount: number;\r\n        symbolCount: number;\r\n        isOpen: boolean;\r\n        version: string;\r\n        languageVersion: ScriptTarget;\r\n    }\r\n\r\n    export interface Program {\r\n        getSourceFile(filename: string): SourceFile;\r\n        getSourceFiles(): SourceFile[];\r\n        getCompilerOptions(): CompilerOptions;\r\n        getCompilerHost(): CompilerHost;\r\n        getDiagnostics(sourceFile?: SourceFile): Diagnostic[];\r\n        getGlobalDiagnostics(): Diagnostic[];\r\n        getTypeChecker(fullTypeCheckMode: boolean): TypeChecker;\r\n        getCommonSourceDirectory(): string;\r\n    }\r\n\r\n    export interface SourceMapSpan {\r\n        /** Line number in the js file*/\r\n        emittedLine: number;\r\n        /** Column number in the js file */\r\n        emittedColumn: number;\r\n        /** Line number in the ts file */\r\n        sourceLine: number;\r\n        /** Column number in the ts file */\r\n        sourceColumn: number;\r\n        /** Optional name (index into names array) associated with this span */\r\n        nameIndex?: number;\r\n        /** ts file (index into sources array) associated with this span*/\r\n        sourceIndex: number;\r\n    }\r\n\r\n    export interface SourceMapData {\r\n        /** Where the sourcemap file is written */\r\n        sourceMapFilePath: string;\r\n        /** source map url written in the js file */\r\n        jsSourceMappingURL: string;\r\n        /** Source map's file field - js file name*/\r\n        sourceMapFile: string;\r\n        /** Source map's sourceRoot field - location where the sources will be present if not \"\" */\r\n        sourceMapSourceRoot: string;\r\n        /** Source map's sources field - list of sources that can be indexed in this source map*/\r\n        sourceMapSources: string[];\r\n        /** input source file (which one can use on program to get the file)\r\n            this is one to one mapping with the sourceMapSources list*/\r\n        inputSourceFileNames: string[];\r\n        /** Source map's names field - list of names that can be indexed in this source map*/\r\n        sourceMapNames?: string[];\r\n        /** Source map's mapping field - encoded source map spans*/\r\n        sourceMapMappings: string;\r\n        /** Raw source map spans that were encoded into the sourceMapMappings*/\r\n        sourceMapDecodedMappings: SourceMapSpan[];\r\n    }\r\n\r\n    export interface EmitResult {\r\n        errors: Diagnostic[];\r\n        sourceMaps: SourceMapData[];  // Array of sourceMapData if compiler emitted sourcemaps\r\n    }\r\n\r\n    export interface TypeChecker {\r\n        getProgram(): Program;\r\n        getDiagnostics(sourceFile?: SourceFile): Diagnostic[];\r\n        getGlobalDiagnostics(): Diagnostic[];\r\n        getNodeCount(): number;\r\n        getIdentifierCount(): number;\r\n        getSymbolCount(): number;\r\n        getTypeCount(): number;\r\n        checkProgram(): void;\r\n        emitFiles(): EmitResult;\r\n        getParentOfSymbol(symbol: Symbol): Symbol;\r\n        getTypeOfSymbol(symbol: Symbol): Type;\r\n        getPropertiesOfType(type: Type): Symbol[];\r\n        getPropertyOfType(type: Type, propetyName: string): Symbol;\r\n        getSignaturesOfType(type: Type, kind: SignatureKind): Signature[];\r\n        getIndexTypeOfType(type: Type, kind: IndexKind): Type;\r\n        getReturnTypeOfSignature(signature: Signature): Type;\r\n        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];\r\n        getSymbolInfo(node: Node): Symbol;\r\n        getTypeOfNode(node: Node): Type;\r\n        getApparentType(type: Type): ApparentType;\r\n        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\r\n        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): string;\r\n        getAugmentedPropertiesOfApparentType(type: Type): Symbol[];\r\n    }\r\n\r\n    export interface TextWriter {\r\n        write(s: string): void;\r\n        writeSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): void;\r\n        writeLine(): void;\r\n        increaseIndent(): void;\r\n        decreaseIndent(): void;\r\n        getText(): string;\r\n    }\r\n\r\n    export enum TypeFormatFlags {\r\n        None                        = 0x00000000, \r\n\r\n        /** writes Array<T> instead T[]  */\r\n        WriteArrayAsGenericType     = 0x00000001,  // Declarations\r\n\r\n        UseTypeOfFunction           = 0x00000002,  // instead of writing signature type of function use typeof\r\n    }\r\n\r\n    export enum SymbolAccessibility {\r\n        Accessible,\r\n        NotAccessible,\r\n        CannotBeNamed\r\n    }\r\n\r\n    export interface SymbolAccessiblityResult {\r\n        accessibility: SymbolAccessibility;\r\n        errorSymbolName?: string // Optional symbol name that results in error\r\n        errorModuleName?: string // If the symbol is not visibile from module, module's name\r\n        aliasesToMakeVisible?: ImportDeclaration[]; // aliases that need to have this symbol visible\r\n    }\r\n\r\n    export interface EmitResolver {\r\n        getProgram(): Program;\r\n        getLocalNameOfContainer(container: Declaration): string;\r\n        getExpressionNamePrefix(node: Identifier): string;\r\n        getPropertyAccessSubstitution(node: PropertyAccess): string;\r\n        getExportAssignmentName(node: SourceFile): string;\r\n        isReferencedImportDeclaration(node: ImportDeclaration): boolean;\r\n        isTopLevelValueImportedViaEntityName(node: ImportDeclaration): boolean;\r\n        getNodeCheckFlags(node: Node): NodeCheckFlags;\r\n        getEnumMemberValue(node: EnumMember): number;\r\n        shouldEmitDeclarations(): boolean;\r\n        isDeclarationVisible(node: Declaration): boolean;\r\n        isImplementationOfOverload(node: FunctionDeclaration): boolean;\r\n        writeTypeAtLocation(location: Node, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: TextWriter): void;\r\n        writeReturnTypeOfSignatureDeclaration(signatureDeclaration: SignatureDeclaration, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: TextWriter): void;\r\n        writeSymbol(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags, writer: TextWriter): void;\r\n        isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags): SymbolAccessiblityResult;\r\n        isImportDeclarationEntityNameReferenceDeclarationVisibile(entityName: EntityName): SymbolAccessiblityResult;\r\n    }\r\n\r\n    export enum SymbolFlags {\r\n        Variable           = 0x00000001,  // Variable or parameter\r\n        Property           = 0x00000002,  // Property or enum member\r\n        EnumMember         = 0x00000004,  // Enum member\r\n        Function           = 0x00000008,  // Function\r\n        Class              = 0x00000010,  // Class\r\n        Interface          = 0x00000020,  // Interface\r\n        Enum               = 0x00000040,  // Enum\r\n        ValueModule        = 0x00000080,  // Instantiated module\r\n        NamespaceModule    = 0x00000100,  // Uninstantiated module\r\n        TypeLiteral        = 0x00000200,  // Type Literal\r\n        ObjectLiteral      = 0x00000400,  // Object Literal\r\n        Method             = 0x00000800,  // Method\r\n        Constructor        = 0x00001000,  // Constructor\r\n        GetAccessor        = 0x00002000,  // Get accessor\r\n        SetAccessor        = 0x00004000,  // Set accessor\r\n        CallSignature      = 0x00008000,  // Call signature\r\n        ConstructSignature = 0x00010000,  // Construct signature\r\n        IndexSignature     = 0x00020000,  // Index signature\r\n        TypeParameter      = 0x00040000,  // Type parameter\r\n\r\n        // Export markers (see comment in declareModuleMember in binder)\r\n        ExportValue        = 0x00080000,  // Exported value marker\r\n        ExportType         = 0x00100000,  // Exported type marker\r\n        ExportNamespace    = 0x00200000,  // Exported namespace marker\r\n\r\n        Import             = 0x00400000,  // Import\r\n        Instantiated       = 0x00800000,  // Instantiated symbol\r\n        Merged             = 0x01000000,  // Merged symbol (created during program binding)\r\n        Transient          = 0x02000000,  // Transient symbol (created during type check)\r\n        Prototype          = 0x04000000,  // Symbol for the prototype property (without source code representation)\r\n\r\n        Value     = Variable | Property | EnumMember | Function | Class | Enum | ValueModule | Method | GetAccessor | SetAccessor,\r\n        Type      = Class | Interface | Enum | TypeLiteral | ObjectLiteral | TypeParameter,\r\n        Namespace = ValueModule | NamespaceModule,\r\n        Module    = ValueModule | NamespaceModule,\r\n        Accessor  = GetAccessor | SetAccessor,\r\n        Signature = CallSignature | ConstructSignature | IndexSignature,\r\n\r\n        ParameterExcludes       = Value,\r\n        VariableExcludes        = Value & ~Variable,\r\n        PropertyExcludes        = Value,\r\n        EnumMemberExcludes      = Value,\r\n        FunctionExcludes        = Value & ~(Function | ValueModule),\r\n        ClassExcludes           = (Value | Type) & ~ValueModule,\r\n        InterfaceExcludes       = Type & ~Interface,\r\n        EnumExcludes            = (Value | Type) & ~(Enum | ValueModule),\r\n        ValueModuleExcludes     = Value & ~(Function | Class | Enum | ValueModule),\r\n        NamespaceModuleExcludes = 0,\r\n        MethodExcludes          = Value & ~Method,\r\n        GetAccessorExcludes     = Value & ~SetAccessor,\r\n        SetAccessorExcludes     = Value & ~GetAccessor,\r\n        TypeParameterExcludes   = Type & ~TypeParameter,\r\n\r\n        // Imports collide with all other imports with the same name.\r\n        ImportExcludes          = Import,\r\n\r\n        ModuleMember = Variable | Function | Class | Interface | Enum | Module | Import,\r\n\r\n        ExportHasLocal = Function | Class | Enum | ValueModule,\r\n\r\n        HasLocals  = Function | Module | Method | Constructor | Accessor | Signature,\r\n        HasExports = Class | Enum | Module,\r\n        HasMembers = Class | Interface | TypeLiteral | ObjectLiteral,\r\n\r\n        IsContainer = HasLocals | HasExports | HasMembers,\r\n        PropertyOrAccessor      = Property | Accessor,\r\n        Export                  = ExportNamespace | ExportType | ExportValue,\r\n    }\r\n\r\n    export interface Symbol {\r\n        flags: SymbolFlags;            // Symbol flags\r\n        name: string;                  // Name of symbol\r\n        id?: number;                   // Unique id (used to look up SymbolLinks)\r\n        mergeId?: number;              // Merge id (used to look up merged symbol)\r\n        declarations?: Declaration[];  // Declarations associated with this symbol\r\n        parent?: Symbol;               // Parent symbol\r\n        members?: SymbolTable;         // Class, interface or literal instance members\r\n        exports?: SymbolTable;         // Module exports\r\n        exportSymbol?: Symbol;         // Exported symbol associated with this symbol\r\n        valueDeclaration?: Declaration // First value declaration of the symbol\r\n    }\r\n\r\n    export interface SymbolLinks {\r\n        target?: Symbol;               // Resolved (non-alias) target of an alias\r\n        type?: Type;                   // Type of value symbol\r\n        declaredType?: Type;           // Type of class, interface, enum, or type parameter\r\n        mapper?: TypeMapper;           // Type mapper for instantiation alias\r\n        referenced?: boolean;          // True if alias symbol has been referenced as a value\r\n        exportAssignSymbol?: Symbol;   // Symbol exported from external module\r\n    }\r\n\r\n    export interface TransientSymbol extends Symbol, SymbolLinks { }\r\n\r\n    export interface SymbolTable {\r\n        [index: string]: Symbol;\r\n    }\r\n\r\n    export enum NodeCheckFlags {\r\n        TypeChecked    = 0x00000001,  // Node has been type checked\r\n        LexicalThis    = 0x00000002,  // Lexical 'this' reference\r\n        CaptureThis    = 0x00000004,  // Lexical 'this' used in body\r\n        EmitExtends    = 0x00000008,  // Emit __extends\r\n        SuperInstance  = 0x00000010,  // Instance 'super' reference\r\n        SuperStatic    = 0x00000020,  // Static 'super' reference\r\n        ContextChecked = 0x00000040,  // Contextual types have been assigned\r\n    }\r\n\r\n    export interface NodeLinks {\r\n        resolvedType?: Type;            // Cached type of type node\r\n        resolvedSignature?: Signature;  // Cached signature of signature node or call expression\r\n        resolvedSymbol?: Symbol;        // Cached name resolution result\r\n        flags?: NodeCheckFlags;         // Set of flags specific to Node\r\n        enumMemberValue?: number;       // Constant value of enum member\r\n        isIllegalTypeReferenceInConstraint?: boolean; // Is type reference in constraint refers to the type parameter from the same list\r\n        isVisible?: boolean;            // Is this node visible\r\n        localModuleName?: string;       // Local name for module instance\r\n    }\r\n\r\n    export enum TypeFlags {\r\n        Any                = 0x00000001,\r\n        String             = 0x00000002,\r\n        Number             = 0x00000004,\r\n        Boolean            = 0x00000008,\r\n        Void               = 0x00000010,\r\n        Undefined          = 0x00000020,\r\n        Null               = 0x00000040,\r\n        Enum               = 0x00000080,  // Enum type\r\n        StringLiteral      = 0x00000100,  // String literal type\r\n        TypeParameter      = 0x00000200,  // Type parameter\r\n        Class              = 0x00000400,  // Class\r\n        Interface          = 0x00000800,  // Interface\r\n        Reference          = 0x00001000,  // Generic type reference\r\n        Anonymous          = 0x00002000,  // Anonymous\r\n        FromSignature      = 0x00004000,  // Created for signature assignment check\r\n\r\n        Intrinsic = Any | String | Number | Boolean | Void | Undefined | Null,\r\n        StringLike = String | StringLiteral,\r\n        NumberLike = Number | Enum,\r\n        ObjectType = Class | Interface | Reference | Anonymous\r\n    }\r\n\r\n    // Properties common to all types\r\n    export interface Type {\r\n        flags: TypeFlags;  // Flags\r\n        id: number;        // Unique ID\r\n        symbol?: Symbol;   // Symbol associated with type (if any)\r\n    }\r\n\r\n    // Intrinsic types (TypeFlags.Intrinsic)\r\n    export interface IntrinsicType extends Type {\r\n        intrinsicName: string;  // Name of intrinsic type\r\n    }\r\n\r\n    // String literal types (TypeFlags.StringLiteral)\r\n    export interface StringLiteralType extends Type {\r\n        text: string;  // Text of string literal\r\n    }\r\n\r\n    // Object types (TypeFlags.ObjectType)\r\n    export interface ObjectType extends Type { }\r\n\r\n    export interface ApparentType extends Type {\r\n        // This property is not used. It is just to make the type system think ApparentType\r\n        // is a strict subtype of Type.\r\n        _apparentTypeBrand: any;\r\n    }\r\n\r\n    // Class and interface types (TypeFlags.Class and TypeFlags.Interface)\r\n    export interface InterfaceType extends ObjectType {\r\n        typeParameters: TypeParameter[];           // Type parameters (undefined if non-generic)\r\n        baseTypes: ObjectType[];                   // Base types\r\n        declaredProperties: Symbol[];              // Declared members\r\n        declaredCallSignatures: Signature[];       // Declared call signatures\r\n        declaredConstructSignatures: Signature[];  // Declared construct signatures\r\n        declaredStringIndexType: Type;             // Declared string index type\r\n        declaredNumberIndexType: Type;             // Declared numeric index type\r\n    }\r\n\r\n    // Type references (TypeFlags.Reference)\r\n    export interface TypeReference extends ObjectType {\r\n        target: GenericType;    // Type reference target\r\n        typeArguments: Type[];  // Type reference type arguments\r\n    }\r\n\r\n    // Generic class and interface types\r\n    export interface GenericType extends InterfaceType, TypeReference {\r\n        instantiations: Map<TypeReference>;   // Generic instantiation cache\r\n        openReferenceTargets: GenericType[];  // Open type reference targets\r\n        openReferenceChecks: Map<boolean>;    // Open type reference check cache\r\n    }\r\n\r\n    // Resolved object type\r\n    export interface ResolvedObjectType extends ObjectType {\r\n        members: SymbolTable;              // Properties by name\r\n        properties: Symbol[];              // Properties\r\n        callSignatures: Signature[];       // Call signatures of type\r\n        constructSignatures: Signature[];  // Construct signatures of type\r\n        stringIndexType: Type;             // String index type\r\n        numberIndexType: Type;             // Numeric index type\r\n    }\r\n\r\n    // Type parameters (TypeFlags.TypeParameter)\r\n    export interface TypeParameter extends Type {\r\n        constraint: Type;        // Constraint\r\n        target?: TypeParameter;  // Instantiation target\r\n        mapper?: TypeMapper;     // Instantiation mapper\r\n    }\r\n\r\n    export enum SignatureKind {\r\n        Call,\r\n        Construct,\r\n    }\r\n\r\n    export interface Signature {\r\n        declaration: SignatureDeclaration;  // Originating declaration\r\n        typeParameters: TypeParameter[];    // Type parameters (undefined if non-generic)\r\n        parameters: Symbol[];               // Parameters\r\n        resolvedReturnType: Type;           // Resolved return type\r\n        minArgumentCount: number;           // Number of non-optional parameters\r\n        hasRestParameter: boolean;          // True if last parameter is rest parameter\r\n        hasStringLiterals: boolean;         // True if instantiated\r\n        target?: Signature;                 // Instantiation target\r\n        mapper?: TypeMapper;                // Instantiation mapper\r\n        erasedSignatureCache?: Signature;   // Erased version of signature (deferred)\r\n        isolatedSignatureType?: ObjectType; // A manufactured type that just contains the signature for purposes of signature comparison\r\n    }\r\n\r\n    export enum IndexKind {\r\n        String,\r\n        Number,\r\n    }\r\n\r\n    export interface TypeMapper {\r\n        (t: Type): Type;\r\n    }\r\n\r\n    export interface InferenceContext {\r\n        typeParameters: TypeParameter[];\r\n        inferences: Type[][];\r\n        inferredTypes: Type[];\r\n    }\r\n\r\n    export interface DiagnosticMessage {\r\n        key: string;\r\n        category: DiagnosticCategory;\r\n        code: number;\r\n    }\r\n\r\n    // A linked list of formatted diagnostic messages to be used as part of a multiline message.\r\n    // It is built from the bottom up, leaving the head to be the \"main\" diagnostic.\r\n    // While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,\r\n    // the difference is that messages are all preformatted in DMC.\r\n    export interface DiagnosticMessageChain {\r\n        messageText: string;\r\n        category: DiagnosticCategory;\r\n        code: number;\r\n        next?: DiagnosticMessageChain;\r\n    }\r\n\r\n    export interface Diagnostic {\r\n        file: SourceFile;\r\n        start: number;\r\n        length: number;\r\n        messageText: string;\r\n        category: DiagnosticCategory;\r\n        code: number;\r\n    }\r\n\r\n    export enum DiagnosticCategory {\r\n        Warning,\r\n        Error,\r\n        Message,\r\n    }\r\n\r\n    export interface CompilerOptions {\r\n        charset?: string;\r\n        codepage?: number;\r\n        declaration?: boolean;\r\n        diagnostics?: boolean;\r\n        emitBOM?: boolean;\r\n        help?: boolean;\r\n        locale?: string;\r\n        mapRoot?: string;\r\n        module?: ModuleKind;\r\n        noImplicitAny?: boolean;\r\n        noLib?: boolean;\r\n        noLibCheck?: boolean;\r\n        noResolve?: boolean;\r\n        out?: string;\r\n        outDir?: string;\r\n        removeComments?: boolean;\r\n        sourceMap?: boolean;\r\n        sourceRoot?: string;\r\n        target?: ScriptTarget;\r\n        version?: boolean;\r\n        watch?: boolean;\r\n\r\n        [option: string]: any;\r\n    }\r\n\r\n    export enum ModuleKind {\r\n        None,\r\n        CommonJS,\r\n        AMD,\r\n    }\r\n\r\n    export enum ScriptTarget {\r\n        ES3,\r\n        ES5,\r\n    }\r\n\r\n    export interface ParsedCommandLine {\r\n        options: CompilerOptions;\r\n        filenames: string[];\r\n        errors: Diagnostic[];\r\n    }\r\n\r\n    export interface CommandLineOption {\r\n        name: string;\r\n        type: any;                          // \"string\", \"number\", \"boolean\", or an object literal mapping named values to actual values\r\n        shortName?: string;                 // A short pneumonic for convenience - for instance, 'h' can be used in place of 'help'.\r\n        description?: DiagnosticMessage;    // The message describing what the command line switch does\r\n        paramName?: DiagnosticMessage;      // The name to be used for a non-boolean option's parameter.\r\n        error?: DiagnosticMessage;          // The error given when the argument does not fit a customized 'type'.\r\n    }\r\n\r\n    export enum CharacterCodes {\r\n        nullCharacter = 0,\r\n        maxAsciiCharacter = 0x7F,\r\n\r\n        lineFeed = 0x0A,              // \\n\r\n        carriageReturn = 0x0D,        // \\r\r\n        lineSeparator = 0x2028,\r\n        paragraphSeparator = 0x2029,\r\n\r\n        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems \r\n        // like an odd disparity?  (Or maybe it's completely fine for them to be different).\r\n        nextLine = 0x0085,\r\n\r\n        // Unicode 3.0 space characters\r\n        space = 0x0020,   // \" \"\r\n        nonBreakingSpace = 0x00A0,   //\r\n        enQuad = 0x2000,\r\n        emQuad = 0x2001,\r\n        enSpace = 0x2002,\r\n        emSpace = 0x2003,\r\n        threePerEmSpace = 0x2004,\r\n        fourPerEmSpace = 0x2005,\r\n        sixPerEmSpace = 0x2006,\r\n        figureSpace = 0x2007,\r\n        punctuationSpace = 0x2008,\r\n        thinSpace = 0x2009,\r\n        hairSpace = 0x200A,\r\n        zeroWidthSpace = 0x200B,\r\n        narrowNoBreakSpace = 0x202F,\r\n        ideographicSpace = 0x3000,\r\n        mathematicalSpace = 0x205F,\r\n        ogham = 0x1680, \r\n\r\n        _ = 0x5F,\r\n        $ = 0x24,\r\n\r\n        _0 = 0x30,\r\n        _1 = 0x31,\r\n        _2 = 0x32,\r\n        _3 = 0x33,\r\n        _4 = 0x34,\r\n        _5 = 0x35,\r\n        _6 = 0x36,\r\n        _7 = 0x37,\r\n        _8 = 0x38,\r\n        _9 = 0x39,\r\n\r\n        a = 0x61,\r\n        b = 0x62,\r\n        c = 0x63,\r\n        d = 0x64,\r\n        e = 0x65,\r\n        f = 0x66,\r\n        g = 0x67,\r\n        h = 0x68,\r\n        i = 0x69,\r\n        j = 0x6A,\r\n        k = 0x6B,\r\n        l = 0x6C,\r\n        m = 0x6D,\r\n        n = 0x6E,\r\n        o = 0x6F,\r\n        p = 0x70,\r\n        q = 0x71,\r\n        r = 0x72,\r\n        s = 0x73,\r\n        t = 0x74,\r\n        u = 0x75,\r\n        v = 0x76,\r\n        w = 0x77,\r\n        x = 0x78,\r\n        y = 0x79,\r\n        z = 0x7A,\r\n\r\n        A = 0x41,\r\n        B = 0x42,\r\n        C = 0x43,\r\n        D = 0x44,\r\n        E = 0x45,\r\n        F = 0x46,\r\n        G = 0x47,\r\n        H = 0x48,\r\n        I = 0x49,\r\n        J = 0x4A,\r\n        K = 0x4B,\r\n        L = 0x4C,\r\n        M = 0x4D,\r\n        N = 0x4E,\r\n        O = 0x4F,\r\n        P = 0x50,\r\n        Q = 0x51,\r\n        R = 0x52,\r\n        S = 0x53,\r\n        T = 0x54,\r\n        U = 0x55,\r\n        V = 0x56,\r\n        W = 0x57,\r\n        X = 0x58,\r\n        Y = 0x59,\r\n        Z = 0x5a,\r\n\r\n        ampersand = 0x26,             // &\r\n        asterisk = 0x2A,              // *\r\n        at = 0x40,                    // @\r\n        backslash = 0x5C,             // \\\r\n        bar = 0x7C,                   // |\r\n        caret = 0x5E,                 // ^\r\n        closeBrace = 0x7D,            // }\r\n        closeBracket = 0x5D,          // ]\r\n        closeParen = 0x29,            // )\r\n        colon = 0x3A,                 // :\r\n        comma = 0x2C,                 // ,\r\n        dot = 0x2E,                   // .\r\n        doubleQuote = 0x22,           // \"\r\n        equals = 0x3D,                // =\r\n        exclamation = 0x21,           // !\r\n        greaterThan = 0x3E,           // >\r\n        lessThan = 0x3C,              // <\r\n        minus = 0x2D,                 // -\r\n        openBrace = 0x7B,             // {\r\n        openBracket = 0x5B,           // [\r\n        openParen = 0x28,             // (\r\n        percent = 0x25,               // %\r\n        plus = 0x2B,                  // +\r\n        question = 0x3F,              // ?\r\n        semicolon = 0x3B,             // ;\r\n        singleQuote = 0x27,           // '\r\n        slash = 0x2F,                 // /\r\n        tilde = 0x7E,                 // ~\r\n\r\n        backspace = 0x08,             // \\b\r\n        formFeed = 0x0C,              // \\f\r\n        byteOrderMark = 0xFEFF,\r\n        tab = 0x09,                   // \\t\r\n        verticalTab = 0x0B,           // \\v\r\n    }\r\n\r\n    export interface CancellationToken {\r\n        isCancellationRequested(): boolean;\r\n    }\r\n\r\n    export interface CompilerHost {\r\n        getSourceFile(filename: string, languageVersion: ScriptTarget, onError?: (message: string) => void): SourceFile;\r\n        getDefaultLibFilename(): string;\r\n        getCancellationToken? (): CancellationToken;\r\n        writeFile(filename: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void): void;\r\n        getCurrentDirectory(): string;\r\n        getCanonicalFileName(fileName: string): string;\r\n        useCaseSensitiveFileNames(): boolean;\r\n        getNewLine(): string;\r\n    }\r\n}\r\n\r\n // file: src/compiler/core.ts\r\n/// <reference path=\"types.ts\"/>\r\n\r\nmodule ts {\r\n    export interface Map<T> {\r\n        [index: string]: T;\r\n    }\r\n\r\n    export interface StringSet extends Map<any> { }\r\n\r\n    export function forEach<T, U>(array: T[], callback: (element: T) => U): U {\r\n        var result: U;\r\n        if (array) {\r\n            for (var i = 0, len = array.length; i < len; i++) {\r\n                if (result = callback(array[i])) break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function contains<T>(array: T[], value: T): boolean {\r\n        if (array) {\r\n            var len = array.length;\r\n            for (var i = 0; i < len; i++) {\r\n                if (array[i] === value) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    export function indexOf<T>(array: T[], value: T): number {\r\n        if (array) {\r\n            var len = array.length;\r\n            for (var i = 0; i < len; i++) {\r\n                if (array[i] === value) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    export function filter<T>(array: T[], f: (x: T) => boolean): T[] {\r\n        var result: T[];\r\n        if (array) {\r\n            result = [];\r\n            for (var i = 0, len = array.length; i < len; i++) {\r\n                var item = array[i];\r\n                if (f(item)) {\r\n                    result.push(item);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function map<T, U>(array: T[], f: (x: T) => U): U[] {\r\n        var result: U[];\r\n        if (array) {\r\n            result = [];\r\n            var len = array.length;\r\n            for (var i = 0; i < len; i++) {\r\n                result.push(f(array[i]));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function concatenate<T>(array1: T[], array2: T[]): T[] {\r\n        if (!array2 || !array2.length) return array1;\r\n        if (!array1 || !array1.length) return array2;\r\n        return array1.concat(array2);\r\n    }\r\n\r\n    export function sum(array: any[], prop: string): number {\r\n        var result = 0;\r\n        for (var i = 0; i < array.length; i++) {\r\n            result += array[i][prop];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function binarySearch(array: number[], value: number): number {\r\n        var low = 0;\r\n        var high = array.length - 1;\r\n\r\n        while (low <= high) {\r\n            var middle = low + ((high - low) >> 1);\r\n            var midValue = array[middle];\r\n\r\n            if (midValue === value) {\r\n                return middle;\r\n            }\r\n            else if (midValue > value) {\r\n                high = middle - 1;\r\n            }\r\n            else {\r\n                low = middle + 1;\r\n            }\r\n        }\r\n\r\n        return ~low;\r\n    }\r\n\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    export function hasProperty<T>(map: Map<T>, key: string): boolean {\r\n        return hasOwnProperty.call(map, key);\r\n    }\r\n\r\n    export function getProperty<T>(map: Map<T>, key: string): T {\r\n        return hasOwnProperty.call(map, key) ? map[key] : undefined;\r\n    }\r\n\r\n    export function isEmpty<T>(map: Map<T>) {\r\n        for (var id in map) {\r\n            if (hasProperty(map, id)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    export function clone<T>(object: T): T {\r\n        var result: any = {};\r\n        for (var id in object) {\r\n            result[id] = (<any>object)[id];\r\n        }\r\n        return <T>result;\r\n    }\r\n\r\n    export function forEachValue<T, U>(map: Map<T>, callback: (value: T) => U): U {\r\n        var result: U;\r\n        for (var id in map) {\r\n            if (result = callback(map[id])) break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function forEachKey<T, U>(map: Map<T>, callback: (key: string) => U): U {\r\n        var result: U;\r\n        for (var id in map) {\r\n            if (result = callback(id)) break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    export function lookUp<T>(map: Map<T>, key: string): T {\r\n        return hasProperty(map, key) ? map[key] : undefined;\r\n    }\r\n\r\n    export function mapToArray<T>(map: Map<T>): T[] {\r\n        var result: T[] = [];\r\n\r\n        for (var id in map) {\r\n            result.push(map[id]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a map from the elements of an array.\r\n     *\r\n     * @param array the array of input elements.\r\n     * @param makeKey a function that produces a key for a given element.\r\n     *\r\n     * This function makes no effort to avoid collisions; if any two elements produce\r\n     * the same key with the given 'makeKey' function, then the element with the higher\r\n     * index in the array will be the one associated with the produced key.\r\n     */\r\n    export function arrayToMap<T>(array: T[], makeKey: (value: T) => string): Map<T> {\r\n        var result: Map<T> = {};\r\n\r\n        forEach(array, value => {\r\n            result[makeKey(value)] = value;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    function formatStringFromArgs(text: string, args: { [index: number]: any; }, baseIndex?: number): string {\r\n        baseIndex = baseIndex || 0;\r\n\r\n        return text.replace(/{(\\d+)}/g, (match, index?) => args[+index + baseIndex]);\r\n    }\r\n\r\n    export var localizedDiagnosticMessages: Map<string> = undefined;\r\n\r\n    export function getLocaleSpecificMessage(message: string) {\r\n        if (ts.localizedDiagnosticMessages) {\r\n            message = localizedDiagnosticMessages[message];\r\n        }\r\n\r\n        return message;\r\n    }\r\n\r\n    export function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage, ...args: any[]): Diagnostic;\r\n    export function createFileDiagnostic(file: SourceFile, start: number, length: number, message: DiagnosticMessage): Diagnostic {\r\n        var text = getLocaleSpecificMessage(message.key);\r\n        \r\n        if (arguments.length > 4) {\r\n            text = formatStringFromArgs(text, arguments, 4);\r\n        }\r\n\r\n        return {\r\n            file: file,\r\n            start: start,\r\n            length: length,\r\n\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code\r\n        };\r\n    }\r\n\r\n    export function createCompilerDiagnostic(message: DiagnosticMessage, ...args: any[]): Diagnostic;\r\n    export function createCompilerDiagnostic(message: DiagnosticMessage): Diagnostic {\r\n        var text = getLocaleSpecificMessage(message.key);\r\n\r\n        if (arguments.length > 1) {\r\n            text = formatStringFromArgs(text, arguments, 1);\r\n        }\r\n\r\n        return {\r\n            file: undefined,\r\n            start: undefined,\r\n            length: undefined,\r\n\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code\r\n        };\r\n    }\r\n\r\n    export function chainDiagnosticMessages(details: DiagnosticMessageChain, message: DiagnosticMessage, ...args: any[]): DiagnosticMessageChain;\r\n    export function chainDiagnosticMessages(details: DiagnosticMessageChain, message: DiagnosticMessage): DiagnosticMessageChain {\r\n        var text = getLocaleSpecificMessage(message.key);\r\n\r\n        if (arguments.length > 2) {\r\n            text = formatStringFromArgs(text, arguments, 2);\r\n        }\r\n\r\n        return {\r\n            messageText: text,\r\n            category: message.category,\r\n            code: message.code,\r\n\r\n            next: details\r\n        };\r\n    }\r\n\r\n    export function flattenDiagnosticChain(file: SourceFile, start: number, length: number, diagnosticChain: DiagnosticMessageChain, newLine: string): Diagnostic {\r\n        var code = diagnosticChain.code;\r\n        var category = diagnosticChain.category;\r\n        var messageText = \"\";\r\n\r\n        var indent = 0;\r\n        while (diagnosticChain) {\r\n            if (indent) {\r\n                messageText += newLine;\r\n                \r\n                for (var i = 0; i < indent; i++) {\r\n                    messageText += \"  \";\r\n                }\r\n            }\r\n            messageText += diagnosticChain.messageText;\r\n            indent++;\r\n            diagnosticChain = diagnosticChain.next;\r\n        }\r\n\r\n        return {\r\n            file: file,\r\n            start: start,\r\n            length: length,\r\n            code: code,\r\n            category: category,\r\n            messageText: messageText\r\n        };\r\n    }\r\n\r\n    export function compareValues<T>(a: T, b: T): number {\r\n        if (a === b) return 0;\r\n        if (a === undefined) return -1;\r\n        if (b === undefined) return 1;\r\n        return a < b ? -1 : 1;\r\n    }\r\n\r\n    function getDiagnosticFilename(diagnostic: Diagnostic): string {\r\n        return diagnostic.file ? diagnostic.file.filename : undefined;\r\n    }\r\n\r\n    export function compareDiagnostics(d1: Diagnostic, d2: Diagnostic): number {\r\n        return compareValues(getDiagnosticFilename(d1), getDiagnosticFilename(d2)) ||\r\n            compareValues(d1.start, d2.start) ||\r\n            compareValues(d1.length, d2.length) ||\r\n            compareValues(d1.code, d2.code) ||\r\n            compareValues(d1.messageText, d2.messageText) ||\r\n            0;\r\n    }\r\n\r\n    export function deduplicateSortedDiagnostics(diagnostics: Diagnostic[]): Diagnostic[] {\r\n        if (diagnostics.length < 2) {\r\n            return diagnostics;\r\n        }\r\n\r\n        var newDiagnostics = [diagnostics[0]];\r\n        var previousDiagnostic = diagnostics[0];\r\n        for (var i = 1; i < diagnostics.length; i++) {\r\n            var currentDiagnostic = diagnostics[i];\r\n            var isDupe = compareDiagnostics(currentDiagnostic, previousDiagnostic) === 0;\r\n            if (!isDupe) {\r\n                newDiagnostics.push(currentDiagnostic);\r\n                previousDiagnostic = currentDiagnostic;\r\n            }\r\n        }\r\n\r\n        return newDiagnostics;\r\n    }\r\n\r\n    export function normalizeSlashes(path: string): string {\r\n        return path.replace(/\\\\/g, \"/\");\r\n    }\r\n\r\n    // Returns length of path root (i.e. length of \"/\", \"x:/\", \"//server/share/\")\r\n    export function getRootLength(path: string): number {\r\n        if (path.charCodeAt(0) === CharacterCodes.slash) {\r\n            if (path.charCodeAt(1) !== CharacterCodes.slash) return 1;\r\n            var p1 = path.indexOf(\"/\", 2);\r\n            if (p1 < 0) return 2;\r\n            var p2 = path.indexOf(\"/\", p1 + 1);\r\n            if (p2 < 0) return p1 + 1;\r\n            return p2 + 1;\r\n        }\r\n        if (path.charCodeAt(1) === CharacterCodes.colon) {\r\n            if (path.charCodeAt(2) === CharacterCodes.slash) return 3;\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    export var directorySeparator = \"/\";\r\n    function getNormalizedParts(normalizedSlashedPath: string, rootLength: number) {\r\n        var parts = normalizedSlashedPath.substr(rootLength).split(directorySeparator);\r\n        var normalized: string[] = [];\r\n        for (var i = 0; i < parts.length; i++) {\r\n            var part = parts[i];\r\n            if (part !== \".\") {\r\n                if (part === \"..\" && normalized.length > 0 && normalized[normalized.length - 1] !== \"..\") {\r\n                    normalized.pop();\r\n                }\r\n                else {\r\n                    normalized.push(part);\r\n                }\r\n            }\r\n        }\r\n\r\n        return normalized;\r\n    }\r\n\r\n    export function normalizePath(path: string): string {\r\n        var path = normalizeSlashes(path);\r\n        var rootLength = getRootLength(path);\r\n        var normalized = getNormalizedParts(path, rootLength);\r\n        return path.substr(0, rootLength) + normalized.join(directorySeparator);\r\n    }\r\n\r\n    export function getDirectoryPath(path: string) {\r\n        return path.substr(0, Math.max(getRootLength(path), path.lastIndexOf(directorySeparator)));\r\n    }\r\n\r\n    export function isUrl(path: string) {\r\n        return path && !isRootedDiskPath(path) && path.indexOf(\"://\") !== -1;\r\n    }\r\n\r\n    export function isRootedDiskPath(path: string) {\r\n        return getRootLength(path) !== 0;\r\n    }\r\n\r\n    function normalizedPathComponents(path: string, rootLength: number) {\r\n        var normalizedParts = getNormalizedParts(path, rootLength);\r\n        return [path.substr(0, rootLength)].concat(normalizedParts);\r\n    }\r\n\r\n    export function getNormalizedPathComponents(path: string, currentDirectory: string) {\r\n        var path = normalizeSlashes(path);\r\n        var rootLength = getRootLength(path);\r\n        if (rootLength == 0) {\r\n            // If the path is not rooted it is relative to current directory\r\n            path = combinePaths(normalizeSlashes(currentDirectory), path);\r\n            rootLength = getRootLength(path);\r\n        }\r\n\r\n        return normalizedPathComponents(path, rootLength);\r\n    }\r\n\r\n    export function getNormalizedPathFromPathCompoments(pathComponents: string[]) {\r\n        if (pathComponents && pathComponents.length) {\r\n            return pathComponents[0] + pathComponents.slice(1).join(directorySeparator);\r\n        }\r\n    }\r\n\r\n    function getNormalizedPathComponentsOfUrl(url: string) {\r\n        // Get root length of http://www.website.com/folder1/foler2/\r\n        // In this example the root is:  http://www.website.com/ \r\n        // normalized path components should be [\"http://www.website.com/\", \"folder1\", \"folder2\"]\r\n\r\n        var urlLength = url.length;\r\n        // Initial root length is http:// part\r\n        var rootLength = url.indexOf(\"://\") + \"://\".length;\r\n        while (rootLength < urlLength) {\r\n            // Consume all immediate slashes in the protocol \r\n            // eg.initial rootlength is just file:// but it needs to consume another \"/\" in file:///\r\n            if (url.charCodeAt(rootLength) === CharacterCodes.slash) {\r\n                rootLength++;\r\n            }\r\n            else {\r\n                // non slash character means we continue proceeding to next component of root search \r\n                break;\r\n            }\r\n        }\r\n\r\n        // there are no parts after http:// just return current string as the pathComponent\r\n        if (rootLength === urlLength) {\r\n            return [url];\r\n        }\r\n\r\n        // Find the index of \"/\" after website.com so the root can be http://www.website.com/ (from existing http://)\r\n        var indexOfNextSlash = url.indexOf(directorySeparator, rootLength);\r\n        if (indexOfNextSlash !== -1) {\r\n            // Found the \"/\" after the website.com so the root is length of http://www.website.com/ \r\n            // and get components afetr the root normally like any other folder components\r\n            rootLength = indexOfNextSlash + 1;\r\n            return normalizedPathComponents(url, rootLength);\r\n        }\r\n        else {\r\n            // Can't find the host assume the rest of the string as component \r\n            // but make sure we append \"/\"  to it as root is not joined using \"/\"\r\n            // eg. if url passed in was http://website.com we want to use root as [http://website.com/] \r\n            // so that other path manipulations will be correct and it can be merged with relative paths correctly\r\n            return [url + directorySeparator];\r\n        }\r\n    }\r\n\r\n    function getNormalizedPathOrUrlComponents(pathOrUrl: string, currentDirectory: string) {\r\n        if (isUrl(pathOrUrl)) {\r\n            return getNormalizedPathComponentsOfUrl(pathOrUrl);\r\n        }\r\n        else {\r\n            return getNormalizedPathComponents(pathOrUrl, currentDirectory);\r\n        }\r\n    }\r\n\r\n    export function getRelativePathToDirectoryOrUrl(directoryPathOrUrl: string, relativeOrAbsolutePath: string, currentDirectory: string, isAbsolutePathAnUrl: boolean) {\r\n        var pathComponents = getNormalizedPathOrUrlComponents(relativeOrAbsolutePath, currentDirectory);\r\n        var directoryComponents = getNormalizedPathOrUrlComponents(directoryPathOrUrl, currentDirectory);\r\n        if (directoryComponents.length > 1 && directoryComponents[directoryComponents.length - 1] === \"\") {\r\n            // If the directory path given was of type test/cases/ then we really need components of directry to be only till its name \r\n            // that is  [\"test\", \"cases\", \"\"] needs to be actually [\"test\", \"cases\"]\r\n            directoryComponents.length--;\r\n        }\r\n\r\n        // Find the component that differs\r\n        for (var joinStartIndex = 0; joinStartIndex < pathComponents.length && joinStartIndex < directoryComponents.length; joinStartIndex++) {\r\n            if (directoryComponents[joinStartIndex] !== pathComponents[joinStartIndex]) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Get the relative path\r\n        if (joinStartIndex) {\r\n            var relativePath = \"\";\r\n            var relativePathComponents = pathComponents.slice(joinStartIndex, pathComponents.length);\r\n            for (; joinStartIndex < directoryComponents.length; joinStartIndex++) {\r\n                if (directoryComponents[joinStartIndex] !== \"\") {\r\n                    relativePath = relativePath + \"..\" + directorySeparator;\r\n                }\r\n            }\r\n\r\n            return relativePath + relativePathComponents.join(directorySeparator);\r\n        }\r\n\r\n        // Cant find the relative path, get the absolute path\r\n        var absolutePath = getNormalizedPathFromPathCompoments(pathComponents);\r\n        if (isAbsolutePathAnUrl && isRootedDiskPath(absolutePath)) {\r\n            absolutePath = \"file:///\" + absolutePath;\r\n        }\r\n\r\n        return absolutePath;\r\n    }\r\n\r\n    export function getBaseFilename(path: string) {\r\n        var i = path.lastIndexOf(directorySeparator);\r\n        return i < 0 ? path : path.substring(i + 1);\r\n    }\r\n\r\n    export function combinePaths(path1: string, path2: string) {\r\n        if (!(path1 && path1.length)) return path2;\r\n        if (!(path2 && path2.length)) return path1;\r\n        if (path2.charAt(0) === directorySeparator) return path2;\r\n        if (path1.charAt(path1.length - 1) === directorySeparator) return path1 + path2;\r\n        return path1 + directorySeparator + path2;\r\n    }\r\n\r\n    export function fileExtensionIs(path: string, extension: string): boolean {\r\n        var pathLen = path.length;\r\n        var extLen = extension.length;\r\n        return pathLen > extLen && path.substr(pathLen - extLen, extLen) === extension;\r\n    }\r\n\r\n    export interface ObjectAllocator {\r\n        getNodeConstructor(kind: SyntaxKind): new () => Node;\r\n        getSymbolConstructor(): new (flags: SymbolFlags, name: string) => Symbol;\r\n        getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type;\r\n        getSignatureConstructor(): new (checker: TypeChecker) => Signature;\r\n    }\r\n\r\n    function Symbol(flags: SymbolFlags, name: string) {\r\n        this.flags = flags;\r\n        this.name = name;\r\n        this.declarations = undefined;\r\n    }\r\n\r\n    function Type(checker: TypeChecker, flags: TypeFlags) {\r\n        this.flags = flags;\r\n    }\r\n\r\n    function Signature(checker: TypeChecker) {\r\n    }\r\n\r\n    export var objectAllocator: ObjectAllocator = {\r\n        getNodeConstructor: kind => {\r\n            function Node() {\r\n            }\r\n            Node.prototype = {\r\n                kind: kind,\r\n                pos: 0,\r\n                end: 0,\r\n                flags: 0,\r\n                parent: undefined,\r\n            };\r\n            return <any>Node;\r\n        },\r\n        getSymbolConstructor: () => <any>Symbol,\r\n        getTypeConstructor: () => <any>Type,\r\n        getSignatureConstructor: () => <any>Signature\r\n    }\r\n\r\n    export enum AssertionLevel {\r\n        None = 0,\r\n        Normal = 1,\r\n        Aggressive = 2,\r\n        VeryAggressive = 3,\r\n    }\r\n\r\n    export module Debug {\r\n        var currentAssertionLevel = AssertionLevel.None;\r\n\r\n        export function shouldAssert(level: AssertionLevel): boolean {\r\n            return currentAssertionLevel >= level;\r\n        }\r\n\r\n        export function assert(expression: any, message?: string, verboseDebugInfo?: () => string): void {\r\n            if (!expression) {\r\n                var verboseDebugString = \"\";\r\n                if (verboseDebugInfo) {\r\n                    verboseDebugString = \"\\r\\nVerbose Debug Information: \" + verboseDebugInfo();\r\n                }\r\n\r\n                throw new Error(\"Debug Failure. False expression: \" + (message || \"\") + verboseDebugString);\r\n            }\r\n        }\r\n\r\n        export function fail(message?: string): void {\r\n            Debug.assert(false, message);\r\n        }\r\n    }\r\n}\r\n\r\n // file: src/compiler/sys.ts\r\n/// <reference path=\"diagnosticInformationMap.generated.ts\"/>\r\n\r\ninterface System {\r\n    args: string[];\r\n    newLine: string;\r\n    useCaseSensitiveFileNames: boolean;\r\n    write(s: string): void;\r\n    readFile(fileName: string, encoding?: string): string;\r\n    writeFile(fileName: string, data: string, writeByteOrderMark?: boolean): void;\r\n    watchFile?(fileName: string, callback: (fileName: string) => void): FileWatcher;\r\n    resolvePath(path: string): string;\r\n    fileExists(path: string): boolean;\r\n    directoryExists(path: string): boolean;\r\n    createDirectory(directoryName: string): void;\r\n    getExecutingFilePath(): string;\r\n    getCurrentDirectory(): string;\r\n    getMemoryUsage?(): number;\r\n    exit(exitCode?: number): void;\r\n}\r\n\r\ninterface FileWatcher {\r\n    close(): void;\r\n}\r\n\r\ndeclare var require: any;\r\ndeclare var module: any;\r\ndeclare var process: any;\r\ndeclare var global: any;\r\n\r\nvar sys: System = (function () {\r\n\r\n    function getWScriptSystem(): System {\r\n\r\n        var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\r\n\r\n        var fileStream = new ActiveXObject(\"ADODB.Stream\");\r\n        fileStream.Type = 2 /*text*/;\r\n\r\n        var binaryStream = new ActiveXObject(\"ADODB.Stream\");\r\n        binaryStream.Type = 1 /*binary*/;\r\n\r\n        var args: string[] = [];\r\n        for (var i = 0; i < WScript.Arguments.length; i++) {\r\n            args[i] = WScript.Arguments.Item(i);\r\n        }\r\n\r\n        function readFile(fileName: string, encoding?: string): string {\r\n            if (!fso.FileExists(fileName)) {\r\n                return undefined;\r\n            }\r\n            fileStream.Open();\r\n            try {\r\n                if (encoding) {\r\n                    fileStream.Charset = encoding;\r\n                    fileStream.LoadFromFile(fileName);\r\n                }\r\n                else {\r\n                    // Load file and read the first two bytes into a string with no interpretation\r\n                    fileStream.Charset = \"x-ansi\";\r\n                    fileStream.LoadFromFile(fileName);\r\n                    var bom = fileStream.ReadText(2) || \"\";\r\n                    // Position must be at 0 before encoding can be changed\r\n                    fileStream.Position = 0;\r\n                    // [0xFF,0xFE] and [0xFE,0xFF] mean utf-16 (little or big endian), otherwise default to utf-8\r\n                    fileStream.Charset = bom.length >= 2 && (bom.charCodeAt(0) === 0xFF && bom.charCodeAt(1) === 0xFE || bom.charCodeAt(0) === 0xFE && bom.charCodeAt(1) === 0xFF) ? \"unicode\" : \"utf-8\";\r\n                }\r\n                // ReadText method always strips byte order mark from resulting string\r\n                return fileStream.ReadText();\r\n            }\r\n            catch (e) {\r\n                throw e.number === -2147024809 ? new Error(ts.Diagnostics.Unsupported_file_encoding.key) : e;\r\n            }\r\n            finally {\r\n                fileStream.Close();\r\n            }\r\n        }\r\n\r\n        function writeFile(fileName: string, data: string, writeByteOrderMark?: boolean): void {\r\n            fileStream.Open();\r\n            binaryStream.Open();\r\n            try {\r\n                // Write characters in UTF-8 encoding\r\n                fileStream.Charset = \"utf-8\";\r\n                fileStream.WriteText(data);\r\n                // If we don't want the BOM, then skip it by setting the starting location to 3 (size of BOM).\r\n                // If not, start from position 0, as the BOM will be added automatically when charset==utf8.\r\n                if (writeByteOrderMark) {\r\n                    fileStream.Position = 0;\r\n                }\r\n                else {\r\n                    fileStream.Position = 3;\r\n                }\r\n                fileStream.CopyTo(binaryStream);\r\n                binaryStream.SaveToFile(fileName, 2 /*overwrite*/);\r\n            }\r\n            finally {\r\n                binaryStream.Close();\r\n                fileStream.Close();\r\n            }\r\n        }\r\n\r\n        return {\r\n            args: args,\r\n            newLine: \"\\r\\n\",\r\n            useCaseSensitiveFileNames: false,\r\n            write(s: string): void {\r\n                WScript.StdOut.Write(s);\r\n            },\r\n            readFile: readFile,\r\n            writeFile: writeFile,\r\n            resolvePath(path: string): string {\r\n                return fso.GetAbsolutePathName(path);\r\n            },\r\n            fileExists(path: string): boolean {\r\n                return fso.FileExists(path);\r\n            },\r\n            directoryExists(path: string) {\r\n                return fso.FolderExists(path);\r\n            },\r\n            createDirectory(directoryName: string) {\r\n                if (!this.directoryExists(directoryName)) {\r\n                    fso.CreateFolder(directoryName);\r\n                }\r\n            },\r\n            getExecutingFilePath() {\r\n                return WScript.ScriptFullName;\r\n            },\r\n            getCurrentDirectory() {\r\n                return new ActiveXObject(\"WScript.Shell\").CurrentDirectory;\r\n            },\r\n            exit(exitCode?: number): void {\r\n                try {\r\n                    WScript.Quit(exitCode);\r\n                }\r\n                catch (e) {\r\n                }\r\n            }\r\n        };\r\n    }\r\n    function getNodeSystem(): System {\r\n        var _fs = require(\"fs\");\r\n        var _path = require(\"path\");\r\n        var _os = require('os');\r\n\r\n        var platform: string = _os.platform();\r\n        // win32\\win64 are case insensitive platforms, MacOS (darwin) by default is also case insensitive\r\n        var useCaseSensitiveFileNames = platform !== \"win32\" && platform !== \"win64\" && platform !== \"darwin\";\r\n\r\n        function readFile(fileName: string, encoding?: string): string {\r\n            if (!_fs.existsSync(fileName)) {\r\n                return undefined;\r\n            }\r\n            var buffer = _fs.readFileSync(fileName);\r\n            var len = buffer.length;\r\n            if (len >= 2 && buffer[0] === 0xFE && buffer[1] === 0xFF) {\r\n                // Big endian UTF-16 byte order mark detected. Since big endian is not supported by node.js,\r\n                // flip all byte pairs and treat as little endian.\r\n                len &= ~1;\r\n                for (var i = 0; i < len; i += 2) {\r\n                    var temp = buffer[i];\r\n                    buffer[i] = buffer[i + 1];\r\n                    buffer[i + 1] = temp;\r\n                }\r\n                return buffer.toString(\"utf16le\", 2);\r\n            }\r\n            if (len >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {\r\n                // Little endian UTF-16 byte order mark detected\r\n                return buffer.toString(\"utf16le\", 2);\r\n            }\r\n            if (len >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\r\n                // UTF-8 byte order mark detected\r\n                return buffer.toString(\"utf8\", 3);\r\n            }\r\n            // Default is UTF-8 with no byte order mark\r\n            return buffer.toString(\"utf8\");\r\n        }\r\n\r\n        function writeFile(fileName: string, data: string, writeByteOrderMark?: boolean): void {\r\n            // If a BOM is required, emit one\r\n            if (writeByteOrderMark) {\r\n                data = '\\uFEFF' + data;\r\n            }\r\n\r\n            _fs.writeFileSync(fileName, data, \"utf8\");\r\n        }\r\n\r\n        return {\r\n            args: process.argv.slice(2),\r\n            newLine: _os.EOL,\r\n            useCaseSensitiveFileNames: useCaseSensitiveFileNames,\r\n            write(s: string): void {\r\n               // 1 is a standard descriptor for stdout\r\n               _fs.writeSync(1, s);\r\n            },\r\n            readFile: readFile,\r\n            writeFile: writeFile,\r\n            watchFile: (fileName, callback) => {\r\n                // watchFile polls a file every 250ms, picking up file notifications.\r\n                _fs.watchFile(fileName, { persistent: true, interval: 250 }, fileChanged);\r\n\r\n                return {\r\n                    close() { _fs.unwatchFile(fileName, fileChanged); }\r\n                };\r\n\r\n                function fileChanged(curr: any, prev: any) {\r\n                    if (+curr.mtime <= +prev.mtime) {\r\n                        return;\r\n                    }\r\n\r\n                    callback(fileName);\r\n                };\r\n            },\r\n            resolvePath: function (path: string): string {\r\n                return _path.resolve(path);\r\n            },\r\n            fileExists(path: string): boolean {\r\n                return _fs.existsSync(path);\r\n            },\r\n            directoryExists(path: string) {\r\n                return _fs.existsSync(path) && _fs.statSync(path).isDirectory();\r\n            },\r\n            createDirectory(directoryName: string) {\r\n                if (!this.directoryExists(directoryName)) {\r\n                    _fs.mkdirSync(directoryName);\r\n                }\r\n            },\r\n            getExecutingFilePath() {\r\n                return process.mainModule.filename;\r\n            },\r\n            getCurrentDirectory() {\r\n                return (<any>process).cwd();\r\n            },\r\n            getMemoryUsage() {\r\n                if (global.gc) {\r\n                    global.gc();\r\n                }\r\n                return process.memoryUsage().heapUsed;\r\n            },\r\n            exit(exitCode?: number): void {\r\n                process.exit(exitCode);\r\n            }\r\n        };\r\n    }\r\n    if (typeof WScript !== \"undefined\" && typeof ActiveXObject === \"function\") {\r\n        return getWScriptSystem();\r\n    }\r\n    else if (typeof module !== \"undefined\" && module.exports) {\r\n        return getNodeSystem();\r\n    }\r\n    else {\r\n        return undefined; // Unsupported host\r\n    }\r\n})();\r\n\r\n // file: src/compiler/parser.ts\r\n/// <reference path=\"sys.ts\"/>\r\n/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"scanner.ts\"/>\r\n\r\nmodule ts {\r\n    var nodeConstructors = new Array<new () => Node>(SyntaxKind.Count);\r\n\r\n    export function getNodeConstructor(kind: SyntaxKind): new () => Node {\r\n        return nodeConstructors[kind] || (nodeConstructors[kind] = objectAllocator.getNodeConstructor(kind));\r\n    }\r\n \r\n    function createRootNode(kind: SyntaxKind, pos: number, end: number, flags: NodeFlags): Node {\r\n        var node = new (getNodeConstructor(kind))();\r\n        node.pos = pos;\r\n        node.end = end;\r\n        node.flags = flags;\r\n        return node;\r\n    }\r\n\r\n    var moduleExtensions = [\".d.ts\", \".ts\", \".js\"];\r\n\r\n    interface ReferenceComments {\r\n        referencedFiles: FileReference[];\r\n        amdDependencies: string[];\r\n    }\r\n\r\n    export function getModuleNameFromFilename(filename: string) {\r\n        for (var i = 0; i < moduleExtensions.length; i++) {\r\n            var ext = moduleExtensions[i];\r\n            var len = filename.length - ext.length;\r\n            if (len > 0 && filename.substr(len) === ext) return filename.substr(0, len);\r\n        }\r\n        return filename;\r\n    }\r\n\r\n    export function getSourceFileOfNode(node: Node): SourceFile {\r\n        while (node && node.kind !== SyntaxKind.SourceFile) node = node.parent;\r\n        return <SourceFile>node;\r\n    }\r\n\r\n    // This is a useful function for debugging purposes.\r\n    export function nodePosToString(node: Node): string {\r\n        var file = getSourceFileOfNode(node);\r\n        var loc = file.getLineAndCharacterFromPosition(node.pos);\r\n        return file.filename + \"(\" + loc.line + \",\" + loc.character + \")\";\r\n    }\r\n\r\n\r\n    export function getStartPosOfNode(node: Node): number {\r\n        return node.pos;\r\n    }\r\n\r\n    export function getTokenPosOfNode(node: Node): number {\r\n        return skipTrivia(getSourceFileOfNode(node).text, node.pos);\r\n    }\r\n\r\n    export function getSourceTextOfNodeFromSourceText(sourceText: string, node: Node): string {\r\n        return sourceText.substring(skipTrivia(sourceText, node.pos), node.end);\r\n    }\r\n\r\n    export function getSourceTextOfNode(node: Node): string {\r\n        var text = getSourceFileOfNode(node).text;\r\n        return text.substring(skipTrivia(text, node.pos), node.end);\r\n    }\r\n\r\n    // Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__'\r\n    export function escapeIdentifier(identifier: string): string {\r\n        return identifier.length >= 2 && identifier.charCodeAt(0) === CharacterCodes._ && identifier.charCodeAt(1) === CharacterCodes._ ? \"_\" + identifier : identifier;\r\n    }\r\n\r\n    // Remove extra underscore from escaped identifier\r\n    export function unescapeIdentifier(identifier: string): string {\r\n        return identifier.length >= 3 && identifier.charCodeAt(0) === CharacterCodes._ && identifier.charCodeAt(1) === CharacterCodes._ && identifier.charCodeAt(2) === CharacterCodes._ ? identifier.substr(1) : identifier;\r\n    }\r\n\r\n    // Return display name of an identifier\r\n    export function identifierToString(identifier: Identifier) {\r\n        return identifier.kind === SyntaxKind.Missing ? \"(Missing)\" : getSourceTextOfNode(identifier);\r\n    }\r\n\r\n    export function createDiagnosticForNode(node: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): Diagnostic {\r\n        node = getErrorSpanForNode(node);\r\n        var file = getSourceFileOfNode(node);\r\n        var start = skipTrivia(file.text, node.pos);\r\n        var length = node.end - start;\r\n\r\n        return createFileDiagnostic(file, start, length, message, arg0, arg1, arg2);\r\n    }\r\n\r\n    export function createDiagnosticForNodeFromMessageChain(node: Node, messageChain: DiagnosticMessageChain, newLine: string): Diagnostic {\r\n        node = getErrorSpanForNode(node);\r\n        var file = getSourceFileOfNode(node);\r\n        var start = skipTrivia(file.text, node.pos);\r\n        var length = node.end - start;\r\n        return flattenDiagnosticChain(file, start, length, messageChain, newLine);\r\n    }\r\n\r\n    export function getErrorSpanForNode(node: Node): Node {\r\n        var errorSpan: Node;\r\n        switch (node.kind) {\r\n            // This list is a work in progress. Add missing node kinds to improve their error\r\n            // spans.\r\n            case SyntaxKind.VariableDeclaration:\r\n            case SyntaxKind.ClassDeclaration:\r\n            case SyntaxKind.InterfaceDeclaration:\r\n            case SyntaxKind.ModuleDeclaration:\r\n            case SyntaxKind.EnumDeclaration:\r\n            case SyntaxKind.EnumMember:\r\n                errorSpan = (<Declaration>node).name;\r\n                break;\r\n        }\r\n\r\n        // We now have the ideal error span, but it may be a node that is optional and absent\r\n        // (e.g. the name of a function expression), in which case errorSpan will be undefined.\r\n        // Alternatively, it might be required and missing (e.g. the name of a module), in which\r\n        // case its pos will equal its end (length 0). In either of these cases, we should fall\r\n        // back to the original node that the error was issued on.\r\n        return errorSpan && errorSpan.pos < errorSpan.end ? errorSpan : node;\r\n    }\r\n\r\n    export function isExternalModule(file: SourceFile): boolean {\r\n        return file.externalModuleIndicator !== undefined;\r\n    }\r\n\r\n    export function isPrologueDirective(node: Node): boolean {\r\n        return node.kind === SyntaxKind.ExpressionStatement && (<ExpressionStatement>node).expression.kind === SyntaxKind.StringLiteral;\r\n    }\r\n\r\n    function isEvalOrArgumentsIdentifier(node: Node): boolean {\r\n        return node.kind === SyntaxKind.Identifier &&\r\n            (<Identifier>node).text &&\r\n            ((<Identifier>node).text === \"eval\" || (<Identifier>node).text === \"arguments\");\r\n    }\r\n\r\n    /// Should be called only on prologue directives (isPrologueDirective(node) should be true)\r\n    function isUseStrictPrologueDirective(node: Node): boolean {\r\n        Debug.assert(isPrologueDirective(node));\r\n        return (<Identifier>(<ExpressionStatement>node).expression).text === \"use strict\";\r\n    }\r\n\r\n    export function getLeadingCommentsOfNode(node: Node, sourceFileOfNode: SourceFile) {\r\n        // If parameter/type parameter, the prev token trailing comments are part of this node too\r\n        if (node.kind === SyntaxKind.Parameter || node.kind === SyntaxKind.TypeParameter) {\r\n            // eg     (/** blah */ a, /** blah */ b);\r\n            return concatenate(getTrailingComments(sourceFileOfNode.text, node.pos),\r\n                // eg:     (\r\n                //          /** blah */ a,\r\n                //          /** blah */ b);\r\n                getLeadingComments(sourceFileOfNode.text, node.pos));\r\n        }\r\n        else {\r\n            return getLeadingComments(sourceFileOfNode.text, node.pos);\r\n        }\r\n    }\r\n\r\n    export function getJsDocComments(node: Declaration, sourceFileOfNode: SourceFile) {\r\n        return filter(getLeadingCommentsOfNode(node, sourceFileOfNode), comment => isJsDocComment(comment));\r\n\r\n        function isJsDocComment(comment: Comment) {\r\n            // js doc is if comment is starting with /** but not if it is /**/\r\n            return sourceFileOfNode.text.charCodeAt(comment.pos + 1) === CharacterCodes.asterisk &&\r\n                sourceFileOfNode.text.charCodeAt(comment.pos + 2) === CharacterCodes.asterisk &&\r\n                sourceFileOfNode.text.charCodeAt(comment.pos + 3) !== CharacterCodes.slash;\r\n        }\r\n    }\r\n\r\n    export var fullTripleSlashReferencePathRegEx = /^(\\/\\/\\/\\s*<reference\\s+path\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/\r\n\r\n    // Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes\r\n    // stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,\r\n    // embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns\r\n    // a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.\r\n    export function forEachChild<T>(node: Node, cbNode: (node: Node) => T, cbNodes?: (nodes: Node[]) => T): T {\r\n        function child(node: Node): T {\r\n            if (node) return cbNode(node);\r\n        }\r\n        function children(nodes: Node[]) {\r\n            if (nodes) {\r\n                if (cbNodes) return cbNodes(nodes);\r\n                var result: T;\r\n                for (var i = 0, len = nodes.length; i < len; i++) {\r\n                    if (result = cbNode(nodes[i])) break;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        if (!node) return;\r\n        switch (node.kind) {\r\n            case SyntaxKind.QualifiedName:\r\n                return child((<QualifiedName>node).left) ||\r\n                    child((<QualifiedName>node).right);\r\n            case SyntaxKind.TypeParameter:\r\n                return child((<TypeParameterDeclaration>node).name) ||\r\n                    child((<TypeParameterDeclaration>node).constraint);\r\n            case SyntaxKind.Parameter:\r\n                return child((<ParameterDeclaration>node).name) ||\r\n                    child((<ParameterDeclaration>node).type) ||\r\n                    child((<ParameterDeclaration>node).initializer);\r\n            case SyntaxKind.Property:\r\n            case SyntaxKind.PropertyAssignment:\r\n                return child((<PropertyDeclaration>node).name) ||\r\n                    child((<PropertyDeclaration>node).type) ||\r\n                    child((<PropertyDeclaration>node).initializer);\r\n            case SyntaxKind.CallSignature:\r\n            case SyntaxKind.ConstructSignature:\r\n            case SyntaxKind.IndexSignature:\r\n                return children((<SignatureDeclaration>node).typeParameters) ||\r\n                    children((<SignatureDeclaration>node).parameters) ||\r\n                    child((<SignatureDeclaration>node).type);\r\n            case SyntaxKind.Method:\r\n            case SyntaxKind.Constructor:\r\n            case SyntaxKind.GetAccessor:\r\n            case SyntaxKind.SetAccessor:\r\n            case SyntaxKind.FunctionExpression:\r\n            case SyntaxKind.FunctionDeclaration:\r\n            case SyntaxKind.ArrowFunction:\r\n                return child((<FunctionDeclaration>node).name) ||\r\n                    children((<FunctionDeclaration>node).typeParameters) ||\r\n                    children((<FunctionDeclaration>node).parameters) ||\r\n                    child((<FunctionDeclaration>node).type) ||\r\n                    child((<FunctionDeclaration>node).body);\r\n            case SyntaxKind.TypeReference:\r\n                return child((<TypeReferenceNode>node).typeName) ||\r\n                    children((<TypeReferenceNode>node).typeArguments);\r\n            case SyntaxKind.TypeQuery:\r\n                return child((<TypeQueryNode>node).exprName);\r\n            case SyntaxKind.TypeLiteral:\r\n                return children((<TypeLiteralNode>node).members);\r\n            case SyntaxKind.ArrayType:\r\n                return child((<ArrayTypeNode>node).elementType);\r\n            case SyntaxKind.ArrayLiteral:\r\n                return children((<ArrayLiteral>node).elements);\r\n            case SyntaxKind.ObjectLiteral:\r\n                return children((<ObjectLiteral>node).properties);\r\n            case SyntaxKind.PropertyAccess:\r\n                return child((<PropertyAccess>node).left) ||\r\n                    child((<PropertyAccess>node).right);\r\n            case SyntaxKind.IndexedAccess:\r\n                return child((<IndexedAccess>node).object) ||\r\n                    child((<IndexedAccess>node).index);\r\n            case SyntaxKind.CallExpression:\r\n            case SyntaxKind.NewExpression:\r\n                return child((<CallExpression>node).func) ||\r\n                    children((<CallExpression>node).typeArguments) ||\r\n                    children((<CallExpression>node).arguments);\r\n            case SyntaxKind.TypeAssertion:\r\n                return child((<TypeAssertion>node).type) ||\r\n                    child((<TypeAssertion>node).operand);\r\n            case SyntaxKind.ParenExpression:\r\n                return child((<ParenExpression>node).expression);\r\n            case SyntaxKind.PrefixOperator:\r\n            case SyntaxKind.PostfixOperator:\r\n                return child((<UnaryExpression>node).operand);\r\n            case SyntaxKind.BinaryExpression:\r\n                return child((<BinaryExpression>node).left) ||\r\n                    child((<BinaryExpression>node).right);\r\n            case SyntaxKind.ConditionalExpression:\r\n                return child((<ConditionalExpression>node).condition) ||\r\n                    child((<ConditionalExpression>node).whenTrue) ||\r\n                    child((<ConditionalExpression>node).whenFalse);\r\n            case SyntaxKind.Block:\r\n            case SyntaxKind.TryBlock:\r\n            case SyntaxKind.FinallyBlock:\r\n            case SyntaxKind.FunctionBlock:\r\n            case SyntaxKind.ModuleBlock:\r\n            case SyntaxKind.SourceFile:\r\n                return children((<Block>node).statements);\r\n            case SyntaxKind.VariableStatement:\r\n                return children((<VariableStatement>node).declarations);\r\n            case SyntaxKind.ExpressionStatement:\r\n                return child((<ExpressionStatement>node).expression);\r\n            case SyntaxKind.IfStatement:\r\n                return child((<IfStatement>node).expression) ||\r\n                    child((<IfStatement>node).thenStatement) ||\r\n                    child((<IfStatement>node).elseStatement);\r\n            case SyntaxKind.DoStatement:\r\n                return child((<DoStatement>node).statement) ||\r\n                    child((<DoStatement>node).expression);\r\n            case SyntaxKind.WhileStatement:\r\n                return child((<WhileStatement>node).expression) ||\r\n                    child((<WhileStatement>node).statement);\r\n            case SyntaxKind.ForStatement:\r\n                return children((<ForStatement>node).declarations) ||\r\n                    child((<ForStatement>node).initializer) ||\r\n                    child((<ForStatement>node).condition) ||\r\n                    child((<ForStatement>node).iterator) ||\r\n                    child((<ForStatement>node).statement);\r\n            case SyntaxKind.ForInStatement:\r\n                return child((<ForInStatement>node).declaration) ||\r\n                    child((<ForInStatement>node).variable) ||\r\n                    child((<ForInStatement>node).expression) ||\r\n                    child((<ForInStatement>node).statement);\r\n            case SyntaxKind.ContinueStatement:\r\n            case SyntaxKind.BreakStatement:\r\n                return child((<BreakOrContinueStatement>node).label);\r\n            case SyntaxKind.ReturnStatement:\r\n                return child((<ReturnStatement>node).expression);\r\n            case SyntaxKind.WithStatement:\r\n                return child((<WithStatement>node).expression) ||\r\n                    child((<WithStatement>node).statement);\r\n            case SyntaxKind.SwitchStatement:\r\n                return child((<SwitchStatement>node).expression) ||\r\n                    children((<SwitchStatement>node).clauses);\r\n            case SyntaxKind.CaseClause:\r\n            case SyntaxKind.DefaultClause:\r\n                return child((<CaseOrDefaultClause>node).expression) ||\r\n                    children((<CaseOrDefaultClause>node).statements);\r\n            case SyntaxKind.LabelledStatement:\r\n                return child((<LabelledStatement>node).label) ||\r\n                    child((<LabelledStatement>node).statement);\r\n            case SyntaxKind.ThrowStatement:\r\n                return child((<ThrowStatement>node).expression);\r\n            case SyntaxKind.TryStatement:\r\n                return child((<TryStatement>node).tryBlock) ||\r\n                    child((<TryStatement>node).catchBlock) ||\r\n                    child((<TryStatement>node).finallyBlock);\r\n            case SyntaxKind.CatchBlock:\r\n                return child((<CatchBlock>node).variable) ||\r\n                    children((<CatchBlock>node).statements);\r\n            case SyntaxKind.VariableDeclaration:\r\n                return child((<VariableDeclaration>node).name) ||\r\n                    child((<VariableDeclaration>node).type) ||\r\n                    child((<VariableDeclaration>node).initializer);\r\n            case SyntaxKind.ClassDeclaration:\r\n                return child((<ClassDeclaration>node).name) ||\r\n                    children((<ClassDeclaration>node).typeParameters) ||\r\n                    child((<ClassDeclaration>node).baseType) ||\r\n                    children((<ClassDeclaration>node).implementedTypes) ||\r\n                    children((<ClassDeclaration>node).members);\r\n            case SyntaxKind.InterfaceDeclaration:\r\n                return child((<InterfaceDeclaration>node).name) ||\r\n                    children((<InterfaceDeclaration>node).typeParameters) ||\r\n                    children((<InterfaceDeclaration>node).baseTypes) ||\r\n                    children((<InterfaceDeclaration>node).members);\r\n            case SyntaxKind.EnumDeclaration:\r\n                return child((<EnumDeclaration>node).name) ||\r\n                    children((<EnumDeclaration>node).members);\r\n            case SyntaxKind.EnumMember:\r\n                return child((<EnumMember>node).name) ||\r\n                    child((<EnumMember>node).initializer);\r\n            case SyntaxKind.ModuleDeclaration:\r\n                return child((<ModuleDeclaration>node).name) ||\r\n                    child((<ModuleDeclaration>node).body);\r\n            case SyntaxKind.ImportDeclaration:\r\n                return child((<ImportDeclaration>node).name) ||\r\n                    child((<ImportDeclaration>node).entityName) ||\r\n                    child((<ImportDeclaration>node).externalModuleName);\r\n            case SyntaxKind.ExportAssignment:\r\n                return child((<ExportAssignment>node).exportName);\r\n        }\r\n    }\r\n\r\n    export function hasRestParameters(s: SignatureDeclaration): boolean {\r\n        return s.parameters.length > 0 && (s.parameters[s.parameters.length - 1].flags & NodeFlags.Rest) !== 0;\r\n    }\r\n\r\n    export function isInAmbientContext(node: Node): boolean {\r\n        while (node) {\r\n            if (node.flags & (NodeFlags.Ambient | NodeFlags.DeclarationFile)) return true;\r\n            node = node.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    enum ParsingContext {\r\n        SourceElements,          // Elements in source file\r\n        ModuleElements,          // Elements in module declaration\r\n        BlockStatements,         // Statements in block\r\n        SwitchClauses,           // Clauses in switch statement\r\n        SwitchClauseStatements,  // Statements in switch clause\r\n        TypeMembers,             // Members in interface or type literal\r\n        ClassMembers,            // Members in class declaration\r\n        EnumMembers,             // Members in enum declaration\r\n        BaseTypeReferences,      // Type references in extends or implements clause\r\n        VariableDeclarations,    // Variable declarations in variable statement\r\n        ArgumentExpressions,     // Expressions in argument list\r\n        ObjectLiteralMembers,    // Members in object literal\r\n        ArrayLiteralMembers,     // Members in array literal\r\n        Parameters,              // Parameters in parameter list\r\n        TypeParameters,          // Type parameters in type parameter list\r\n        TypeArguments,           // Type arguments in type argument list\r\n        Count                    // Number of parsing contexts\r\n    }\r\n\r\n    enum Tristate {\r\n        False,\r\n        True,\r\n        Unknown\r\n    }\r\n\r\n    function parsingContextErrors(context: ParsingContext): DiagnosticMessage {\r\n        switch (context) {\r\n            case ParsingContext.SourceElements:         return Diagnostics.Declaration_or_statement_expected;\r\n            case ParsingContext.ModuleElements:         return Diagnostics.Declaration_or_statement_expected;\r\n            case ParsingContext.BlockStatements:        return Diagnostics.Statement_expected;\r\n            case ParsingContext.SwitchClauses:          return Diagnostics.case_or_default_expected;\r\n            case ParsingContext.SwitchClauseStatements: return Diagnostics.Statement_expected;\r\n            case ParsingContext.TypeMembers:            return Diagnostics.Property_or_signature_expected;\r\n            case ParsingContext.ClassMembers:           return Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected;\r\n            case ParsingContext.EnumMembers:            return Diagnostics.Enum_member_expected;\r\n            case ParsingContext.BaseTypeReferences:     return Diagnostics.Type_reference_expected;\r\n            case ParsingContext.VariableDeclarations:   return Diagnostics.Variable_declaration_expected;\r\n            case ParsingContext.ArgumentExpressions:    return Diagnostics.Argument_expression_expected;\r\n            case ParsingContext.ObjectLiteralMembers:   return Diagnostics.Property_assignment_expected;\r\n            case ParsingContext.ArrayLiteralMembers:    return Diagnostics.Expression_or_comma_expected;\r\n            case ParsingContext.Parameters:             return Diagnostics.Parameter_declaration_expected;\r\n            case ParsingContext.TypeParameters:         return Diagnostics.Type_parameter_declaration_expected;\r\n            case ParsingContext.TypeArguments:          return Diagnostics.Type_argument_expected;\r\n        }\r\n    };\r\n\r\n    enum LookAheadMode {\r\n        NotLookingAhead,\r\n        NoErrorYet,\r\n        Error\r\n    }\r\n\r\n    enum ModifierContext {\r\n        SourceElements,          // Top level elements in a source file\r\n        ModuleElements,          // Elements in module declaration\r\n        ClassMembers,            // Members in class declaration\r\n        Parameters,              // Parameters in parameter list\r\n    }\r\n\r\n    enum TrailingCommaBehavior {\r\n        Disallow,\r\n        Allow,\r\n        Preserve\r\n    }\r\n\r\n    // Tracks whether we nested (directly or indirectly) in a certain control block.\r\n    // Used for validating break and continue statements.\r\n    enum ControlBlockContext {\r\n        NotNested,\r\n        Nested,\r\n        CrossingFunctionBoundary\r\n    }\r\n\r\n    interface LabelledStatementInfo {\r\n        addLabel(label: Identifier): void;\r\n        pushCurrentLabelSet(isIterationStatement: boolean): void;\r\n        pushFunctionBoundary(): void;\r\n        pop(): void;\r\n        nodeIsNestedInLabel(label: Identifier, requireIterationStatement: boolean, stopAtFunctionBoundary: boolean): ControlBlockContext;\r\n    }\r\n\r\n    export function createSourceFile(filename: string, sourceText: string, languageVersion: ScriptTarget, version: string, isOpen: boolean = false): SourceFile {\r\n        var file: SourceFile;\r\n        var scanner: Scanner;\r\n        var token: SyntaxKind;\r\n        var parsingContext: ParsingContext;\r\n        var commentRanges: TextRange[];\r\n        var identifiers: Map<string> = {};\r\n        var identifierCount = 0;\r\n        var nodeCount = 0;\r\n        var lineStarts: number[];\r\n        var isInStrictMode = false;\r\n\r\n        var lookAheadMode = LookAheadMode.NotLookingAhead;\r\n        var inAmbientContext = false;\r\n        var inFunctionBody = false;\r\n        var inSwitchStatement = ControlBlockContext.NotNested;\r\n        var inIterationStatement = ControlBlockContext.NotNested;\r\n\r\n        // The following is a state machine that tracks what labels are in our current parsing\r\n        // context. So if we are parsing a node that is nested (arbitrarily deeply) in a label,\r\n        // it will be tracked in this data structure. It is used for checking break/continue\r\n        // statements, and checking for duplicate labels.\r\n        var labelledStatementInfo: LabelledStatementInfo = (() => {\r\n            // These are initialized on demand because labels are rare, so it is usually\r\n            // not even necessary to allocate these.\r\n            var functionBoundarySentinel: StringSet;\r\n            var currentLabelSet: StringSet;\r\n            var labelSetStack: StringSet[];\r\n            var isIterationStack: boolean[];\r\n\r\n            function addLabel(label: Identifier): void {\r\n                if (!currentLabelSet) {\r\n                    currentLabelSet = {};\r\n                }\r\n                currentLabelSet[label.text] = true;\r\n            }\r\n\r\n            function pushCurrentLabelSet(isIterationStatement: boolean): void {\r\n                if (!labelSetStack && !isIterationStack) {\r\n                    labelSetStack = [];\r\n                    isIterationStack = [];\r\n                }\r\n                Debug.assert(currentLabelSet !== undefined);\r\n                labelSetStack.push(currentLabelSet);\r\n                isIterationStack.push(isIterationStatement);\r\n                currentLabelSet = undefined;\r\n            }\r\n\r\n            function pushFunctionBoundary(): void {\r\n                if (!functionBoundarySentinel) {\r\n                    functionBoundarySentinel = {};\r\n                    if (!labelSetStack && !isIterationStack) {\r\n                        labelSetStack = [];\r\n                        isIterationStack = [];\r\n                    }\r\n                }\r\n                Debug.assert(currentLabelSet === undefined);\r\n                labelSetStack.push(functionBoundarySentinel);\r\n\r\n                // It does not matter what we push here, since we will never ask if a function boundary\r\n                // is an iteration statement\r\n                isIterationStack.push(false);\r\n            }\r\n\r\n            function pop(): void {\r\n                // Assert that we are in a \"pushed\" state\r\n                Debug.assert(labelSetStack.length && isIterationStack.length && currentLabelSet === undefined);\r\n                labelSetStack.pop();\r\n                isIterationStack.pop();\r\n            }\r\n\r\n            function nodeIsNestedInLabel(label: Identifier, requireIterationStatement: boolean, stopAtFunctionBoundary: boolean): ControlBlockContext {\r\n                if (!requireIterationStatement && currentLabelSet && hasProperty(currentLabelSet, label.text)) {\r\n                    return ControlBlockContext.Nested;\r\n                }\r\n\r\n                if (!labelSetStack) {\r\n                    return ControlBlockContext.NotNested;\r\n                }\r\n\r\n                // We want to start searching for the label at the lowest point in the tree,\r\n                // and climb up from there. So we start at the end of the labelSetStack array.\r\n                var crossedFunctionBoundary = false;\r\n                for (var i = labelSetStack.length - 1; i >= 0; i--) {\r\n                    var labelSet = labelSetStack[i];\r\n                    // Not allowed to cross function boundaries, so stop if we encounter one\r\n                    if (labelSet === functionBoundarySentinel) {\r\n                        if (stopAtFunctionBoundary) {\r\n                            break;\r\n                        }\r\n                        else {\r\n                            crossedFunctionBoundary = true;\r\n                            continue;\r\n                        }\r\n                    }\r\n                    \r\n                    // If we require an iteration statement, only search in the current\r\n                    // statement if it is an iteration statement\r\n                    if (requireIterationStatement && isIterationStack[i] === false) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (hasProperty(labelSet, label.text)) {\r\n                        return crossedFunctionBoundary ? ControlBlockContext.CrossingFunctionBoundary : ControlBlockContext.Nested;\r\n                    }\r\n                }\r\n\r\n                // This is a bit of a misnomer. If the caller passed true for stopAtFunctionBoundary,\r\n                // there actually may be an enclosing label across a function boundary, but we will\r\n                // just return NotNested\r\n                return ControlBlockContext.NotNested;\r\n            }\r\n\r\n            return {\r\n                addLabel: addLabel,\r\n                pushCurrentLabelSet: pushCurrentLabelSet,\r\n                pushFunctionBoundary: pushFunctionBoundary,\r\n                pop: pop,\r\n                nodeIsNestedInLabel: nodeIsNestedInLabel,\r\n            };\r\n        })();\r\n\r\n        function getLineAndCharacterlFromSourcePosition(position: number) {\r\n            if (!lineStarts) {\r\n                lineStarts = getLineStarts(sourceText);\r\n            }\r\n            return getLineAndCharacterOfPosition(lineStarts, position);\r\n        }\r\n\r\n        function getPositionFromSourceLineAndCharacter(line: number, character: number): number {\r\n            if (!lineStarts) {\r\n                lineStarts = getLineStarts(sourceText);\r\n            }\r\n            return getPositionFromLineAndCharacter(lineStarts, line, character);\r\n        }\r\n\r\n        function error(message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): void {\r\n            var start = scanner.getTokenPos();\r\n            var length = scanner.getTextPos() - start;\r\n\r\n            errorAtPos(start, length, message, arg0, arg1, arg2);\r\n        }\r\n\r\n        // This is just like createDiagnosticForNode except that it uses the current file\r\n        // being parsed instead of the file containing the node. This is because during\r\n        // parse, the nodes do not have parent pointers to get to the file.\r\n        //\r\n        // It is very intentional that we are not checking or changing the lookAheadMode value\r\n        // here. 'grammarErrorOnNode' is called when we are doing extra grammar checks and not\r\n        // when we are doing the actual parsing to determine what the user wrote.  In other \r\n        // words, this function is called once we have already parsed the node, and are just\r\n        // applying some stricter checks on that node.\r\n        function grammarErrorOnNode(node: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): void {\r\n            var span = getErrorSpanForNode(node);\r\n            var start = skipTrivia(file.text, span.pos);\r\n            var length = span.end - start;\r\n\r\n            file.syntacticErrors.push(createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));\r\n        }\r\n\r\n        function reportInvalidUseInStrictMode(node: Identifier): void {\r\n            // identifierToString cannot be used here since it uses backreference to 'parent' that is not yet set\r\n            var name = sourceText.substring(skipTrivia(sourceText, node.pos), node.end);\r\n            grammarErrorOnNode(node, Diagnostics.Invalid_use_of_0_in_strict_mode, name);\r\n        }\r\n\r\n\r\n        function grammarErrorAtPos(start: number, length: number, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): void {\r\n            file.syntacticErrors.push(createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));\r\n        }\r\n\r\n        function errorAtPos(start: number, length: number, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): void {\r\n            var lastErrorPos = file.syntacticErrors.length\r\n                ? file.syntacticErrors[file.syntacticErrors.length - 1].start\r\n                : -1;\r\n            if (start !== lastErrorPos) {\r\n                file.syntacticErrors.push(createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));\r\n            }\r\n\r\n            if (lookAheadMode === LookAheadMode.NoErrorYet) {\r\n                lookAheadMode = LookAheadMode.Error;\r\n            }\r\n        }\r\n\r\n        function scanError(message: DiagnosticMessage) {\r\n            var pos = scanner.getTextPos();\r\n            errorAtPos(pos, 0, message);\r\n        }\r\n\r\n        function onComment(pos: number, end: number) {\r\n            if (commentRanges) commentRanges.push({ pos: pos, end: end });\r\n        }\r\n\r\n        function getNodePos(): number {\r\n            return scanner.getStartPos();\r\n        }\r\n\r\n        function getNodeEnd(): number {\r\n            return scanner.getStartPos();\r\n        }\r\n\r\n        function nextToken(): SyntaxKind {\r\n            return token = scanner.scan();\r\n        }\r\n\r\n        function getTokenPos(pos: number): number {\r\n            return skipTrivia(sourceText, pos);\r\n        }\r\n\r\n        function reScanGreaterToken(): SyntaxKind {\r\n            return token = scanner.reScanGreaterToken();\r\n        }\r\n\r\n        function reScanSlashToken(): SyntaxKind {\r\n            return token = scanner.reScanSlashToken();\r\n        }\r\n\r\n        function lookAheadHelper<T>(callback: () => T, alwaysResetState: boolean): T {\r\n            // Keep track of the state we'll need to rollback to if lookahead fails (or if the \r\n            // caller asked us to always reset our state).\r\n            var saveToken = token;\r\n            var saveSyntacticErrorsLength = file.syntacticErrors.length;\r\n\r\n            // Keep track of the current look ahead mode (this matters if we have nested \r\n            // speculative parsing).\r\n            var saveLookAheadMode = lookAheadMode;\r\n\r\n            // Mark that we're in speculative parsing and then try to parse out whatever code\r\n            // the callback wants.\r\n            lookAheadMode = LookAheadMode.NoErrorYet;\r\n            var result = callback();\r\n\r\n            // If we switched from 1 to to -1 then a parse error occurred during the callback.\r\n            // If that's the case, then we want to act as if we never got any result at all.\r\n            Debug.assert(lookAheadMode === LookAheadMode.Error || lookAheadMode === LookAheadMode.NoErrorYet);\r\n            if (lookAheadMode === LookAheadMode.Error) {\r\n                result = undefined;\r\n            }\r\n\r\n            // Now restore as appropriate.\r\n            lookAheadMode = saveLookAheadMode;\r\n            if (!result || alwaysResetState) {\r\n                token = saveToken;\r\n                file.syntacticErrors.length = saveSyntacticErrorsLength;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function lookAhead<T>(callback: () => T): T {\r\n            var result: T;\r\n            scanner.tryScan(() => {\r\n                result = lookAheadHelper(callback, /*alwaysResetState:*/ true);\r\n\r\n                // Returning false here indicates to the scanner that it should always jump\r\n                // back to where it started.  This makes sense as 'lookahead' acts as if \r\n                // neither the parser nor scanner was affected by the operation.\r\n                //\r\n                // Note: the rewinding of the parser state is already handled in lookAheadHelper\r\n                // (because we passed 'true' for alwaysResetState).\r\n                return false;\r\n            });\r\n\r\n            return result;\r\n        }\r\n\r\n        function tryParse<T>(callback: () => T): T {\r\n            return scanner.tryScan(() => lookAheadHelper(callback, /*alwaysResetState:*/ false));\r\n        }\r\n\r\n        function isIdentifier(): boolean {\r\n            return token === SyntaxKind.Identifier || (isInStrictMode ? token > SyntaxKind.LastFutureReservedWord : token > SyntaxKind.LastReservedWord);\r\n        }\r\n\r\n        function parseExpected(t: SyntaxKind): boolean {\r\n            if (token === t) {\r\n                nextToken();\r\n                return true;\r\n            }\r\n            error(Diagnostics._0_expected, tokenToString(t));\r\n            return false;\r\n        }\r\n\r\n        function parseOptional(t: SyntaxKind): boolean {\r\n            if (token === t) {\r\n                nextToken();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function canParseSemicolon() {\r\n            // If there's a real semicolon, then we can always parse it out.\r\n            if (token === SyntaxKind.SemicolonToken) {\r\n                return true;\r\n            }\r\n\r\n            // We can parse out an optional semicolon in ASI cases in the following cases.\r\n            return token === SyntaxKind.CloseBraceToken || token === SyntaxKind.EndOfFileToken || scanner.hasPrecedingLineBreak();\r\n        }\r\n\r\n        function parseSemicolon(): void {\r\n            if (canParseSemicolon()) {\r\n                if (token === SyntaxKind.SemicolonToken) {\r\n                    // consume the semicolon if it was explicitly provided.\r\n                    nextToken();\r\n                }\r\n            }\r\n            else {\r\n                error(Diagnostics._0_expected, \";\");\r\n            }\r\n        }\r\n\r\n        function createNode(kind: SyntaxKind, pos?: number): Node {\r\n            nodeCount++;\r\n            var node = new (nodeConstructors[kind] || (nodeConstructors[kind] = objectAllocator.getNodeConstructor(kind)))();\r\n            if (!(pos >= 0)) pos = scanner.getStartPos();\r\n            node.pos = pos;\r\n            node.end = pos;\r\n            return node;\r\n        }\r\n\r\n        function finishNode<T extends Node>(node: T): T {\r\n            node.end = scanner.getStartPos();\r\n            return node;\r\n        }\r\n\r\n        function createMissingNode(): Node {\r\n            return createNode(SyntaxKind.Missing);\r\n        }\r\n\r\n        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues\r\n        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for\r\n        // each identifier in order to reduce memory consumption.\r\n        function createIdentifier(isIdentifier: boolean): Identifier {\r\n            identifierCount++;\r\n            if (isIdentifier) {\r\n                var node = <Identifier>createNode(SyntaxKind.Identifier);\r\n                var text = escapeIdentifier(scanner.getTokenValue());\r\n                node.text = hasProperty(identifiers, text) ? identifiers[text] : (identifiers[text] = text);\r\n                nextToken();\r\n                return finishNode(node);\r\n            }\r\n            error(Diagnostics.Identifier_expected);\r\n            return <Identifier>createMissingNode();\r\n        }\r\n\r\n        function parseIdentifier(): Identifier {\r\n            return createIdentifier(isIdentifier());\r\n        }\r\n\r\n        function parseIdentifierName(): Identifier {\r\n            return createIdentifier(token >= SyntaxKind.Identifier);\r\n        }\r\n\r\n        function isPropertyName(): boolean {\r\n            return token >= SyntaxKind.Identifier || token === SyntaxKind.StringLiteral || token === SyntaxKind.NumericLiteral;\r\n        }\r\n\r\n        function parsePropertyName(): Identifier {\r\n            if (token === SyntaxKind.StringLiteral || token === SyntaxKind.NumericLiteral) {\r\n                return <LiteralExpression>parsePrimaryExpression();\r\n            }\r\n            return parseIdentifierName();\r\n        }\r\n\r\n\r\n        function isKeyword(token: SyntaxKind): boolean {\r\n            return SyntaxKind.FirstKeyword <= token && token <= SyntaxKind.LastKeyword;\r\n        }\r\n\r\n        function isModifier(token: SyntaxKind): boolean {\r\n            switch (token) {\r\n                case SyntaxKind.PublicKeyword:\r\n                case SyntaxKind.PrivateKeyword:\r\n                case SyntaxKind.StaticKeyword:\r\n                case SyntaxKind.ExportKeyword:\r\n                case SyntaxKind.DeclareKeyword:\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function parseContextualModifier(t: SyntaxKind): boolean {\r\n            return token === t && tryParse(() => {\r\n                nextToken();\r\n                return token === SyntaxKind.OpenBracketToken || isPropertyName();\r\n            });\r\n        }\r\n\r\n        function parseAnyContextualModifier(): boolean {\r\n            return isModifier(token) && tryParse(() => {\r\n                nextToken();\r\n                return token === SyntaxKind.OpenBracketToken || isPropertyName();\r\n            });\r\n        }\r\n\r\n        // True if positioned at the start of a list element\r\n        function isListElement(kind: ParsingContext, inErrorRecovery: boolean): boolean {\r\n            switch (kind) {\r\n                case ParsingContext.SourceElements:\r\n                case ParsingContext.ModuleElements:\r\n                    return isSourceElement(inErrorRecovery);\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauseStatements:\r\n                    return isStatement(inErrorRecovery);\r\n                case ParsingContext.SwitchClauses:\r\n                    return token === SyntaxKind.CaseKeyword || token === SyntaxKind.DefaultKeyword;\r\n                case ParsingContext.TypeMembers:\r\n                    return isTypeMember();\r\n                case ParsingContext.ClassMembers:\r\n                    return lookAhead(isClassMemberStart);\r\n                case ParsingContext.EnumMembers:\r\n                case ParsingContext.ObjectLiteralMembers:\r\n                    return isPropertyName();\r\n                case ParsingContext.BaseTypeReferences:\r\n                    return isIdentifier() && ((token !== SyntaxKind.ExtendsKeyword && token !== SyntaxKind.ImplementsKeyword) || !lookAhead(() => (nextToken(), isIdentifier())));\r\n                case ParsingContext.VariableDeclarations:\r\n                case ParsingContext.TypeParameters:\r\n                    return isIdentifier();\r\n                case ParsingContext.ArgumentExpressions:\r\n                    return isExpression();\r\n                case ParsingContext.ArrayLiteralMembers:\r\n                    return token === SyntaxKind.CommaToken || isExpression();\r\n                case ParsingContext.Parameters:\r\n                    return isParameter();\r\n                case ParsingContext.TypeArguments:\r\n                    return isType();\r\n            }\r\n\r\n            Debug.fail(\"Non-exhaustive case in 'isListElement'.\");\r\n        }\r\n\r\n        // True if positioned at a list terminator\r\n        function isListTerminator(kind: ParsingContext): boolean {\r\n            if (token === SyntaxKind.EndOfFileToken) {\r\n                // Being at the end of the file ends all lists.\r\n                return true;\r\n            }\r\n\r\n            switch (kind) {\r\n                case ParsingContext.ModuleElements:\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauses:\r\n                case ParsingContext.TypeMembers:\r\n                case ParsingContext.ClassMembers:\r\n                case ParsingContext.EnumMembers:\r\n                case ParsingContext.ObjectLiteralMembers:\r\n                    return token === SyntaxKind.CloseBraceToken;\r\n                case ParsingContext.SwitchClauseStatements:\r\n                    return token === SyntaxKind.CloseBraceToken || token === SyntaxKind.CaseKeyword || token === SyntaxKind.DefaultKeyword;\r\n                case ParsingContext.BaseTypeReferences:\r\n                    return token === SyntaxKind.OpenBraceToken || token === SyntaxKind.ExtendsKeyword || token === SyntaxKind.ImplementsKeyword;\r\n                case ParsingContext.VariableDeclarations:\r\n                    return isVariableDeclaratorListTerminator();\r\n                case ParsingContext.TypeParameters:\r\n                    // Tokens other than '>' are here for better error recovery\r\n                    return token === SyntaxKind.GreaterThanToken || token === SyntaxKind.OpenParenToken || token === SyntaxKind.OpenBraceToken || token === SyntaxKind.ExtendsKeyword || token === SyntaxKind.ImplementsKeyword;\r\n                case ParsingContext.ArgumentExpressions:\r\n                    // Tokens other than ')' are here for better error recovery\r\n                    return token === SyntaxKind.CloseParenToken || token === SyntaxKind.SemicolonToken;\r\n                case ParsingContext.ArrayLiteralMembers:\r\n                    return token === SyntaxKind.CloseBracketToken;\r\n                case ParsingContext.Parameters:\r\n                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery\r\n                    return token === SyntaxKind.CloseParenToken || token === SyntaxKind.CloseBracketToken || token === SyntaxKind.OpenBraceToken;\r\n                case ParsingContext.TypeArguments:\r\n                    // Tokens other than '>' are here for better error recovery\r\n                    return token === SyntaxKind.GreaterThanToken || token === SyntaxKind.OpenParenToken;\r\n            }\r\n        }\r\n\r\n        function isVariableDeclaratorListTerminator(): boolean {\r\n            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done \r\n            // with parsing the list of  variable declarators.\r\n            if (canParseSemicolon()) {\r\n                return true;\r\n            }\r\n\r\n            // in the case where we're parsing the variable declarator of a 'for-in' statement, we \r\n            // are done if we see an 'in' keyword in front of us.\r\n            if (token === SyntaxKind.InKeyword) {\r\n                return true;\r\n            }\r\n\r\n            // ERROR RECOVERY TWEAK:\r\n            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an\r\n            // arrow function here and it's going to be very unlikely that we'll resynchronize and get\r\n            // another variable declaration.\r\n            if (token === SyntaxKind.EqualsGreaterThanToken) {\r\n                return true;\r\n            }\r\n\r\n            // Keep trying to parse out variable declarators.\r\n            return false;\r\n        }\r\n\r\n        // True if positioned at element or terminator of the current list or any enclosing list\r\n        function isInSomeParsingContext(): boolean {\r\n            for (var kind = 0; kind < ParsingContext.Count; kind++) {\r\n                if (parsingContext & (1 << kind)) {\r\n                    if (isListElement(kind, /* inErrorRecovery */ true) || isListTerminator(kind)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Parses a list of elements\r\n        function parseList<T extends Node>(kind: ParsingContext, checkForStrictMode: boolean, parseElement: () => T): NodeArray<T> {\r\n            var saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << kind;\r\n            var result = <NodeArray<T>>[];\r\n            result.pos = getNodePos();\r\n            var saveIsInStrictMode = isInStrictMode;\r\n            while (!isListTerminator(kind)) {\r\n                if (isListElement(kind, /* inErrorRecovery */ false)) {\r\n                    var element = parseElement();\r\n                    result.push(element);\r\n                    // test elements only if we are not already in strict mode\r\n                    if (!isInStrictMode && checkForStrictMode) {\r\n                        if (isPrologueDirective(element)) {\r\n                            if (isUseStrictPrologueDirective(element)) {\r\n                                isInStrictMode = true;\r\n                                checkForStrictMode = false;\r\n                            }\r\n                        }\r\n                        else {\r\n                            checkForStrictMode = false;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    error(parsingContextErrors(kind));\r\n                    if (isInSomeParsingContext()) {\r\n                        break;\r\n                    }\r\n                    nextToken();\r\n                }\r\n            }\r\n            isInStrictMode = saveIsInStrictMode;\r\n            result.end = getNodeEnd();\r\n            parsingContext = saveParsingContext;\r\n            return result;\r\n        }\r\n\r\n        // Parses a comma-delimited list of elements\r\n        function parseDelimitedList<T extends Node>(kind: ParsingContext, parseElement: () => T, trailingCommaBehavior: TrailingCommaBehavior): NodeArray<T> {\r\n            var saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << kind;\r\n            var result = <NodeArray<T>>[];\r\n            result.pos = getNodePos();\r\n            // Keep track of how many errors we had before the list started. If we don't see any new\r\n            // errors resulting from the list being malformed, we are free to complain about a trailing comma.\r\n            var errorCountBeforeParsingList = file.syntacticErrors.length;\r\n            var commaStart = -1; // Meaning the previous token was not a comma\r\n            while (true) {\r\n                if (isListElement(kind, /* inErrorRecovery */ false)) {\r\n                    result.push(parseElement());\r\n                    commaStart = scanner.getTokenPos();\r\n                    if (parseOptional(SyntaxKind.CommaToken)) {\r\n                        continue;\r\n                    }\r\n                    commaStart = -1; // Back to the state where the last token was not a comma\r\n                    if (isListTerminator(kind)) {\r\n                        break;\r\n                    }\r\n                    error(Diagnostics._0_expected, \",\");\r\n                }\r\n                else if (isListTerminator(kind)) {\r\n                    // Check if the last token was a comma.\r\n                    if (commaStart >= 0) {\r\n                        if (trailingCommaBehavior === TrailingCommaBehavior.Disallow) {\r\n                            if (file.syntacticErrors.length === errorCountBeforeParsingList) {\r\n                                // Report a grammar error so we don't affect lookahead\r\n                                grammarErrorAtPos(commaStart, scanner.getStartPos() - commaStart, Diagnostics.Trailing_comma_not_allowed);\r\n                            }\r\n                        }\r\n                        else if (trailingCommaBehavior === TrailingCommaBehavior.Preserve) {\r\n                            result.push(<T>createNode(SyntaxKind.OmittedExpression));\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                else {\r\n                    error(parsingContextErrors(kind));\r\n                    if (isInSomeParsingContext()) {\r\n                        break;\r\n                    }\r\n                    nextToken();\r\n                }\r\n            }\r\n            result.end = getNodeEnd();\r\n            parsingContext = saveParsingContext;\r\n            return result;\r\n        }\r\n\r\n        function createMissingList<T>(): NodeArray<T> {\r\n            var pos = getNodePos();\r\n            var result = <NodeArray<T>>[];\r\n            result.pos = pos;\r\n            result.end = pos;\r\n            return result;\r\n        }\r\n\r\n        function createNodeArray<T extends Node>(node: T): NodeArray<T> {\r\n            var result = <NodeArray<T>>[node];\r\n            result.pos = node.pos;\r\n            result.end = node.end;\r\n            return result;\r\n        }\r\n\r\n        function parseBracketedList<T extends Node>(kind: ParsingContext, parseElement: () => T, startToken: SyntaxKind, endToken: SyntaxKind): NodeArray<T> {\r\n            if (parseExpected(startToken)) {\r\n                var result = parseDelimitedList(kind, parseElement, TrailingCommaBehavior.Disallow);\r\n                parseExpected(endToken);\r\n                return result;\r\n            }\r\n            return createMissingList<T>();\r\n        }\r\n\r\n        // The allowReservedWords parameter controls whether reserved words are permitted after the first dot\r\n        function parseEntityName(allowReservedWords: boolean): EntityName {\r\n            var entity: EntityName = parseIdentifier();\r\n            while (parseOptional(SyntaxKind.DotToken)) {\r\n                var node = <QualifiedName>createNode(SyntaxKind.QualifiedName, entity.pos);\r\n                node.left = entity;\r\n                node.right = allowReservedWords ? parseIdentifierName() : parseIdentifier();\r\n                entity = finishNode(node);\r\n            }\r\n            return entity;\r\n        }\r\n\r\n        function parseTokenNode(): Node {\r\n            var node = createNode(token);\r\n            nextToken();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseLiteralNode(): LiteralExpression {\r\n            var node = <LiteralExpression>createNode(token);\r\n            node.text = scanner.getTokenValue();\r\n            var tokenPos = scanner.getTokenPos();\r\n            nextToken();\r\n            finishNode(node);\r\n            \r\n            // Octal literals are not allowed in strict mode or ES5\r\n            // Note that theoretically the following condition would hold true literals like 009,\r\n            // which is not octal.But because of how the scanner separates the tokens, we would\r\n            // never get a token like this.Instead, we would get 00 and 9 as two separate tokens.\r\n            // We also do not need to check for negatives because any prefix operator would be part of a\r\n            // parent unary expression.\r\n            if (node.kind === SyntaxKind.NumericLiteral\r\n                && sourceText.charCodeAt(tokenPos) === CharacterCodes._0\r\n                && isOctalDigit(sourceText.charCodeAt(tokenPos + 1))) {\r\n\r\n                if (isInStrictMode) {\r\n                    grammarErrorOnNode(node, Diagnostics.Octal_literals_are_not_allowed_in_strict_mode);\r\n                }\r\n                else if (languageVersion >= ScriptTarget.ES5) {\r\n                    grammarErrorOnNode(node, Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher);\r\n                }\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        function parseStringLiteral(): LiteralExpression {\r\n            if (token === SyntaxKind.StringLiteral) return parseLiteralNode();\r\n            error(Diagnostics.String_literal_expected);\r\n            return <LiteralExpression>createMissingNode();\r\n        }\r\n\r\n        // TYPES\r\n\r\n        function parseTypeReference(): TypeReferenceNode {\r\n            var node = <TypeReferenceNode>createNode(SyntaxKind.TypeReference);\r\n            node.typeName = parseEntityName(/*allowReservedWords*/ false);\r\n            if (!scanner.hasPrecedingLineBreak() && token === SyntaxKind.LessThanToken) {\r\n                node.typeArguments = parseTypeArguments();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeQuery(): TypeQueryNode {\r\n            var node = <TypeQueryNode>createNode(SyntaxKind.TypeQuery);\r\n            parseExpected(SyntaxKind.TypeOfKeyword);\r\n            node.exprName = parseEntityName(/*allowReservedWords*/ true);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeParameter(): TypeParameterDeclaration {\r\n            var node = <TypeParameterDeclaration>createNode(SyntaxKind.TypeParameter);\r\n            node.name = parseIdentifier();\r\n            if (parseOptional(SyntaxKind.ExtendsKeyword)) {\r\n                // It's not uncommon for people to write improper constraints to a generic.  If the \r\n                // user writes a constraint that is an expression and not an actual type, then parse\r\n                // it out as an expression (so we can recover well), but report that a type is needed\r\n                // instead.\r\n                if (isType() || !isExpression()) {\r\n                    node.constraint = parseType();\r\n                }\r\n                else {\r\n                    // It was not a type, and it looked like an expression.  Parse out an expression\r\n                    // here so we recover well.  Note: it is important that we call parseUnaryExpression\r\n                    // and not parseExpression here.  If the user has:\r\n                    //\r\n                    //      <T extends \"\">\r\n                    //\r\n                    // We do *not* want to consume the  >  as we're consuming the expression for \"\".\r\n                    var expr = parseUnaryExpression();\r\n                    grammarErrorOnNode(expr, Diagnostics.Type_expected);\r\n                }\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTypeParameters(): NodeArray<TypeParameterDeclaration> {\r\n            if (token === SyntaxKind.LessThanToken) {\r\n                var pos = getNodePos();\r\n                var result = parseBracketedList(ParsingContext.TypeParameters, parseTypeParameter, SyntaxKind.LessThanToken, SyntaxKind.GreaterThanToken);\r\n                if (!result.length) {\r\n                    var start = getTokenPos(pos);\r\n                    var length = getNodePos() - start;\r\n                    errorAtPos(start, length, Diagnostics.Type_parameter_list_cannot_be_empty);\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n\r\n        function parseParameterType(): TypeNode {\r\n            return parseOptional(SyntaxKind.ColonToken) ? token === SyntaxKind.StringLiteral ? parseStringLiteral() : parseType() : undefined;\r\n        }\r\n\r\n        function isParameter(): boolean {\r\n            return token === SyntaxKind.DotDotDotToken || isIdentifier() || isModifier(token);\r\n        }\r\n\r\n        function parseParameter(flags: NodeFlags = 0): ParameterDeclaration {\r\n            var node = <ParameterDeclaration>createNode(SyntaxKind.Parameter);\r\n            node.flags |= parseAndCheckModifiers(ModifierContext.Parameters);\r\n            if (parseOptional(SyntaxKind.DotDotDotToken)) {\r\n                node.flags |= NodeFlags.Rest;\r\n            }\r\n            node.name = parseIdentifier();\r\n            if (node.name.kind === SyntaxKind.Missing && node.flags === 0 && isModifier(token)) {\r\n                // in cases like\r\n                // 'use strict' \r\n                // function foo(static)\r\n                // isParameter('static') === true, because of isModifier('static')\r\n                // however 'static' is not a legal identifier in a strict mode.\r\n                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)\r\n                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)\r\n                // to avoid this we'll advance cursor to the next token.\r\n                nextToken();\r\n            }\r\n\r\n            if (parseOptional(SyntaxKind.QuestionToken)) {\r\n                node.flags |= NodeFlags.QuestionMark;\r\n            }\r\n            node.type = parseParameterType();\r\n            node.initializer = parseInitializer(/*inParameter*/ true);\r\n\r\n            // Do not check for initializers in an ambient context for parameters. This is not\r\n            // a grammar error because the grammar allows arbitrary call signatures in\r\n            // an ambient context.\r\n            // It is actually not necessary for this to be an error at all. The reason is that\r\n            // function/constructor implementations are syntactically disallowed in ambient\r\n            // contexts. In addition, parameter initializers are semantically disallowed in\r\n            // overload signatures. So parameter initializers are transitively disallowed in\r\n            // ambient contexts.\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseSignature(kind: SyntaxKind, returnToken: SyntaxKind): ParsedSignature {\r\n            if (kind === SyntaxKind.ConstructSignature) {\r\n                parseExpected(SyntaxKind.NewKeyword);\r\n            }\r\n            var typeParameters = parseTypeParameters();\r\n            var parameters = parseParameterList(SyntaxKind.OpenParenToken, SyntaxKind.CloseParenToken);\r\n            checkParameterList(parameters);\r\n            var type = parseOptional(returnToken) ? parseType() : undefined;\r\n            return {\r\n                typeParameters: typeParameters,\r\n                parameters: parameters,\r\n                type: type\r\n            };\r\n        }\r\n\r\n        // Because we use this for index signatures as well, we sometimes use\r\n        // parentheses, and sometimes use brackets.\r\n        function parseParameterList(startDelimiter: SyntaxKind, endDelimiter: SyntaxKind) {\r\n            return parseBracketedList(ParsingContext.Parameters, parseParameter, startDelimiter, endDelimiter);\r\n        }\r\n\r\n        function checkParameterList(parameters: NodeArray<ParameterDeclaration>): void {\r\n            var seenOptionalParameter = false;\r\n            var parameterCount = parameters.length;\r\n\r\n            for (var i = 0; i < parameterCount; i++) {\r\n                var parameter = parameters[i];\r\n                // It is a SyntaxError if the Identifier \"eval\" or the Identifier \"arguments\" occurs as the \r\n                // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code \r\n                // or if its FunctionBody is strict code(11.1.5).\r\n                // It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a \r\n                // strict mode FunctionDeclaration or FunctionExpression(13.1) \r\n                if (isInStrictMode && isEvalOrArgumentsIdentifier(parameter.name)) {\r\n                    reportInvalidUseInStrictMode(parameter.name);\r\n                    return;\r\n                }\r\n                else if (parameter.flags & NodeFlags.Rest) {\r\n                    if (i !== (parameterCount - 1)) {\r\n                        grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);\r\n                        return;\r\n                    }\r\n\r\n                    if (parameter.flags & NodeFlags.QuestionMark) {\r\n                        grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_be_optional);\r\n                        return;\r\n                    }\r\n\r\n                    if (parameter.initializer) {\r\n                        grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer);\r\n                        return;\r\n                    }\r\n                }\r\n                else if (parameter.flags & NodeFlags.QuestionMark || parameter.initializer) {\r\n                    seenOptionalParameter = true;\r\n\r\n                    if (parameter.flags & NodeFlags.QuestionMark && parameter.initializer) {\r\n                        grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer);\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    if (seenOptionalParameter) {\r\n                        grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function parseSignatureMember(kind: SyntaxKind, returnToken: SyntaxKind): SignatureDeclaration {\r\n            var node = <SignatureDeclaration>createNode(kind);\r\n            var sig = parseSignature(kind, returnToken);\r\n            node.typeParameters = sig.typeParameters;\r\n            node.parameters = sig.parameters;\r\n            node.type = sig.type;\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseIndexSignatureMember(): SignatureDeclaration {\r\n            var node = <SignatureDeclaration>createNode(SyntaxKind.IndexSignature);\r\n            var errorCountBeforeIndexSignature = file.syntacticErrors.length;\r\n            var indexerStart = scanner.getTokenPos();\r\n            node.parameters = parseParameterList(SyntaxKind.OpenBracketToken, SyntaxKind.CloseBracketToken);\r\n            var indexerLength = scanner.getStartPos() - indexerStart;\r\n            node.type = parseTypeAnnotation();\r\n            parseSemicolon();\r\n            if (file.syntacticErrors.length === errorCountBeforeIndexSignature) {\r\n                checkIndexSignature(node, indexerStart, indexerLength);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function checkIndexSignature(node: SignatureDeclaration, indexerStart: number, indexerLength: number): void {\r\n            var parameter = node.parameters[0];\r\n            if (node.parameters.length !== 1) {\r\n                var arityDiagnostic = Diagnostics.An_index_signature_must_have_exactly_one_parameter;\r\n                if (parameter) {\r\n                    grammarErrorOnNode(parameter.name, arityDiagnostic);\r\n                }\r\n                else {\r\n                    grammarErrorAtPos(indexerStart, indexerLength, arityDiagnostic);\r\n                }\r\n                return;\r\n            }\r\n            else if (parameter.flags & NodeFlags.Rest) {\r\n                grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_cannot_have_a_rest_parameter);\r\n                return;\r\n            }\r\n            else if (parameter.flags & NodeFlags.Modifier) {\r\n                grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);\r\n                return;\r\n            }\r\n            else if (parameter.flags & NodeFlags.QuestionMark) {\r\n                grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);\r\n                return;\r\n            }\r\n            else if (parameter.initializer) {\r\n                grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);\r\n                return;\r\n            }\r\n            else if (!parameter.type) {\r\n                grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);\r\n                return;\r\n            }\r\n            else if (parameter.type.kind !== SyntaxKind.StringKeyword &&\r\n                parameter.type.kind !== SyntaxKind.NumberKeyword) {\r\n                grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_or_number);\r\n                return;\r\n            }\r\n            else if (!node.type) {\r\n                grammarErrorAtPos(indexerStart, indexerLength, Diagnostics.An_index_signature_must_have_a_type_annotation);\r\n                return;\r\n            }\r\n        }\r\n\r\n        function parsePropertyOrMethod(): Declaration {\r\n            var node = <Declaration>createNode(SyntaxKind.Unknown);\r\n            node.name = parsePropertyName();\r\n            if (parseOptional(SyntaxKind.QuestionToken)) {\r\n                node.flags |= NodeFlags.QuestionMark;\r\n            }\r\n            if (token === SyntaxKind.OpenParenToken || token === SyntaxKind.LessThanToken) {\r\n                node.kind = SyntaxKind.Method;\r\n                var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n                (<MethodDeclaration>node).typeParameters = sig.typeParameters;\r\n                (<MethodDeclaration>node).parameters = sig.parameters;\r\n                (<MethodDeclaration>node).type = sig.type;\r\n            }\r\n            else {\r\n                node.kind = SyntaxKind.Property;\r\n                (<PropertyDeclaration>node).type = parseTypeAnnotation();\r\n            }\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isTypeMember(): boolean {\r\n            switch (token) {\r\n                case SyntaxKind.OpenParenToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.OpenBracketToken:\r\n                    return true;\r\n                default:\r\n                    return isPropertyName() && lookAhead(() => nextToken() === SyntaxKind.OpenParenToken || token === SyntaxKind.LessThanToken || token === SyntaxKind.QuestionToken ||\r\n                        token === SyntaxKind.ColonToken || canParseSemicolon());\r\n            }\r\n        }\r\n\r\n        function parseTypeMember(): Declaration {\r\n            switch (token) {\r\n                case SyntaxKind.OpenParenToken:\r\n                case SyntaxKind.LessThanToken:\r\n                    return parseSignatureMember(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n                case SyntaxKind.OpenBracketToken:\r\n                    return parseIndexSignatureMember();\r\n                case SyntaxKind.NewKeyword:\r\n                    if (lookAhead(() => nextToken() === SyntaxKind.OpenParenToken || token === SyntaxKind.LessThanToken)) {\r\n                        return parseSignatureMember(SyntaxKind.ConstructSignature, SyntaxKind.ColonToken);\r\n                    }\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.NumericLiteral:\r\n                    return parsePropertyOrMethod();\r\n                default:\r\n                    if (token >= SyntaxKind.Identifier) {\r\n                        return parsePropertyOrMethod();\r\n                    }\r\n            }\r\n        }\r\n\r\n        function parseTypeLiteral(): TypeLiteralNode {\r\n            var node = <TypeLiteralNode>createNode(SyntaxKind.TypeLiteral);\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                node.members = parseList(ParsingContext.TypeMembers, /*checkForStrictMode*/ false, parseTypeMember);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.members = createMissingList<Node>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionType(signatureKind: SyntaxKind): TypeLiteralNode {\r\n            var node = <TypeLiteralNode>createNode(SyntaxKind.TypeLiteral);\r\n            var member = <SignatureDeclaration>createNode(signatureKind);\r\n            var sig = parseSignature(signatureKind, SyntaxKind.EqualsGreaterThanToken);\r\n            member.typeParameters = sig.typeParameters;\r\n            member.parameters = sig.parameters;\r\n            member.type = sig.type;\r\n            finishNode(member);\r\n            node.members = createNodeArray(member);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseKeywordAndNoDot(): Node {\r\n            var node = parseTokenNode();\r\n            return token === SyntaxKind.DotToken ? undefined : node;\r\n        }\r\n\r\n        function parseNonArrayType(): TypeNode {\r\n            switch (token) {\r\n                case SyntaxKind.AnyKeyword:\r\n                case SyntaxKind.StringKeyword:\r\n                case SyntaxKind.NumberKeyword:\r\n                case SyntaxKind.BooleanKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                    var node = tryParse(parseKeywordAndNoDot);\r\n                    return node || parseTypeReference();\r\n                case SyntaxKind.TypeOfKeyword:\r\n                    return parseTypeQuery();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseTypeLiteral();\r\n                case SyntaxKind.OpenParenToken:\r\n                case SyntaxKind.LessThanToken:\r\n                    return parseFunctionType(SyntaxKind.CallSignature);\r\n                case SyntaxKind.NewKeyword:\r\n                    return parseFunctionType(SyntaxKind.ConstructSignature);\r\n                default:\r\n                    if (isIdentifier()) {\r\n                        return parseTypeReference();\r\n                    }\r\n            }\r\n            error(Diagnostics.Type_expected);\r\n            return <TypeNode>createMissingNode();\r\n        }\r\n\r\n        function isType(): boolean {\r\n            switch (token) {\r\n                case SyntaxKind.AnyKeyword:\r\n                case SyntaxKind.StringKeyword:\r\n                case SyntaxKind.NumberKeyword:\r\n                case SyntaxKind.BooleanKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.NewKeyword:\r\n                    return true;\r\n                case SyntaxKind.OpenParenToken:\r\n                    // Only consider an ( as the start of a type if we have  ()  or  (id\r\n                    // We don't want to consider things like  (1)  as a function type.\r\n                    return lookAhead(() => {\r\n                        nextToken();\r\n                        return token === SyntaxKind.CloseParenToken || isParameter();\r\n                    });\r\n                default:\r\n                    return isIdentifier();\r\n            }\r\n        }\r\n\r\n        function parseType(): TypeNode {\r\n            var type = parseNonArrayType();\r\n            while (type && !scanner.hasPrecedingLineBreak() && parseOptional(SyntaxKind.OpenBracketToken)) {\r\n                parseExpected(SyntaxKind.CloseBracketToken);\r\n                var node = <ArrayTypeNode>createNode(SyntaxKind.ArrayType, type.pos);\r\n                node.elementType = type;\r\n                type = finishNode(node);\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function parseTypeAnnotation(): TypeNode {\r\n            return parseOptional(SyntaxKind.ColonToken) ? parseType() : undefined;\r\n        }\r\n\r\n        // EXPRESSIONS\r\n\r\n        function isExpression(): boolean {\r\n            switch (token) {\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.SuperKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                case SyntaxKind.OpenParenToken:\r\n                case SyntaxKind.OpenBracketToken:\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.FunctionKeyword:\r\n                case SyntaxKind.NewKeyword:\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.SlashEqualsToken:\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DeleteKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.PlusPlusToken:\r\n                case SyntaxKind.MinusMinusToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.Identifier:\r\n                    return true;\r\n                default:\r\n                    return isIdentifier();\r\n            }\r\n        }\r\n\r\n        function isExpressionStatement(): boolean {\r\n            // As per the grammar, neither '{' nor 'function' can start an expression statement.\r\n            return token !== SyntaxKind.OpenBraceToken && token !== SyntaxKind.FunctionKeyword && isExpression();\r\n        }\r\n\r\n        function parseExpression(noIn?: boolean): Expression {\r\n            var expr = parseAssignmentExpression(noIn);\r\n            while (parseOptional(SyntaxKind.CommaToken)) {\r\n                expr = makeBinaryExpression(expr, SyntaxKind.CommaToken, parseAssignmentExpression(noIn));\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        function parseInitializer(inParameter: boolean, noIn?: boolean): Expression {\r\n            if (token !== SyntaxKind.EqualsToken) {\r\n                // It's not uncommon during typing for the user to miss writing the '=' token.  Check if\r\n                // there is no newline after the last token and if we're on an expression.  If so, parse\r\n                // this as an equals-value clause with a missing equals.\r\n                // NOTE: There are two places where we allow equals-value clauses.  The first is in a \r\n                // variable declarator.  The second is with a parameter.  For variable declarators\r\n                // it's more likely that a { would be a allowed (as an object literal).  While this\r\n                // is also allowed for parameters, the risk is that we consume the { as an object\r\n                // literal when it really will be for the block following the parameter.\r\n                if (scanner.hasPrecedingLineBreak() || (inParameter && token === SyntaxKind.OpenBraceToken) || !isExpression()) {\r\n                    // preceding line break, open brace in a parameter (likely a function body) or current token is not an expression - \r\n                    // do not try to parse initializer\r\n                    return undefined;\r\n                }\r\n            }\r\n\r\n            parseExpected(SyntaxKind.EqualsToken);\r\n            return parseAssignmentExpression(noIn);\r\n        }\r\n\r\n        function parseAssignmentExpression(noIn?: boolean): Expression {\r\n            // Augmented by TypeScript:\r\n            //\r\n            //  AssignmentExpression[in]:\r\n            //      1) ConditionalExpression[in]\r\n            //      2) LeftHandSideExpression = AssignmentExpression[in]\r\n            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[in]\r\n            //      4) ArrowFunctionExpression <-- added by TypeScript\r\n            //\r\n            // Note: for ease of implementation we treat productions '2' and '3' as the same thing. \r\n            // (i.e. they're both BinaryExpressions with an assignment operator in it).\r\n\r\n            // First, check if we have an arrow function (production '4') that starts with a parenthesized\r\n            // parameter list. If we do, we must *not* recurse for productsion 1, 2 or 3. An ArrowFunction is\r\n            // not a  LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done \r\n            // with AssignmentExpression if we see one.\r\n            var arrowExpression = tryParseParenthesizedArrowFunctionExpression();\r\n            if (arrowExpression) {\r\n                return arrowExpression;\r\n            }\r\n\r\n            // Now try to handle the rest of the cases.  First, see if we can parse out up to and\r\n            // including a conditional expression.\r\n            var expr = parseConditionalExpression(noIn);\r\n\r\n            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized\r\n            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single\r\n            // identifier and the current token is an arrow.\r\n            if (expr.kind === SyntaxKind.Identifier && token === SyntaxKind.EqualsGreaterThanToken) {\r\n                return parseSimpleArrowFunctionExpression(<Identifier>expr);\r\n            }\r\n\r\n            // Now see if we might be in cases '2' or '3'.\r\n            // If the expression was a LHS expression, and we  have an assignment operator, then \r\n            // we're in '2' or '3'.  Consume the assignment and return.\r\n            if (isLeftHandSideExpression(expr) && isAssignmentOperator()) {\r\n                if (isInStrictMode && isEvalOrArgumentsIdentifier(expr)) {\r\n                    // ECMA 262 (Annex C) The identifier eval or arguments may not appear as the LeftHandSideExpression of an \r\n                    // Assignment operator(11.13) or of a PostfixExpression(11.3)\r\n                    reportInvalidUseInStrictMode(<Identifier>expr);\r\n                }\r\n                var operator = token;\r\n                nextToken();\r\n                return makeBinaryExpression(expr, operator, parseAssignmentExpression(noIn));\r\n            }\r\n\r\n            // otherwise this was production '1'.  Return whatever we parsed so far.\r\n            return expr;\r\n        }\r\n\r\n        function isLeftHandSideExpression(expr: Expression): boolean {\r\n            if (expr) {\r\n                switch (expr.kind) {\r\n                    case SyntaxKind.PropertyAccess:\r\n                    case SyntaxKind.IndexedAccess:\r\n                    case SyntaxKind.NewExpression:\r\n                    case SyntaxKind.CallExpression:\r\n                    case SyntaxKind.ArrayLiteral:\r\n                    case SyntaxKind.ParenExpression:\r\n                    case SyntaxKind.ObjectLiteral:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.Identifier:\r\n                    case SyntaxKind.Missing:\r\n                    case SyntaxKind.RegularExpressionLiteral:\r\n                    case SyntaxKind.NumericLiteral:\r\n                    case SyntaxKind.StringLiteral:\r\n                    case SyntaxKind.FalseKeyword:\r\n                    case SyntaxKind.NullKeyword:\r\n                    case SyntaxKind.ThisKeyword:\r\n                    case SyntaxKind.TrueKeyword:\r\n                    case SyntaxKind.SuperKeyword:\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function parseSimpleArrowFunctionExpression(identifier: Identifier): Expression {\r\n            Debug.assert(token === SyntaxKind.EqualsGreaterThanToken, \"parseSimpleArrowFunctionExpression should only have been called if we had a =>\");\r\n            parseExpected(SyntaxKind.EqualsGreaterThanToken);\r\n\r\n            var parameter = <ParameterDeclaration>createNode(SyntaxKind.Parameter, identifier.pos);\r\n            parameter.name = identifier;\r\n            finishNode(parameter);\r\n\r\n            var parameters = <NodeArray<ParameterDeclaration>>[];\r\n            parameters.push(parameter);\r\n            parameters.pos = parameter.pos;\r\n            parameters.end = parameter.end;\r\n\r\n            var signature = <ParsedSignature> { parameters: parameters };\r\n\r\n            return parseArrowExpressionTail(identifier.pos, signature, /*noIn:*/ false);\r\n        }\r\n\r\n        function tryParseParenthesizedArrowFunctionExpression(): Expression {\r\n            // Indicates whether we are certain that we should parse an arrow expression.\r\n            var triState = isParenthesizedArrowFunctionExpression();\r\n\r\n            if (triState === Tristate.False) {\r\n                return undefined;\r\n            }\r\n\r\n            var pos = getNodePos();\r\n\r\n            if (triState === Tristate.True) {\r\n                var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n\r\n                // If we have an arrow, then try to parse the body.\r\n                // Even if not, try to parse if we have an opening brace, just in case we're in an error state.\r\n                if (parseExpected(SyntaxKind.EqualsGreaterThanToken) || token === SyntaxKind.OpenBraceToken) {\r\n                    return parseArrowExpressionTail(pos, sig, /* noIn: */ false);\r\n                }\r\n                else {\r\n                    // If not, we're probably better off bailing out and returning a bogus function expression.\r\n                    return makeFunctionExpression(SyntaxKind.ArrowFunction, pos, /* name */ undefined, sig, createMissingNode());\r\n                }\r\n            }\r\n            \r\n            // *Maybe* we had an arrow function and we need to try to parse it out,\r\n            // rolling back and trying other parses if we fail.\r\n            var sig = tryParseSignatureIfArrowOrBraceFollows();\r\n            if (sig) {\r\n                parseExpected(SyntaxKind.EqualsGreaterThanToken);\r\n                return parseArrowExpressionTail(pos, sig, /*noIn:*/ false);\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        }\r\n\r\n        //  True        -> We definitely expect a parenthesized arrow function here.\r\n        //  False       -> There *cannot* be a parenthesized arrow function here.\r\n        //  Unknown     -> There *might* be a parenthesized arrow function here.\r\n        //                 Speculatively look ahead to be sure, and rollback if not.\r\n        function isParenthesizedArrowFunctionExpression(): Tristate {\r\n            if (token === SyntaxKind.OpenParenToken || token === SyntaxKind.LessThanToken) {\r\n                return lookAhead(() => {\r\n                    var first = token;\r\n                    var second = nextToken();\r\n\r\n                    if (first === SyntaxKind.OpenParenToken) {\r\n                        if (second === SyntaxKind.CloseParenToken) {\r\n                            // Simple cases: \"() =>\", \"(): \", and  \"() {\".\r\n                            // This is an arrow function with no parameters.\r\n                            // The last one is not actually an arrow function,\r\n                            // but this is probably what the user intended.\r\n                            var third = nextToken();\r\n                            switch (third) {\r\n                                case SyntaxKind.EqualsGreaterThanToken:\r\n                                case SyntaxKind.ColonToken:\r\n                                case SyntaxKind.OpenBraceToken:\r\n                                    return Tristate.True;\r\n                                default:\r\n                                    return Tristate.False;\r\n                            }\r\n                        }\r\n\r\n                        // Simple case: \"(...\"\r\n                        // This is an arrow function with a rest parameter.\r\n                        if (second === SyntaxKind.DotDotDotToken) {\r\n                            return Tristate.True;\r\n                        }\r\n\r\n                        // If we had \"(\" followed by something that's not an identifier,\r\n                        // then this definitely doesn't look like a lambda.\r\n                        // Note: we could be a little more lenient and allow\r\n                        // \"(public\" or \"(private\". These would not ever actually be allowed,\r\n                        // but we could provide a good error message instead of bailing out.\r\n                        if (!isIdentifier()) {\r\n                            return Tristate.False;\r\n                        }\r\n\r\n                        // If we have something like \"(a:\", then we must have a\r\n                        // type-annotated parameter in an arrow function expression.\r\n                        if (nextToken() === SyntaxKind.ColonToken) {\r\n                            return Tristate.True;\r\n                        }\r\n\r\n                        // This *could* be a parenthesized arrow function.\r\n                        // Return Unknown to let the caller know.\r\n                        return Tristate.Unknown;\r\n                    }\r\n                    else {\r\n                        Debug.assert(first === SyntaxKind.LessThanToken);\r\n\r\n                        // If we have \"<\" not followed by an identifier,\r\n                        // then this definitely is not an arrow function.\r\n                        if (!isIdentifier()) {\r\n                            return Tristate.False;\r\n                        }\r\n\r\n                        // This *could* be a parenthesized arrow function.\r\n                        return Tristate.Unknown;\r\n                    }\r\n                });\r\n            }\r\n            if (token === SyntaxKind.EqualsGreaterThanToken) {\r\n                // ERROR RECOVERY TWEAK:\r\n                // If we see a standalone => try to parse it as an arrow function expression as that's\r\n                // likely whatthe user intended to write.\r\n                return Tristate.True;\r\n            }\r\n            // Definitely not a parenthesized arrow function.\r\n            return Tristate.False;\r\n        }\r\n\r\n        function tryParseSignatureIfArrowOrBraceFollows(): ParsedSignature {\r\n            return tryParse(() => {\r\n                var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n\r\n                // Parsing a signature isn't enough.\r\n                // Parenthesized arrow signatures often look like other valid expressions.\r\n                // For instance:\r\n                //  - \"(x = 10)\" is an assignment expression parsed as a signature with a default parameter value.\r\n                //  - \"(x,y)\" is a comma expression parsed as a signature with two parameters.\r\n                //  - \"a ? (b): c\" will have \"(b):\" parsed as a signature with a return type annotation.\r\n                //\r\n                // So we need just a bit of lookahead to ensure that it can only be a signature.\r\n                if (token === SyntaxKind.EqualsGreaterThanToken || token === SyntaxKind.OpenBraceToken) {\r\n                    return sig;\r\n                }\r\n\r\n                return undefined;\r\n            });\r\n        }\r\n\r\n        function parseArrowExpressionTail(pos: number, sig: ParsedSignature, noIn: boolean): FunctionExpression {\r\n            var body: Node;\r\n\r\n            if (token === SyntaxKind.OpenBraceToken) {\r\n                body = parseBody(/* ignoreMissingOpenBrace */ false);\r\n            }\r\n            else if (isStatement(/* inErrorRecovery */ true) && !isExpressionStatement() && token !== SyntaxKind.FunctionKeyword) {\r\n                // Check if we got a plain statement (i.e. no expression-statements, no functions expressions/declarations)\r\n                //\r\n                // Here we try to recover from a potential error situation in the case where the \r\n                // user meant to supply a block. For example, if the user wrote:\r\n                //\r\n                //  a =>\r\n                //      var v = 0;\r\n                //  }\r\n                //\r\n                // they may be missing an open brace.  Check to see if that's the case so we can\r\n                // try to recover better.  If we don't do this, then the next close curly we see may end\r\n                // up preemptively closing the containing construct.\r\n                //\r\n                // Note: even when 'ignoreMissingOpenBrace' is passed as true, parseBody will still error.\r\n                body = parseBody(/* ignoreMissingOpenBrace */ true);\r\n            }\r\n            else {\r\n                body = parseAssignmentExpression(noIn);\r\n            }\r\n\r\n            return makeFunctionExpression(SyntaxKind.ArrowFunction, pos, /* name */ undefined, sig, body);\r\n        }\r\n\r\n        function isAssignmentOperator(): boolean {\r\n            return token >= SyntaxKind.FirstAssignment && token <= SyntaxKind.LastAssignment;\r\n        }\r\n\r\n        function parseConditionalExpression(noIn?: boolean): Expression {\r\n            var expr = parseBinaryExpression(noIn);\r\n            while (parseOptional(SyntaxKind.QuestionToken)) {\r\n                var node = <ConditionalExpression>createNode(SyntaxKind.ConditionalExpression, expr.pos);\r\n                node.condition = expr;\r\n                node.whenTrue = parseAssignmentExpression(false);\r\n                parseExpected(SyntaxKind.ColonToken);\r\n                node.whenFalse = parseAssignmentExpression(noIn);\r\n                expr = finishNode(node);\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        function parseBinaryExpression(noIn?: boolean): Expression {\r\n            return parseBinaryOperators(parseUnaryExpression(), 0, noIn);\r\n        }\r\n\r\n        function parseBinaryOperators(expr: Expression, minPrecedence: number, noIn?: boolean): Expression {\r\n            while (true) {\r\n                reScanGreaterToken();\r\n                var precedence = getOperatorPrecedence();\r\n                if (precedence && precedence > minPrecedence && (!noIn || token !== SyntaxKind.InKeyword)) {\r\n                    var operator = token;\r\n                    nextToken();\r\n                    expr = makeBinaryExpression(expr, operator, parseBinaryOperators(parseUnaryExpression(), precedence, noIn));\r\n                    continue;\r\n                }\r\n                return expr;\r\n            }\r\n        }\r\n\r\n        function getOperatorPrecedence(): number {\r\n            switch (token) {\r\n                case SyntaxKind.BarBarToken:\r\n                    return 1;\r\n                case SyntaxKind.AmpersandAmpersandToken:\r\n                    return 2;\r\n                case SyntaxKind.BarToken:\r\n                    return 3;\r\n                case SyntaxKind.CaretToken:\r\n                    return 4;\r\n                case SyntaxKind.AmpersandToken:\r\n                    return 5;\r\n                case SyntaxKind.EqualsEqualsToken:\r\n                case SyntaxKind.ExclamationEqualsToken:\r\n                case SyntaxKind.EqualsEqualsEqualsToken:\r\n                case SyntaxKind.ExclamationEqualsEqualsToken:\r\n                    return 6;\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.GreaterThanToken:\r\n                case SyntaxKind.LessThanEqualsToken:\r\n                case SyntaxKind.GreaterThanEqualsToken:\r\n                case SyntaxKind.InstanceOfKeyword:\r\n                case SyntaxKind.InKeyword:\r\n                    return 7;\r\n                case SyntaxKind.LessThanLessThanToken:\r\n                case SyntaxKind.GreaterThanGreaterThanToken:\r\n                case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\r\n                    return 8;\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                    return 9;\r\n                case SyntaxKind.AsteriskToken:\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.PercentToken:\r\n                    return 10;\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function makeBinaryExpression(left: Expression, operator: SyntaxKind, right: Expression): BinaryExpression {\r\n            var node = <BinaryExpression>createNode(SyntaxKind.BinaryExpression, left.pos);\r\n            node.left = left;\r\n            node.operator = operator;\r\n            node.right = right;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseUnaryExpression(): Expression {\r\n            var pos = getNodePos();\r\n            switch (token) {\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DeleteKeyword:\r\n                case SyntaxKind.TypeOfKeyword:\r\n                case SyntaxKind.VoidKeyword:\r\n                case SyntaxKind.PlusPlusToken:\r\n                case SyntaxKind.MinusMinusToken:\r\n                    var operator = token;\r\n                    nextToken();\r\n                    var operand = parseUnaryExpression();\r\n                    if (isInStrictMode) {\r\n                        // The identifier eval or arguments may not appear as the LeftHandSideExpression of an \r\n                        // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression \r\n                        // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator\r\n                        if ((token === SyntaxKind.PlusPlusToken || token === SyntaxKind.MinusMinusToken) && isEvalOrArgumentsIdentifier(operand)) {\r\n                            reportInvalidUseInStrictMode(<Identifier>operand);\r\n                        }\r\n                        else if (token === SyntaxKind.DeleteKeyword && operand.kind === SyntaxKind.Identifier) {\r\n                            // When a delete operator occurs within strict mode code, a SyntaxError is thrown if its \r\n                            // UnaryExpression is a direct reference to a variable, function argument, or function name\r\n                            grammarErrorOnNode(operand, Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode);\r\n                        }\r\n                    }\r\n                    return makeUnaryExpression(SyntaxKind.PrefixOperator, pos, operator, operand);\r\n                case SyntaxKind.LessThanToken:\r\n                    return parseTypeAssertion();\r\n            }\r\n\r\n            var primaryExpression = parsePrimaryExpression();\r\n            // TS 1.0 spec (2014): 4.8\r\n            // CallExpression:  ( Modified )\r\n            //  super   (   ArgumentListopt   )\r\n            //  super   .   IdentifierName\r\n            var illegalUsageOfSuperKeyword =\r\n                primaryExpression.kind === SyntaxKind.SuperKeyword && token !== SyntaxKind.OpenParenToken && token !== SyntaxKind.DotToken;\r\n\r\n            if (illegalUsageOfSuperKeyword) {\r\n                error(Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);\r\n            }\r\n\r\n            var expr = parseCallAndAccess(primaryExpression, /* inNewExpression */ false);\r\n\r\n            Debug.assert(isLeftHandSideExpression(expr));\r\n            if ((token === SyntaxKind.PlusPlusToken || token === SyntaxKind.MinusMinusToken) && !scanner.hasPrecedingLineBreak()) {\r\n                // The identifier eval or arguments may not appear as the LeftHandSideExpression of an \r\n                // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression \r\n                // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator. \r\n                if (isInStrictMode && isEvalOrArgumentsIdentifier(expr)) {\r\n                    reportInvalidUseInStrictMode(<Identifier>expr);\r\n                }\r\n                var operator = token;\r\n                nextToken();\r\n                expr = makeUnaryExpression(SyntaxKind.PostfixOperator, expr.pos, operator, expr);\r\n            }\r\n\r\n            return expr;\r\n        }\r\n\r\n        function parseTypeAssertion(): TypeAssertion {\r\n            var node = <TypeAssertion>createNode(SyntaxKind.TypeAssertion);\r\n            parseExpected(SyntaxKind.LessThanToken);\r\n            node.type = parseType();\r\n            parseExpected(SyntaxKind.GreaterThanToken);\r\n            node.operand = parseUnaryExpression();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function makeUnaryExpression(kind: SyntaxKind, pos: number, operator: SyntaxKind, operand: Expression): UnaryExpression {\r\n            var node = <UnaryExpression>createNode(kind, pos);\r\n            node.operator = operator;\r\n            node.operand = operand;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseCallAndAccess(expr: Expression, inNewExpression: boolean): Expression {\r\n            while (true) {\r\n                if (parseOptional(SyntaxKind.DotToken)) {\r\n                    var propertyAccess = <PropertyAccess>createNode(SyntaxKind.PropertyAccess, expr.pos);\r\n                    propertyAccess.left = expr;\r\n                    propertyAccess.right = parseIdentifierName();\r\n                    expr = finishNode(propertyAccess);\r\n                    continue;\r\n                }\r\n\r\n                var bracketStart = scanner.getTokenPos();\r\n                if (parseOptional(SyntaxKind.OpenBracketToken)) {\r\n\r\n                    var indexedAccess = <IndexedAccess>createNode(SyntaxKind.IndexedAccess, expr.pos);\r\n                    indexedAccess.object = expr;\r\n\r\n                    // It's not uncommon for a user to write: \"new Type[]\".\r\n                    // Check for that common pattern and report a better error message.\r\n                    if (inNewExpression && parseOptional(SyntaxKind.CloseBracketToken)) {\r\n                        indexedAccess.index = createMissingNode();\r\n                        grammarErrorAtPos(bracketStart, scanner.getStartPos() - bracketStart, Diagnostics.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);\r\n                    }\r\n                    else {\r\n                        indexedAccess.index = parseExpression();\r\n                        parseExpected(SyntaxKind.CloseBracketToken);\r\n                    }\r\n\r\n                    expr = finishNode(indexedAccess);\r\n                    continue;\r\n                }\r\n\r\n                // Try to parse a Call Expression unless we are in a New Expression.\r\n                // If we are parsing a New Expression, then parentheses are optional, \r\n                // and is taken care of by the 'parseNewExpression' caller.\r\n                if ((token === SyntaxKind.OpenParenToken || token === SyntaxKind.LessThanToken) && !inNewExpression) {\r\n                    var callExpr = <CallExpression>createNode(SyntaxKind.CallExpression, expr.pos);\r\n                    callExpr.func = expr;\r\n                    if (token === SyntaxKind.LessThanToken) {\r\n                        if (!(callExpr.typeArguments = tryParse(parseTypeArgumentsAndOpenParen))) return expr;\r\n                    }\r\n                    else {\r\n                        parseExpected(SyntaxKind.OpenParenToken);\r\n                    }\r\n                    callExpr.arguments = parseDelimitedList(ParsingContext.ArgumentExpressions, parseAssignmentExpression, TrailingCommaBehavior.Disallow);\r\n                    parseExpected(SyntaxKind.CloseParenToken);\r\n                    expr = finishNode(callExpr);\r\n                    continue;\r\n                }\r\n                return expr;\r\n            }\r\n        }\r\n\r\n        function parseTypeArgumentsAndOpenParen(): NodeArray<TypeNode> {\r\n            var result = parseTypeArguments();\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            return result;\r\n        }\r\n\r\n        function parseTypeArguments(): NodeArray<TypeNode> {\r\n            var typeArgumentListStart = scanner.getTokenPos();\r\n            var errorCountBeforeTypeParameterList = file.syntacticErrors.length;\r\n            var result = parseBracketedList(ParsingContext.TypeArguments, parseType, SyntaxKind.LessThanToken, SyntaxKind.GreaterThanToken);\r\n            if (!result.length && file.syntacticErrors.length === errorCountBeforeTypeParameterList) {\r\n                grammarErrorAtPos(typeArgumentListStart, scanner.getStartPos() - typeArgumentListStart, Diagnostics.Type_argument_list_cannot_be_empty);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function parsePrimaryExpression(): Expression {\r\n            switch (token) {\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.SuperKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                    return parseTokenNode();\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                    return parseLiteralNode();\r\n                case SyntaxKind.OpenParenToken:\r\n                    return parseParenExpression();\r\n                case SyntaxKind.OpenBracketToken:\r\n                    return parseArrayLiteral();\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseObjectLiteral();\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseFunctionExpression();\r\n                case SyntaxKind.NewKeyword:\r\n                    return parseNewExpression();\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.SlashEqualsToken:\r\n                    if (reScanSlashToken() === SyntaxKind.RegularExpressionLiteral) {\r\n                        return parseLiteralNode();\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (isIdentifier()) {\r\n                        return parseIdentifier();\r\n                    }\r\n            }\r\n            error(Diagnostics.Expression_expected);\r\n            return <Expression>createMissingNode();\r\n        }\r\n\r\n        function parseParenExpression(): ParenExpression {\r\n            var node = <ParenExpression>createNode(SyntaxKind.ParenExpression);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseArrayLiteralElement(): Expression {\r\n            return token === SyntaxKind.CommaToken ? createNode(SyntaxKind.OmittedExpression) : parseAssignmentExpression();\r\n        }\r\n\r\n        function parseArrayLiteral(): ArrayLiteral {\r\n            var node = <ArrayLiteral>createNode(SyntaxKind.ArrayLiteral);\r\n            parseExpected(SyntaxKind.OpenBracketToken);\r\n            if (scanner.hasPrecedingLineBreak()) node.flags |= NodeFlags.MultiLine;\r\n            node.elements = parseDelimitedList(ParsingContext.ArrayLiteralMembers, parseArrayLiteralElement, TrailingCommaBehavior.Preserve);\r\n            parseExpected(SyntaxKind.CloseBracketToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parsePropertyAssignment(): PropertyDeclaration {\r\n            var node = <PropertyDeclaration>createNode(SyntaxKind.PropertyAssignment);\r\n            node.name = parsePropertyName();\r\n            if (token === SyntaxKind.OpenParenToken || token === SyntaxKind.LessThanToken) {\r\n                var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n                var body = parseBody(/* ignoreMissingOpenBrace */ false);\r\n                // do not propagate property name as name for function expression\r\n                // for scenarios like \r\n                // var x = 1;\r\n                // var y = { x() { } } \r\n                // otherwise this will bring y.x into the scope of x which is incorrect\r\n                node.initializer = makeFunctionExpression(SyntaxKind.FunctionExpression, node.pos, undefined, sig, body);\r\n            }\r\n            else {\r\n                parseExpected(SyntaxKind.ColonToken);\r\n                node.initializer = parseAssignmentExpression(false);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseObjectLiteralMember(): Node {\r\n            var initialPos = getNodePos();\r\n            var initialToken = token;\r\n            if (parseContextualModifier(SyntaxKind.GetKeyword) || parseContextualModifier(SyntaxKind.SetKeyword)) {\r\n                var kind = initialToken === SyntaxKind.GetKeyword ? SyntaxKind.GetAccessor : SyntaxKind.SetAccessor;\r\n                return parseAndCheckMemberAccessorDeclaration(kind, initialPos, 0);\r\n            }\r\n            return parsePropertyAssignment();\r\n        }\r\n\r\n        function parseObjectLiteral(): ObjectLiteral {\r\n            var node = <ObjectLiteral>createNode(SyntaxKind.ObjectLiteral);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n            if (scanner.hasPrecedingLineBreak()) {\r\n                node.flags |= NodeFlags.MultiLine;\r\n            }\r\n\r\n            // ES3 itself does not accept a trailing comma in an object literal, however, we'd like to preserve it in ES5.\r\n            var trailingCommaBehavior = languageVersion === ScriptTarget.ES3 ? TrailingCommaBehavior.Allow : TrailingCommaBehavior.Preserve;\r\n\r\n            node.properties = parseDelimitedList(ParsingContext.ObjectLiteralMembers, parseObjectLiteralMember, trailingCommaBehavior);\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n\r\n            var seen: Map<SymbolFlags> = {};\r\n            var Property    = 1;\r\n            var GetAccessor = 2;\r\n            var SetAccesor =  4;\r\n            var GetOrSetAccessor = GetAccessor | SetAccesor;\r\n            forEach(node.properties, (p: Declaration) => {\r\n                if (p.kind === SyntaxKind.OmittedExpression) {\r\n                    return;\r\n                }\r\n                // ECMA-262 11.1.5 Object Initialiser \r\n                // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true\r\n                // a.This production is contained in strict code and IsDataDescriptor(previous) is true and \r\n                // IsDataDescriptor(propId.descriptor) is true.\r\n                //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.\r\n                //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.\r\n                //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true \r\n                // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields \r\n                var currentKind: number;\r\n                if (p.kind === SyntaxKind.PropertyAssignment) {\r\n                    currentKind = Property;\r\n                }\r\n                else if (p.kind === SyntaxKind.GetAccessor) {\r\n                    currentKind = GetAccessor;\r\n                }\r\n                else if (p.kind === SyntaxKind.SetAccessor) {\r\n                    currentKind = SetAccesor;\r\n                }\r\n                else {\r\n                    Debug.fail(\"Unexpected syntax kind:\" + SyntaxKind[p.kind]);\r\n                }\r\n\r\n                if (!hasProperty(seen, p.name.text)) {\r\n                    seen[p.name.text] = currentKind;\r\n                }\r\n                else {\r\n                    var existingKind = seen[p.name.text];\r\n                    if (currentKind === Property && existingKind === Property) {\r\n                        if (isInStrictMode) {\r\n                            grammarErrorOnNode(p.name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode);\r\n                        }\r\n                    }\r\n                    else if ((currentKind & GetOrSetAccessor) && (existingKind & GetOrSetAccessor)) {\r\n                        if (existingKind !== GetOrSetAccessor && currentKind !== existingKind) {\r\n                            seen[p.name.text] = currentKind | existingKind;\r\n                        }\r\n                        else {\r\n                            grammarErrorOnNode(p.name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);\r\n                        }\r\n                    }\r\n                    else {\r\n                        grammarErrorOnNode(p.name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);\r\n                    }\r\n                }\r\n            });\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionExpression(): FunctionExpression {\r\n            var pos = getNodePos();\r\n            parseExpected(SyntaxKind.FunctionKeyword);\r\n            var name = isIdentifier() ? parseIdentifier() : undefined;\r\n            var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n            var body = parseBody(/* ignoreMissingOpenBrace */ false);\r\n            if (name && isInStrictMode && isEvalOrArgumentsIdentifier(name)) {\r\n                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the \r\n                // Identifier of a FunctionDeclaration or FunctionExpression or as a formal parameter name(13.1)\r\n                reportInvalidUseInStrictMode(name);\r\n            }\r\n            return makeFunctionExpression(SyntaxKind.FunctionExpression, pos, name, sig, body);\r\n        }\r\n\r\n        function makeFunctionExpression(kind: SyntaxKind, pos: number, name: Identifier, sig: ParsedSignature, body: Node): FunctionExpression {\r\n            var node = <FunctionExpression>createNode(kind, pos);\r\n            node.name = name;\r\n            node.typeParameters = sig.typeParameters;\r\n            node.parameters = sig.parameters;\r\n            node.type = sig.type;\r\n            node.body = body;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseNewExpression(): NewExpression {\r\n            var node = <NewExpression>createNode(SyntaxKind.NewExpression);\r\n            parseExpected(SyntaxKind.NewKeyword);\r\n            node.func = parseCallAndAccess(parsePrimaryExpression(), /* inNewExpression */ true);\r\n            if (parseOptional(SyntaxKind.OpenParenToken) || token === SyntaxKind.LessThanToken && (node.typeArguments = tryParse(parseTypeArgumentsAndOpenParen))) {\r\n                node.arguments = parseDelimitedList(ParsingContext.ArgumentExpressions, parseAssignmentExpression, TrailingCommaBehavior.Disallow);\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        // STATEMENTS\r\n\r\n        function parseBlock(ignoreMissingOpenBrace: boolean, checkForStrictMode: boolean): Block {\r\n            var node = <Block>createNode(SyntaxKind.Block);\r\n            if (parseExpected(SyntaxKind.OpenBraceToken) || ignoreMissingOpenBrace) {\r\n                node.statements = parseList(ParsingContext.BlockStatements,checkForStrictMode, parseStatement);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.statements = createMissingList<Statement>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseBody(ignoreMissingOpenBrace: boolean): Block {\r\n            var saveInFunctionBody = inFunctionBody;\r\n            var saveInSwitchStatement = inSwitchStatement;\r\n            var saveInIterationStatement = inIterationStatement;\r\n\r\n            inFunctionBody = true;\r\n            if (inSwitchStatement === ControlBlockContext.Nested) {\r\n                inSwitchStatement = ControlBlockContext.CrossingFunctionBoundary;\r\n            }\r\n            if (inIterationStatement === ControlBlockContext.Nested) {\r\n                inIterationStatement = ControlBlockContext.CrossingFunctionBoundary;\r\n            }\r\n            labelledStatementInfo.pushFunctionBoundary();\r\n\r\n            var block = parseBlock(ignoreMissingOpenBrace, /*checkForStrictMode*/ true);\r\n            block.kind = SyntaxKind.FunctionBlock;\r\n\r\n            labelledStatementInfo.pop();\r\n            inFunctionBody = saveInFunctionBody;\r\n            inSwitchStatement = saveInSwitchStatement;\r\n            inIterationStatement = saveInIterationStatement;\r\n\r\n            return block;\r\n        }\r\n\r\n        function parseEmptyStatement(): Statement {\r\n            var node = <Statement>createNode(SyntaxKind.EmptyStatement);\r\n            parseExpected(SyntaxKind.SemicolonToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseIfStatement(): IfStatement {\r\n            var node = <IfStatement>createNode(SyntaxKind.IfStatement);\r\n            parseExpected(SyntaxKind.IfKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            node.thenStatement = parseStatement();\r\n            node.elseStatement = parseOptional(SyntaxKind.ElseKeyword) ? parseStatement() : undefined;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseDoStatement(): DoStatement {\r\n            var node = <DoStatement>createNode(SyntaxKind.DoStatement);\r\n            parseExpected(SyntaxKind.DoKeyword);\r\n\r\n            var saveInIterationStatement = inIterationStatement;\r\n            inIterationStatement = ControlBlockContext.Nested;\r\n            node.statement = parseStatement();\r\n            inIterationStatement = saveInIterationStatement;\r\n\r\n            parseExpected(SyntaxKind.WhileKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n\r\n            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html\r\n            // 157 min --- All allen at wirfs-brock.com CONF --- \"do{;}while(false)false\" prohibited in \r\n            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby\r\n            //  do;while(0)x will have a semicolon inserted before x.\r\n            parseOptional(SyntaxKind.SemicolonToken);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseWhileStatement(): WhileStatement {\r\n            var node = <WhileStatement>createNode(SyntaxKind.WhileStatement);\r\n            parseExpected(SyntaxKind.WhileKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n\r\n            var saveInIterationStatement = inIterationStatement;\r\n            inIterationStatement = ControlBlockContext.Nested;\r\n            node.statement = parseStatement();\r\n            inIterationStatement = saveInIterationStatement;\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseForOrForInStatement(): Statement {\r\n            var pos = getNodePos();\r\n            parseExpected(SyntaxKind.ForKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            if (token !== SyntaxKind.SemicolonToken) {\r\n                if (parseOptional(SyntaxKind.VarKeyword)) {\r\n                    var declarations = parseVariableDeclarationList(0, true);\r\n                    if (!declarations.length) {\r\n                        error(Diagnostics.Variable_declaration_list_cannot_be_empty);\r\n                    }\r\n                }\r\n                else {\r\n                    var varOrInit = parseExpression(true);\r\n                }\r\n            }\r\n            var forOrForInStatement: IterationStatement;\r\n            if (parseOptional(SyntaxKind.InKeyword)) {\r\n                var forInStatement = <ForInStatement>createNode(SyntaxKind.ForInStatement, pos);\r\n                if (declarations) {\r\n                    if (declarations.length > 1) {\r\n                        error(Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);\r\n                    }\r\n                    forInStatement.declaration = declarations[0];\r\n                }\r\n                else {\r\n                    forInStatement.variable = varOrInit;\r\n                }\r\n                forInStatement.expression = parseExpression();\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n                forOrForInStatement = forInStatement;\r\n            }\r\n            else {\r\n                var forStatement = <ForStatement>createNode(SyntaxKind.ForStatement, pos);\r\n                if (declarations) forStatement.declarations = declarations;\r\n                if (varOrInit) forStatement.initializer = varOrInit;\r\n                parseExpected(SyntaxKind.SemicolonToken);\r\n                if (token !== SyntaxKind.SemicolonToken && token !== SyntaxKind.CloseParenToken) {\r\n                    forStatement.condition = parseExpression();\r\n                }\r\n                parseExpected(SyntaxKind.SemicolonToken);\r\n                if (token !== SyntaxKind.CloseParenToken) {\r\n                    forStatement.iterator = parseExpression();\r\n                }\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n                forOrForInStatement = forStatement;\r\n            }\r\n\r\n            var saveInIterationStatement = inIterationStatement;\r\n            inIterationStatement = ControlBlockContext.Nested;\r\n            forOrForInStatement.statement = parseStatement();\r\n            inIterationStatement = saveInIterationStatement;\r\n\r\n            return finishNode(forOrForInStatement);\r\n        }\r\n\r\n        function parseBreakOrContinueStatement(kind: SyntaxKind): BreakOrContinueStatement {\r\n            var node = <BreakOrContinueStatement>createNode(kind);\r\n            var errorCountBeforeStatement = file.syntacticErrors.length;\r\n            parseExpected(kind === SyntaxKind.BreakStatement ? SyntaxKind.BreakKeyword : SyntaxKind.ContinueKeyword);\r\n            if (!canParseSemicolon()) node.label = parseIdentifier();\r\n            parseSemicolon();\r\n            finishNode(node);\r\n\r\n            // In an ambient context, we will already give an error for having a statement.\r\n            if (!inAmbientContext && errorCountBeforeStatement === file.syntacticErrors.length) {\r\n                if (node.label) {\r\n                    checkBreakOrContinueStatementWithLabel(node);\r\n                }\r\n                else {\r\n                    checkBareBreakOrContinueStatement(node);\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n\r\n        function checkBareBreakOrContinueStatement(node: BreakOrContinueStatement): void {\r\n            if (node.kind === SyntaxKind.BreakStatement) {\r\n                if (inIterationStatement === ControlBlockContext.Nested\r\n                    || inSwitchStatement === ControlBlockContext.Nested) {\r\n                    return;\r\n                }\r\n                else if (inIterationStatement === ControlBlockContext.NotNested\r\n                    && inSwitchStatement === ControlBlockContext.NotNested) {\r\n                    grammarErrorOnNode(node, Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement);\r\n                    return;\r\n                }\r\n                // Fall through\r\n            }\r\n            else if (node.kind === SyntaxKind.ContinueStatement) {\r\n                if (inIterationStatement === ControlBlockContext.Nested) {\r\n                    return;\r\n                }\r\n                else if (inIterationStatement === ControlBlockContext.NotNested) {\r\n                    grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement);\r\n                    return;\r\n                }\r\n                // Fall through\r\n            }\r\n            else {\r\n                Debug.fail(\"checkAnonymousBreakOrContinueStatement\");\r\n            }\r\n\r\n            Debug.assert(inIterationStatement === ControlBlockContext.CrossingFunctionBoundary\r\n                || inSwitchStatement === ControlBlockContext.CrossingFunctionBoundary);\r\n            grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary);\r\n        }\r\n\r\n        function checkBreakOrContinueStatementWithLabel(node: BreakOrContinueStatement): void {\r\n            // For error specificity, if the label is not found, we want to distinguish whether it is because\r\n            // it crossed a function boundary or it was simply not found. To do this, we pass false for\r\n            // stopAtFunctionBoundary.\r\n            var nodeIsNestedInLabel = labelledStatementInfo.nodeIsNestedInLabel(node.label,\r\n                /*requireIterationStatement*/ node.kind === SyntaxKind.ContinueStatement,\r\n                /*stopAtFunctionBoundary*/ false);\r\n            if (nodeIsNestedInLabel === ControlBlockContext.Nested) {\r\n                return;\r\n            }\r\n\r\n            if (nodeIsNestedInLabel === ControlBlockContext.CrossingFunctionBoundary) {\r\n                grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary);\r\n                return;\r\n            }\r\n\r\n            // It is NotNested\r\n            if (node.kind === SyntaxKind.ContinueStatement) {\r\n                grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);\r\n            }\r\n            else if (node.kind === SyntaxKind.BreakStatement) {\r\n                grammarErrorOnNode(node, Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement);\r\n            }\r\n            else {\r\n                Debug.fail(\"checkBreakOrContinueStatementWithLabel\");\r\n            }\r\n        }\r\n\r\n        function parseReturnStatement(): ReturnStatement {\r\n            var node = <ReturnStatement>createNode(SyntaxKind.ReturnStatement);\r\n            var errorCountBeforeReturnStatement = file.syntacticErrors.length;\r\n            var returnTokenStart = scanner.getTokenPos();\r\n            var returnTokenLength = scanner.getTextPos() - returnTokenStart;\r\n\r\n            parseExpected(SyntaxKind.ReturnKeyword);\r\n            if (!canParseSemicolon()) node.expression = parseExpression();\r\n            parseSemicolon();\r\n\r\n            // In an ambient context, we will already give an error for having a statement.\r\n            if (!inFunctionBody && !inAmbientContext && errorCountBeforeReturnStatement === file.syntacticErrors.length) {\r\n                grammarErrorAtPos(returnTokenStart, returnTokenLength, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseWithStatement(): WithStatement {\r\n            var node = <WithStatement>createNode(SyntaxKind.WithStatement);\r\n            var startPos = scanner.getTokenPos();\r\n            parseExpected(SyntaxKind.WithKeyword);\r\n            var endPos = scanner.getStartPos();\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            node.statement = parseStatement();\r\n            node = finishNode(node);\r\n            if (isInStrictMode) {\r\n                // Strict mode code may not include a WithStatement. The occurrence of a WithStatement in such \r\n                // a context is an \r\n                grammarErrorAtPos(startPos, endPos - startPos, Diagnostics.with_statements_are_not_allowed_in_strict_mode);\r\n            }\r\n            return node;\r\n        }\r\n\r\n        function parseCaseClause(): CaseOrDefaultClause {\r\n            var node = <CaseOrDefaultClause>createNode(SyntaxKind.CaseClause);\r\n            parseExpected(SyntaxKind.CaseKeyword);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.ColonToken);\r\n            node.statements = parseList(ParsingContext.SwitchClauseStatements, /*checkForStrictMode*/ false, parseStatement);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseDefaultClause(): CaseOrDefaultClause {\r\n            var node = <CaseOrDefaultClause>createNode(SyntaxKind.DefaultClause);\r\n            parseExpected(SyntaxKind.DefaultKeyword);\r\n            parseExpected(SyntaxKind.ColonToken);\r\n            node.statements = parseList(ParsingContext.SwitchClauseStatements, /*checkForStrictMode*/ false, parseStatement);\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseCaseOrDefaultClause(): CaseOrDefaultClause {\r\n            return token === SyntaxKind.CaseKeyword ? parseCaseClause() : parseDefaultClause();\r\n        }\r\n\r\n        function parseSwitchStatement(): SwitchStatement {\r\n            var node = <SwitchStatement>createNode(SyntaxKind.SwitchStatement);\r\n            parseExpected(SyntaxKind.SwitchKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            node.expression = parseExpression();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            parseExpected(SyntaxKind.OpenBraceToken);\r\n\r\n            var saveInSwitchStatement = inSwitchStatement;\r\n            inSwitchStatement = ControlBlockContext.Nested;\r\n            node.clauses = parseList(ParsingContext.SwitchClauses, /*checkForStrictMode*/ false, parseCaseOrDefaultClause);\r\n            inSwitchStatement = saveInSwitchStatement;\r\n\r\n            parseExpected(SyntaxKind.CloseBraceToken);\r\n\r\n            // Error on duplicate 'default' clauses.\r\n            var defaultClauses: CaseOrDefaultClause[] = filter(node.clauses, clause => clause.kind === SyntaxKind.DefaultClause);\r\n            for (var i = 1, n = defaultClauses.length; i < n; i++) {\r\n                var clause = defaultClauses[i];\r\n                var start = skipTrivia(file.text, clause.pos);\r\n                var end = clause.statements.length > 0 ? clause.statements[0].pos : clause.end;\r\n                grammarErrorAtPos(start, end - start, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseThrowStatement(): ThrowStatement {\r\n            var node = <ThrowStatement>createNode(SyntaxKind.ThrowStatement);\r\n            parseExpected(SyntaxKind.ThrowKeyword);\r\n            if (scanner.hasPrecedingLineBreak()) {\r\n                error(Diagnostics.Line_break_not_permitted_here);\r\n            }\r\n            node.expression = parseExpression();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        // TODO: Review for error recovery\r\n        function parseTryStatement(): TryStatement {\r\n            var node = <TryStatement>createNode(SyntaxKind.TryStatement);\r\n            node.tryBlock = parseTokenAndBlock(SyntaxKind.TryKeyword, SyntaxKind.TryBlock);\r\n            if (token === SyntaxKind.CatchKeyword) {\r\n                node.catchBlock = parseCatchBlock();\r\n            }\r\n            if (token === SyntaxKind.FinallyKeyword) {\r\n                node.finallyBlock = parseTokenAndBlock(SyntaxKind.FinallyKeyword, SyntaxKind.FinallyBlock);\r\n            }\r\n            if (!(node.catchBlock || node.finallyBlock)) {\r\n                error(Diagnostics.catch_or_finally_expected);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseTokenAndBlock(token: SyntaxKind, kind: SyntaxKind): Block {\r\n            var pos = getNodePos();\r\n            parseExpected(token);\r\n            var result = parseBlock(/* ignoreMissingOpenBrace */ false, /*checkForStrictMode*/ false);\r\n            result.kind = kind;\r\n            result.pos = pos;\r\n            return result;\r\n        }\r\n\r\n        function parseCatchBlock(): CatchBlock {\r\n            var pos = getNodePos();\r\n            parseExpected(SyntaxKind.CatchKeyword);\r\n            parseExpected(SyntaxKind.OpenParenToken);\r\n            var variable = parseIdentifier();\r\n            var typeAnnotationColonStart = scanner.getTokenPos();\r\n            var typeAnnotationColonLength = scanner.getTextPos() - typeAnnotationColonStart;\r\n            var typeAnnotation = parseTypeAnnotation();\r\n            parseExpected(SyntaxKind.CloseParenToken);\r\n            var result = <CatchBlock>parseBlock(/* ignoreMissingOpenBrace */ false, /*checkForStrictMode*/ false);\r\n            result.kind = SyntaxKind.CatchBlock;\r\n            result.pos = pos;\r\n            result.variable = variable;\r\n\r\n            if (typeAnnotation) {\r\n                errorAtPos(typeAnnotationColonStart, typeAnnotationColonLength, Diagnostics.Catch_clause_parameter_cannot_have_a_type_annotation);\r\n            }\r\n            if (isInStrictMode && isEvalOrArgumentsIdentifier(variable)) {\r\n                // It is a SyntaxError if a TryStatement with a Catch occurs within strict code and the Identifier of the \r\n                // Catch production is eval or arguments\r\n                reportInvalidUseInStrictMode(variable);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function parseDebuggerStatement(): Statement {\r\n            var node = <Statement>createNode(SyntaxKind.DebuggerStatement);\r\n            parseExpected(SyntaxKind.DebuggerKeyword);\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isIterationStatementStart(): boolean {\r\n            return token === SyntaxKind.WhileKeyword || token === SyntaxKind.DoKeyword || token === SyntaxKind.ForKeyword;\r\n        }\r\n\r\n        function parseStatementWithLabelSet(): Statement {\r\n            labelledStatementInfo.pushCurrentLabelSet(isIterationStatementStart());\r\n            var statement = parseStatement();\r\n            labelledStatementInfo.pop();\r\n            return statement;\r\n        }\r\n\r\n        function isLabel(): boolean {\r\n            return isIdentifier() && lookAhead(() => nextToken() === SyntaxKind.ColonToken);\r\n        }\r\n\r\n        function parseLabelledStatement(): LabelledStatement {\r\n            var node = <LabelledStatement>createNode(SyntaxKind.LabelledStatement);\r\n            node.label = parseIdentifier();\r\n            parseExpected(SyntaxKind.ColonToken);\r\n\r\n            if (labelledStatementInfo.nodeIsNestedInLabel(node.label, /*requireIterationStatement*/ false, /*stopAtFunctionBoundary*/ true)) {\r\n                grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getSourceTextOfNodeFromSourceText(sourceText, node.label));\r\n            }\r\n            labelledStatementInfo.addLabel(node.label);\r\n\r\n            // We only want to call parseStatementWithLabelSet when the label set is complete\r\n            // Therefore, keep parsing labels until we know we're done.\r\n            node.statement = isLabel() ? parseLabelledStatement() : parseStatementWithLabelSet();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExpressionStatement(): ExpressionStatement {\r\n            var node = <ExpressionStatement>createNode(SyntaxKind.ExpressionStatement);\r\n            node.expression = parseExpression();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isStatement(inErrorRecovery: boolean): boolean {\r\n            switch (token) {\r\n                case SyntaxKind.SemicolonToken:\r\n                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.\r\n                    // The problem is that ';' can show up in far too many contexts, and if we see one \r\n                    // and assume it's a statement, then we may bail out innapropriately from whatever \r\n                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then\r\n                    // we really don't want to assume the class is over and we're on a statement in the\r\n                    // outer module.  We just want to consume and move on.\r\n                    return !inErrorRecovery;\r\n                case SyntaxKind.OpenBraceToken:\r\n                case SyntaxKind.VarKeyword:\r\n                case SyntaxKind.FunctionKeyword:\r\n                case SyntaxKind.IfKeyword:\r\n                case SyntaxKind.DoKeyword:\r\n                case SyntaxKind.WhileKeyword:\r\n                case SyntaxKind.ForKeyword:\r\n                case SyntaxKind.ContinueKeyword:\r\n                case SyntaxKind.BreakKeyword:\r\n                case SyntaxKind.ReturnKeyword:\r\n                case SyntaxKind.WithKeyword:\r\n                case SyntaxKind.SwitchKeyword:\r\n                case SyntaxKind.ThrowKeyword:\r\n                case SyntaxKind.TryKeyword:\r\n                case SyntaxKind.DebuggerKeyword:\r\n                // 'catch' and 'finally' do not actually indicate that the code is part of a statement,\r\n                // however, we say they are here so that we may gracefully parse them and error later.\r\n                case SyntaxKind.CatchKeyword:\r\n                case SyntaxKind.FinallyKeyword:\r\n                    return true;\r\n                case SyntaxKind.InterfaceKeyword:\r\n                case SyntaxKind.ClassKeyword:\r\n                case SyntaxKind.ModuleKeyword:\r\n                case SyntaxKind.EnumKeyword:\r\n                    // When followed by an identifier, these do not start a statement but might\r\n                    // instead be following declarations\r\n                    if (isDeclaration()) {\r\n                        return false;\r\n                    }\r\n                case SyntaxKind.PublicKeyword:\r\n                case SyntaxKind.PrivateKeyword:\r\n                case SyntaxKind.StaticKeyword:\r\n                    // When followed by an identifier or keyword, these do not start a statement but\r\n                    // might instead be following type members\r\n                    if (lookAhead(() => nextToken() >= SyntaxKind.Identifier)) {\r\n                        return false;\r\n                    }\r\n                default:\r\n                    return isExpression();\r\n            }\r\n        }\r\n\r\n        function parseStatement(): Statement {\r\n            switch (token) {\r\n                case SyntaxKind.OpenBraceToken:\r\n                    return parseBlock(/* ignoreMissingOpenBrace */ false, /*checkForStrictMode*/ false);\r\n                case SyntaxKind.VarKeyword:\r\n                    return parseVariableStatement();\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return parseFunctionDeclaration();\r\n                case SyntaxKind.SemicolonToken:\r\n                    return parseEmptyStatement();\r\n                case SyntaxKind.IfKeyword:\r\n                    return parseIfStatement();\r\n                case SyntaxKind.DoKeyword:\r\n                    return parseDoStatement();\r\n                case SyntaxKind.WhileKeyword:\r\n                    return parseWhileStatement();\r\n                case SyntaxKind.ForKeyword:\r\n                    return parseForOrForInStatement();\r\n                case SyntaxKind.ContinueKeyword:\r\n                    return parseBreakOrContinueStatement(SyntaxKind.ContinueStatement);\r\n                case SyntaxKind.BreakKeyword:\r\n                    return parseBreakOrContinueStatement(SyntaxKind.BreakStatement);\r\n                case SyntaxKind.ReturnKeyword:\r\n                    return parseReturnStatement();\r\n                case SyntaxKind.WithKeyword:\r\n                    return parseWithStatement();\r\n                case SyntaxKind.SwitchKeyword:\r\n                    return parseSwitchStatement();\r\n                case SyntaxKind.ThrowKeyword:\r\n                    return parseThrowStatement();\r\n                case SyntaxKind.TryKeyword:\r\n                // Include the next two for error recovery.\r\n                case SyntaxKind.CatchKeyword:\r\n                case SyntaxKind.FinallyKeyword:\r\n                    return parseTryStatement();\r\n                case SyntaxKind.DebuggerKeyword:\r\n                    return parseDebuggerStatement();\r\n                default:\r\n                    if (isLabel()) {\r\n                        return parseLabelledStatement();\r\n                    }\r\n                    return parseExpressionStatement();\r\n            }\r\n        }\r\n\r\n        function parseStatementOrFunction(): Statement {\r\n            return token === SyntaxKind.FunctionKeyword ? parseFunctionDeclaration() : parseStatement();\r\n        }\r\n\r\n        function parseAndCheckFunctionBody(isConstructor: boolean): Block {\r\n            var initialPosition = scanner.getTokenPos();\r\n            var errorCountBeforeBody = file.syntacticErrors.length;\r\n            if (token === SyntaxKind.OpenBraceToken) {\r\n                var body = parseBody(/* ignoreMissingOpenBrace */ false);\r\n                if (body && inAmbientContext && file.syntacticErrors.length === errorCountBeforeBody) {\r\n                    var diagnostic = isConstructor ? Diagnostics.A_constructor_implementation_cannot_be_declared_in_an_ambient_context : Diagnostics.A_function_implementation_cannot_be_declared_in_an_ambient_context;\r\n                    grammarErrorAtPos(initialPosition, 1, diagnostic);\r\n                }\r\n                return body;\r\n            }\r\n            if (canParseSemicolon()) {\r\n                parseSemicolon();\r\n                return undefined;\r\n            }\r\n            error(Diagnostics.Block_or_expected); // block or ';' expected\r\n        }\r\n\r\n        // DECLARATIONS\r\n\r\n        function parseVariableDeclaration(flags: NodeFlags, noIn?: boolean): VariableDeclaration {\r\n            var node = <VariableDeclaration>createNode(SyntaxKind.VariableDeclaration);\r\n            node.flags = flags;\r\n            var errorCountBeforeVariableDeclaration = file.syntacticErrors.length;\r\n            node.name = parseIdentifier();\r\n            node.type = parseTypeAnnotation();\r\n\r\n            // Issue any initializer-related errors on the equals token\r\n            var initializerStart = scanner.getTokenPos();\r\n            var initializerFirstTokenLength = scanner.getTextPos() - initializerStart;\r\n            node.initializer = parseInitializer(/*inParameter*/ false, noIn);\r\n\r\n            if (inAmbientContext && node.initializer && errorCountBeforeVariableDeclaration === file.syntacticErrors.length) {\r\n                grammarErrorAtPos(initializerStart, initializerFirstTokenLength, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);\r\n            }\r\n            if (isInStrictMode && isEvalOrArgumentsIdentifier(node.name)) {\r\n                // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code \r\n                // and its Identifier is eval or arguments \r\n                reportInvalidUseInStrictMode(node.name);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseVariableDeclarationList(flags: NodeFlags, noIn?: boolean): NodeArray<VariableDeclaration> {\r\n            return parseDelimitedList(ParsingContext.VariableDeclarations, () => parseVariableDeclaration(flags, noIn), TrailingCommaBehavior.Disallow);\r\n        }\r\n\r\n        function parseVariableStatement(pos?: number, flags?: NodeFlags): VariableStatement {\r\n            var node = <VariableStatement>createNode(SyntaxKind.VariableStatement, pos);\r\n            if (flags) node.flags = flags;\r\n            var errorCountBeforeVarStatement = file.syntacticErrors.length;\r\n            parseExpected(SyntaxKind.VarKeyword);\r\n            node.declarations = parseVariableDeclarationList(flags, /*noIn*/false);\r\n            parseSemicolon();\r\n            if (!node.declarations.length && file.syntacticErrors.length === errorCountBeforeVarStatement) {\r\n                grammarErrorOnNode(node, Diagnostics.Variable_declaration_list_cannot_be_empty);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseFunctionDeclaration(pos?: number, flags?: NodeFlags): FunctionDeclaration {\r\n            var node = <FunctionDeclaration>createNode(SyntaxKind.FunctionDeclaration, pos);\r\n            if (flags) node.flags = flags;\r\n            parseExpected(SyntaxKind.FunctionKeyword);\r\n            node.name = parseIdentifier();\r\n            var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n            node.typeParameters = sig.typeParameters;\r\n            node.parameters = sig.parameters;\r\n            node.type = sig.type;\r\n            node.body = parseAndCheckFunctionBody(/*isConstructor*/ false);\r\n            if (isInStrictMode && isEvalOrArgumentsIdentifier(node.name)) {\r\n                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the \r\n                // Identifier of a FunctionDeclaration or FunctionExpression or as a formal parameter name(13.1)\r\n                reportInvalidUseInStrictMode(node.name);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseConstructorDeclaration(pos: number, flags: NodeFlags): ConstructorDeclaration {\r\n            var node = <ConstructorDeclaration>createNode(SyntaxKind.Constructor, pos);\r\n            node.flags = flags;\r\n            parseExpected(SyntaxKind.ConstructorKeyword);\r\n            var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n            node.typeParameters = sig.typeParameters;\r\n            node.parameters = sig.parameters;\r\n            node.type = sig.type;\r\n            node.body = parseAndCheckFunctionBody(/*isConstructor*/ true);\r\n            if (node.typeParameters) {\r\n                grammarErrorAtPos(node.typeParameters.pos, node.typeParameters.end - node.typeParameters.pos, Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);\r\n            }\r\n            if (node.type) {\r\n                grammarErrorOnNode(node.type, Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parsePropertyMemberDeclaration(pos: number, flags: NodeFlags): Declaration {\r\n            var errorCountBeforePropertyDeclaration = file.syntacticErrors.length;\r\n            var name = parsePropertyName();\r\n\r\n            var questionStart = scanner.getTokenPos();\r\n            if (parseOptional(SyntaxKind.QuestionToken)) {\r\n                errorAtPos(questionStart, scanner.getStartPos() - questionStart, Diagnostics.A_class_member_cannot_be_declared_optional);\r\n            }\r\n\r\n            if (token === SyntaxKind.OpenParenToken || token === SyntaxKind.LessThanToken) {\r\n                var method = <MethodDeclaration>createNode(SyntaxKind.Method, pos);\r\n                method.flags = flags;\r\n                method.name = name;\r\n                var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n                method.typeParameters = sig.typeParameters;\r\n                method.parameters = sig.parameters;\r\n                method.type = sig.type;\r\n                method.body = parseAndCheckFunctionBody(/*isConstructor*/ false);\r\n                return finishNode(method);\r\n            }\r\n            else {\r\n                var property = <PropertyDeclaration>createNode(SyntaxKind.Property, pos);\r\n                property.flags = flags;\r\n                property.name = name;\r\n                property.type = parseTypeAnnotation();\r\n\r\n                var initializerStart = scanner.getTokenPos();\r\n                var initializerFirstTokenLength = scanner.getTextPos() - initializerStart;\r\n                property.initializer = parseInitializer(/*inParameter*/ false);\r\n                parseSemicolon();\r\n\r\n                if (inAmbientContext && property.initializer && errorCountBeforePropertyDeclaration === file.syntacticErrors.length) {\r\n                    grammarErrorAtPos(initializerStart, initializerFirstTokenLength, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);\r\n                }\r\n                return finishNode(property);\r\n            }\r\n        }\r\n\r\n        function parseAndCheckMemberAccessorDeclaration(kind: SyntaxKind, pos: number, flags: NodeFlags): MethodDeclaration {\r\n            var errorCountBeforeAccessor = file.syntacticErrors.length;\r\n            var accessor = parseMemberAccessorDeclaration(kind, pos, flags);\r\n\r\n            if (errorCountBeforeAccessor === file.syntacticErrors.length) {\r\n                if (languageVersion < ScriptTarget.ES5) {\r\n                    grammarErrorOnNode(accessor.name, Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);\r\n                }\r\n                else if (inAmbientContext) {\r\n                    grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_be_declared_in_an_ambient_context);\r\n                }\r\n                else if (accessor.typeParameters) {\r\n                    grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_have_type_parameters);\r\n                }\r\n                else if (kind === SyntaxKind.GetAccessor && accessor.parameters.length) {\r\n                    grammarErrorOnNode(accessor.name, Diagnostics.A_get_accessor_cannot_have_parameters);\r\n                }\r\n                else if (kind === SyntaxKind.SetAccessor) {\r\n                    if (accessor.type) {\r\n                        grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);\r\n                    }\r\n                    else if (accessor.parameters.length !== 1) {\r\n                        grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_must_have_exactly_one_parameter);\r\n                    }\r\n                    else {\r\n                        var parameter = accessor.parameters[0];\r\n                        if (parameter.flags & NodeFlags.Rest) {\r\n                            grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_rest_parameter);\r\n                        }\r\n                        else if (parameter.flags & NodeFlags.Modifier) {\r\n                            grammarErrorOnNode(accessor.name, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);\r\n                        }\r\n                        else if (parameter.flags & NodeFlags.QuestionMark) {\r\n                            grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);\r\n                        }\r\n                        else if (parameter.initializer) {\r\n                            grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return accessor;\r\n        }\r\n\r\n        function parseMemberAccessorDeclaration(kind: SyntaxKind, pos: number, flags: NodeFlags): MethodDeclaration {\r\n            var node = <MethodDeclaration>createNode(kind, pos);\r\n            node.flags = flags;\r\n            node.name = parsePropertyName();\r\n            var sig = parseSignature(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\r\n            node.typeParameters = sig.typeParameters;\r\n            node.parameters = sig.parameters;\r\n            node.type = sig.type;\r\n\r\n            // A common error is to try to declare an accessor in an ambient class.\r\n            if (inAmbientContext && canParseSemicolon()) {\r\n                parseSemicolon();\r\n                node.body = createMissingNode();\r\n            }\r\n            else {\r\n                node.body = parseBody(/* ignoreMissingOpenBrace */ false);\r\n            }\r\n\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isClassMemberStart(): boolean {\r\n            var idToken: SyntaxKind;\r\n\r\n            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier.\r\n            while (isModifier(token)) {\r\n                idToken = token;\r\n                nextToken();\r\n            }\r\n\r\n            // Try to get the first property-like token following all modifiers.\r\n            // This can either be an identifier or the 'get' or 'set' keywords.\r\n            if (isPropertyName()) {\r\n                idToken = token;\r\n                nextToken();\r\n            }\r\n\r\n            // Index signatures are class members; we can parse.\r\n            if (token === SyntaxKind.OpenBracketToken) {\r\n                return true;\r\n            }\r\n            \r\n            // If we were able to get any potential identifier...\r\n            if (idToken !== undefined) {\r\n                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.\r\n                if (!isKeyword(idToken) || idToken === SyntaxKind.SetKeyword || idToken === SyntaxKind.GetKeyword) {\r\n                    return true;\r\n                }\r\n\r\n                // If it *is* a keyword, but not an accessor, check a little farther along\r\n                // to see if it should actually be parsed as a class member.\r\n                switch (token) {\r\n                    case SyntaxKind.OpenParenToken:     // Method declaration\r\n                    case SyntaxKind.LessThanToken:      // Generic Method declaration\r\n                    case SyntaxKind.ColonToken:         // Type Annotation for declaration\r\n                    case SyntaxKind.EqualsToken:        // Initializer for declaration\r\n                    case SyntaxKind.QuestionToken:      // Not valid, but permitted so that it gets caught later on.\r\n                        return true;\r\n                    default:\r\n                        // Covers\r\n                        //  - Semicolons     (declaration termination)\r\n                        //  - Closing braces (end-of-class, must be declaration)\r\n                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)\r\n                        //  - Line-breaks    (enabling *automatic semicolon insertion*)\r\n                        return canParseSemicolon();\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function parseAndCheckModifiers(context: ModifierContext): number {\r\n            var flags = 0;\r\n            var lastStaticModifierStart: number;\r\n            var lastStaticModifierLength: number;\r\n            var lastDeclareModifierStart: number;\r\n            var lastDeclareModifierLength: number;\r\n            var lastPrivateModifierStart: number;\r\n            var lastPrivateModifierLength: number;\r\n\r\n            while (true) {\r\n                var modifierStart = scanner.getTokenPos();\r\n                var modifierToken = token;\r\n\r\n                // Try to parse the modifier\r\n                if (!parseAnyContextualModifier()) break;\r\n\r\n                var modifierLength = scanner.getStartPos() - modifierStart;\r\n\r\n                switch (modifierToken) {\r\n                    case SyntaxKind.PublicKeyword:\r\n                        if (flags & NodeFlags.Private || flags & NodeFlags.Public) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics.Accessibility_modifier_already_seen);\r\n                        }\r\n                        else if (flags & NodeFlags.Static) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_must_precede_1_modifier, \"public\", \"static\");\r\n                        }\r\n                        else if (context === ModifierContext.ModuleElements || context === ModifierContext.SourceElements) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_cannot_appear_on_a_module_element, \"public\");\r\n                        }\r\n                        flags |= NodeFlags.Public;\r\n                        break;\r\n\r\n                    case SyntaxKind.PrivateKeyword:\r\n                        if (flags & NodeFlags.Private || flags & NodeFlags.Public) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics.Accessibility_modifier_already_seen);\r\n                        }\r\n                        else if (flags & NodeFlags.Static) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_must_precede_1_modifier, \"private\", \"static\");\r\n                        }\r\n                        else if (context === ModifierContext.ModuleElements || context === ModifierContext.SourceElements) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_cannot_appear_on_a_module_element, \"private\");\r\n                        }\r\n                        lastPrivateModifierStart = modifierStart;\r\n                        lastPrivateModifierLength = modifierLength;\r\n                        flags |= NodeFlags.Private;\r\n                        break;\r\n\r\n                    case SyntaxKind.StaticKeyword:\r\n                        if (flags & NodeFlags.Static) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_already_seen, \"static\");\r\n                        }\r\n                        else if (context === ModifierContext.ModuleElements || context === ModifierContext.SourceElements) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_cannot_appear_on_a_module_element, \"static\");\r\n                        }\r\n                        else if (context === ModifierContext.Parameters) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_cannot_appear_on_a_parameter, \"static\");\r\n                        }\r\n                        lastStaticModifierStart = modifierStart;\r\n                        lastStaticModifierLength = modifierLength;\r\n                        flags |= NodeFlags.Static;\r\n                        break;\r\n\r\n                    case SyntaxKind.ExportKeyword:\r\n                        if (flags & NodeFlags.Export) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_already_seen, \"export\");\r\n                        }\r\n                        else if (flags & NodeFlags.Ambient) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_must_precede_1_modifier, \"export\", \"declare\");\r\n                        }\r\n                        else if (context === ModifierContext.ClassMembers) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_cannot_appear_on_a_class_element, \"export\");\r\n                        }\r\n                        else if (context === ModifierContext.Parameters) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_cannot_appear_on_a_parameter, \"export\");\r\n                        }\r\n                        flags |= NodeFlags.Export;\r\n                        break;\r\n\r\n                    case SyntaxKind.DeclareKeyword:\r\n                        if (flags & NodeFlags.Ambient) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_already_seen, \"declare\");\r\n                        }\r\n                        else if (context === ModifierContext.ClassMembers) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_cannot_appear_on_a_class_element, \"declare\");\r\n                        }\r\n                        else if (context === ModifierContext.Parameters) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics._0_modifier_cannot_appear_on_a_parameter, \"declare\");\r\n                        }\r\n                        else if (inAmbientContext && context === ModifierContext.ModuleElements) {\r\n                            grammarErrorAtPos(modifierStart, modifierLength, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);\r\n                        }\r\n                        lastDeclareModifierStart = modifierStart;\r\n                        lastDeclareModifierLength = modifierLength;\r\n                        flags |= NodeFlags.Ambient;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (token === SyntaxKind.ConstructorKeyword && flags & NodeFlags.Static) {\r\n                grammarErrorAtPos(lastStaticModifierStart, lastStaticModifierLength, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, \"static\");\r\n            }\r\n            else if (token === SyntaxKind.ConstructorKeyword && flags & NodeFlags.Private) {\r\n                grammarErrorAtPos(lastPrivateModifierStart, lastPrivateModifierLength, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, \"private\");\r\n            }\r\n            else if (token === SyntaxKind.ImportKeyword) {\r\n                if (flags & NodeFlags.Ambient) {\r\n                    grammarErrorAtPos(lastDeclareModifierStart, lastDeclareModifierLength, Diagnostics.A_declare_modifier_cannot_be_used_with_an_import_declaration, \"declare\");\r\n                }\r\n            }\r\n            else if (token === SyntaxKind.InterfaceKeyword) {\r\n                if (flags & NodeFlags.Ambient) {\r\n                    grammarErrorAtPos(lastDeclareModifierStart, lastDeclareModifierLength, Diagnostics.A_declare_modifier_cannot_be_used_with_an_interface_declaration, \"declare\");\r\n                }\r\n            }\r\n            else if (token !== SyntaxKind.ExportKeyword && !(flags & NodeFlags.Ambient) && inAmbientContext && context === ModifierContext.SourceElements) {\r\n                // A declare modifier is required for any top level .d.ts declaration except export=, interfaces and imports:\r\n                // categories:\r\n                //\r\n                //  DeclarationElement:\r\n                //     ExportAssignment\r\n                //     export_opt   InterfaceDeclaration\r\n                //     export_opt   ImportDeclaration\r\n                //     export_opt   ExternalImportDeclaration\r\n                //     export_opt   AmbientDeclaration\r\n                //\r\n                var declarationStart = scanner.getTokenPos();\r\n                var declarationFirstTokenLength = scanner.getTextPos() - declarationStart;\r\n                grammarErrorAtPos(declarationStart, declarationFirstTokenLength, Diagnostics.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);\r\n            }\r\n            return flags;\r\n        }\r\n\r\n        function parseClassMemberDeclaration(): Declaration {\r\n            var pos = getNodePos();\r\n            var flags = parseAndCheckModifiers(ModifierContext.ClassMembers);\r\n            if (parseContextualModifier(SyntaxKind.GetKeyword)) {\r\n                return parseAndCheckMemberAccessorDeclaration(SyntaxKind.GetAccessor, pos, flags);\r\n            }\r\n            if (parseContextualModifier(SyntaxKind.SetKeyword)) {\r\n                return parseAndCheckMemberAccessorDeclaration(SyntaxKind.SetAccessor, pos, flags);\r\n            }\r\n            if (token === SyntaxKind.ConstructorKeyword) {\r\n                return parseConstructorDeclaration(pos, flags);\r\n            }\r\n            if (token >= SyntaxKind.Identifier || token === SyntaxKind.StringLiteral || token === SyntaxKind.NumericLiteral) {\r\n                return parsePropertyMemberDeclaration(pos, flags);\r\n            }\r\n            if (token === SyntaxKind.OpenBracketToken) {\r\n                if (flags) {\r\n                    var start = getTokenPos(pos);\r\n                    var length = getNodePos() - start;\r\n                    errorAtPos(start, length, Diagnostics.Modifiers_not_permitted_on_index_signature_members);\r\n                }\r\n                return parseIndexSignatureMember();\r\n            }\r\n\r\n            // 'isClassMemberStart' should have hinted not to attempt parsing.\r\n            Debug.fail(\"Should not have attempted to parse class member declaration.\");\r\n        }\r\n\r\n        function parseClassDeclaration(pos: number, flags: NodeFlags): ClassDeclaration {\r\n            var node = <ClassDeclaration>createNode(SyntaxKind.ClassDeclaration, pos);\r\n            node.flags = flags;\r\n            var errorCountBeforeClassDeclaration = file.syntacticErrors.length;\r\n            parseExpected(SyntaxKind.ClassKeyword);\r\n            node.name = parseIdentifier();\r\n            node.typeParameters = parseTypeParameters();\r\n            // TODO(jfreeman): Parse arbitrary sequence of heritage clauses and error for order and duplicates\r\n            node.baseType = parseOptional(SyntaxKind.ExtendsKeyword) ? parseTypeReference() : undefined;\r\n            var implementsKeywordStart = scanner.getTokenPos();\r\n            var implementsKeywordLength: number;\r\n            if (parseOptional(SyntaxKind.ImplementsKeyword)) {\r\n                implementsKeywordLength = scanner.getStartPos() - implementsKeywordStart;\r\n                node.implementedTypes = parseDelimitedList(ParsingContext.BaseTypeReferences, parseTypeReference, TrailingCommaBehavior.Disallow);\r\n            }\r\n            var errorCountBeforeClassBody = file.syntacticErrors.length;\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                node.members = parseList(ParsingContext.ClassMembers, /*checkForStrictMode*/ false, parseClassMemberDeclaration);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.members = createMissingList<Declaration>();\r\n            }\r\n            if (node.implementedTypes && !node.implementedTypes.length && errorCountBeforeClassBody === errorCountBeforeClassDeclaration) {\r\n                grammarErrorAtPos(implementsKeywordStart, implementsKeywordLength, Diagnostics._0_list_cannot_be_empty, \"implements\");\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseInterfaceDeclaration(pos: number, flags: NodeFlags): InterfaceDeclaration {\r\n            var node = <InterfaceDeclaration>createNode(SyntaxKind.InterfaceDeclaration, pos);\r\n            node.flags = flags;\r\n            var errorCountBeforeInterfaceDeclaration = file.syntacticErrors.length;\r\n            parseExpected(SyntaxKind.InterfaceKeyword);\r\n            node.name = parseIdentifier();\r\n            node.typeParameters = parseTypeParameters();\r\n            // TODO(jfreeman): Parse arbitrary sequence of heritage clauses and error for order and duplicates\r\n            var extendsKeywordStart = scanner.getTokenPos();\r\n            var extendsKeywordLength: number;\r\n            if (parseOptional(SyntaxKind.ExtendsKeyword)) {\r\n                extendsKeywordLength = scanner.getStartPos() - extendsKeywordStart;\r\n                node.baseTypes = parseDelimitedList(ParsingContext.BaseTypeReferences, parseTypeReference, TrailingCommaBehavior.Disallow);\r\n            }\r\n            var errorCountBeforeInterfaceBody = file.syntacticErrors.length;\r\n            node.members = parseTypeLiteral().members;\r\n            if (node.baseTypes && !node.baseTypes.length && errorCountBeforeInterfaceBody === errorCountBeforeInterfaceDeclaration) {\r\n                grammarErrorAtPos(extendsKeywordStart, extendsKeywordLength, Diagnostics._0_list_cannot_be_empty, \"extends\");\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseAndCheckEnumDeclaration(pos: number, flags: NodeFlags): EnumDeclaration {\r\n            function isIntegerLiteral(expression: Expression): boolean {\r\n                function isInteger(literalExpression: LiteralExpression): boolean {\r\n                    // Allows for scientific notation since literalExpression.text was formed by\r\n                    // coercing a number to a string. Sometimes this coersion can yield a string\r\n                    // in scientific notation.\r\n                    // We also don't need special logic for hex because a hex integer is converted\r\n                    // to decimal when it is coerced.\r\n                    return /^[0-9]+([eE]\\+?[0-9]+)?$/.test(literalExpression.text);\r\n                }\r\n\r\n                if (expression.kind === SyntaxKind.PrefixOperator) {\r\n                    var unaryExpression = <UnaryExpression>expression;\r\n                    if (unaryExpression.operator === SyntaxKind.PlusToken || unaryExpression.operator === SyntaxKind.MinusToken) {\r\n                        expression = unaryExpression.operand;\r\n                    }\r\n                }\r\n                if (expression.kind === SyntaxKind.NumericLiteral) {\r\n                    return isInteger(<LiteralExpression>expression);\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            var inConstantEnumMemberSection = true;\r\n            // In an ambient declaration, the grammar only allows integer literals as initializers.\r\n            // In a nonambient declaration, the grammar allows uninitialized members only in a\r\n            // ConstantEnumMemberSection, which starts at the beginning of an enum declaration\r\n            // or any time an integer literal initializer is encountered.\r\n            function parseAndCheckEnumMember(): EnumMember {\r\n                var node = <EnumMember>createNode(SyntaxKind.EnumMember);\r\n                var errorCountBeforeEnumMember = file.syntacticErrors.length;\r\n                node.name = parsePropertyName();\r\n                node.initializer = parseInitializer(/*inParameter*/ false);\r\n\r\n                if (inAmbientContext) {\r\n                    if (node.initializer && !isIntegerLiteral(node.initializer) && errorCountBeforeEnumMember === file.syntacticErrors.length) {\r\n                        grammarErrorOnNode(node.name, Diagnostics.Ambient_enum_elements_can_only_have_integer_literal_initializers);\r\n                    }\r\n                }\r\n                else if (node.initializer) {\r\n                    inConstantEnumMemberSection = isIntegerLiteral(node.initializer);\r\n                }\r\n                else if (!inConstantEnumMemberSection && errorCountBeforeEnumMember === file.syntacticErrors.length) {\r\n                    grammarErrorOnNode(node.name, Diagnostics.Enum_member_must_have_initializer);\r\n                }\r\n                return finishNode(node);\r\n            }\r\n\r\n            var node = <EnumDeclaration>createNode(SyntaxKind.EnumDeclaration, pos);\r\n            node.flags = flags;\r\n            parseExpected(SyntaxKind.EnumKeyword);\r\n            node.name = parseIdentifier();\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                node.members = parseDelimitedList(ParsingContext.EnumMembers, parseAndCheckEnumMember, TrailingCommaBehavior.Allow);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.members = createMissingList<EnumMember>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleBody(): Block {\r\n            var node = <Block>createNode(SyntaxKind.ModuleBlock);\r\n            if (parseExpected(SyntaxKind.OpenBraceToken)) {\r\n                node.statements = parseList(ParsingContext.ModuleElements, /*checkForStrictMode*/ false, parseModuleElement);\r\n                parseExpected(SyntaxKind.CloseBraceToken);\r\n            }\r\n            else {\r\n                node.statements = createMissingList<Statement>();\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseInternalModuleTail(pos: number, flags: NodeFlags): ModuleDeclaration {\r\n            var node = <ModuleDeclaration>createNode(SyntaxKind.ModuleDeclaration, pos);\r\n            node.flags = flags;\r\n            node.name = parseIdentifier();\r\n            if (parseOptional(SyntaxKind.DotToken)) {\r\n                node.body = parseInternalModuleTail(getNodePos(), NodeFlags.Export);\r\n            }\r\n            else {\r\n                node.body = parseModuleBody();\r\n                forEach((<Block>node.body).statements, s => {\r\n                    if (s.kind === SyntaxKind.ExportAssignment) {\r\n                        // Export assignments are not allowed in an internal module\r\n                        grammarErrorOnNode(s, Diagnostics.An_export_assignment_cannot_be_used_in_an_internal_module);\r\n                    }\r\n                    else if (s.kind === SyntaxKind.ImportDeclaration && (<ImportDeclaration>s).externalModuleName) {\r\n                        grammarErrorOnNode(s, Diagnostics.Import_declarations_in_an_internal_module_cannot_reference_an_external_module);\r\n                    }\r\n                });\r\n            }\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseAmbientExternalModuleDeclaration(pos: number, flags: NodeFlags): ModuleDeclaration {\r\n            var node = <ModuleDeclaration>createNode(SyntaxKind.ModuleDeclaration, pos);\r\n            node.flags = flags;\r\n            node.name = parseStringLiteral();\r\n            if (!inAmbientContext) {\r\n                var errorCount = file.syntacticErrors.length;\r\n                // Only report this error if we have not already errored about a missing declare modifier,\r\n                // which would have been at or after pos\r\n                if (!errorCount || file.syntacticErrors[errorCount - 1].start < getTokenPos(pos)) {\r\n                    grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names);\r\n                }\r\n            }\r\n\r\n            // For error recovery, just in case the user forgot the declare modifier on this ambient\r\n            // external module, treat it as ambient anyway.\r\n            var saveInAmbientContext = inAmbientContext;\r\n            inAmbientContext = true;\r\n            node.body = parseModuleBody();\r\n            inAmbientContext = saveInAmbientContext;\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseModuleDeclaration(pos: number, flags: NodeFlags): ModuleDeclaration {\r\n            parseExpected(SyntaxKind.ModuleKeyword);\r\n            return token === SyntaxKind.StringLiteral ? parseAmbientExternalModuleDeclaration(pos, flags) : parseInternalModuleTail(pos, flags);\r\n        }\r\n\r\n        function parseImportDeclaration(pos: number, flags: NodeFlags): ImportDeclaration {\r\n            var node = <ImportDeclaration>createNode(SyntaxKind.ImportDeclaration, pos);\r\n            node.flags = flags;\r\n            parseExpected(SyntaxKind.ImportKeyword);\r\n            node.name = parseIdentifier();\r\n            parseExpected(SyntaxKind.EqualsToken);\r\n            var entityName = parseEntityName(/*allowReservedWords*/ false);\r\n            if (entityName.kind === SyntaxKind.Identifier && (<Identifier>entityName).text === \"require\" && parseOptional(SyntaxKind.OpenParenToken)) {\r\n                node.externalModuleName = parseStringLiteral();\r\n                parseExpected(SyntaxKind.CloseParenToken);\r\n            }\r\n            else {\r\n                node.entityName = entityName;\r\n            }\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function parseExportAssignmentTail(pos: number): ExportAssignment {\r\n            var node = <ExportAssignment>createNode(SyntaxKind.ExportAssignment, pos);\r\n            node.exportName = parseIdentifier();\r\n            parseSemicolon();\r\n            return finishNode(node);\r\n        }\r\n\r\n        function isDeclaration() {\r\n            switch (token) {\r\n                case SyntaxKind.VarKeyword:\r\n                case SyntaxKind.FunctionKeyword:\r\n                    return true;\r\n                case SyntaxKind.ClassKeyword:\r\n                case SyntaxKind.InterfaceKeyword:\r\n                case SyntaxKind.EnumKeyword:\r\n                case SyntaxKind.ImportKeyword:\r\n                    // Not true keywords so ensure an identifier follows\r\n                    return lookAhead(() => nextToken() >= SyntaxKind.Identifier);\r\n                case SyntaxKind.ModuleKeyword:\r\n                    // Not a true keyword so ensure an identifier or string literal follows\r\n                    return lookAhead(() => nextToken() >= SyntaxKind.Identifier || token === SyntaxKind.StringLiteral);\r\n                case SyntaxKind.ExportKeyword:\r\n                    // Check for export assignment or modifier on source element\r\n                    return lookAhead(() => nextToken() === SyntaxKind.EqualsToken || isDeclaration());\r\n                case SyntaxKind.DeclareKeyword:\r\n                case SyntaxKind.PublicKeyword:\r\n                case SyntaxKind.PrivateKeyword:\r\n                case SyntaxKind.StaticKeyword:\r\n                    // Check for modifier on source element\r\n                    return lookAhead(() => { nextToken(); return isDeclaration(); });\r\n            }\r\n        }\r\n\r\n        function parseDeclaration(modifierContext: ModifierContext): Statement {\r\n            var pos = getNodePos();\r\n            var errorCountBeforeModifiers = file.syntacticErrors.length;\r\n            var flags = parseAndCheckModifiers(modifierContext);\r\n\r\n            if (token === SyntaxKind.ExportKeyword) {\r\n                var modifiersEnd = scanner.getStartPos();\r\n                nextToken();\r\n                if (parseOptional(SyntaxKind.EqualsToken)) {\r\n                    var exportAssignmentTail = parseExportAssignmentTail(pos);\r\n                    if (flags !== 0 && errorCountBeforeModifiers === file.syntacticErrors.length) {\r\n                        var modifiersStart = skipTrivia(sourceText, pos);\r\n                        grammarErrorAtPos(modifiersStart, modifiersEnd - modifiersStart, Diagnostics.An_export_assignment_cannot_have_modifiers);\r\n                    }\r\n                    return exportAssignmentTail;\r\n                }\r\n            }\r\n\r\n            var saveInAmbientContext = inAmbientContext;\r\n            if (flags & NodeFlags.Ambient) {\r\n                inAmbientContext = true;\r\n            }\r\n\r\n            var result: Declaration;\r\n            switch (token) {\r\n                case SyntaxKind.VarKeyword:\r\n                    result = parseVariableStatement(pos, flags);\r\n                    break;\r\n                case SyntaxKind.FunctionKeyword:\r\n                    result = parseFunctionDeclaration(pos, flags);\r\n                    break;\r\n                case SyntaxKind.ClassKeyword:\r\n                    result = parseClassDeclaration(pos, flags);\r\n                    break;\r\n                case SyntaxKind.InterfaceKeyword:\r\n                    result = parseInterfaceDeclaration(pos, flags);\r\n                    break;\r\n                case SyntaxKind.EnumKeyword:\r\n                    result = parseAndCheckEnumDeclaration(pos, flags);\r\n                    break;\r\n                case SyntaxKind.ModuleKeyword:\r\n                    result = parseModuleDeclaration(pos, flags);\r\n                    break;\r\n                case SyntaxKind.ImportKeyword:\r\n                    result = parseImportDeclaration(pos, flags);\r\n                    break;\r\n                default:\r\n                    error(Diagnostics.Declaration_expected);\r\n            }\r\n\r\n            inAmbientContext = saveInAmbientContext;\r\n            return result;\r\n        }\r\n\r\n        function isSourceElement(inErrorRecovery: boolean): boolean {\r\n            return isDeclaration() || isStatement(inErrorRecovery);\r\n        }\r\n\r\n        function parseSourceElement() {\r\n            return parseSourceElementOrModuleElement(ModifierContext.SourceElements);\r\n        }\r\n\r\n        function parseModuleElement() {\r\n            return parseSourceElementOrModuleElement(ModifierContext.ModuleElements);\r\n        }\r\n\r\n        function parseSourceElementOrModuleElement(modifierContext: ModifierContext): Statement {\r\n            if (isDeclaration()) {\r\n                return parseDeclaration(modifierContext);\r\n            }\r\n\r\n            var statementStart = scanner.getTokenPos();\r\n            var statementFirstTokenLength = scanner.getTextPos() - statementStart;\r\n            var errorCountBeforeStatement = file.syntacticErrors.length;\r\n            var statement = parseStatement();\r\n\r\n            if (inAmbientContext && file.syntacticErrors.length === errorCountBeforeStatement) {\r\n                grammarErrorAtPos(statementStart, statementFirstTokenLength, Diagnostics.Statements_are_not_allowed_in_ambient_contexts);\r\n            }\r\n\r\n            return statement;\r\n        }\r\n\r\n        function processReferenceComments(): ReferenceComments {\r\n            var referencedFiles: FileReference[] = [];\r\n            var amdDependencies: string[] = [];\r\n            commentRanges = [];\r\n            token = scanner.scan();\r\n\r\n            for (var i = 0; i < commentRanges.length; i++) {\r\n                var range = commentRanges[i];\r\n                var comment = sourceText.substring(range.pos, range.end);\r\n                var simpleReferenceRegEx = /^\\/\\/\\/\\s*<reference\\s+/gim;\r\n                if (simpleReferenceRegEx.exec(comment)) {\r\n                    var isNoDefaultLibRegEx = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib=)('|\")(.+?)\\2\\s*\\/>/gim;\r\n                    if (isNoDefaultLibRegEx.exec(comment)) {\r\n                        file.hasNoDefaultLib = true;\r\n                    }\r\n                    else {\r\n                        var matchResult = fullTripleSlashReferencePathRegEx.exec(comment);\r\n                        if (!matchResult) {\r\n                            var start = range.pos;\r\n                            var length = range.end - start;\r\n                            errorAtPos(start, length, Diagnostics.Invalid_reference_directive_syntax);\r\n                        }\r\n                        else {\r\n                            referencedFiles.push({\r\n                                pos: range.pos,\r\n                                end: range.end,\r\n                                filename: matchResult[3]\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    var amdDependencyRegEx = /^\\/\\/\\/\\s*<amd-dependency\\s+path\\s*=\\s*('|\")(.+?)\\1/gim;\r\n                    var amdDependencyMatchResult = amdDependencyRegEx.exec(comment);\r\n                    if (amdDependencyMatchResult) {\r\n                        amdDependencies.push(amdDependencyMatchResult[2]);\r\n                    }\r\n                }\r\n            }\r\n            commentRanges = undefined;\r\n            return {\r\n                referencedFiles: referencedFiles,\r\n                amdDependencies: amdDependencies\r\n            };\r\n        }\r\n\r\n        function getExternalModuleIndicator() {\r\n            return forEach(file.statements, node =>\r\n                node.flags & NodeFlags.Export\r\n                || node.kind === SyntaxKind.ImportDeclaration && (<ImportDeclaration>node).externalModuleName\r\n                || node.kind === SyntaxKind.ExportAssignment\r\n                ? node\r\n                : undefined);\r\n        }\r\n\r\n        scanner = createScanner(languageVersion, sourceText, scanError, onComment);\r\n        var rootNodeFlags: NodeFlags = 0;\r\n        if (fileExtensionIs(filename, \".d.ts\")) {\r\n            rootNodeFlags = NodeFlags.DeclarationFile;\r\n            inAmbientContext = true;\r\n        }\r\n        file = <SourceFile>createRootNode(SyntaxKind.SourceFile, 0, sourceText.length, rootNodeFlags);\r\n        file.filename = normalizePath(filename);\r\n        file.text = sourceText;\r\n        file.getLineAndCharacterFromPosition = getLineAndCharacterlFromSourcePosition;\r\n        file.getPositionFromLineAndCharacter = getPositionFromSourceLineAndCharacter;\r\n        file.syntacticErrors = [];\r\n        file.semanticErrors = [];\r\n        var referenceComments = processReferenceComments(); \r\n        file.referencedFiles = referenceComments.referencedFiles;\r\n        file.amdDependencies = referenceComments.amdDependencies;\r\n        file.statements = parseList(ParsingContext.SourceElements, /*checkForStrictMode*/ true, parseSourceElement);\r\n        file.externalModuleIndicator = getExternalModuleIndicator();\r\n        file.nodeCount = nodeCount;\r\n        file.identifierCount = identifierCount;\r\n        file.version = version;\r\n        file.isOpen = isOpen;\r\n        file.languageVersion = languageVersion;\r\n        return file;\r\n    }\r\n\r\n    export function createProgram(rootNames: string[], options: CompilerOptions, host: CompilerHost): Program {\r\n        var program: Program;\r\n        var files: SourceFile[] = [];\r\n        var filesByName: Map<SourceFile> = {};\r\n        var errors: Diagnostic[] = [];\r\n        var seenNoDefaultLib = options.noLib;\r\n        var commonSourceDirectory: string;\r\n\r\n        forEach(rootNames, name => processRootFile(name, false));\r\n        if (!seenNoDefaultLib) {\r\n            processRootFile(host.getDefaultLibFilename(), true);\r\n        }\r\n        verifyCompilerOptions();\r\n        errors.sort(compareDiagnostics);\r\n        program = {\r\n            getSourceFile: getSourceFile,\r\n            getSourceFiles: () => files,\r\n            getCompilerOptions: () => options,\r\n            getCompilerHost: () => host,\r\n            getDiagnostics: getDiagnostics,\r\n            getGlobalDiagnostics: getGlobalDiagnostics,\r\n            getTypeChecker: fullTypeCheckMode => createTypeChecker(program, fullTypeCheckMode),\r\n            getCommonSourceDirectory: () => commonSourceDirectory,\r\n        };\r\n        return program;\r\n\r\n        function getSourceFile(filename: string) {\r\n            filename = host.getCanonicalFileName(filename);\r\n            return hasProperty(filesByName, filename) ? filesByName[filename] : undefined;\r\n        }\r\n\r\n        function getDiagnostics(sourceFile?: SourceFile): Diagnostic[] {\r\n            return sourceFile ? filter(errors, e => e.file === sourceFile) : errors;\r\n        }\r\n\r\n        function getGlobalDiagnostics(): Diagnostic[] {\r\n            return filter(errors, e => !e.file);\r\n        }\r\n\r\n        function hasExtension(filename: string): boolean {\r\n            return getBaseFilename(filename).indexOf(\".\") >= 0;\r\n        }\r\n\r\n        function processRootFile(filename: string, isDefaultLib: boolean) {\r\n            processSourceFile(normalizePath(filename), isDefaultLib);\r\n        }\r\n\r\n        function processSourceFile(filename: string, isDefaultLib: boolean, refFile?: SourceFile, refPos?: number, refEnd?: number) {\r\n            if (refEnd !== undefined && refPos !== undefined) {\r\n                var start = refPos;\r\n                var length = refEnd - refPos;\r\n            }\r\n            if (hasExtension(filename)) {\r\n                if (!fileExtensionIs(filename, \".ts\")) {\r\n                    errors.push(createFileDiagnostic(refFile, start, length, Diagnostics.File_0_must_have_extension_ts_or_d_ts, filename));\r\n                }\r\n                else if (!findSourceFile(filename, isDefaultLib, refFile, refPos, refEnd)) {\r\n                    errors.push(createFileDiagnostic(refFile, start, length, Diagnostics.File_0_not_found, filename));\r\n                }\r\n            }\r\n            else {\r\n                if (!(findSourceFile(filename + \".ts\", isDefaultLib, refFile, refPos, refEnd) || findSourceFile(filename + \".d.ts\", isDefaultLib, refFile, refPos, refEnd))) {\r\n                    errors.push(createFileDiagnostic(refFile, start, length, Diagnostics.File_0_not_found, filename + \".ts\"));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Get source file from normalized filename\r\n        function findSourceFile(filename: string, isDefaultLib: boolean, refFile?: SourceFile, refStart?: number, refLength?: number): SourceFile {\r\n            // Look through existing source files to see if we've encountered it.\r\n            var canonicalName = host.getCanonicalFileName(filename);\r\n            var file = getSourceFile(filename);\r\n            if (file) {\r\n                if (host.useCaseSensitiveFileNames() && canonicalName !== file.filename) {\r\n                    errors.push(createFileDiagnostic(refFile, refStart, refLength,\r\n                        Diagnostics.Filename_0_differs_from_already_included_filename_1_only_in_casing, filename, file.filename));\r\n                } \r\n            }\r\n            else {\r\n                // If we haven't, read the file.\r\n                file = host.getSourceFile(filename, options.target, hostErrorMessage => {\r\n                    errors.push(createFileDiagnostic(refFile, refStart, refLength,\r\n                        Diagnostics.Cannot_read_file_0_Colon_1, filename, hostErrorMessage));\r\n                });\r\n                if (file) {\r\n                    filesByName[host.getCanonicalFileName(filename)] = file;\r\n                    seenNoDefaultLib = seenNoDefaultLib || file.hasNoDefaultLib;\r\n                    if (!options.noResolve) {\r\n                        var basePath = getDirectoryPath(filename);\r\n                        processReferencedFiles(file, basePath);\r\n                        processImportedModules(file, basePath);\r\n                    }\r\n                    if (isDefaultLib) {\r\n                        files.unshift(file);\r\n                    }\r\n                    else {\r\n                        files.push(file);\r\n                    }\r\n                    forEach(file.syntacticErrors, e => {\r\n                        errors.push(e);\r\n                    });\r\n                }\r\n            }\r\n\r\n            return file;\r\n        }\r\n\r\n        function processReferencedFiles(file: SourceFile, basePath: string) {\r\n            forEach(file.referencedFiles, ref => {\r\n                processSourceFile(normalizePath(combinePaths(basePath, ref.filename)), /* isDefaultLib */ false, file, ref.pos, ref.end);\r\n            });\r\n        }\r\n\r\n        function processImportedModules(file: SourceFile, basePath: string) {\r\n            forEach(file.statements, node => {\r\n                if (node.kind === SyntaxKind.ImportDeclaration && (<ImportDeclaration>node).externalModuleName) {\r\n                    var nameLiteral = (<ImportDeclaration>node).externalModuleName;\r\n                    var moduleName = nameLiteral.text;\r\n                    if (moduleName) {\r\n                        var searchPath = basePath;\r\n                        while (true) {\r\n                            var searchName = normalizePath(combinePaths(searchPath, moduleName));\r\n                            if (findModuleSourceFile(searchName + \".ts\", nameLiteral) || findModuleSourceFile(searchName + \".d.ts\", nameLiteral)) {\r\n                                break;\r\n                            }\r\n\r\n                            var parentPath = getDirectoryPath(searchPath);\r\n                            if (parentPath === searchPath) {\r\n                                break;\r\n                            }\r\n                            searchPath = parentPath;\r\n                        }\r\n                    }\r\n                }\r\n                else if (node.kind === SyntaxKind.ModuleDeclaration && (<ModuleDeclaration>node).name.kind === SyntaxKind.StringLiteral && (node.flags & NodeFlags.Ambient || file.flags & NodeFlags.DeclarationFile)) {\r\n                    // TypeScript 1.0 spec (April 2014): 12.1.6\r\n                    // An AmbientExternalModuleDeclaration declares an external module. \r\n                    // This type of declaration is permitted only in the global module.\r\n                    // The StringLiteral must specify a top - level external module name.\r\n                    // Relative external module names are not permitted\r\n                    forEachChild((<ModuleDeclaration>node).body, node => {\r\n                        if (node.kind === SyntaxKind.ImportDeclaration && (<ImportDeclaration>node).externalModuleName) {\r\n                            var nameLiteral = (<ImportDeclaration>node).externalModuleName; \r\n                            var moduleName = nameLiteral.text;\r\n                            if (moduleName) {\r\n                                // TypeScript 1.0 spec (April 2014): 12.1.6\r\n                                // An ExternalImportDeclaration in anAmbientExternalModuleDeclaration may reference other external modules \r\n                                // only through top - level external module names. Relative external module names are not permitted.\r\n                                var searchName = normalizePath(combinePaths(basePath, moduleName));\r\n                                var tsFile = findModuleSourceFile(searchName + \".ts\", nameLiteral);\r\n                                if (!tsFile) {\r\n                                    findModuleSourceFile(searchName + \".d.ts\", nameLiteral);\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n\r\n            function findModuleSourceFile(filename: string, nameLiteral: LiteralExpression) {\r\n                return findSourceFile(filename, /* isDefaultLib */ false, file, nameLiteral.pos, nameLiteral.end - nameLiteral.pos);\r\n            }\r\n        }\r\n\r\n        function verifyCompilerOptions() {\r\n            if (!options.sourceMap && (options.mapRoot || options.sourceRoot)) {\r\n                // Error to specify --mapRoot or --sourceRoot without mapSourceFiles\r\n                if (options.mapRoot) {\r\n                    errors.push(createCompilerDiagnostic(Diagnostics.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option));\r\n                }\r\n                if (options.sourceRoot) {\r\n                    errors.push(createCompilerDiagnostic(Diagnostics.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option));\r\n                }\r\n                return;\r\n            }\r\n\r\n            var firstExternalModule = forEach(files, f => isExternalModule(f) ? f : undefined);\r\n            if (firstExternalModule && options.module === ModuleKind.None) {\r\n                // We cannot use createDiagnosticFromNode because nodes do not have parents yet\r\n                var externalModuleErrorSpan = getErrorSpanForNode(firstExternalModule.externalModuleIndicator);\r\n                var errorStart = skipTrivia(firstExternalModule.text, externalModuleErrorSpan.pos);\r\n                var errorLength = externalModuleErrorSpan.end - errorStart;\r\n                errors.push(createFileDiagnostic(firstExternalModule, errorStart, errorLength, Diagnostics.Cannot_compile_external_modules_unless_the_module_flag_is_provided));\r\n            }\r\n\r\n            // there has to be common source directory if user specified --outdir || --sourcRoot\r\n            // if user specified --mapRoot, there needs to be common source directory if there would be multiple files being emitted\r\n            if (options.outDir || // there is --outDir specified\r\n                options.sourceRoot || // there is --sourceRoot specified\r\n                (options.mapRoot &&  // there is --mapRoot Specified and there would be multiple js files generated\r\n                (!options.out || firstExternalModule !== undefined))) {\r\n\r\n                var commonPathComponents: string[];\r\n                forEach(files, sourceFile => {\r\n                    // Each file contributes into common source file path\r\n                    if (!(sourceFile.flags & NodeFlags.DeclarationFile)\r\n                        && !fileExtensionIs(sourceFile.filename, \".js\")) {\r\n                        var sourcePathCompoments = getNormalizedPathComponents(sourceFile.filename, host.getCurrentDirectory());\r\n                        sourcePathCompoments.pop(); // FileName is not part of directory\r\n                        if (commonPathComponents) {\r\n                            for (var i = 0; i < Math.min(commonPathComponents.length, sourcePathCompoments.length); i++) {\r\n                                if (commonPathComponents[i] !== sourcePathCompoments[i]) {\r\n                                    if (i === 0) {\r\n                                        errors.push(createCompilerDiagnostic(Diagnostics.Cannot_find_the_common_subdirectory_path_for_the_input_files));\r\n                                        return;\r\n                                    }\r\n\r\n                                    // New common path found that is 0 -> i-1\r\n                                    commonPathComponents.length = i;\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            // If the fileComponent path completely matched and less than already found update the length\r\n                            if (sourcePathCompoments.length < commonPathComponents.length) {\r\n                                commonPathComponents.length = sourcePathCompoments.length;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // first file\r\n                            commonPathComponents = sourcePathCompoments;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                commonSourceDirectory = getNormalizedPathFromPathCompoments(commonPathComponents);\r\n                if (commonSourceDirectory) {\r\n                    // Make sure directory path ends with directory separator so this string can directly \r\n                    // used to replace with \"\" to get the relative path of the source file and the relative path doesnt\r\n                    // start with / making it rooted path\r\n                    commonSourceDirectory += directorySeparator;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n // file: src/compiler/binder.ts\r\n/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"scanner.ts\"/>\r\n/// <reference path=\"parser.ts\"/>\r\n\r\nmodule ts {\r\n\r\n    export function isInstantiated(node: Node): boolean {\r\n        // A module is uninstantiated if it contains only \r\n        // 1. interface declarations\r\n        if (node.kind === SyntaxKind.InterfaceDeclaration) {\r\n            return false;\r\n        }\r\n        // 2. non - exported import declarations\r\n        else if (node.kind === SyntaxKind.ImportDeclaration && !(node.flags & NodeFlags.Export)) {\r\n            return false;\r\n        }\r\n        // 3. other uninstantiated module declarations.\r\n        else if (node.kind === SyntaxKind.ModuleBlock && !forEachChild(node, isInstantiated)) {\r\n            return false;\r\n        }\r\n        else if (node.kind === SyntaxKind.ModuleDeclaration && !isInstantiated((<ModuleDeclaration>node).body)) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    export function bindSourceFile(file: SourceFile) {\r\n\r\n        var parent: Node;\r\n        var container: Declaration;\r\n        var lastContainer: Declaration;\r\n        var symbolCount = 0;\r\n        var Symbol = objectAllocator.getSymbolConstructor();\r\n\r\n        if (!file.locals) {\r\n            file.locals = {};\r\n            container = file;\r\n            bind(file);\r\n            file.symbolCount = symbolCount;\r\n        }\r\n\r\n        function createSymbol(flags: SymbolFlags, name: string): Symbol {\r\n            symbolCount++;\r\n            return new Symbol(flags, name);\r\n        }\r\n\r\n        function addDeclarationToSymbol(symbol: Symbol, node: Declaration, symbolKind: SymbolFlags) {\r\n            symbol.flags |= symbolKind;\r\n            if (!symbol.declarations) symbol.declarations = [];\r\n            symbol.declarations.push(node);\r\n            if (symbolKind & SymbolFlags.HasExports && !symbol.exports) symbol.exports = {};\r\n            if (symbolKind & SymbolFlags.HasMembers && !symbol.members) symbol.members = {};\r\n            node.symbol = symbol;\r\n            if (symbolKind & SymbolFlags.Value && !symbol.valueDeclaration) symbol.valueDeclaration = node;\r\n        }\r\n\r\n        function getDeclarationName(node: Declaration): string {\r\n            if (node.name) {\r\n                if (node.kind === SyntaxKind.ModuleDeclaration && node.name.kind === SyntaxKind.StringLiteral) {\r\n                    return '\"' + node.name.text + '\"';\r\n                }\r\n                return node.name.text;\r\n            }\r\n            switch (node.kind) {\r\n                case SyntaxKind.Constructor: return \"__constructor\";\r\n                case SyntaxKind.CallSignature: return \"__call\";\r\n                case SyntaxKind.ConstructSignature: return \"__new\";\r\n                case SyntaxKind.IndexSignature: return \"__index\";\r\n            }\r\n        }\r\n\r\n        function getDisplayName(node: Declaration): string {\r\n            return node.name ? identifierToString(node.name) : getDeclarationName(node);\r\n        }\r\n\r\n        function declareSymbol(symbols: SymbolTable, parent: Symbol, node: Declaration, includes: SymbolFlags, excludes: SymbolFlags): Symbol {\r\n            var name = getDeclarationName(node);\r\n            if (name !== undefined) {\r\n                var symbol = hasProperty(symbols, name) ? symbols[name] : (symbols[name] = createSymbol(0, name));\r\n                if (symbol.flags & excludes) {\r\n                    if (node.name) {\r\n                        node.name.parent = node;\r\n                    }\r\n                    file.semanticErrors.push(createDiagnosticForNode(node.name ? node.name : node,\r\n                        Diagnostics.Duplicate_identifier_0, getDisplayName(node)));\r\n                    symbol = createSymbol(0, name);\r\n                }\r\n            }\r\n            else {\r\n                symbol = createSymbol(0, \"__missing\");\r\n            }\r\n            addDeclarationToSymbol(symbol, node, includes);\r\n            symbol.parent = parent;\r\n\r\n            if (node.kind === SyntaxKind.ClassDeclaration && symbol.exports) {\r\n                // TypeScript 1.0 spec (April 2014): 8.4\r\n                // Every class automatically contains a static property member named 'prototype', \r\n                // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.\r\n                // It is an error to explicitly declare a static property member with the name 'prototype'.\r\n                var prototypeSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.Prototype, \"prototype\");\r\n                if (hasProperty(symbol.exports, prototypeSymbol.name)) {\r\n                    if (node.name) {\r\n                        node.name.parent = node;\r\n                    }\r\n                    file.semanticErrors.push(createDiagnosticForNode(symbol.exports[prototypeSymbol.name].declarations[0],\r\n                        Diagnostics.Duplicate_identifier_0, prototypeSymbol.name));\r\n                }\r\n                symbol.exports[prototypeSymbol.name] = prototypeSymbol;\r\n                prototypeSymbol.parent = symbol;\r\n            }\r\n\r\n            return symbol;\r\n        }\r\n\r\n        function isAmbientContext(node: Node): boolean {\r\n            while (node) {\r\n                if (node.flags & NodeFlags.Ambient) return true;\r\n                node = node.parent;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function declareModuleMember(node: Declaration, symbolKind: SymbolFlags, symbolExcludes: SymbolFlags) {\r\n            // Exported module members are given 2 symbols: A local symbol that is classified with an ExportValue,\r\n            // ExportType, or ExportContainer flag, and an associated export symbol with all the correct flags set\r\n            // on it. There are 2 main reasons:\r\n            //\r\n            //   1. We treat locals and exports of the same name as mutually exclusive within a container. \r\n            //      That means the binder will issue a Duplicate Identifier error if you mix locals and exports\r\n            //      with the same name in the same container.\r\n            //      TODO: Make this a more specific error and decouple it from the exclusion logic.\r\n            //   2. When we checkIdentifier in the checker, we set its resolved symbol to the local symbol,\r\n            //      but return the export symbol (by calling getExportSymbolOfValueSymbolIfExported). That way\r\n            //      when the emitter comes back to it, it knows not to qualify the name if it was found in a containing scope.\r\n            var exportKind = 0;\r\n            if (symbolKind & SymbolFlags.Value) {\r\n                exportKind |= SymbolFlags.ExportValue;\r\n            }\r\n            if (symbolKind & SymbolFlags.Type) {\r\n                exportKind |= SymbolFlags.ExportType;\r\n            }\r\n            if (symbolKind & SymbolFlags.Namespace) {\r\n                exportKind |= SymbolFlags.ExportNamespace;\r\n            }\r\n            if (node.flags & NodeFlags.Export || (node.kind !== SyntaxKind.ImportDeclaration && isAmbientContext(container))) {\r\n                if (exportKind) {\r\n                    var local = declareSymbol(container.locals, undefined, node, exportKind, symbolExcludes);\r\n                    local.exportSymbol = declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);\r\n                    node.localSymbol = local;\r\n                }\r\n                else {\r\n                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);\r\n                }\r\n            }\r\n            else {\r\n                declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);\r\n            }\r\n        }\r\n\r\n        // All container nodes are kept on a linked list in declaration order. This list is used by the getLocalNameOfContainer function\r\n        // in the type checker to validate that the local name used for a container is unique.\r\n        function bindChildren(node: Declaration, symbolKind: SymbolFlags) {\r\n            if (symbolKind & SymbolFlags.HasLocals) {\r\n                node.locals = {};\r\n            }\r\n            var saveParent = parent;\r\n            var saveContainer = container;\r\n            parent = node;\r\n            if (symbolKind & SymbolFlags.IsContainer) {\r\n                container = node;\r\n                // If container is not on container list, add it to the list\r\n                if (lastContainer !== container && !container.nextContainer) {\r\n                    if (lastContainer) {\r\n                        lastContainer.nextContainer = container;\r\n                    }\r\n                    lastContainer = container;\r\n                }\r\n            }\r\n            forEachChild(node, bind);\r\n            container = saveContainer;\r\n            parent = saveParent;\r\n        }\r\n\r\n        function bindDeclaration(node: Declaration, symbolKind: SymbolFlags, symbolExcludes: SymbolFlags) {\r\n            switch (container.kind) {\r\n                case SyntaxKind.ModuleDeclaration:\r\n                    declareModuleMember(node, symbolKind, symbolExcludes);\r\n                    break;\r\n                case SyntaxKind.SourceFile:\r\n                    if (isExternalModule(<SourceFile>container)) {\r\n                        declareModuleMember(node, symbolKind, symbolExcludes);\r\n                        break;\r\n                    }\r\n                case SyntaxKind.CallSignature:\r\n                case SyntaxKind.ConstructSignature:\r\n                case SyntaxKind.IndexSignature:\r\n                case SyntaxKind.Method:\r\n                case SyntaxKind.Constructor:\r\n                case SyntaxKind.GetAccessor:\r\n                case SyntaxKind.SetAccessor:\r\n                case SyntaxKind.FunctionDeclaration:\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ArrowFunction:\r\n                    declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);\r\n                    break;\r\n                case SyntaxKind.ClassDeclaration:\r\n                    if (node.flags & NodeFlags.Static) {\r\n                        declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);\r\n                        break;\r\n                    }\r\n                case SyntaxKind.TypeLiteral:\r\n                case SyntaxKind.ObjectLiteral:\r\n                case SyntaxKind.InterfaceDeclaration:\r\n                    declareSymbol(container.symbol.members, container.symbol, node, symbolKind, symbolExcludes);\r\n                    break;\r\n                case SyntaxKind.EnumDeclaration:\r\n                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);\r\n                    break;\r\n            }\r\n            bindChildren(node, symbolKind);\r\n        }\r\n\r\n        function bindConstructorDeclaration(node: ConstructorDeclaration) {\r\n            bindDeclaration(node, SymbolFlags.Constructor, 0);\r\n            forEach(node.parameters, p => {\r\n                if (p.flags & (NodeFlags.Public | NodeFlags.Private)) {\r\n                    bindDeclaration(p, SymbolFlags.Property, SymbolFlags.PropertyExcludes);\r\n                }\r\n            });\r\n        }\r\n\r\n        function bindModuleDeclaration(node: ModuleDeclaration) {\r\n            if (node.name.kind === SyntaxKind.StringLiteral) {\r\n                bindDeclaration(node, SymbolFlags.ValueModule, SymbolFlags.ValueModuleExcludes);\r\n            }\r\n            else if (isInstantiated(node)) {\r\n                bindDeclaration(node, SymbolFlags.ValueModule, SymbolFlags.ValueModuleExcludes);\r\n            }\r\n            else {\r\n                bindDeclaration(node, SymbolFlags.NamespaceModule, SymbolFlags.NamespaceModuleExcludes);\r\n            }\r\n        }\r\n\r\n        function bindAnonymousDeclaration(node: Node, symbolKind: SymbolFlags, name: string) {\r\n            var symbol = createSymbol(symbolKind, name);\r\n            addDeclarationToSymbol(symbol, node, symbolKind);\r\n            bindChildren(node, symbolKind);\r\n        }\r\n\r\n        function bindCatchVariableDeclaration(node: CatchBlock) {\r\n            var symbol = createSymbol(SymbolFlags.Variable, node.variable.text || \"__missing\");\r\n            addDeclarationToSymbol(symbol, node, SymbolFlags.Variable);\r\n            var saveParent = parent;\r\n            parent = node;\r\n            forEachChild(node, bind);\r\n            parent = saveParent;\r\n        }\r\n\r\n        function bind(node: Node) {\r\n            node.parent = parent;\r\n            switch (node.kind) {\r\n                case SyntaxKind.TypeParameter:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.TypeParameter, SymbolFlags.TypeParameterExcludes);\r\n                    break;\r\n                case SyntaxKind.Parameter:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Variable, SymbolFlags.ParameterExcludes);\r\n                    break;\r\n                case SyntaxKind.VariableDeclaration:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Variable, SymbolFlags.VariableExcludes);\r\n                    break;\r\n                case SyntaxKind.Property:\r\n                case SyntaxKind.PropertyAssignment:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Property, SymbolFlags.PropertyExcludes);\r\n                    break;\r\n                case SyntaxKind.EnumMember:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.EnumMember, SymbolFlags.EnumMemberExcludes);\r\n                    break;\r\n                case SyntaxKind.CallSignature:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.CallSignature, 0);\r\n                    break;\r\n                case SyntaxKind.Method:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Method, SymbolFlags.MethodExcludes);\r\n                    break;\r\n                case SyntaxKind.ConstructSignature:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.ConstructSignature, 0);\r\n                    break;\r\n                case SyntaxKind.IndexSignature:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.IndexSignature, 0);\r\n                    break;\r\n                case SyntaxKind.FunctionDeclaration:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Function, SymbolFlags.FunctionExcludes);\r\n                    break;\r\n                case SyntaxKind.Constructor:\r\n                    bindConstructorDeclaration(<ConstructorDeclaration>node);\r\n                    break;\r\n                case SyntaxKind.GetAccessor:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.GetAccessor, SymbolFlags.GetAccessorExcludes);\r\n                    break;\r\n                case SyntaxKind.SetAccessor:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.SetAccessor, SymbolFlags.SetAccessorExcludes);\r\n                    break;\r\n                case SyntaxKind.TypeLiteral:\r\n                    bindAnonymousDeclaration(node, SymbolFlags.TypeLiteral, \"__type\");\r\n                    break;\r\n                case SyntaxKind.ObjectLiteral:\r\n                    bindAnonymousDeclaration(node, SymbolFlags.ObjectLiteral, \"__object\");\r\n                    break;\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ArrowFunction:\r\n                    bindAnonymousDeclaration(node, SymbolFlags.Function, \"__function\");\r\n                    break;\r\n                case SyntaxKind.CatchBlock:\r\n                    bindCatchVariableDeclaration(<CatchBlock>node);\r\n                    break;\r\n                case SyntaxKind.ClassDeclaration:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Class, SymbolFlags.ClassExcludes);\r\n                    break;\r\n                case SyntaxKind.InterfaceDeclaration:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Interface, SymbolFlags.InterfaceExcludes);\r\n                    break;\r\n                case SyntaxKind.EnumDeclaration:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Enum, SymbolFlags.EnumExcludes);\r\n                    break;\r\n                case SyntaxKind.ModuleDeclaration:\r\n                    bindModuleDeclaration(<ModuleDeclaration>node);\r\n                    break;\r\n                case SyntaxKind.ImportDeclaration:\r\n                    bindDeclaration(<Declaration>node, SymbolFlags.Import, SymbolFlags.ImportExcludes);\r\n                    break;\r\n                case SyntaxKind.SourceFile:\r\n                    if (isExternalModule(<SourceFile>node)) {\r\n                        bindAnonymousDeclaration(node, SymbolFlags.ValueModule, '\"' + getModuleNameFromFilename((<SourceFile>node).filename) + '\"');\r\n                        break;\r\n                    }\r\n                default:\r\n                    var saveParent = parent;\r\n                    parent = node;\r\n                    forEachChild(node, bind);\r\n                    parent = saveParent;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n // file: src/compiler/emitter.ts\r\n/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"scanner.ts\"/>\r\n/// <reference path=\"parser.ts\"/>\r\n\r\nmodule ts {\r\n    interface EmitTextWriter extends TextWriter {\r\n        rawWrite(s: string): void;\r\n        writeLiteral(s: string): void;\r\n        getTextPos(): number;\r\n        getLine(): number;\r\n        getColumn(): number;\r\n        getIndent(): number;\r\n    }\r\n\r\n    var indentStrings: string[] = [\"\", \"    \"];\r\n    function getIndentString(level: number) {\r\n        if (indentStrings[level] === undefined) {\r\n            indentStrings[level] = getIndentString(level - 1) + indentStrings[1];\r\n        }\r\n        return indentStrings[level];\r\n    }\r\n\r\n    function getIndentSize() {\r\n        return indentStrings[1].length;\r\n    }\r\n\r\n    export function emitFiles(resolver: EmitResolver): EmitResult {\r\n        var program = resolver.getProgram();\r\n        var compilerHost = program.getCompilerHost();\r\n        var compilerOptions = program.getCompilerOptions();\r\n        var sourceMapDataList: SourceMapData[] = compilerOptions.sourceMap ? [] : undefined;\r\n        var diagnostics: Diagnostic[] = [];\r\n        var newLine = program.getCompilerHost().getNewLine();\r\n\r\n        function getSourceFilePathInNewDir(newDirPath: string, sourceFile: SourceFile) {\r\n            var sourceFilePath = getNormalizedPathFromPathCompoments(getNormalizedPathComponents(sourceFile.filename, compilerHost.getCurrentDirectory()));\r\n            sourceFilePath = sourceFilePath.replace(program.getCommonSourceDirectory(), \"\");\r\n            return combinePaths(newDirPath, sourceFilePath);\r\n        }\r\n\r\n        function shouldEmitToOwnFile(sourceFile: SourceFile) {\r\n            if (!(sourceFile.flags & NodeFlags.DeclarationFile)) {\r\n                if ((isExternalModule(sourceFile) || !compilerOptions.out) && !fileExtensionIs(sourceFile.filename, \".js\")) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function getOwnEmitOutputFilePath(sourceFile: SourceFile, extension: string) {\r\n            if (program.getCompilerOptions().outDir) {\r\n                var emitOutputFilePathWithoutExtension = getModuleNameFromFilename(getSourceFilePathInNewDir(program.getCompilerOptions().outDir, sourceFile));\r\n            }\r\n            else {\r\n                var emitOutputFilePathWithoutExtension = getModuleNameFromFilename(sourceFile.filename);\r\n            }\r\n\r\n            return emitOutputFilePathWithoutExtension + extension;\r\n        }\r\n\r\n        function isExternalModuleOrDeclarationFile(sourceFile: SourceFile) {\r\n            return isExternalModule(sourceFile) || (sourceFile.flags & NodeFlags.DeclarationFile) !== 0;\r\n        }\r\n\r\n        function getFirstConstructorWithBody(node: ClassDeclaration): ConstructorDeclaration {\r\n            return forEach(node.members, member => {\r\n                if (member.kind === SyntaxKind.Constructor && (<ConstructorDeclaration>member).body) {\r\n                    return <ConstructorDeclaration>member;\r\n                }\r\n            });\r\n        }\r\n\r\n        function getAllAccessorDeclarations(node: ClassDeclaration, accessor: AccessorDeclaration) {\r\n            var firstAccessor: AccessorDeclaration;\r\n            var getAccessor: AccessorDeclaration;\r\n            var setAccessor: AccessorDeclaration;\r\n            forEach(node.members, (member: Declaration) => {\r\n                if ((member.kind === SyntaxKind.GetAccessor || member.kind === SyntaxKind.SetAccessor) &&\r\n                    member.name.text === accessor.name.text &&\r\n                    (member.flags & NodeFlags.Static) === (accessor.flags & NodeFlags.Static)) {\r\n                    if (!firstAccessor) {\r\n                        firstAccessor = <AccessorDeclaration>member;\r\n                    }\r\n\r\n                    if (member.kind === SyntaxKind.GetAccessor && !getAccessor) {\r\n                        getAccessor = <AccessorDeclaration>member;\r\n                    }\r\n\r\n                    if (member.kind === SyntaxKind.SetAccessor && !setAccessor) {\r\n                        setAccessor = <AccessorDeclaration>member;\r\n                    }\r\n                }\r\n            });\r\n            return {\r\n                firstAccessor: firstAccessor,\r\n                getAccessor: getAccessor,\r\n                setAccessor: setAccessor\r\n            };\r\n        }\r\n\r\n        function createTextWriter(writeSymbol: (symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags)=> void): EmitTextWriter {\r\n            var output = \"\";\r\n            var indent = 0;\r\n            var lineStart = true;\r\n            var lineCount = 0;\r\n            var linePos = 0;\r\n\r\n            function write(s: string) {\r\n                if (s && s.length) {\r\n                    if (lineStart) {\r\n                        output += getIndentString(indent);\r\n                        lineStart = false;\r\n                    }\r\n                    output += s;\r\n                }\r\n            }\r\n\r\n            function rawWrite(s: string) {\r\n                if (s !== undefined) {\r\n                    if (lineStart) {\r\n                        lineStart = false;\r\n                    }\r\n                    output += s;\r\n                }\r\n            }\r\n\r\n            function writeLiteral(s: string) {\r\n                if (s && s.length) {\r\n                    write(s);\r\n                    var pos = 0;\r\n                    while (pos < s.length) {\r\n                        switch (s.charCodeAt(pos++)) {\r\n                            case CharacterCodes.carriageReturn:\r\n                                if (pos < s.length && s.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                                    pos++;\r\n                                }\r\n                            case CharacterCodes.lineFeed:\r\n                                lineCount++;\r\n                                linePos = output.length - s.length + pos;\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            function writeLine() {\r\n                if (!lineStart) {\r\n                    output += newLine;\r\n                    lineCount++;\r\n                    linePos = output.length;\r\n                    lineStart = true;\r\n                }\r\n            }\r\n\r\n            return {\r\n                write: write,\r\n                writeSymbol: writeSymbol,\r\n                rawWrite: rawWrite,\r\n                writeLiteral: writeLiteral,\r\n                writeLine: writeLine,\r\n                increaseIndent: () => indent++,\r\n                decreaseIndent: () => indent--,\r\n                getIndent: () => indent,\r\n                getTextPos: () => output.length,\r\n                getLine: () => lineCount + 1,\r\n                getColumn: () => lineStart ? indent * getIndentSize() + 1 : output.length - linePos + 1,\r\n                getText: () => output,\r\n            };\r\n        }\r\n\r\n        // Get source text of node in the current source file. Unlike getSourceTextOfNode this function\r\n        // doesn't walk the parent chain to find the containing source file, rather it assumes the node is\r\n        // in the source file currently being processed.\r\n        var currentSourceFile: SourceFile;\r\n        function getSourceTextOfLocalNode(node: Node): string {\r\n            var text = currentSourceFile.text;\r\n            return text.substring(skipTrivia(text, node.pos), node.end);\r\n        }\r\n\r\n        function getLineOfLocalPosition(pos: number) {\r\n            return currentSourceFile.getLineAndCharacterFromPosition(pos).line;\r\n        }\r\n\r\n        function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {\r\n            compilerHost.writeFile(filename, data, writeByteOrderMark, hostErrorMessage => {\r\n                diagnostics.push(createCompilerDiagnostic(Diagnostics.Could_not_write_file_0_Colon_1, filename, hostErrorMessage));\r\n            });\r\n        }\r\n\r\n        function emitComments(comments: Comment[], trailingSeparator: boolean, writer: EmitTextWriter, writeComment: (comment: Comment, writer: EmitTextWriter) => void) {\r\n            var emitLeadingSpace = !trailingSeparator;\r\n            forEach(comments, comment => {\r\n                if (emitLeadingSpace) {\r\n                    writer.write(\" \");\r\n                    emitLeadingSpace = false;\r\n                }\r\n                writeComment(comment, writer);\r\n                if (comment.hasTrailingNewLine) {\r\n                    writer.writeLine();\r\n                }\r\n                else if (trailingSeparator) {\r\n                    writer.write(\" \");\r\n                }\r\n                else {\r\n                    // Emit leading space to separate comment during next comment emit\r\n                    emitLeadingSpace = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        function emitNewLineBeforeLeadingComments(node: TextRange, leadingComments: Comment[], writer: EmitTextWriter) {\r\n            // If the leading comments start on different line than the start of node, write new line\r\n            if (leadingComments && leadingComments.length && node.pos !== leadingComments[0].pos &&\r\n                getLineOfLocalPosition(node.pos) !== getLineOfLocalPosition(leadingComments[0].pos)) {\r\n                writer.writeLine();\r\n            }\r\n        }\r\n\r\n        function writeCommentRange(comment: Comment, writer: EmitTextWriter) {\r\n            if (currentSourceFile.text.charCodeAt(comment.pos + 1) === CharacterCodes.asterisk) {\r\n                var firstCommentLineAndCharacter = currentSourceFile.getLineAndCharacterFromPosition(comment.pos);\r\n                var firstCommentLineIndent: number;\r\n                for (var pos = comment.pos, currentLine = firstCommentLineAndCharacter.line; pos < comment.end; currentLine++) {\r\n                    var nextLineStart = currentSourceFile.getPositionFromLineAndCharacter(currentLine + 1, /*character*/1);\r\n\r\n                    if (pos !== comment.pos) {\r\n                        // If we are not emitting first line, we need to write the spaces to adjust the alignment\r\n                        if (firstCommentLineIndent === undefined) {\r\n                            firstCommentLineIndent = calculateIndent(currentSourceFile.getPositionFromLineAndCharacter(firstCommentLineAndCharacter.line, /*character*/1),\r\n                                comment.pos);\r\n                        }\r\n\r\n                        // These are number of spaces writer is going to write at current indent\r\n                        var currentWriterIndentSpacing = writer.getIndent() * getIndentSize();\r\n\r\n                        // Number of spaces we want to be writing\r\n                        // eg: Assume writer indent\r\n                        // module m {\r\n                        //         /* starts at character 9 this is line 1\r\n                        //    * starts at character pos 4 line                        --1  = 8 - 8 + 3\r\n                        //   More left indented comment */                            --2  = 8 - 8 + 2\r\n                        //     class c { }\r\n                        // }\r\n                        // module m {\r\n                        //     /* this is line 1 -- Assume current writer indent 8\r\n                        //      * line                                                --3 = 8 - 4 + 5 \r\n                        //            More right indented comment */                  --4 = 8 - 4 + 11\r\n                        //     class c { }\r\n                        // }\r\n                        var spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(pos, nextLineStart); \r\n                        if (spacesToEmit > 0) {\r\n                            var numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();\r\n                            var indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());\r\n\r\n                            // Write indent size string ( in eg 1: = \"\", 2: \"\" , 3: string with 8 spaces 4: string with 12 spaces\r\n                            writer.rawWrite(indentSizeSpaceString);\r\n\r\n                            // Emit the single spaces (in eg: 1: 3 spaces, 2: 2 spaces, 3: 1 space, 4: 3 spaces)\r\n                            while (numberOfSingleSpacesToEmit) {\r\n                                writer.rawWrite(\" \");\r\n                                numberOfSingleSpacesToEmit--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // No spaces to emit write empty string\r\n                            writer.rawWrite(\"\");\r\n                        }\r\n                    }\r\n\r\n                    // Write the comment line text\r\n                    writeTrimmedCurrentLine(pos, nextLineStart);\r\n\r\n                    pos = nextLineStart;\r\n                }\r\n            }\r\n            else {\r\n                // Single line comment of styly //....\r\n                writer.write(currentSourceFile.text.substring(comment.pos, comment.end));\r\n            }\r\n\r\n            function writeTrimmedCurrentLine(pos: number, nextLineStart: number) {\r\n                var end = Math.min(comment.end, nextLineStart - 1);\r\n                var currentLineText = currentSourceFile.text.substring(pos, end).replace(/^\\s+|\\s+$/g, '');\r\n                if (currentLineText) {\r\n                    // trimmed forward and ending spaces text\r\n                    writer.write(currentLineText);\r\n                    if (end !== comment.end) {\r\n                        writer.writeLine();\r\n                    }\r\n                }\r\n                else {\r\n                    // Empty string - make sure we write empty line\r\n                    writer.writeLiteral(newLine);\r\n                }\r\n            }\r\n\r\n            function calculateIndent(pos: number, end: number) {\r\n                var currentLineIndent = 0;\r\n                while (pos < end && isWhiteSpace(currentSourceFile.text.charCodeAt(pos))) {\r\n                    pos++;\r\n                    if (currentSourceFile.text.charCodeAt(pos) === CharacterCodes.tab) {\r\n                        // Tabs = size of the indent\r\n                        currentLineIndent += getIndentSize();\r\n                    }\r\n                    else {\r\n                        // Single space\r\n                        currentLineIndent++;\r\n                    }\r\n                }\r\n\r\n                return currentLineIndent;\r\n            }\r\n        }\r\n\r\n        function emitJavaScript(jsFilePath: string, root?: SourceFile) {\r\n            var writer = createTextWriter(writeSymbol);\r\n            var write = writer.write;\r\n            var writeLine = writer.writeLine;\r\n            var increaseIndent = writer.increaseIndent;\r\n            var decreaseIndent = writer.decreaseIndent;\r\n\r\n            var extendsEmitted = false;\r\n\r\n            /** write emitted output to disk*/\r\n            var writeEmittedFiles = writeJavaScriptFile;\r\n\r\n            /** Emit leading comments of the node */\r\n            var emitLeadingComments = compilerOptions.removeComments ? (node: Node) => { } : emitLeadingDeclarationComments;\r\n\r\n            /** Emit Trailing comments of the node */\r\n            var emitTrailingComments = compilerOptions.removeComments ? (node: Node) => { } : emitTrailingDeclarationComments;\r\n\r\n            var emitLeadingCommentsOfPosition = compilerOptions.removeComments ? (pos: number) => { } : emitLeadingCommentsOfLocalPosition;\r\n\r\n            var detachedCommentsInfo: { nodePos: number; detachedCommentEndPos: number }[];\r\n            /** Emit detached comments of the node */\r\n            var emitDetachedComments = compilerOptions.removeComments ? (node: TextRange) => { } : emitDetachedCommentsAtPosition;\r\n\r\n            /** Emits /// or pinned which is comment starting with /*! comments */\r\n            var emitPinnedOrTripleSlashComments = compilerOptions.removeComments ? (node: Node) => { } : emitPinnedOrTripleSlashCommentsOfNode;\r\n\r\n            var writeComment = writeCommentRange;\r\n\r\n            /** Emit a node */\r\n            var emit = emitNode;\r\n\r\n            /** Called just before starting emit of a node */\r\n            var emitStart = function (node: Node) { };\r\n\r\n            /** Called once the emit of the node is done */\r\n            var emitEnd = function (node: Node) { };\r\n\r\n            /** Emit the text for the given token that comes after startPos\r\n              * This by default writes the text provided with the given tokenKind \r\n              * but if optional emitFn callback is provided the text is emitted using the callback instead of default text\r\n              * @param tokenKind the kind of the token to search and emit\r\n              * @param startPos the position in the source to start searching for the token\r\n              * @param emitFn if given will be invoked to emit the text instead of actual token emit */\r\n            var emitToken = emitTokenText;\r\n\r\n            /** Called to before starting the lexical scopes as in function/class in the emitted code because of node\r\n              * @param scopeDeclaration node that starts the lexical scope\r\n              * @param scopeName Optional name of this scope instead of deducing one from the declaration node */\r\n            var scopeEmitStart = function (scopeDeclaration: Node, scopeName?: string) { }\r\n\r\n            /** Called after coming out of the scope */\r\n            var scopeEmitEnd = function () { }\r\n\r\n            /** Sourcemap data that will get encoded */\r\n            var sourceMapData: SourceMapData;\r\n\r\n            function writeSymbol(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags) { }\r\n\r\n            function initializeEmitterWithSourceMaps() {\r\n                var sourceMapDir: string; // The directory in which sourcemap will be\r\n\r\n                // Current source map file and its index in the sources list\r\n                var sourceMapSourceIndex = -1;\r\n\r\n                // Names and its index map\r\n                var sourceMapNameIndexMap: Map<number> = {};\r\n                var sourceMapNameIndices: number[] = [];\r\n                function getSourceMapNameIndex() {\r\n                    return sourceMapNameIndices.length ? sourceMapNameIndices[sourceMapNameIndices.length - 1] : -1;\r\n                }\r\n\r\n                // Last recorded and encoded spans\r\n                var lastRecordedSourceMapSpan: SourceMapSpan;\r\n                var lastEncodedSourceMapSpan: SourceMapSpan = {\r\n                    emittedLine: 1,\r\n                    emittedColumn: 1,\r\n                    sourceLine: 1,\r\n                    sourceColumn: 1,\r\n                    sourceIndex: 0\r\n                };\r\n                var lastEncodedNameIndex = 0;\r\n\r\n                // Encoding for sourcemap span\r\n                function encodeLastRecordedSourceMapSpan() {\r\n                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {\r\n                        return;\r\n                    }\r\n\r\n                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;\r\n                    // Line/Comma deliminators\r\n                    if (lastEncodedSourceMapSpan.emittedLine == lastRecordedSourceMapSpan.emittedLine) {\r\n                        // Emit comma to separate the entry\r\n                        if (sourceMapData.sourceMapMappings) {\r\n                            sourceMapData.sourceMapMappings += \",\";\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Emit line deliminators\r\n                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {\r\n                            sourceMapData.sourceMapMappings += \";\";\r\n                        }\r\n                        prevEncodedEmittedColumn = 1;\r\n                    }\r\n\r\n                    // 1. Relative Column 0 based\r\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);\r\n\r\n                    // 2. Relative sourceIndex \r\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);\r\n\r\n                    // 3. Relative sourceLine 0 based\r\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);\r\n\r\n                    // 4. Relative sourceColumn 0 based \r\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);\r\n\r\n                    // 5. Relative namePosition 0 based\r\n                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {\r\n                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);\r\n                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;\r\n                    }\r\n\r\n                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;\r\n                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);\r\n\r\n                    function base64VLQFormatEncode(inValue: number) {\r\n                        function base64FormatEncode(inValue: number) {\r\n                            if (inValue < 64) {\r\n                                return 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.charAt(inValue);\r\n                            }\r\n                            throw TypeError(inValue + \": not a 64 based value\");\r\n                        }\r\n\r\n                        // Add a new least significant bit that has the sign of the value.\r\n                        // if negative number the least significant bit that gets added to the number has value 1\r\n                        // else least significant bit value that gets added is 0\r\n                        // eg. -1 changes to binary : 01 [1] => 3\r\n                        //     +1 changes to binary : 01 [0] => 2\r\n                        if (inValue < 0) {\r\n                            inValue = ((-inValue) << 1) + 1;\r\n                        }\r\n                        else {\r\n                            inValue = inValue << 1;\r\n                        }\r\n\r\n                        // Encode 5 bits at a time starting from least significant bits\r\n                        var encodedStr = \"\";\r\n                        do {\r\n                            var currentDigit = inValue & 31; // 11111\r\n                            inValue = inValue >> 5;\r\n                            if (inValue > 0) {\r\n                                // There are still more digits to decode, set the msb (6th bit)\r\n                                currentDigit = currentDigit | 32;\r\n                            }\r\n                            encodedStr = encodedStr + base64FormatEncode(currentDigit);\r\n                        } while (inValue > 0);\r\n\r\n                        return encodedStr;\r\n                    }\r\n                }\r\n\r\n                function recordSourceMapSpan(pos: number) {\r\n                    var sourceLinePos = currentSourceFile.getLineAndCharacterFromPosition(pos);\r\n                    var emittedLine = writer.getLine();\r\n                    var emittedColumn = writer.getColumn();\r\n\r\n                    // If this location wasnt recorded or the location in source is going backwards, record the span\r\n                    if (!lastRecordedSourceMapSpan ||\r\n                        lastRecordedSourceMapSpan.emittedLine != emittedLine ||\r\n                        lastRecordedSourceMapSpan.emittedColumn != emittedColumn ||\r\n                        (lastRecordedSourceMapSpan.sourceIndex === sourceMapSourceIndex &&\r\n                        (lastRecordedSourceMapSpan.sourceLine > sourceLinePos.line ||\r\n                        (lastRecordedSourceMapSpan.sourceLine === sourceLinePos.line && lastRecordedSourceMapSpan.sourceColumn > sourceLinePos.character)))) {\r\n                        // Encode the last recordedSpan before assigning new\r\n                        encodeLastRecordedSourceMapSpan();\r\n\r\n                        // New span\r\n                        lastRecordedSourceMapSpan = {\r\n                            emittedLine: emittedLine,\r\n                            emittedColumn: emittedColumn,\r\n                            sourceLine: sourceLinePos.line,\r\n                            sourceColumn: sourceLinePos.character,\r\n                            nameIndex: getSourceMapNameIndex(),\r\n                            sourceIndex: sourceMapSourceIndex\r\n                        };\r\n                    }\r\n                    else {\r\n                        // Take the new pos instead since there is no change in emittedLine and column since last location\r\n                        lastRecordedSourceMapSpan.sourceLine = sourceLinePos.line;\r\n                        lastRecordedSourceMapSpan.sourceColumn = sourceLinePos.character;\r\n                        lastRecordedSourceMapSpan.sourceIndex = sourceMapSourceIndex;\r\n                    }\r\n                }\r\n\r\n                function recordEmitNodeStartSpan(node: Node) {\r\n                    // Get the token pos after skipping to the token (ignoring the leading trivia)\r\n                    recordSourceMapSpan(skipTrivia(currentSourceFile.text, node.pos));\r\n                }\r\n\r\n                function recordEmitNodeEndSpan(node: Node) {\r\n                    recordSourceMapSpan(node.end);\r\n                }\r\n\r\n                function writeTextWithSpanRecord(tokenKind: SyntaxKind, startPos: number, emitFn?: () => void) {\r\n                    var tokenStartPos = ts.skipTrivia(currentSourceFile.text, startPos);\r\n                    recordSourceMapSpan(tokenStartPos);\r\n                    var tokenEndPos = emitTokenText(tokenKind, tokenStartPos, emitFn);\r\n                    recordSourceMapSpan(tokenEndPos);\r\n                    return tokenEndPos;\r\n                }\r\n\r\n                function recordNewSourceFileStart(node: SourceFile) {\r\n                    // Add the the file to tsFilePaths\r\n                    // If sourceroot option: Use the relative path corresponding to the common directory path \r\n                    // otherwise source locations relative to map file location\r\n                    var sourcesDirectoryPath = compilerOptions.sourceRoot ? program.getCommonSourceDirectory() : sourceMapDir;\r\n\r\n                    sourceMapData.sourceMapSources.push(getRelativePathToDirectoryOrUrl(sourcesDirectoryPath,\r\n                        node.filename,\r\n                        compilerHost.getCurrentDirectory(),\r\n                    /*isAbsolutePathAnUrl*/ true));\r\n                    sourceMapSourceIndex = sourceMapData.sourceMapSources.length - 1;\r\n\r\n                    // The one that can be used from program to get the actual source file\r\n                    sourceMapData.inputSourceFileNames.push(node.filename);\r\n                }\r\n\r\n                function recordScopeNameOfNode(node: Node, scopeName?: string) {\r\n                    function recordScopeNameIndex(scopeNameIndex: number) {\r\n                        sourceMapNameIndices.push(scopeNameIndex);\r\n                    }\r\n\r\n                    function recordScopeNameStart(scopeName: string) {\r\n                        var scopeNameIndex = -1;\r\n                        if (scopeName) {\r\n                            var parentIndex = getSourceMapNameIndex();\r\n                            if (parentIndex !== -1) {\r\n                                scopeName = sourceMapData.sourceMapNames[parentIndex] + \".\" + scopeName;\r\n                            }\r\n\r\n                            scopeNameIndex = getProperty(sourceMapNameIndexMap, scopeName);\r\n                            if (scopeNameIndex === undefined) {\r\n                                scopeNameIndex = sourceMapData.sourceMapNames.length;\r\n                                sourceMapData.sourceMapNames.push(scopeName);\r\n                                sourceMapNameIndexMap[scopeName] = scopeNameIndex;\r\n                            }\r\n                        }\r\n                        recordScopeNameIndex(scopeNameIndex);\r\n                    }\r\n\r\n                    if (scopeName) {\r\n                        // The scope was already given a name  use it\r\n                        recordScopeNameStart(scopeName);\r\n                    }\r\n                    else if (node.kind === SyntaxKind.FunctionDeclaration ||\r\n                        node.kind === SyntaxKind.FunctionExpression ||\r\n                        node.kind === SyntaxKind.Method ||\r\n                        node.kind === SyntaxKind.GetAccessor ||\r\n                        node.kind === SyntaxKind.SetAccessor ||\r\n                        node.kind === SyntaxKind.ModuleDeclaration ||\r\n                        node.kind === SyntaxKind.ClassDeclaration ||\r\n                        node.kind === SyntaxKind.EnumDeclaration) {\r\n                        // Declaration and has associated name use it\r\n                        if ((<Declaration>node).name) {\r\n                            scopeName = (<Declaration>node).name.text;\r\n                        }\r\n                        recordScopeNameStart(scopeName);\r\n                    }\r\n                    else {\r\n                        // Block just use the name from upper level scope\r\n                        recordScopeNameIndex(getSourceMapNameIndex());\r\n                    }\r\n                }\r\n\r\n                function recordScopeNameEnd() {\r\n                    sourceMapNameIndices.pop();\r\n                };\r\n\r\n                function writeCommentRangeWithMap(comment: Comment, writer: EmitTextWriter) {\r\n                    recordSourceMapSpan(comment.pos);\r\n                    writeCommentRange(comment, writer);\r\n                    recordSourceMapSpan(comment.end);\r\n                }\r\n\r\n                function writeJavaScriptAndSourceMapFile(emitOutput: string, writeByteOrderMark: boolean) {\r\n                    // Write source map file\r\n                    encodeLastRecordedSourceMapSpan();\r\n                    writeFile(sourceMapData.sourceMapFilePath, JSON.stringify({\r\n                        version: 3,\r\n                        file: sourceMapData.sourceMapFile,\r\n                        sourceRoot: sourceMapData.sourceMapSourceRoot,\r\n                        sources: sourceMapData.sourceMapSources,\r\n                        names: sourceMapData.sourceMapNames,\r\n                        mappings: sourceMapData.sourceMapMappings\r\n                    }), /*writeByteOrderMark*/ false);\r\n                    sourceMapDataList.push(sourceMapData);\r\n\r\n                    // Write sourcemap url to the js file and write the js file\r\n                    writeJavaScriptFile(emitOutput + \"//# sourceMappingURL=\" + sourceMapData.jsSourceMappingURL, writeByteOrderMark);\r\n                }\r\n\r\n                // Initialize source map data\r\n                var sourceMapJsFile = getBaseFilename(normalizeSlashes(jsFilePath));\r\n                sourceMapData = {\r\n                    sourceMapFilePath: jsFilePath + \".map\",\r\n                    jsSourceMappingURL: sourceMapJsFile + \".map\",\r\n                    sourceMapFile: sourceMapJsFile,\r\n                    sourceMapSourceRoot: compilerOptions.sourceRoot || \"\",\r\n                    sourceMapSources: [],\r\n                    inputSourceFileNames: [],\r\n                    sourceMapNames: [],\r\n                    sourceMapMappings: \"\",\r\n                    sourceMapDecodedMappings: []\r\n                };\r\n\r\n                // Normalize source root and make sure it has trailing \"/\" so that it can be used to combine paths with the \r\n                // relative paths of the sources list in the sourcemap\r\n                sourceMapData.sourceMapSourceRoot = ts.normalizeSlashes(sourceMapData.sourceMapSourceRoot);\r\n                if (sourceMapData.sourceMapSourceRoot.length && sourceMapData.sourceMapSourceRoot.charCodeAt(sourceMapData.sourceMapSourceRoot.length - 1) !== CharacterCodes.slash) {\r\n                    sourceMapData.sourceMapSourceRoot += directorySeparator;\r\n                }\r\n\r\n                if (compilerOptions.mapRoot) {\r\n                    sourceMapDir = normalizeSlashes(compilerOptions.mapRoot);\r\n                    if (root) { // emitting single module file\r\n                        // For modules or multiple emit files the mapRoot will have directory structure like the sources\r\n                        // So if src\\a.ts and src\\lib\\b.ts are compiled together user would be moving the maps into mapRoot\\a.js.map and mapRoot\\lib\\b.js.map\r\n                        sourceMapDir = getDirectoryPath(getSourceFilePathInNewDir(sourceMapDir, root));\r\n                    }\r\n\r\n                    if (!isRootedDiskPath(sourceMapDir) && !isUrl(sourceMapDir)) {\r\n                        // The relative paths are relative to the common directory\r\n                        sourceMapDir = combinePaths(program.getCommonSourceDirectory(), sourceMapDir);\r\n                        sourceMapData.jsSourceMappingURL = getRelativePathToDirectoryOrUrl(\r\n                            getDirectoryPath(normalizePath(jsFilePath)), // get the relative sourceMapDir path based on jsFilePath\r\n                            combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL), // this is where user expects to see sourceMap\r\n                            compilerHost.getCurrentDirectory(),\r\n                        /*isAbsolutePathAnUrl*/ true);\r\n                    }\r\n                    else {\r\n                        sourceMapData.jsSourceMappingURL = combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL);\r\n                    }\r\n                }\r\n                else {\r\n                    sourceMapDir = getDirectoryPath(normalizePath(jsFilePath));\r\n                }\r\n\r\n                function emitNodeWithMap(node: Node) {\r\n                    if (node) {\r\n                        if (node.kind != SyntaxKind.SourceFile) {\r\n                            recordEmitNodeStartSpan(node);\r\n                            emitNode(node);\r\n                            recordEmitNodeEndSpan(node);\r\n                        }\r\n                        else {\r\n                            recordNewSourceFileStart(<SourceFile>node);\r\n                            emitNode(node);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                writeEmittedFiles = writeJavaScriptAndSourceMapFile;\r\n                emit = emitNodeWithMap;\r\n                emitStart = recordEmitNodeStartSpan;\r\n                emitEnd = recordEmitNodeEndSpan;\r\n                emitToken = writeTextWithSpanRecord;\r\n                scopeEmitStart = recordScopeNameOfNode;\r\n                scopeEmitEnd = recordScopeNameEnd;\r\n                writeComment = writeCommentRangeWithMap;\r\n            }\r\n\r\n            function writeJavaScriptFile(emitOutput: string, writeByteOrderMark: boolean) {\r\n                writeFile(jsFilePath, emitOutput, writeByteOrderMark);\r\n            }\r\n\r\n            function emitTokenText(tokenKind: SyntaxKind, startPos: number, emitFn?: () => void) {\r\n                var tokenString = tokenToString(tokenKind);\r\n                if (emitFn) {\r\n                    emitFn();\r\n                }\r\n                else {\r\n                    write(tokenString);\r\n                }\r\n                return startPos + tokenString.length;\r\n            }\r\n\r\n            function emitOptional(prefix: string, node: Node) {\r\n                if (node) {\r\n                    write(prefix);\r\n                    emit(node);\r\n                }\r\n            }\r\n\r\n            function emitCommaList(nodes: Node[], count?: number) {\r\n                if (!(count >= 0)) count = nodes.length;\r\n                if (nodes) {\r\n                    for (var i = 0; i < count; i++) {\r\n                        if (i) write(\", \");\r\n                        emit(nodes[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitMultiLineList(nodes: Node[]) {\r\n                if (nodes) {\r\n                    for (var i = 0; i < nodes.length; i++) {\r\n                        if (i) write(\",\");\r\n                        writeLine();\r\n                        emit(nodes[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitLines(nodes: Node[]) {\r\n                emitLinesStartingAt(nodes, /*startIndex*/ 0);\r\n            }\r\n\r\n            function emitLinesStartingAt(nodes: Node[], startIndex: number): void {\r\n                for (var i = startIndex; i < nodes.length; i++) {\r\n                    writeLine();\r\n                    emit(nodes[i]);\r\n                }\r\n            }\r\n\r\n            function emitLiteral(node: LiteralExpression) {\r\n                var text = getSourceTextOfLocalNode(node);\r\n                if (node.kind === SyntaxKind.StringLiteral && compilerOptions.sourceMap) {\r\n                    writer.writeLiteral(text);\r\n                }\r\n                else {\r\n                    write(text);\r\n                }\r\n            }\r\n\r\n            // This function specifically handles numeric/string literals for enum and accessor 'identifiers'.\r\n            // In a sense, it does not actually emit identifiers as much as it declares a name for a specific property.\r\n            function emitQuotedIdentifier(node: Identifier) {\r\n                if (node.kind === SyntaxKind.StringLiteral) {\r\n                    emitLiteral(node);\r\n                }\r\n                else {\r\n                    write(\"\\\"\");\r\n\r\n                    if (node.kind === SyntaxKind.NumericLiteral) {\r\n                        write(node.text);\r\n                    }\r\n                    else {\r\n                        write(getSourceTextOfLocalNode(node));\r\n                    }\r\n\r\n                    write(\"\\\"\");\r\n                }\r\n            }\r\n\r\n            function isNonExpressionIdentifier(node: Identifier) {\r\n                var parent = node.parent;\r\n                switch (parent.kind) {\r\n                    case SyntaxKind.Parameter:\r\n                    case SyntaxKind.VariableDeclaration:\r\n                    case SyntaxKind.Property:\r\n                    case SyntaxKind.PropertyAssignment:\r\n                    case SyntaxKind.EnumMember:\r\n                    case SyntaxKind.Method:\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                    case SyntaxKind.EnumDeclaration:\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                    case SyntaxKind.ImportDeclaration:\r\n                        return (<Declaration>parent).name === node;\r\n                    case SyntaxKind.BreakStatement:\r\n                    case SyntaxKind.ContinueStatement:\r\n                    case SyntaxKind.ExportAssignment:\r\n                        return false;\r\n                    case SyntaxKind.LabelledStatement:\r\n                        return (<LabelledStatement>node.parent).label === node;\r\n                    case SyntaxKind.CatchBlock:\r\n                        return (<CatchBlock>node.parent).variable === node;\r\n                }\r\n            }\r\n\r\n            function emitIdentifier(node: Identifier) {\r\n                if (!isNonExpressionIdentifier(node)) {\r\n                    var prefix = resolver.getExpressionNamePrefix(node);\r\n                    if (prefix) {\r\n                        write(prefix);\r\n                        write(\".\");\r\n                    }\r\n                }\r\n                write(getSourceTextOfLocalNode(node));\r\n            }\r\n\r\n            function emitThis(node: Node) {\r\n                if (resolver.getNodeCheckFlags(node) & NodeCheckFlags.LexicalThis) {\r\n                    write(\"_this\");\r\n                }\r\n                else {\r\n                    write(\"this\");\r\n                }\r\n            }\r\n\r\n            function emitSuper(node: Node) {\r\n                var flags = resolver.getNodeCheckFlags(node);\r\n                if (flags & NodeCheckFlags.SuperInstance) {\r\n                    write(\"_super.prototype\");\r\n                }\r\n                else if (flags & NodeCheckFlags.SuperStatic) {\r\n                    write(\"_super\");\r\n                }\r\n                else {\r\n                    write(\"super\");\r\n                }\r\n            }\r\n\r\n            function emitArrayLiteral(node: ArrayLiteral) {\r\n                if (node.flags & NodeFlags.MultiLine) {\r\n                    write(\"[\");\r\n                    increaseIndent();\r\n                    emitMultiLineList(node.elements);\r\n                    decreaseIndent();\r\n                    writeLine();\r\n                    write(\"]\");\r\n                }\r\n                else {\r\n                    write(\"[\");\r\n                    emitCommaList(node.elements);\r\n                    write(\"]\");\r\n                }\r\n            }\r\n\r\n            function emitObjectLiteral(node: ObjectLiteral) {\r\n                if (!node.properties.length) {\r\n                    write(\"{}\");\r\n                }\r\n                else if (node.flags & NodeFlags.MultiLine) {\r\n                    write(\"{\");\r\n                    increaseIndent();\r\n                    emitMultiLineList(node.properties);\r\n                    decreaseIndent();\r\n                    writeLine();\r\n                    write(\"}\");\r\n                }\r\n                else {\r\n                    write(\"{ \");\r\n                    emitCommaList(node.properties);\r\n                    write(\" }\");\r\n                }\r\n            }\r\n\r\n            function emitPropertyAssignment(node: PropertyDeclaration) {\r\n                emitLeadingComments(node);\r\n                emit(node.name);\r\n                write(\": \");\r\n                emit(node.initializer);\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitPropertyAccess(node: PropertyAccess) {\r\n                var text = resolver.getPropertyAccessSubstitution(node);\r\n                if (text) {\r\n                    write(text);\r\n                    return;\r\n                }\r\n                emit(node.left);\r\n                write(\".\");\r\n                emit(node.right);\r\n            }\r\n\r\n            function emitIndexedAccess(node: IndexedAccess) {\r\n                emit(node.object);\r\n                write(\"[\");\r\n                emit(node.index);\r\n                write(\"]\");\r\n            }\r\n\r\n            function emitCallExpression(node: CallExpression) {\r\n                var superCall = false;\r\n                if (node.func.kind === SyntaxKind.SuperKeyword) {\r\n                    write(\"_super\");\r\n                    superCall = true;\r\n                }\r\n                else {\r\n                    emit(node.func);\r\n                    superCall = node.func.kind === SyntaxKind.PropertyAccess && (<PropertyAccess>node.func).left.kind === SyntaxKind.SuperKeyword;\r\n                }\r\n                if (superCall) {\r\n                    write(\".call(\");\r\n                    emitThis(node.func);\r\n                    if (node.arguments.length) {\r\n                        write(\", \");\r\n                        emitCommaList(node.arguments);\r\n                    }\r\n                    write(\")\");\r\n                }\r\n                else {\r\n                    write(\"(\");\r\n                    emitCommaList(node.arguments);\r\n                    write(\")\");\r\n                }\r\n            }\r\n\r\n            function emitNewExpression(node: NewExpression) {\r\n                write(\"new \");\r\n                emit(node.func);\r\n                if (node.arguments) {\r\n                    write(\"(\");\r\n                    emitCommaList(node.arguments);\r\n                    write(\")\");\r\n                }\r\n            }\r\n\r\n            function emitParenExpression(node: ParenExpression) {\r\n                if (node.expression.kind === SyntaxKind.TypeAssertion) {\r\n                    var operand = (<TypeAssertion>node.expression).operand;\r\n\r\n                    // Make sure we consider all nested cast expressions, e.g.:\r\n                    // (<any><number><any>-A).x; \r\n                    while (operand.kind == SyntaxKind.TypeAssertion) {\r\n                        operand = (<TypeAssertion>operand).operand;\r\n                    }\r\n\r\n                    // We have an expression of the form: (<Type>SubExpr)\r\n                    // Emitting this as (SubExpr) is really not desirable. We would like to emit the subexpr as is.\r\n                    // Omitting the parentheses, however, could cause change in the semantics of the generated\r\n                    // code if the casted expression has a lower precedence than the rest of the expression, e.g.: \r\n                    //      (<any>new A).foo should be emitted as (new A).foo and not new A.foo\r\n                    //      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()\r\n                    //      new (<any>A()) should be emitted as new (A()) and not new A()\r\n                    //      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()\r\n                    if (operand.kind !== SyntaxKind.PrefixOperator && operand.kind !== SyntaxKind.PostfixOperator && operand.kind !== SyntaxKind.NewExpression &&\r\n                        !(operand.kind === SyntaxKind.CallExpression && node.parent.kind === SyntaxKind.NewExpression) &&\r\n                        !(operand.kind === SyntaxKind.FunctionExpression && node.parent.kind === SyntaxKind.CallExpression)) {\r\n                        emit(operand);\r\n                        return;\r\n                    }\r\n                }\r\n                write(\"(\");\r\n                emit(node.expression);\r\n                write(\")\");\r\n            }\r\n\r\n            function emitUnaryExpression(node: UnaryExpression) {\r\n                if (node.kind === SyntaxKind.PrefixOperator) {\r\n                    write(tokenToString(node.operator));\r\n                }\r\n                // In some cases, we need to emit a space between the operator and the operand. One obvious case\r\n                // is when the operator is an identifer, like delete or typeof. We also need to do this for plus\r\n                // and minus expressions in certain cases. Specifically, consider the following two cases (parens\r\n                // are just for clarity of exposition, and not part of the source code):\r\n                //\r\n                //  (+(+1))\r\n                //  (+(++1))\r\n                //\r\n                // We need to emit a space in both cases. In the first case, the absence of a space will make\r\n                // the resulting expression a prefix increment operation. And in the second, it will make the resulting\r\n                // expression a prefix increment whose operand is a plus expression - (++(+x))\r\n                // The same is true of minus of course.\r\n                if (node.operator >= SyntaxKind.Identifier) {\r\n                    write(\" \");\r\n                }\r\n                else if (node.kind === SyntaxKind.PrefixOperator && node.operand.kind === SyntaxKind.PrefixOperator) {\r\n                    var operand = <UnaryExpression>node.operand;\r\n                    if (node.operator === SyntaxKind.PlusToken && (operand.operator === SyntaxKind.PlusToken || operand.operator === SyntaxKind.PlusPlusToken)) {\r\n                        write(\" \");\r\n                    }\r\n                    else if (node.operator === SyntaxKind.MinusToken && (operand.operator === SyntaxKind.MinusToken || operand.operator === SyntaxKind.MinusMinusToken)) {\r\n                        write(\" \");\r\n                    }\r\n                }\r\n                emit(node.operand);\r\n                if (node.kind === SyntaxKind.PostfixOperator) {\r\n                    write(tokenToString(node.operator));\r\n                }\r\n            }\r\n\r\n            function emitBinaryExpression(node: BinaryExpression) {\r\n                emit(node.left);\r\n                if (node.operator !== SyntaxKind.CommaToken) write(\" \");\r\n                write(tokenToString(node.operator));\r\n                write(\" \");\r\n                emit(node.right);\r\n            }\r\n\r\n            function emitConditionalExpression(node: ConditionalExpression) {\r\n                emit(node.condition);\r\n                write(\" ? \");\r\n                emit(node.whenTrue);\r\n                write(\" : \");\r\n                emit(node.whenFalse);\r\n            }\r\n\r\n            function emitBlock(node: Block) {\r\n                emitToken(SyntaxKind.OpenBraceToken, node.pos);\r\n                increaseIndent();\r\n                scopeEmitStart(node.parent);\r\n                if (node.kind === SyntaxKind.ModuleBlock) {\r\n                    Debug.assert(node.parent.kind === SyntaxKind.ModuleDeclaration);\r\n                    emitCaptureThisForNodeIfNecessary(node.parent);\r\n                }\r\n                emitLines(node.statements);\r\n                decreaseIndent();\r\n                writeLine();\r\n                emitToken(SyntaxKind.CloseBraceToken, node.statements.end);\r\n                scopeEmitEnd();\r\n            }\r\n\r\n            function emitEmbeddedStatement(node: Node) {\r\n                if (node.kind === SyntaxKind.Block) {\r\n                    write(\" \");\r\n                    emit(<Block>node);\r\n                }\r\n                else {\r\n                    increaseIndent();\r\n                    writeLine();\r\n                    emit(node);\r\n                    decreaseIndent();\r\n                }\r\n            }\r\n\r\n            function emitExpressionStatement(node: ExpressionStatement) {\r\n                var isArrowExpression = node.expression.kind === SyntaxKind.ArrowFunction;\r\n                emitLeadingComments(node);\r\n                if (isArrowExpression) write(\"(\");\r\n                emit(node.expression);\r\n                if (isArrowExpression) write(\")\");\r\n                write(\";\");\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitIfStatement(node: IfStatement) {\r\n                emitLeadingComments(node);\r\n                var endPos = emitToken(SyntaxKind.IfKeyword, node.pos);\r\n                write(\" \");\r\n                endPos = emitToken(SyntaxKind.OpenParenToken, endPos);\r\n                emit(node.expression);\r\n                emitToken(SyntaxKind.CloseParenToken, node.expression.end);\r\n                emitEmbeddedStatement(node.thenStatement);\r\n                if (node.elseStatement) {\r\n                    writeLine();\r\n                    emitToken(SyntaxKind.ElseKeyword, node.thenStatement.end);\r\n                    if (node.elseStatement.kind === SyntaxKind.IfStatement) {\r\n                        write(\" \");\r\n                        emit(node.elseStatement);\r\n                    }\r\n                    else {\r\n                        emitEmbeddedStatement(node.elseStatement);\r\n                    }\r\n                }\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitDoStatement(node: DoStatement) {\r\n                write(\"do\");\r\n                emitEmbeddedStatement(node.statement);\r\n                if (node.statement.kind === SyntaxKind.Block) {\r\n                    write(\" \");\r\n                }\r\n                else {\r\n                    writeLine();\r\n                }\r\n                write(\"while (\");\r\n                emit(node.expression);\r\n                write(\");\");\r\n            }\r\n\r\n            function emitWhileStatement(node: WhileStatement) {\r\n                write(\"while (\");\r\n                emit(node.expression);\r\n                write(\")\");\r\n                emitEmbeddedStatement(node.statement);\r\n            }\r\n\r\n            function emitForStatement(node: ForStatement) {\r\n                var endPos = emitToken(SyntaxKind.ForKeyword, node.pos);\r\n                write(\" \");\r\n                endPos = emitToken(SyntaxKind.OpenParenToken, endPos);\r\n                if (node.declarations) {\r\n                    emitToken(SyntaxKind.VarKeyword, endPos);\r\n                    write(\" \");\r\n                    emitCommaList(node.declarations);\r\n                }\r\n                if (node.initializer) {\r\n                    emit(node.initializer);\r\n                }\r\n                write(\";\");\r\n                emitOptional(\" \", node.condition);\r\n                write(\";\");\r\n                emitOptional(\" \", node.iterator);\r\n                write(\")\");\r\n                emitEmbeddedStatement(node.statement);\r\n            }\r\n\r\n            function emitForInStatement(node: ForInStatement) {\r\n                var endPos = emitToken(SyntaxKind.ForKeyword, node.pos);\r\n                write(\" \");\r\n                endPos = emitToken(SyntaxKind.OpenParenToken, endPos);\r\n                if (node.declaration) {\r\n                    emitToken(SyntaxKind.VarKeyword, endPos);\r\n                    write(\" \");\r\n                    emit(node.declaration);\r\n                }\r\n                else {\r\n                    emit(node.variable);\r\n                }\r\n                write(\" in \");\r\n                emit(node.expression);\r\n                emitToken(SyntaxKind.CloseParenToken, node.expression.end);\r\n                emitEmbeddedStatement(node.statement);\r\n            }\r\n\r\n            function emitBreakOrContinueStatement(node: BreakOrContinueStatement) {\r\n                emitToken(node.kind === SyntaxKind.BreakStatement ? SyntaxKind.BreakKeyword : SyntaxKind.ContinueKeyword, node.pos);\r\n                emitOptional(\" \", node.label);\r\n                write(\";\");\r\n            }\r\n\r\n            function emitReturnStatement(node: ReturnStatement) {\r\n                emitLeadingComments(node);\r\n                emitToken(SyntaxKind.ReturnKeyword, node.pos);\r\n                emitOptional(\" \", node.expression);\r\n                write(\";\");\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitWithStatement(node: WhileStatement) {\r\n                write(\"with (\");\r\n                emit(node.expression);\r\n                write(\")\");\r\n                emitEmbeddedStatement(node.statement);\r\n            }\r\n\r\n            function emitSwitchStatement(node: SwitchStatement) {\r\n                var endPos = emitToken(SyntaxKind.SwitchKeyword, node.pos);\r\n                write(\" \");\r\n                emitToken(SyntaxKind.OpenParenToken, endPos);\r\n                emit(node.expression);\r\n                endPos = emitToken(SyntaxKind.CloseParenToken, node.expression.end);\r\n                write(\" \");\r\n                emitToken(SyntaxKind.OpenBraceToken, endPos);\r\n                increaseIndent();\r\n                emitLines(node.clauses);\r\n                decreaseIndent();\r\n                writeLine();\r\n                emitToken(SyntaxKind.CloseBraceToken, node.clauses.end);\r\n            }\r\n\r\n            function emitCaseOrDefaultClause(node: CaseOrDefaultClause) {\r\n                if (node.kind === SyntaxKind.CaseClause) {\r\n                    write(\"case \");\r\n                    emit(node.expression);\r\n                    write(\":\");\r\n                }\r\n                else {\r\n                    write(\"default:\");\r\n                }\r\n                increaseIndent();\r\n                emitLines(node.statements);\r\n                decreaseIndent();\r\n            }\r\n\r\n            function emitThrowStatement(node: ThrowStatement) {\r\n                write(\"throw \");\r\n                emit(node.expression);\r\n                write(\";\");\r\n            }\r\n\r\n            function emitTryStatement(node: TryStatement) {\r\n                write(\"try \");\r\n                emit(node.tryBlock);\r\n                emit(node.catchBlock);\r\n                if (node.finallyBlock) {\r\n                    writeLine();\r\n                    write(\"finally \");\r\n                    emit(node.finallyBlock);\r\n                }\r\n            }\r\n\r\n            function emitCatchBlock(node: CatchBlock) {\r\n                writeLine();\r\n                var endPos = emitToken(SyntaxKind.CatchKeyword, node.pos);\r\n                write(\" \");\r\n                emitToken(SyntaxKind.OpenParenToken, endPos);\r\n                emit(node.variable);\r\n                emitToken(SyntaxKind.CloseParenToken, node.variable.end);\r\n                write(\" \");\r\n                emitBlock(node);\r\n            }\r\n\r\n            function emitDebuggerStatement(node: Node) {\r\n                emitToken(SyntaxKind.DebuggerKeyword, node.pos);\r\n                write(\";\");\r\n            }\r\n\r\n            function emitLabelledStatement(node: LabelledStatement) {\r\n                emit(node.label);\r\n                write(\": \");\r\n                emit(node.statement);\r\n            }\r\n\r\n            function getContainingModule(node: Node): ModuleDeclaration {\r\n                do {\r\n                    node = node.parent;\r\n                } while (node && node.kind !== SyntaxKind.ModuleDeclaration);\r\n                return <ModuleDeclaration>node;\r\n            }\r\n\r\n            function emitModuleMemberName(node: Declaration) {\r\n                emitStart(node.name);\r\n                if (node.flags & NodeFlags.Export) {\r\n                    var container = getContainingModule(node);\r\n                    write(container ? resolver.getLocalNameOfContainer(container) : \"exports\");\r\n                    write(\".\");\r\n                }\r\n                emitNode(node.name);\r\n                emitEnd(node.name);\r\n            }\r\n\r\n            function emitVariableDeclaration(node: VariableDeclaration) {\r\n                emitLeadingComments(node);\r\n                emitModuleMemberName(node);\r\n                emitOptional(\" = \", node.initializer);\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitVariableStatement(node: VariableStatement) {\r\n                emitLeadingComments(node);\r\n                if (!(node.flags & NodeFlags.Export)) write(\"var \");\r\n                emitCommaList(node.declarations);\r\n                write(\";\");\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitParameter(node: ParameterDeclaration) {\r\n                emitLeadingComments(node);\r\n                emit(node.name);\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitDefaultValueAssignments(node: FunctionDeclaration) {\r\n                forEach(node.parameters, param => {\r\n                    if (param.initializer) {\r\n                        writeLine();\r\n                        emitStart(param);\r\n                        write(\"if (\");\r\n                        emitNode(param.name);\r\n                        write(\" === void 0)\");\r\n                        emitEnd(param);\r\n                        write(\" { \");\r\n                        emitStart(param);\r\n                        emitNode(param.name);\r\n                        write(\" = \");\r\n                        emitNode(param.initializer);\r\n                        emitEnd(param);\r\n                        write(\"; }\");\r\n                    }\r\n                });\r\n            }\r\n\r\n            function emitRestParameter(node: FunctionDeclaration) {\r\n                if (hasRestParameters(node)) {\r\n                    var restIndex = node.parameters.length - 1;\r\n                    var restParam = node.parameters[restIndex];\r\n                    writeLine();\r\n                    emitLeadingComments(restParam);\r\n                    emitStart(restParam);\r\n                    write(\"var \");\r\n                    emitNode(restParam.name);\r\n                    write(\" = [];\");\r\n                    emitEnd(restParam);\r\n                    emitTrailingComments(restParam);\r\n                    writeLine();\r\n                    write(\"for (\");\r\n                    emitStart(restParam);\r\n                    write(\"var _i = \" + restIndex + \";\");\r\n                    emitEnd(restParam);\r\n                    write(\" \");\r\n                    emitStart(restParam);\r\n                    write(\"_i < arguments.length;\");\r\n                    emitEnd(restParam);\r\n                    write(\" \");\r\n                    emitStart(restParam);\r\n                    write(\"_i++\");\r\n                    emitEnd(restParam);\r\n                    write(\") {\");\r\n                    increaseIndent();\r\n                    writeLine();\r\n                    emitStart(restParam);\r\n                    emitNode(restParam.name);\r\n                    write(\"[_i - \" + restIndex + \"] = arguments[_i];\");\r\n                    emitEnd(restParam);\r\n                    decreaseIndent();\r\n                    writeLine();\r\n                    write(\"}\");\r\n                }\r\n            }\r\n\r\n            function emitAccessor(node: AccessorDeclaration) {\r\n                emitLeadingComments(node);\r\n                write(node.kind === SyntaxKind.GetAccessor ? \"get \" : \"set \");\r\n                emit(node.name);\r\n                emitSignatureAndBody(node);\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitFunctionDeclaration(node: FunctionDeclaration) {\r\n                if (!node.body) {\r\n                    return emitPinnedOrTripleSlashComments(node);\r\n                }\r\n\r\n                if (node.kind !== SyntaxKind.Method) {\r\n                    // Methods will emit the comments as part of emitting method declaration\r\n                    emitLeadingComments(node);\r\n                }\r\n                write(\"function \");\r\n                if (node.kind === SyntaxKind.FunctionDeclaration || (node.kind === SyntaxKind.FunctionExpression && node.name)) {\r\n                    emit(node.name);\r\n                }\r\n                emitSignatureAndBody(node);\r\n                if (node.kind !== SyntaxKind.Method) {\r\n                    emitTrailingComments(node);\r\n                }\r\n            }\r\n\r\n            function emitCaptureThisForNodeIfNecessary(node: Node): void {\r\n                if (resolver.getNodeCheckFlags(node) & NodeCheckFlags.CaptureThis) {\r\n                    writeLine();\r\n                    emitStart(node);\r\n                    write(\"var _this = this;\");\r\n                    emitEnd(node);\r\n                }\r\n            }\r\n\r\n            function emitSignatureParameters(node: FunctionDeclaration) {\r\n                increaseIndent();\r\n                write(\"(\");\r\n                if (node) {\r\n                    emitCommaList(node.parameters, node.parameters.length - (hasRestParameters(node) ? 1 : 0));\r\n                }\r\n                write(\")\");\r\n                decreaseIndent();\r\n            }\r\n\r\n            function emitSignatureAndBody(node: FunctionDeclaration) {\r\n                emitSignatureParameters(node);\r\n                write(\" {\");\r\n                scopeEmitStart(node);\r\n                increaseIndent();\r\n\r\n                emitDetachedComments(node.body.kind === SyntaxKind.FunctionBlock ? (<Block>node.body).statements : node.body);\r\n\r\n                var startIndex = 0;\r\n                if (node.body.kind === SyntaxKind.FunctionBlock) {\r\n                    startIndex = emitDirectivePrologues((<Block>node.body).statements, /*startWithNewLine*/ true);\r\n                }\r\n                var outPos = writer.getTextPos();\r\n                emitCaptureThisForNodeIfNecessary(node);\r\n                emitDefaultValueAssignments(node);\r\n                emitRestParameter(node);\r\n                if (node.body.kind !== SyntaxKind.FunctionBlock && outPos === writer.getTextPos()) {\r\n                    decreaseIndent();\r\n                    write(\" \");\r\n                    emitStart(node.body);\r\n                    write(\"return \");\r\n                    emitNode(node.body);\r\n                    emitEnd(node.body);\r\n                    write(\"; \");\r\n                    emitStart(node.body);\r\n                    write(\"}\");\r\n                    emitEnd(node.body);\r\n                }\r\n                else {\r\n                    if (node.body.kind === SyntaxKind.FunctionBlock) {\r\n                        emitLinesStartingAt((<Block>node.body).statements, startIndex);\r\n                    }\r\n                    else {\r\n                        writeLine();\r\n                        emitLeadingComments(node.body);\r\n                        write(\"return \");\r\n                        emit(node.body);\r\n                        write(\";\");\r\n                        emitTrailingComments(node.body);\r\n                    }\r\n                    writeLine();\r\n                    if (node.body.kind === SyntaxKind.FunctionBlock) {\r\n                        emitLeadingCommentsOfPosition((<Block>node.body).statements.end);\r\n                        decreaseIndent();\r\n                        emitToken(SyntaxKind.CloseBraceToken, (<Block>node.body).statements.end);\r\n                    }\r\n                    else {\r\n                        decreaseIndent();\r\n                        emitStart(node.body);\r\n                        write(\"}\");\r\n                        emitEnd(node.body);\r\n                    }\r\n                }\r\n                scopeEmitEnd();\r\n                if (node.flags & NodeFlags.Export) {\r\n                    writeLine();\r\n                    emitStart(node);\r\n                    emitModuleMemberName(node);\r\n                    write(\" = \");\r\n                    emit(node.name);\r\n                    emitEnd(node);\r\n                    write(\";\");\r\n                }\r\n            }\r\n\r\n            function findInitialSuperCall(ctor: ConstructorDeclaration): ExpressionStatement {\r\n                if (ctor.body) {\r\n                    var statement = (<Block>ctor.body).statements[0];\r\n                    if (statement && statement.kind === SyntaxKind.ExpressionStatement) {\r\n                        var expr = (<ExpressionStatement>statement).expression;\r\n                        if (expr && expr.kind === SyntaxKind.CallExpression) {\r\n                            var func = (<CallExpression>expr).func;\r\n                            if (func && func.kind === SyntaxKind.SuperKeyword) {\r\n                                return <ExpressionStatement>statement;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitParameterPropertyAssignments(node: ConstructorDeclaration) {\r\n                forEach(node.parameters, param => {\r\n                    if (param.flags & (NodeFlags.Public | NodeFlags.Private)) {\r\n                        writeLine();\r\n                        emitStart(param);\r\n                        emitStart(param.name);\r\n                        write(\"this.\");\r\n                        emitNode(param.name);\r\n                        emitEnd(param.name);\r\n                        write(\" = \");\r\n                        emit(param.name);\r\n                        write(\";\");\r\n                        emitEnd(param);\r\n                    }\r\n                });\r\n            }\r\n\r\n            function emitMemberAccess(memberName: Identifier) {\r\n                if (memberName.kind === SyntaxKind.StringLiteral || memberName.kind === SyntaxKind.NumericLiteral) {\r\n                    write(\"[\");\r\n                    emitNode(memberName);\r\n                    write(\"]\");\r\n                }\r\n                else {\r\n                    write(\".\");\r\n                    emitNode(memberName);\r\n                }\r\n            }\r\n\r\n            function emitMemberAssignments(node: ClassDeclaration, staticFlag: NodeFlags) {\r\n                forEach(node.members, member => {\r\n                    if (member.kind === SyntaxKind.Property && (member.flags & NodeFlags.Static) === staticFlag && (<PropertyDeclaration>member).initializer) {\r\n                        writeLine();\r\n                        emitLeadingComments(member);\r\n                        emitStart(member);\r\n                        emitStart((<PropertyDeclaration>member).name);\r\n                        if (staticFlag) {\r\n                            emitNode(node.name);\r\n                        }\r\n                        else {\r\n                            write(\"this\");\r\n                        }\r\n                        emitMemberAccess((<PropertyDeclaration>member).name);\r\n                        emitEnd((<PropertyDeclaration>member).name);\r\n                        write(\" = \");\r\n                        emit((<PropertyDeclaration>member).initializer);\r\n                        write(\";\");\r\n                        emitEnd(member);\r\n                        emitTrailingComments(member);\r\n                    }\r\n                });\r\n            }\r\n\r\n            function emitMemberFunctions(node: ClassDeclaration) {\r\n                forEach(node.members, member => {\r\n                    if (member.kind === SyntaxKind.Method) {\r\n                        if (!(<MethodDeclaration>member).body) {\r\n                            return emitPinnedOrTripleSlashComments(member);\r\n                        }\r\n\r\n                        writeLine();\r\n                        emitLeadingComments(member);\r\n                        emitStart(member);\r\n                        emitStart((<MethodDeclaration>member).name);\r\n                        emitNode(node.name);\r\n                        if (!(member.flags & NodeFlags.Static)) {\r\n                            write(\".prototype\");\r\n                        }\r\n                        emitMemberAccess((<MethodDeclaration>member).name);\r\n                        emitEnd((<MethodDeclaration>member).name);\r\n                        write(\" = \");\r\n                        emitStart(member);\r\n                        emitFunctionDeclaration(<MethodDeclaration>member);\r\n                        emitEnd(member);\r\n                        emitEnd(member);\r\n                        write(\";\");\r\n                        emitTrailingComments(member);\r\n                    }\r\n                    else if (member.kind === SyntaxKind.GetAccessor || member.kind === SyntaxKind.SetAccessor) {\r\n                        var accessors = getAllAccessorDeclarations(node, <AccessorDeclaration>member);\r\n                        if (member === accessors.firstAccessor) {\r\n                            writeLine();\r\n                            emitStart(member);\r\n                            write(\"Object.defineProperty(\");\r\n                            emitStart((<AccessorDeclaration>member).name);\r\n                            emitNode(node.name);\r\n                            if (!(member.flags & NodeFlags.Static)) {\r\n                                write(\".prototype\");\r\n                            }\r\n                            write(\", \");\r\n                            emitQuotedIdentifier((<AccessorDeclaration>member).name);\r\n                            emitEnd((<AccessorDeclaration>member).name);\r\n                            write(\", {\");\r\n                            increaseIndent();\r\n                            if (accessors.getAccessor) {\r\n                                writeLine();\r\n                                emitLeadingComments(accessors.getAccessor);\r\n                                write(\"get: \");\r\n                                emitStart(accessors.getAccessor);\r\n                                write(\"function \");\r\n                                emitSignatureAndBody(accessors.getAccessor);\r\n                                emitEnd(accessors.getAccessor);\r\n                                emitTrailingComments(accessors.getAccessor);\r\n                                write(\",\");\r\n                            }\r\n                            if (accessors.setAccessor) {\r\n                                writeLine();\r\n                                emitLeadingComments(accessors.setAccessor);\r\n                                write(\"set: \");\r\n                                emitStart(accessors.setAccessor);\r\n                                write(\"function \");\r\n                                emitSignatureAndBody(accessors.setAccessor);\r\n                                emitEnd(accessors.setAccessor);\r\n                                emitTrailingComments(accessors.setAccessor);\r\n                                write(\",\");\r\n                            }\r\n                            writeLine();\r\n                            write(\"enumerable: true,\");\r\n                            writeLine();\r\n                            write(\"configurable: true\");\r\n                            decreaseIndent();\r\n                            writeLine();\r\n                            write(\"});\");\r\n                            emitEnd(member);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            function emitClassDeclaration(node: ClassDeclaration) {\r\n                emitLeadingComments(node);\r\n                write(\"var \");\r\n                emit(node.name);\r\n                write(\" = (function (\");\r\n                if (node.baseType) {\r\n                    write(\"_super\");\r\n                }\r\n                write(\") {\");\r\n                increaseIndent();\r\n                scopeEmitStart(node);\r\n                if (node.baseType) {\r\n                    writeLine();\r\n                    emitStart(node.baseType);\r\n                    write(\"__extends(\");\r\n                    emit(node.name);\r\n                    write(\", _super);\");\r\n                    emitEnd(node.baseType);\r\n                }\r\n                writeLine();\r\n                emitConstructorOfClass();\r\n                emitMemberFunctions(node);\r\n                emitMemberAssignments(node, NodeFlags.Static);\r\n                writeLine();\r\n                function emitClassReturnStatement() {\r\n                    write(\"return \");\r\n                    emitNode(node.name);\r\n                }\r\n                emitToken(SyntaxKind.CloseBraceToken, node.members.end, emitClassReturnStatement);\r\n                write(\";\");\r\n                decreaseIndent();\r\n                writeLine();\r\n                emitToken(SyntaxKind.CloseBraceToken, node.members.end);\r\n                scopeEmitEnd();\r\n                emitStart(node);\r\n                write(\")(\");\r\n                if (node.baseType) {\r\n                    emit(node.baseType.typeName);\r\n                }\r\n                write(\");\");\r\n                emitEnd(node);\r\n                if (node.flags & NodeFlags.Export) {\r\n                    writeLine();\r\n                    emitStart(node);\r\n                    emitModuleMemberName(node);\r\n                    write(\" = \");\r\n                    emit(node.name);\r\n                    emitEnd(node);\r\n                    write(\";\");\r\n                }\r\n                emitTrailingComments(node);\r\n\r\n                function emitConstructorOfClass() {\r\n                    // Emit the constructor overload pinned comments\r\n                    forEach(node.members, member => {\r\n                        if (member.kind === SyntaxKind.Constructor && !(<ConstructorDeclaration>member).body) {\r\n                            emitPinnedOrTripleSlashComments(member);\r\n                        }\r\n                    });\r\n\r\n                    var ctor = getFirstConstructorWithBody(node);\r\n                    if (ctor) {\r\n                        emitLeadingComments(ctor);\r\n                    }\r\n                    emitStart(<Node>ctor || node);\r\n                    write(\"function \");\r\n                    emit(node.name);\r\n                    emitSignatureParameters(ctor);\r\n                    write(\" {\");\r\n                    scopeEmitStart(node, \"constructor\");\r\n                    increaseIndent();\r\n                    if (ctor) {\r\n                        emitDetachedComments((<Block>ctor.body).statements);\r\n                    }\r\n                    emitCaptureThisForNodeIfNecessary(node);\r\n                    if (ctor) {\r\n                        emitDefaultValueAssignments(ctor);\r\n                        emitRestParameter(ctor);\r\n                        if (node.baseType) {\r\n                            var superCall = findInitialSuperCall(ctor);\r\n                            if (superCall) {\r\n                                writeLine();\r\n                                emit(superCall);\r\n                            }\r\n                        }\r\n                        emitParameterPropertyAssignments(ctor);\r\n                    }\r\n                    else {\r\n                        if (node.baseType) {\r\n                            writeLine();\r\n                            emitStart(node.baseType);\r\n                            write(\"_super.apply(this, arguments);\");\r\n                            emitEnd(node.baseType);\r\n                        }\r\n                    }\r\n                    emitMemberAssignments(node, /*nonstatic*/0);\r\n                    if (ctor) {\r\n                        var statements: Node[] = (<Block>ctor.body).statements;\r\n                        if (superCall) statements = statements.slice(1);\r\n                        emitLines(statements);\r\n                    }\r\n                    writeLine();\r\n                    if (ctor) {\r\n                        emitLeadingCommentsOfPosition((<Block>ctor.body).statements.end);\r\n                    }\r\n                    decreaseIndent();\r\n                    emitToken(SyntaxKind.CloseBraceToken, ctor ? (<Block>ctor.body).statements.end : node.members.end);\r\n                    scopeEmitEnd();\r\n                    emitEnd(<Node>ctor || node);\r\n                    if (ctor) {\r\n                        emitTrailingComments(ctor);\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitInterfaceDeclaration(node: InterfaceDeclaration) {\r\n                emitPinnedOrTripleSlashComments(node);\r\n            }\r\n\r\n            function emitEnumDeclaration(node: EnumDeclaration) {\r\n                emitLeadingComments(node);\r\n                if (!(node.flags & NodeFlags.Export)) {\r\n                    emitStart(node);\r\n                    write(\"var \");\r\n                    emit(node.name);\r\n                    emitEnd(node);\r\n                    write(\";\");\r\n                }\r\n                writeLine();\r\n                emitStart(node);\r\n                write(\"(function (\");\r\n                emitStart(node.name);\r\n                write(resolver.getLocalNameOfContainer(node));\r\n                emitEnd(node.name);\r\n                write(\") {\");\r\n                increaseIndent();\r\n                scopeEmitStart(node);\r\n                emitEnumMemberDeclarations();\r\n                decreaseIndent();\r\n                writeLine();\r\n                emitToken(SyntaxKind.CloseBraceToken, node.members.end);\r\n                scopeEmitEnd();\r\n                write(\")(\");\r\n                emitModuleMemberName(node);\r\n                write(\" || (\");\r\n                emitModuleMemberName(node);\r\n                write(\" = {}));\");\r\n                emitEnd(node);\r\n                if (node.flags & NodeFlags.Export) {\r\n                    writeLine();\r\n                    emitStart(node);\r\n                    write(\"var \");\r\n                    emit(node.name);\r\n                    write(\" = \");\r\n                    emitModuleMemberName(node);\r\n                    emitEnd(node);\r\n                    write(\";\");\r\n                }\r\n                emitTrailingComments(node);\r\n\r\n                function emitEnumMemberDeclarations() {\r\n                    forEach(node.members, member => {\r\n                        writeLine();\r\n                        emitLeadingComments(member);\r\n                        emitStart(member);\r\n                        write(resolver.getLocalNameOfContainer(node));\r\n                        write(\"[\");\r\n                        write(resolver.getLocalNameOfContainer(node));\r\n                        write(\"[\");\r\n                        emitQuotedIdentifier(member.name);\r\n                        write(\"] = \");\r\n                        if (member.initializer) {\r\n                            emit(member.initializer);\r\n                        }\r\n                        else {\r\n                            write(resolver.getEnumMemberValue(member).toString());\r\n                        }\r\n                        write(\"] = \");\r\n                        emitQuotedIdentifier(member.name);\r\n                        emitEnd(member);\r\n                        write(\";\");\r\n                        emitTrailingComments(member);\r\n                    });\r\n                }\r\n            }\r\n\r\n            function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration: ModuleDeclaration): ModuleDeclaration {\r\n                if (moduleDeclaration.body.kind === SyntaxKind.ModuleDeclaration) {\r\n                    var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(<ModuleDeclaration>moduleDeclaration.body);\r\n                    return recursiveInnerModule || <ModuleDeclaration>moduleDeclaration.body;\r\n                }\r\n            }\r\n\r\n            function emitModuleDeclaration(node: ModuleDeclaration) {\r\n                if (!isInstantiated(node)) {\r\n                    return emitPinnedOrTripleSlashComments(node);\r\n                }\r\n\r\n                emitLeadingComments(node);\r\n                if (!(node.flags & NodeFlags.Export)) {\r\n                    emitStart(node);\r\n                    write(\"var \");\r\n                    emit(node.name);\r\n                    write(\";\");\r\n                    emitEnd(node);\r\n                    writeLine();\r\n                }\r\n                emitStart(node);\r\n                write(\"(function (\");\r\n                emitStart(node.name);\r\n                write(resolver.getLocalNameOfContainer(node));\r\n                emitEnd(node.name);\r\n                write(\") \");\r\n                if (node.body.kind === SyntaxKind.ModuleBlock) {\r\n                    emit(node.body);\r\n                }\r\n                else {\r\n                    write(\"{\");\r\n                    increaseIndent();\r\n                    scopeEmitStart(node);\r\n                    emitCaptureThisForNodeIfNecessary(node);\r\n                    writeLine();\r\n                    emit(node.body);\r\n                    decreaseIndent();\r\n                    writeLine();\r\n                    var moduleBlock = <Block>getInnerMostModuleDeclarationFromDottedModule(node).body;\r\n                    emitToken(SyntaxKind.CloseBraceToken, moduleBlock.statements.end);\r\n                    scopeEmitEnd();\r\n                }\r\n                write(\")(\");\r\n                emitModuleMemberName(node);\r\n                write(\" || (\");\r\n                emitModuleMemberName(node);\r\n                write(\" = {}));\");\r\n                emitEnd(node);\r\n                if (node.flags & NodeFlags.Export) {\r\n                    writeLine();\r\n                    emitStart(node);\r\n                    write(\"var \");\r\n                    emit(node.name);\r\n                    write(\" = \");\r\n                    emitModuleMemberName(node);\r\n                    emitEnd(node);\r\n                    write(\";\");\r\n                }\r\n                emitTrailingComments(node);\r\n            }\r\n\r\n            function emitImportDeclaration(node: ImportDeclaration) {\r\n                var emitImportDeclaration = resolver.isReferencedImportDeclaration(node);\r\n\r\n                if (!emitImportDeclaration) {\r\n                    // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when\r\n                    // - current file is not external module\r\n                    // - import declaration is top level and target is value imported by entity name\r\n                    emitImportDeclaration = !isExternalModule(currentSourceFile) && resolver.isTopLevelValueImportedViaEntityName(node);\r\n                }\r\n\r\n                if (emitImportDeclaration) {\r\n                    if (node.externalModuleName && node.parent.kind === SyntaxKind.SourceFile && compilerOptions.module === ModuleKind.AMD) {\r\n                        if (node.flags & NodeFlags.Export) {\r\n                            writeLine();\r\n                            emitLeadingComments(node);\r\n                            emitStart(node);\r\n                            emitModuleMemberName(node);\r\n                            write(\" = \");\r\n                            emit(node.name);\r\n                            write(\";\");\r\n                            emitEnd(node);\r\n                            emitTrailingComments(node);\r\n                        }\r\n                    }\r\n                    else {\r\n                        writeLine();\r\n                        emitLeadingComments(node);\r\n                        emitStart(node);\r\n                        if (!(node.flags & NodeFlags.Export)) write(\"var \");\r\n                        emitModuleMemberName(node);\r\n                        write(\" = \");\r\n                        if (node.entityName) {\r\n                            emit(node.entityName);\r\n                        }\r\n                        else {\r\n                            write(\"require(\");\r\n                            emitStart(node.externalModuleName);\r\n                            emitLiteral(node.externalModuleName);\r\n                            emitEnd(node.externalModuleName);\r\n                            emitToken(SyntaxKind.CloseParenToken, node.externalModuleName.end);\r\n                        }\r\n                        write(\";\");\r\n                        emitEnd(node);\r\n                        emitTrailingComments(node);\r\n                    }\r\n                }\r\n            }\r\n\r\n            function getExternalImportDeclarations(node: SourceFile): ImportDeclaration[] {\r\n                var result: ImportDeclaration[] = [];\r\n                forEach(node.statements, stat => {\r\n                    if (stat.kind === SyntaxKind.ImportDeclaration && (<ImportDeclaration>stat).externalModuleName && resolver.isReferencedImportDeclaration(stat)) {\r\n                        result.push(<ImportDeclaration>stat);\r\n                    }\r\n                });\r\n                return result;\r\n            }\r\n\r\n            function getFirstExportAssignment(sourceFile: SourceFile) {\r\n                return forEach(sourceFile.statements, node => {\r\n                    if (node.kind === SyntaxKind.ExportAssignment) {\r\n                        return <ExportAssignment>node;\r\n                    }\r\n                });\r\n            }\r\n\r\n            function emitAMDModule(node: SourceFile, startIndex: number) {\r\n                var imports = getExternalImportDeclarations(node);\r\n                writeLine();\r\n                write(\"define([\\\"require\\\", \\\"exports\\\"\");\r\n                forEach(imports, imp => {\r\n                    write(\", \");\r\n                    emitLiteral(imp.externalModuleName);\r\n                });\r\n                forEach(node.amdDependencies, amdDependency => {\r\n                    var text = \"\\\"\" + amdDependency + \"\\\"\";\r\n                    write(\", \");\r\n                    write(text);\r\n                });\r\n                write(\"], function (require, exports\");\r\n                forEach(imports, imp => {\r\n                    write(\", \");\r\n                    emit(imp.name);\r\n                });\r\n                write(\") {\");\r\n                increaseIndent();\r\n                emitCaptureThisForNodeIfNecessary(node);\r\n                emitLinesStartingAt(node.statements, startIndex);\r\n                var exportName = resolver.getExportAssignmentName(node);\r\n                if (exportName) {\r\n                    writeLine();\r\n                    var exportAssignement = getFirstExportAssignment(node);\r\n                    emitStart(exportAssignement);\r\n                    write(\"return \");\r\n                    emitStart(exportAssignement.exportName);\r\n                    write(exportName);\r\n                    emitEnd(exportAssignement.exportName);\r\n                    write(\";\");\r\n                    emitEnd(exportAssignement);\r\n                }\r\n                decreaseIndent();\r\n                writeLine();\r\n                write(\"});\");\r\n            }\r\n\r\n            function emitCommonJSModule(node: SourceFile, startIndex: number) {\r\n                emitCaptureThisForNodeIfNecessary(node);\r\n                emitLinesStartingAt(node.statements, startIndex);\r\n                var exportName = resolver.getExportAssignmentName(node);\r\n                if (exportName) {\r\n                    writeLine();\r\n                    var exportAssignement = getFirstExportAssignment(node);\r\n                    emitStart(exportAssignement);\r\n                    write(\"module.exports = \");\r\n                    emitStart(exportAssignement.exportName);\r\n                    write(exportName);\r\n                    emitEnd(exportAssignement.exportName);\r\n                    write(\";\");\r\n                    emitEnd(exportAssignement);\r\n                }\r\n            }\r\n\r\n            function emitDirectivePrologues(statements: Statement[], startWithNewLine: boolean): number {\r\n                for (var i = 0; i < statements.length; ++i) {\r\n                    if (isPrologueDirective(statements[i])) {\r\n                        if (startWithNewLine || i > 0) {\r\n                            writeLine();\r\n                        }\r\n                        emit(statements[i]);\r\n                    }\r\n                    else {\r\n                        // return index of the first non prologue directive\r\n                        return i;\r\n                    }\r\n                }\r\n                return statements.length;\r\n            }\r\n\r\n            function emitSourceFile(node: SourceFile) {\r\n                currentSourceFile = node;\r\n                // Start new file on new line\r\n                writeLine();\r\n                emitDetachedComments(node);\r\n                // emit prologue directives prior to __extends\r\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ false);\r\n                if (!extendsEmitted && resolver.getNodeCheckFlags(node) & NodeCheckFlags.EmitExtends) {\r\n                    writeLine();\r\n                    write(\"var __extends = this.__extends || function (d, b) {\");\r\n                    increaseIndent();\r\n                    writeLine();\r\n                    write(\"for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\");\r\n                    writeLine();\r\n                    write(\"function __() { this.constructor = d; }\");\r\n                    writeLine();\r\n                    write(\"__.prototype = b.prototype;\");\r\n                    writeLine();\r\n                    write(\"d.prototype = new __();\");\r\n                    decreaseIndent();\r\n                    writeLine();\r\n                    write(\"};\");\r\n                    extendsEmitted = true;\r\n                }\r\n                if (isExternalModule(node)) {\r\n                    if (compilerOptions.module === ModuleKind.AMD) {\r\n                        emitAMDModule(node, startIndex);\r\n                    }\r\n                    else {\r\n                        emitCommonJSModule(node, startIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    emitCaptureThisForNodeIfNecessary(node);\r\n                    emitLinesStartingAt(node.statements, startIndex);\r\n                }\r\n            }\r\n\r\n            function emitNode(node: Node) {\r\n                if (!node) {\r\n                    return;\r\n                }\r\n\r\n                if (node.flags & NodeFlags.Ambient) {\r\n                    return emitPinnedOrTripleSlashComments(node);\r\n                }\r\n\r\n                switch (node.kind) {\r\n                    case SyntaxKind.Identifier:\r\n                        return emitIdentifier(<Identifier>node);\r\n                    case SyntaxKind.Parameter:\r\n                        return emitParameter(<ParameterDeclaration>node);\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                        return emitAccessor(<AccessorDeclaration>node);\r\n                    case SyntaxKind.ThisKeyword:\r\n                        return emitThis(node);\r\n                    case SyntaxKind.SuperKeyword:\r\n                        return emitSuper(node);\r\n                    case SyntaxKind.NullKeyword:\r\n                        return write(\"null\");\r\n                    case SyntaxKind.TrueKeyword:\r\n                        return write(\"true\");\r\n                    case SyntaxKind.FalseKeyword:\r\n                        return write(\"false\");\r\n                    case SyntaxKind.NumericLiteral:\r\n                    case SyntaxKind.StringLiteral:\r\n                    case SyntaxKind.RegularExpressionLiteral:\r\n                        return emitLiteral(<LiteralExpression>node);\r\n                    case SyntaxKind.QualifiedName:\r\n                        return emitPropertyAccess(<QualifiedName>node);\r\n                    case SyntaxKind.ArrayLiteral:\r\n                        return emitArrayLiteral(<ArrayLiteral>node);\r\n                    case SyntaxKind.ObjectLiteral:\r\n                        return emitObjectLiteral(<ObjectLiteral>node);\r\n                    case SyntaxKind.PropertyAssignment:\r\n                        return emitPropertyAssignment(<PropertyDeclaration>node);\r\n                    case SyntaxKind.PropertyAccess:\r\n                        return emitPropertyAccess(<PropertyAccess>node);\r\n                    case SyntaxKind.IndexedAccess:\r\n                        return emitIndexedAccess(<IndexedAccess>node);\r\n                    case SyntaxKind.CallExpression:\r\n                        return emitCallExpression(<CallExpression>node);\r\n                    case SyntaxKind.NewExpression:\r\n                        return emitNewExpression(<NewExpression>node);\r\n                    case SyntaxKind.TypeAssertion:\r\n                        return emit((<TypeAssertion>node).operand);\r\n                    case SyntaxKind.ParenExpression:\r\n                        return emitParenExpression(<ParenExpression>node);\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.ArrowFunction:\r\n                        return emitFunctionDeclaration(<FunctionDeclaration>node);\r\n                    case SyntaxKind.PrefixOperator:\r\n                    case SyntaxKind.PostfixOperator:\r\n                        return emitUnaryExpression(<UnaryExpression>node);\r\n                    case SyntaxKind.BinaryExpression:\r\n                        return emitBinaryExpression(<BinaryExpression>node);\r\n                    case SyntaxKind.ConditionalExpression:\r\n                        return emitConditionalExpression(<ConditionalExpression>node);\r\n                    case SyntaxKind.OmittedExpression:\r\n                        return;\r\n                    case SyntaxKind.Block:\r\n                    case SyntaxKind.TryBlock:\r\n                    case SyntaxKind.FinallyBlock:\r\n                    case SyntaxKind.FunctionBlock:\r\n                    case SyntaxKind.ModuleBlock:\r\n                        return emitBlock(<Block>node);\r\n                    case SyntaxKind.VariableStatement:\r\n                        return emitVariableStatement(<VariableStatement>node);\r\n                    case SyntaxKind.EmptyStatement:\r\n                        return write(\";\");\r\n                    case SyntaxKind.ExpressionStatement:\r\n                        return emitExpressionStatement(<ExpressionStatement>node);\r\n                    case SyntaxKind.IfStatement:\r\n                        return emitIfStatement(<IfStatement>node);\r\n                    case SyntaxKind.DoStatement:\r\n                        return emitDoStatement(<DoStatement>node);\r\n                    case SyntaxKind.WhileStatement:\r\n                        return emitWhileStatement(<WhileStatement>node);\r\n                    case SyntaxKind.ForStatement:\r\n                        return emitForStatement(<ForStatement>node);\r\n                    case SyntaxKind.ForInStatement:\r\n                        return emitForInStatement(<ForInStatement>node);\r\n                    case SyntaxKind.ContinueStatement:\r\n                    case SyntaxKind.BreakStatement:\r\n                        return emitBreakOrContinueStatement(<BreakOrContinueStatement>node);\r\n                    case SyntaxKind.ReturnStatement:\r\n                        return emitReturnStatement(<ReturnStatement>node);\r\n                    case SyntaxKind.WithStatement:\r\n                        return emitWithStatement(<WithStatement>node);\r\n                    case SyntaxKind.SwitchStatement:\r\n                        return emitSwitchStatement(<SwitchStatement>node);\r\n                    case SyntaxKind.CaseClause:\r\n                    case SyntaxKind.DefaultClause:\r\n                        return emitCaseOrDefaultClause(<CaseOrDefaultClause>node);\r\n                    case SyntaxKind.LabelledStatement:\r\n                        return emitLabelledStatement(<LabelledStatement>node);\r\n                    case SyntaxKind.ThrowStatement:\r\n                        return emitThrowStatement(<ThrowStatement>node);\r\n                    case SyntaxKind.TryStatement:\r\n                        return emitTryStatement(<TryStatement>node);\r\n                    case SyntaxKind.CatchBlock:\r\n                        return emitCatchBlock(<CatchBlock>node);\r\n                    case SyntaxKind.DebuggerStatement:\r\n                        return emitDebuggerStatement(node);\r\n                    case SyntaxKind.VariableDeclaration:\r\n                        return emitVariableDeclaration(<VariableDeclaration>node);\r\n                    case SyntaxKind.ClassDeclaration:\r\n                        return emitClassDeclaration(<ClassDeclaration>node);\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                        return emitInterfaceDeclaration(<InterfaceDeclaration>node);\r\n                    case SyntaxKind.EnumDeclaration:\r\n                        return emitEnumDeclaration(<EnumDeclaration>node);\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                        return emitModuleDeclaration(<ModuleDeclaration>node);\r\n                    case SyntaxKind.ImportDeclaration:\r\n                        return emitImportDeclaration(<ImportDeclaration>node);\r\n                    case SyntaxKind.SourceFile:\r\n                        return emitSourceFile(<SourceFile>node);\r\n                }\r\n            }\r\n\r\n            function hasDetachedComments(pos: number) {\r\n                return detachedCommentsInfo !== undefined && detachedCommentsInfo[detachedCommentsInfo.length - 1].nodePos === pos;\r\n            }\r\n\r\n            function getLeadingCommentsWithoutDetachedComments() {\r\n                // get the leading comments from detachedPos\r\n                var leadingComments = getLeadingComments(currentSourceFile.text, detachedCommentsInfo[detachedCommentsInfo.length - 1].detachedCommentEndPos);\r\n                if (detachedCommentsInfo.length - 1) {\r\n                    detachedCommentsInfo.pop();\r\n                }\r\n                else {\r\n                    detachedCommentsInfo = undefined;\r\n                }\r\n\r\n                return leadingComments;\r\n            }\r\n\r\n            function getLeadingCommentsToEmit(node: Node) {\r\n                // Emit the leading comments only if the parent's pos doesnt match because parent should take care of emitting these comments\r\n                if (node.parent.kind === SyntaxKind.SourceFile || node.pos !== node.parent.pos) {\r\n                    var leadingComments: Comment[];\r\n                    if (hasDetachedComments(node.pos)) {\r\n                        // get comments without detached comments\r\n                        leadingComments = getLeadingCommentsWithoutDetachedComments();\r\n                    }\r\n                    else {\r\n                        // get the leading comments from the node\r\n                        leadingComments = getLeadingCommentsOfNode(node, currentSourceFile);\r\n                    }\r\n                    return leadingComments;\r\n                }\r\n            }\r\n\r\n            function emitLeadingDeclarationComments(node: Node) {\r\n                var leadingComments = getLeadingCommentsToEmit(node);\r\n                emitNewLineBeforeLeadingComments(node, leadingComments, writer);\r\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\r\n                emitComments(leadingComments, /*trailingSeparator*/ true, writer, writeComment);\r\n            }\r\n\r\n            function emitTrailingDeclarationComments(node: Node) {\r\n                // Emit the trailing comments only if the parent's end doesnt match\r\n                if (node.parent.kind === SyntaxKind.SourceFile || node.end !== node.parent.end) {\r\n                    var trailingComments = getTrailingComments(currentSourceFile.text, node.end);\r\n                    // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/\r\n                    emitComments(trailingComments, /*trailingSeparator*/ false, writer, writeComment);\r\n                }\r\n            }\r\n\r\n            function emitLeadingCommentsOfLocalPosition(pos: number) {\r\n                var leadingComments: Comment[];\r\n                if (hasDetachedComments(pos)) {\r\n                    // get comments without detached comments\r\n                    leadingComments = getLeadingCommentsWithoutDetachedComments();\r\n                }\r\n                else {\r\n                    // get the leading comments from the node\r\n                    leadingComments = getLeadingComments(currentSourceFile.text, pos);\r\n                }\r\n                emitNewLineBeforeLeadingComments({ pos: pos, end: pos }, leadingComments, writer);\r\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\r\n                emitComments(leadingComments, /*trailingSeparator*/ true, writer, writeComment);\r\n            }\r\n\r\n            function emitDetachedCommentsAtPosition(node: TextRange) {\r\n                var leadingComments = getLeadingComments(currentSourceFile.text, node.pos);\r\n                if (leadingComments) {\r\n                    var detachedComments: Comment[] = [];\r\n                    var lastComment: Comment;\r\n\r\n                    forEach(leadingComments, comment => {\r\n                        if (lastComment) {\r\n                            var lastCommentLine = getLineOfLocalPosition(lastComment.end);\r\n                            var commentLine = getLineOfLocalPosition(comment.pos);\r\n\r\n                            if (commentLine >= lastCommentLine + 2) {\r\n                                // There was a blank line between the last comment and this comment.  This\r\n                                // comment is not part of the copyright comments.  Return what we have so \r\n                                // far.\r\n                                return detachedComments;\r\n                            }\r\n                        }\r\n\r\n                        detachedComments.push(comment);\r\n                        lastComment = comment;\r\n                    });\r\n\r\n                    if (detachedComments.length) {\r\n                        // All comments look like they could have been part of the copyright header.  Make\r\n                        // sure there is at least one blank line between it and the node.  If not, it's not\r\n                        // a copyright header.\r\n                        var lastCommentLine = getLineOfLocalPosition(detachedComments[detachedComments.length - 1].end);\r\n                        var astLine = getLineOfLocalPosition(skipTrivia(currentSourceFile.text, node.pos));\r\n                        if (astLine >= lastCommentLine + 2) {\r\n                            // Valid detachedComments\r\n                            emitNewLineBeforeLeadingComments(node, leadingComments, writer);\r\n                            emitComments(detachedComments, /*trailingSeparator*/ true, writer, writeComment);\r\n                            var currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: detachedComments[detachedComments.length - 1].end };\r\n                            if (detachedCommentsInfo) {\r\n                                detachedCommentsInfo.push(currentDetachedCommentInfo);\r\n                            }\r\n                            else {\r\n                                detachedCommentsInfo = [currentDetachedCommentInfo];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitPinnedOrTripleSlashCommentsOfNode(node: Node) {\r\n                var pinnedComments = ts.filter(getLeadingCommentsToEmit(node), isPinnedOrTripleSlashComment);\r\n\r\n                function isPinnedOrTripleSlashComment(comment: Comment) {\r\n                    if (currentSourceFile.text.charCodeAt(comment.pos + 1) === CharacterCodes.asterisk) {\r\n                        return currentSourceFile.text.charCodeAt(comment.pos + 2) === CharacterCodes.exclamation;\r\n                    }\r\n                    // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text \r\n                    // so that we dont end up computing comment string and doing match for all // comments\r\n                    else if (currentSourceFile.text.charCodeAt(comment.pos + 1) === CharacterCodes.slash &&\r\n                        comment.pos + 2 < comment.end &&\r\n                        currentSourceFile.text.charCodeAt(comment.pos + 2) === CharacterCodes.slash &&\r\n                        currentSourceFile.text.substring(comment.pos, comment.end).match(fullTripleSlashReferencePathRegEx)) {\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                emitNewLineBeforeLeadingComments(node, pinnedComments, writer);\r\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\r\n                emitComments(pinnedComments, /*trailingSeparator*/ true, writer, writeComment);\r\n            }\r\n\r\n            if (compilerOptions.sourceMap) {\r\n                initializeEmitterWithSourceMaps();\r\n            }\r\n\r\n            if (root) {\r\n                emit(root);\r\n            }\r\n            else {\r\n                forEach(program.getSourceFiles(), sourceFile => {\r\n                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {\r\n                        emit(sourceFile);\r\n                    }\r\n                });\r\n            }\r\n\r\n            writeLine();\r\n            writeEmittedFiles(writer.getText(), /*writeByteOrderMark*/ compilerOptions.emitBOM);\r\n        }\r\n\r\n        function emitDeclarations(jsFilePath: string, root?: SourceFile) {\r\n            var writer = createTextWriter(writeSymbol);\r\n            var write = writer.write;\r\n            var writeLine = writer.writeLine;\r\n            var increaseIndent = writer.increaseIndent;\r\n            var decreaseIndent = writer.decreaseIndent;\r\n\r\n            var enclosingDeclaration: Node;\r\n            var reportedDeclarationError = false;\r\n\r\n            var emitJsDocComments = compilerOptions.removeComments ? function (declaration: Declaration) { } : writeJsDocComments;\r\n\r\n            var aliasDeclarationEmitInfo: {\r\n                declaration: ImportDeclaration;\r\n                outputPos: number;\r\n                indent: number;\r\n                asynchronousOutput?: string; // If the output for alias was written asynchronously, the corresponding output\r\n            }[] = [];\r\n\r\n            var getSymbolVisibilityDiagnosticMessage: (symbolAccesibilityResult: SymbolAccessiblityResult) => {\r\n                errorNode: Node;\r\n                diagnosticMessage: DiagnosticMessage;\r\n                typeName?: Identifier\r\n            }\r\n\r\n            function writeAsychronousImportDeclarations(importDeclarations: ImportDeclaration[]) {\r\n                var oldWriter = writer;\r\n                forEach(importDeclarations, aliasToWrite => {\r\n                    var aliasEmitInfo = forEach(aliasDeclarationEmitInfo, declEmitInfo => declEmitInfo.declaration === aliasToWrite ? declEmitInfo : undefined);\r\n                    writer = createTextWriter(writeSymbol);\r\n                    for (var declarationIndent = aliasEmitInfo.indent; declarationIndent; declarationIndent--) {\r\n                        writer.increaseIndent();\r\n                    }\r\n\r\n                    writeImportDeclaration(aliasToWrite);\r\n                    aliasEmitInfo.asynchronousOutput = writer.getText();\r\n                });\r\n                writer = oldWriter;\r\n            }\r\n\r\n            function writeSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags) {\r\n                var symbolAccesibilityResult = resolver.isSymbolAccessible(symbol, enclosingDeclaration, meaning);\r\n                if (symbolAccesibilityResult.accessibility === SymbolAccessibility.Accessible) {\r\n                    resolver.writeSymbol(symbol, enclosingDeclaration, meaning, writer);\r\n\r\n                    // write the aliases\r\n                    if (symbolAccesibilityResult && symbolAccesibilityResult.aliasesToMakeVisible) {\r\n                        writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);\r\n                    }\r\n                }\r\n                else {\r\n                    // Report error\r\n                    reportedDeclarationError = true;\r\n                    var errorInfo = getSymbolVisibilityDiagnosticMessage(symbolAccesibilityResult);\r\n                    if (errorInfo) {\r\n                        if (errorInfo.typeName) {\r\n                            diagnostics.push(createDiagnosticForNode(errorInfo.errorNode,\r\n                                errorInfo.diagnosticMessage,\r\n                                getSourceTextOfLocalNode(errorInfo.typeName),\r\n                                symbolAccesibilityResult.errorSymbolName,\r\n                                symbolAccesibilityResult.errorModuleName));\r\n                        }\r\n                        else {\r\n                            diagnostics.push(createDiagnosticForNode(errorInfo.errorNode,\r\n                                errorInfo.diagnosticMessage,\r\n                                symbolAccesibilityResult.errorSymbolName,\r\n                                symbolAccesibilityResult.errorModuleName));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitLines(nodes: Node[]) {\r\n                for (var i = 0, n = nodes.length; i < n; i++) {\r\n                    emitNode(nodes[i]);\r\n                }\r\n            }\r\n\r\n            function emitCommaList(nodes: Node[], eachNodeEmitFn: (node: Node) => void) {\r\n                var currentWriterPos = writer.getTextPos();\r\n                for (var i = 0, n = nodes.length; i < n; i++) {\r\n                    if (currentWriterPos !== writer.getTextPos()) {\r\n                        write(\", \");\r\n                    }\r\n                    currentWriterPos = writer.getTextPos();\r\n                    eachNodeEmitFn(nodes[i]);\r\n                }\r\n            }\r\n\r\n            function writeJsDocComments(declaration: Declaration) {\r\n                if (declaration) {\r\n                    var jsDocComments = getJsDocComments(declaration, currentSourceFile);\r\n                    emitNewLineBeforeLeadingComments(declaration, jsDocComments, writer);\r\n                    // jsDoc comments are emitted at /*leading comment1 */space/*leading comment*/space\r\n                    emitComments(jsDocComments, /*trailingSeparator*/ true, writer, writeCommentRange);\r\n                }\r\n            }\r\n\r\n            function emitSourceTextOfNode(node: Node) {\r\n                write(getSourceTextOfLocalNode(node));\r\n            }\r\n\r\n            function emitSourceFile(node: SourceFile) {\r\n                currentSourceFile = node;\r\n                enclosingDeclaration = node;\r\n                emitLines(node.statements);\r\n            }\r\n\r\n            function emitExportAssignment(node: ExportAssignment) {\r\n                write(\"export = \");\r\n                emitSourceTextOfNode(node.exportName);\r\n                write(\";\");\r\n                writeLine();\r\n            }\r\n\r\n            function emitDeclarationFlags(node: Declaration) {\r\n                if (node.flags & NodeFlags.Static) {\r\n                    if (node.flags & NodeFlags.Private) {\r\n                        write(\"private \");\r\n                    }\r\n                    write(\"static \");\r\n                }\r\n                else {\r\n                    if (node.flags & NodeFlags.Private) {\r\n                        write(\"private \");\r\n                    }\r\n                    // If the node is parented in the current source file we need to emit export declare or just export\r\n                    else if (node.parent === currentSourceFile) {\r\n                        // If the node is exported \r\n                        if (node.flags & NodeFlags.Export) {\r\n                            write(\"export \");\r\n                        }\r\n\r\n                        if (node.kind !== SyntaxKind.InterfaceDeclaration) {\r\n                            write(\"declare \");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitImportDeclaration(node: ImportDeclaration) {\r\n                var nodeEmitInfo = {\r\n                    declaration: node,\r\n                    outputPos: writer.getTextPos(),\r\n                    indent: writer.getIndent(),\r\n                    hasWritten: resolver.isDeclarationVisible(node)\r\n                };\r\n                aliasDeclarationEmitInfo.push(nodeEmitInfo);\r\n                if (nodeEmitInfo.hasWritten) {\r\n                    writeImportDeclaration(node);\r\n                }\r\n            }\r\n\r\n            function writeImportDeclaration(node: ImportDeclaration) {\r\n                // note usage of writer. methods instead of aliases created, just to make sure we are using \r\n                // correct writer especially to handle asynchronous alias writing\r\n                emitJsDocComments(node);\r\n                if (node.flags & NodeFlags.Export) {\r\n                    writer.write(\"export \");\r\n                }\r\n                writer.write(\"import \");\r\n                writer.write(getSourceTextOfLocalNode(node.name));\r\n                writer.write(\" = \");\r\n                if (node.entityName) {\r\n                    checkEntityNameAccessible();\r\n                    writer.write(getSourceTextOfLocalNode(node.entityName));\r\n                    writer.write(\";\");\r\n                }\r\n                else {\r\n                    writer.write(\"require(\");\r\n                    writer.write(getSourceTextOfLocalNode(node.externalModuleName));\r\n                    writer.write(\");\");\r\n                }\r\n                writer.writeLine();\r\n\r\n                function checkEntityNameAccessible() {\r\n                    var symbolAccesibilityResult = resolver.isImportDeclarationEntityNameReferenceDeclarationVisibile(node.entityName);\r\n                    if (symbolAccesibilityResult.accessibility === SymbolAccessibility.Accessible) {\r\n                        // write the aliases\r\n                        if (symbolAccesibilityResult.aliasesToMakeVisible) {\r\n                            writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Report error\r\n                        reportedDeclarationError = true;\r\n                        diagnostics.push(createDiagnosticForNode(node,\r\n                            Diagnostics.Import_declaration_0_is_using_private_name_1,\r\n                            getSourceTextOfLocalNode(node.name),\r\n                            symbolAccesibilityResult.errorSymbolName));\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitModuleDeclaration(node: ModuleDeclaration) {\r\n                if (resolver.isDeclarationVisible(node)) {\r\n                    emitJsDocComments(node);\r\n                    emitDeclarationFlags(node);\r\n                    write(\"module \");\r\n                    emitSourceTextOfNode(node.name);\r\n                    while (node.body.kind !== SyntaxKind.ModuleBlock) {\r\n                        node = <ModuleDeclaration>node.body;\r\n                        write(\".\");\r\n                        emitSourceTextOfNode(node.name);\r\n                    }\r\n                    var prevEnclosingDeclaration = enclosingDeclaration;\r\n                    enclosingDeclaration = node;\r\n                    write(\" {\");\r\n                    writeLine();\r\n                    increaseIndent();\r\n                    emitLines((<Block>node.body).statements);\r\n                    decreaseIndent();\r\n                    write(\"}\");\r\n                    writeLine();\r\n                    enclosingDeclaration = prevEnclosingDeclaration;\r\n                }\r\n            }\r\n\r\n            function emitEnumDeclaration(node: EnumDeclaration) {\r\n                if (resolver.isDeclarationVisible(node)) {\r\n                    emitJsDocComments(node);\r\n                    emitDeclarationFlags(node);\r\n                    write(\"enum \");\r\n                    emitSourceTextOfNode(node.name);\r\n                    write(\" {\");\r\n                    writeLine();\r\n                    increaseIndent();\r\n                    emitLines(node.members);\r\n                    decreaseIndent();\r\n                    write(\"}\");\r\n                    writeLine();\r\n                }\r\n            }\r\n\r\n            function emitEnumMemberDeclaration(node: EnumMember) {\r\n                emitJsDocComments(node);\r\n                emitSourceTextOfNode(node.name);\r\n                var enumMemberValue = resolver.getEnumMemberValue(node);\r\n                if (enumMemberValue !== undefined) {\r\n                    write(\" = \");\r\n                    write(enumMemberValue.toString());\r\n                }\r\n                write(\",\");\r\n                writeLine();\r\n            }\r\n\r\n            function emitTypeParameters(typeParameters: TypeParameterDeclaration[]) {\r\n                function emitTypeParameter(node: TypeParameterDeclaration) {\r\n                    function getTypeParameterConstraintVisibilityError(symbolAccesibilityResult: SymbolAccessiblityResult) {\r\n                        // Type parameter constraints are named by user so we should always be able to name it\r\n                        var diagnosticMessage: DiagnosticMessage;\r\n                        switch (node.parent.kind) {\r\n                            case SyntaxKind.ClassDeclaration:\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_private_name_1;\r\n                                break;\r\n\r\n                            case SyntaxKind.InterfaceDeclaration:\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1;\r\n                                break;\r\n\r\n                            case SyntaxKind.ConstructSignature:\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;\r\n                                break;\r\n\r\n                            case SyntaxKind.CallSignature:\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;\r\n                                break;\r\n\r\n                            case SyntaxKind.Method:\r\n                                if (node.parent.flags & NodeFlags.Static) {\r\n                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                    Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                                    Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;\r\n                                }\r\n                                else if (node.parent.parent.kind === SyntaxKind.ClassDeclaration) {\r\n                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                    Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                                    Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;\r\n                                }\r\n                                else {\r\n                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                    Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :\r\n                                    Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;\r\n                                }\r\n                                break;\r\n\r\n                            case SyntaxKind.FunctionDeclaration:\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_private_name_1;\r\n                                break;\r\n\r\n                            default:\r\n                                Debug.fail(\"This is unknown parent for type parameter: \" + SyntaxKind[node.parent.kind]);\r\n                        }\r\n\r\n                        return {\r\n                            diagnosticMessage: diagnosticMessage,\r\n                            errorNode: node,\r\n                            typeName: node.name\r\n                        };\r\n                    }\r\n\r\n                    increaseIndent();\r\n                    emitJsDocComments(node);\r\n                    decreaseIndent();\r\n                    emitSourceTextOfNode(node.name);\r\n                    // If there is constraint present and this is not a type parameter of the private method emit the constraint\r\n                    if (node.constraint && (node.parent.kind !== SyntaxKind.Method || !(node.parent.flags & NodeFlags.Private))) {\r\n                        write(\" extends \");\r\n                        getSymbolVisibilityDiagnosticMessage = getTypeParameterConstraintVisibilityError;\r\n                        resolver.writeTypeAtLocation(node.constraint, enclosingDeclaration, TypeFormatFlags.UseTypeOfFunction, writer);\r\n                    }\r\n                }\r\n\r\n                if (typeParameters) {\r\n                    write(\"<\");\r\n                    emitCommaList(typeParameters, emitTypeParameter);\r\n                    write(\">\");\r\n                }\r\n            }\r\n\r\n            function emitHeritageClause(typeReferences: TypeReferenceNode[], isImplementsList: boolean) {\r\n                if (typeReferences) {\r\n                    write(isImplementsList ? \" implements \" : \" extends \");\r\n                    emitCommaList(typeReferences, emitTypeOfTypeReference);\r\n                }\r\n\r\n                function emitTypeOfTypeReference(node: Node) {\r\n                    getSymbolVisibilityDiagnosticMessage = getHeritageClauseVisibilityError;\r\n                    resolver.writeTypeAtLocation(node, enclosingDeclaration, TypeFormatFlags.WriteArrayAsGenericType | TypeFormatFlags.UseTypeOfFunction, writer);\r\n\r\n                    function getHeritageClauseVisibilityError(symbolAccesibilityResult: SymbolAccessiblityResult) {\r\n                        var diagnosticMessage: DiagnosticMessage;\r\n                        // Heritage clause is written by user so it can always be named\r\n                        if (node.parent.kind === SyntaxKind.ClassDeclaration) {\r\n                            // Class\r\n                            if (symbolAccesibilityResult.errorModuleName) {\r\n                                // Module is inaccessible\r\n                                diagnosticMessage = isImplementsList ?\r\n                                Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2;\r\n                            }\r\n                            else {\r\n                                // Class or Interface implemented/extended is inaccessible\r\n                                diagnosticMessage = isImplementsList ?\r\n                                Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_private_name_1 :\r\n                                Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_private_name_1;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (symbolAccesibilityResult.errorModuleName) {\r\n                                // Module is inaccessible\r\n                                diagnosticMessage = Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_name_1_from_private_module_2;\r\n                            }\r\n                            else {\r\n                                // interface is inaccessible\r\n                                diagnosticMessage = Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1;\r\n                            }\r\n                        }\r\n\r\n                        return {\r\n                            diagnosticMessage: diagnosticMessage,\r\n                            errorNode: node,\r\n                            typeName: (<Declaration>node.parent).name\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitClassDeclaration(node: ClassDeclaration) {\r\n                function emitParameterProperties(constructorDeclaration: ConstructorDeclaration) {\r\n                    if (constructorDeclaration) {\r\n                        forEach(constructorDeclaration.parameters, param => {\r\n                            if (param.flags & (NodeFlags.Public | NodeFlags.Private)) {\r\n                                emitPropertyDeclaration(param);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (resolver.isDeclarationVisible(node)) {\r\n                    emitJsDocComments(node);\r\n                    emitDeclarationFlags(node);\r\n                    write(\"class \");\r\n                    emitSourceTextOfNode(node.name);\r\n                    var prevEnclosingDeclaration = enclosingDeclaration;\r\n                    enclosingDeclaration = node;\r\n                    emitTypeParameters(node.typeParameters);\r\n                    if (node.baseType) {\r\n                        emitHeritageClause([node.baseType], /*isImplementsList*/ false);\r\n                    }\r\n                    emitHeritageClause(node.implementedTypes, /*isImplementsList*/ true);\r\n                    write(\" {\");\r\n                    writeLine();\r\n                    increaseIndent();\r\n                    emitParameterProperties(getFirstConstructorWithBody(node));\r\n                    emitLines(node.members);\r\n                    decreaseIndent();\r\n                    write(\"}\");\r\n                    writeLine();\r\n                    enclosingDeclaration = prevEnclosingDeclaration;\r\n                }\r\n            }\r\n\r\n            function emitInterfaceDeclaration(node: InterfaceDeclaration) {\r\n                if (resolver.isDeclarationVisible(node)) {\r\n                    emitJsDocComments(node);\r\n                    emitDeclarationFlags(node);\r\n                    write(\"interface \");\r\n                    emitSourceTextOfNode(node.name);\r\n                    var prevEnclosingDeclaration = enclosingDeclaration;\r\n                    enclosingDeclaration = node;\r\n                    emitTypeParameters(node.typeParameters);\r\n                    emitHeritageClause(node.baseTypes, /*isImplementsList*/ false);\r\n                    write(\" {\");\r\n                    writeLine();\r\n                    increaseIndent();\r\n                    emitLines(node.members);\r\n                    decreaseIndent();\r\n                    write(\"}\");\r\n                    writeLine();\r\n                    enclosingDeclaration = prevEnclosingDeclaration;\r\n                }\r\n            }\r\n\r\n            function emitPropertyDeclaration(node: PropertyDeclaration) {\r\n                emitJsDocComments(node);\r\n                emitDeclarationFlags(node);\r\n                emitVariableDeclaration(node);\r\n                write(\";\");\r\n                writeLine();\r\n            }\r\n\r\n            function emitVariableDeclaration(node: VariableDeclaration) {\r\n                // If we are emitting property it isnt moduleElement and hence we already know it needs to be emitted\r\n                // so there is no check needed to see if declaration is visible\r\n                if (node.kind !== SyntaxKind.VariableDeclaration || resolver.isDeclarationVisible(node)) {\r\n                    emitSourceTextOfNode(node.name);\r\n                    // If optional property emit ?\r\n                    if (node.kind === SyntaxKind.Property && (node.flags & NodeFlags.QuestionMark)) {\r\n                        write(\"?\");\r\n                    }\r\n                    if (!(node.flags & NodeFlags.Private)) {\r\n                        write(\": \");\r\n                        getSymbolVisibilityDiagnosticMessage = getVariableDeclarationTypeVisibilityError;\r\n                        resolver.writeTypeAtLocation(node, enclosingDeclaration, TypeFormatFlags.UseTypeOfFunction, writer);\r\n                    }\r\n                }\r\n\r\n                function getVariableDeclarationTypeVisibilityError(symbolAccesibilityResult: SymbolAccessiblityResult) {\r\n                    var diagnosticMessage: DiagnosticMessage;\r\n                    if (node.kind === SyntaxKind.VariableDeclaration) {\r\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                        symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                        Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :\r\n                        Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_private_module_2 :\r\n                        Diagnostics.Exported_variable_0_has_or_is_using_private_name_1;\r\n                    }\r\n                    // This check is to ensure we dont report error on constructor parameter property as that error would be reported during parameter emit\r\n                    else if (node.kind === SyntaxKind.Property) {\r\n                        if (node.flags & NodeFlags.Static) {\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                            Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :\r\n                            Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_private_name_1;\r\n                        }\r\n                        else if (node.parent.kind === SyntaxKind.ClassDeclaration) {\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                            Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :\r\n                            Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Public_property_0_of_exported_class_has_or_is_using_private_name_1;\r\n                        }\r\n                        else {\r\n                            // Interfaces cannot have types that cannot be named\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            Diagnostics.Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Property_0_of_exported_interface_has_or_is_using_private_name_1;\r\n                        }\r\n                    }\r\n\r\n                    return diagnosticMessage !== undefined ? {\r\n                        diagnosticMessage: diagnosticMessage,\r\n                        errorNode: node,\r\n                        typeName: node.name\r\n                    } : undefined;\r\n                }\r\n            }\r\n\r\n            function emitVariableStatement(node: VariableStatement) {\r\n                var hasDeclarationWithEmit = forEach(node.declarations, varDeclaration => resolver.isDeclarationVisible(varDeclaration));\r\n                if (hasDeclarationWithEmit) {\r\n                    emitJsDocComments(node);\r\n                    emitDeclarationFlags(node);\r\n                    write(\"var \");\r\n                    emitCommaList(node.declarations, emitVariableDeclaration);\r\n                    write(\";\");\r\n                    writeLine();\r\n                }\r\n            }\r\n\r\n            function emitAccessorDeclaration(node: AccessorDeclaration) {\r\n                var accessors = getAllAccessorDeclarations(<ClassDeclaration>node.parent, node);\r\n                if (node === accessors.firstAccessor) {\r\n                    emitJsDocComments(accessors.getAccessor);\r\n                    emitJsDocComments(accessors.setAccessor);\r\n                    emitDeclarationFlags(node);\r\n                    emitSourceTextOfNode(node.name);\r\n                    if (!(node.flags & NodeFlags.Private)) {\r\n                        write(\": \");\r\n                        getSymbolVisibilityDiagnosticMessage = getAccessorDeclarationTypeVisibilityError;\r\n                        resolver.writeTypeAtLocation(node, enclosingDeclaration, TypeFormatFlags.UseTypeOfFunction, writer);\r\n                    }\r\n                    write(\";\");\r\n                    writeLine();\r\n                }\r\n\r\n                function getAccessorDeclarationTypeVisibilityError(symbolAccesibilityResult: SymbolAccessiblityResult) {\r\n                    var diagnosticMessage: DiagnosticMessage;\r\n                    if (node.kind === SyntaxKind.SetAccessor) {\r\n                        // Setters have to have type named and cannot infer it so, the type should always be named\r\n                        if (node.parent.flags & NodeFlags.Static) {\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1;\r\n                        }\r\n                        else {\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1;\r\n                        }\r\n                        return {\r\n                            diagnosticMessage: diagnosticMessage,\r\n                            errorNode: node.parameters[0],\r\n                            typeName: node.name\r\n                        };\r\n                    }\r\n                    else {\r\n                        if (node.flags & NodeFlags.Static) {\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                            Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named :\r\n                            Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 :\r\n                            Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0;\r\n                        }\r\n                        else {\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                            Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named :\r\n                            Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 :\r\n                            Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0;\r\n                        }\r\n                        return {\r\n                            diagnosticMessage: diagnosticMessage,\r\n                            errorNode: node.name,\r\n                            typeName: undefined\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            function emitFunctionDeclaration(node: FunctionDeclaration) {\r\n                // If we are emitting Method/Constructor it isnt moduleElement and hence already determined to be emitting\r\n                // so no need to verify if the declaration is visible\r\n                if ((node.kind !== SyntaxKind.FunctionDeclaration || resolver.isDeclarationVisible(node)) &&\r\n                    !resolver.isImplementationOfOverload(node)) {\r\n                    emitJsDocComments(node);\r\n                    emitDeclarationFlags(node);\r\n                    if (node.kind === SyntaxKind.FunctionDeclaration) {\r\n                        write(\"function \");\r\n                        emitSourceTextOfNode(node.name);\r\n                    }\r\n                    else if (node.kind === SyntaxKind.Constructor) {\r\n                        write(\"constructor\");\r\n                    }\r\n                    else {\r\n                        emitSourceTextOfNode(node.name);\r\n                        if (node.flags & NodeFlags.QuestionMark) {\r\n                            write(\"?\");\r\n                        }\r\n                    }\r\n                    emitSignatureDeclaration(node);\r\n                }\r\n            }\r\n\r\n            function emitConstructSignatureDeclaration(node: SignatureDeclaration) {\r\n                emitJsDocComments(node);\r\n                write(\"new \");\r\n                emitSignatureDeclaration(node);\r\n            }\r\n\r\n            function emitSignatureDeclaration(node: SignatureDeclaration) {\r\n                if (node.kind === SyntaxKind.CallSignature || node.kind === SyntaxKind.IndexSignature) {\r\n                    // Only index and call signatures are emitted directly, so emit their js doc comments, rest will do that in their own functions\r\n                    emitJsDocComments(node);\r\n                }\r\n                emitTypeParameters(node.typeParameters);\r\n                if (node.kind === SyntaxKind.IndexSignature) {\r\n                    write(\"[\");\r\n                }\r\n                else {\r\n                    write(\"(\");\r\n                }\r\n\r\n                // Parameters\r\n                emitCommaList(node.parameters, emitParameterDeclaration);\r\n\r\n                if (node.kind === SyntaxKind.IndexSignature) {\r\n                    write(\"]\");\r\n                }\r\n                else {\r\n                    write(\")\");\r\n                }\r\n\r\n                // If this is not a constructor and is not private, emit the return type\r\n                if (node.kind !== SyntaxKind.Constructor && !(node.flags & NodeFlags.Private)) {\r\n                    write(\": \");\r\n                    getSymbolVisibilityDiagnosticMessage = getReturnTypeVisibilityError;\r\n                    resolver.writeReturnTypeOfSignatureDeclaration(node, enclosingDeclaration, TypeFormatFlags.UseTypeOfFunction, writer);\r\n                }\r\n                write(\";\");\r\n                writeLine();\r\n\r\n                function getReturnTypeVisibilityError(symbolAccesibilityResult: SymbolAccessiblityResult) {\r\n                    var diagnosticMessage: DiagnosticMessage;\r\n                    switch (node.kind) {\r\n                        case SyntaxKind.ConstructSignature:\r\n                            // Interfaces cannot have return types that cannot be named\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? \r\n                            Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 :\r\n                            Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0;\r\n                            break;\r\n\r\n                        case SyntaxKind.CallSignature:\r\n                            // Interfaces cannot have return types that cannot be named\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 :\r\n                            Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0;\r\n                            break;\r\n\r\n                        case SyntaxKind.IndexSignature:\r\n                            // Interfaces cannot have return types that cannot be named\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 :\r\n                            Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0;\r\n                            break;\r\n\r\n                        case SyntaxKind.Method:\r\n                            if (node.flags & NodeFlags.Static) {\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                                Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named :\r\n                                Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 :\r\n                                Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0;\r\n                            }\r\n                            else if (node.parent.kind === SyntaxKind.ClassDeclaration) {\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                                Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named :\r\n                                Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 :\r\n                                Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0;\r\n                            }\r\n                            else {\r\n                                // Interfaces cannot have return types that cannot be named\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1 :\r\n                                Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0;\r\n                            }\r\n                            break;\r\n\r\n                        case SyntaxKind.FunctionDeclaration:\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                            Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named :\r\n                            Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1 :\r\n                            Diagnostics.Return_type_of_exported_function_has_or_is_using_private_name_0;\r\n                            break;\r\n\r\n                        default:\r\n                            Debug.fail(\"This is unknown kind for signature: \" + SyntaxKind[node.kind]);\r\n                    }\r\n\r\n                    return {\r\n                        diagnosticMessage: diagnosticMessage,\r\n                        errorNode: <Node>node.name || node,\r\n                    };\r\n                }\r\n            }\r\n\r\n            function emitParameterDeclaration(node: ParameterDeclaration) {\r\n                increaseIndent();\r\n                emitJsDocComments(node);\r\n                if (node.flags & NodeFlags.Rest) {\r\n                    write(\"...\");\r\n                }\r\n                emitSourceTextOfNode(node.name);\r\n                if (node.initializer || (node.flags & NodeFlags.QuestionMark)) {\r\n                    write(\"?\");\r\n                }\r\n                decreaseIndent();\r\n\r\n                if (!(node.parent.flags & NodeFlags.Private)) {\r\n                    write(\": \");\r\n                    getSymbolVisibilityDiagnosticMessage = getParameterDeclarationTypeVisibilityError;\r\n                    resolver.writeTypeAtLocation(node, enclosingDeclaration, TypeFormatFlags.UseTypeOfFunction, writer);\r\n                }\r\n\r\n                function getParameterDeclarationTypeVisibilityError(symbolAccesibilityResult: SymbolAccessiblityResult) {\r\n                    var diagnosticMessage: DiagnosticMessage;\r\n                    switch (node.parent.kind) {\r\n                        case SyntaxKind.Constructor:\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                            Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :\r\n                            Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1;\r\n                            break;\r\n\r\n                        case SyntaxKind.ConstructSignature:\r\n                            // Interfaces cannot have parameter types that cannot be named\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;\r\n                            break;\r\n\r\n                        case SyntaxKind.CallSignature:\r\n                            // Interfaces cannot have parameter types that cannot be named\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;\r\n                            break;\r\n\r\n                        case SyntaxKind.Method:\r\n                            if (node.parent.flags & NodeFlags.Static) {\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                                Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :\r\n                                Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;\r\n                            }\r\n                            else if (node.parent.parent.kind === SyntaxKind.ClassDeclaration) {\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                                Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :\r\n                                Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;\r\n                            }\r\n                            else {\r\n                                // Interfaces cannot have parameter types that cannot be named\r\n                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                                Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :\r\n                                Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;\r\n                            }\r\n                            break;\r\n\r\n                        case SyntaxKind.FunctionDeclaration:\r\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ?\r\n                            symbolAccesibilityResult.accessibility === SymbolAccessibility.CannotBeNamed ?\r\n                            Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :\r\n                            Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 :\r\n                            Diagnostics.Parameter_0_of_exported_function_has_or_is_using_private_name_1;\r\n                            break;\r\n\r\n                        default:\r\n                            Debug.fail(\"This is unknown parent for parameter: \" + SyntaxKind[node.parent.kind]);\r\n                    }\r\n\r\n                    return {\r\n                        diagnosticMessage: diagnosticMessage,\r\n                        errorNode: node,\r\n                        typeName: node.name\r\n                    };\r\n                }\r\n            }\r\n\r\n            function emitNode(node: Node) {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.Method:\r\n                        return emitFunctionDeclaration(<FunctionDeclaration>node);\r\n                    case SyntaxKind.ConstructSignature:\r\n                        return emitConstructSignatureDeclaration(<SignatureDeclaration>node);\r\n                    case SyntaxKind.CallSignature:\r\n                    case SyntaxKind.IndexSignature:\r\n                        return emitSignatureDeclaration(<SignatureDeclaration>node);\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                        return emitAccessorDeclaration(<AccessorDeclaration>node);\r\n                    case SyntaxKind.VariableStatement:\r\n                        return emitVariableStatement(<VariableStatement>node);\r\n                    case SyntaxKind.Property:\r\n                        return emitPropertyDeclaration(<PropertyDeclaration>node);\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                        return emitInterfaceDeclaration(<InterfaceDeclaration>node);\r\n                    case SyntaxKind.ClassDeclaration:\r\n                        return emitClassDeclaration(<ClassDeclaration>node);\r\n                    case SyntaxKind.EnumMember:\r\n                        return emitEnumMemberDeclaration(<EnumMember>node);\r\n                    case SyntaxKind.EnumDeclaration:\r\n                        return emitEnumDeclaration(<EnumDeclaration>node);\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                        return emitModuleDeclaration(<ModuleDeclaration>node);\r\n                    case SyntaxKind.ImportDeclaration:\r\n                        return emitImportDeclaration(<ImportDeclaration>node);\r\n                    case SyntaxKind.ExportAssignment:\r\n                        return emitExportAssignment(<ExportAssignment>node);\r\n                    case SyntaxKind.SourceFile:\r\n                        return emitSourceFile(<SourceFile>node);\r\n                }\r\n            }\r\n\r\n            function resolveScriptReference(sourceFile: SourceFile, reference: FileReference) {\r\n                var referenceFileName = compilerOptions.noResolve\r\n                    ? reference.filename\r\n                    : normalizePath(combinePaths(getDirectoryPath(sourceFile.filename), reference.filename));\r\n                return program.getSourceFile(referenceFileName);\r\n            }\r\n\r\n            // Contains the reference paths that needs to go in the declaration file. \r\n            // Collecting this separately because reference paths need to be first thing in the declaration file \r\n            // and we could be collecting these paths from multiple files into single one with --out option\r\n            var referencePathsOutput = \"\";\r\n            function writeReferencePath(referencedFile: SourceFile) {\r\n                var declFileName = referencedFile.flags & NodeFlags.DeclarationFile\r\n                    ? referencedFile.filename // Declaration file, use declaration file name\r\n                    : shouldEmitToOwnFile(referencedFile)\r\n                    ? getOwnEmitOutputFilePath(referencedFile, \".d.ts\") // Own output file so get the .d.ts file\r\n                    : getModuleNameFromFilename(compilerOptions.out) + \".d.ts\";// Global out file\r\n\r\n                declFileName = getRelativePathToDirectoryOrUrl(\r\n                    getDirectoryPath(normalizeSlashes(jsFilePath)),\r\n                    declFileName,\r\n                    compilerHost.getCurrentDirectory(),\r\n                /*isAbsolutePathAnUrl*/ false);\r\n\r\n                referencePathsOutput += \"/// <reference path='\" + declFileName + \"' />\" + newLine;\r\n            }\r\n\r\n            if (root) {\r\n                // Emiting single file so emit references in this file only\r\n                var addedGlobalFileReference = false;\r\n                forEach(root.referencedFiles, fileReference => {\r\n                    var referencedFile = resolveScriptReference(root, fileReference);\r\n\r\n                    // All the references that are not going to be part of same file\r\n                    if ((referencedFile.flags & NodeFlags.DeclarationFile) || // This is a declare file reference\r\n                        shouldEmitToOwnFile(referencedFile) || // This is referenced file is emitting its own js file\r\n                        !addedGlobalFileReference) { // Or the global out file corresponding to this reference was not added\r\n\r\n                        writeReferencePath(referencedFile);\r\n                        if (!isExternalModuleOrDeclarationFile(referencedFile)) {\r\n                            addedGlobalFileReference = true;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                emitNode(root);\r\n            }\r\n            else {\r\n                // Emit references corresponding to this file\r\n                var emittedReferencedFiles: SourceFile[] = [];\r\n                forEach(program.getSourceFiles(), sourceFile => {\r\n                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {\r\n                        // Check what references need to be added\r\n                        forEach(sourceFile.referencedFiles, fileReference => {\r\n                            var referencedFile = resolveScriptReference(sourceFile, fileReference);\r\n\r\n                            // If the reference file is declaration file or external module emit that reference\r\n                            if (isExternalModuleOrDeclarationFile(referencedFile) &&\r\n                                !contains(emittedReferencedFiles, referencedFile)) { // If the file refernece was not already emitted\r\n\r\n                                writeReferencePath(referencedFile);\r\n                                emittedReferencedFiles.push(referencedFile);\r\n                            }\r\n                        });\r\n\r\n                        emitNode(sourceFile);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // TODO(shkamat): Should we not write any declaration file if any of them can produce error, \r\n            // or should we just not write this file like we are doing now\r\n            if (!reportedDeclarationError) {\r\n                var declarationOutput = referencePathsOutput;\r\n                var synchronousDeclarationOutput = writer.getText();\r\n                // apply additions\r\n                var appliedSyncOutputPos = 0;\r\n                forEach(aliasDeclarationEmitInfo, aliasEmitInfo => {\r\n                    if (aliasEmitInfo.asynchronousOutput) {\r\n                        declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos, aliasEmitInfo.outputPos);\r\n                        declarationOutput += aliasEmitInfo.asynchronousOutput;\r\n                        appliedSyncOutputPos = aliasEmitInfo.outputPos;\r\n                    }\r\n                });\r\n                declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos);\r\n                writeFile(getModuleNameFromFilename(jsFilePath) + \".d.ts\", declarationOutput, compilerOptions.emitBOM);\r\n            }\r\n        }\r\n\r\n        var shouldEmitDeclarations = resolver.shouldEmitDeclarations();\r\n        function emitFile(jsFilePath: string, sourceFile?: SourceFile) {\r\n            emitJavaScript(jsFilePath, sourceFile);\r\n            if (shouldEmitDeclarations) {\r\n                emitDeclarations(jsFilePath, sourceFile);\r\n            }\r\n        }\r\n\r\n        forEach(program.getSourceFiles(), sourceFile => {\r\n            if (shouldEmitToOwnFile(sourceFile)) {\r\n                var jsFilePath = getOwnEmitOutputFilePath(sourceFile, \".js\");\r\n                emitFile(jsFilePath, sourceFile);\r\n            }\r\n        });\r\n        if (compilerOptions.out) {\r\n            emitFile(compilerOptions.out);\r\n        }\r\n\r\n        // Sort and make the unique list of diagnostics\r\n        diagnostics.sort(compareDiagnostics);\r\n        diagnostics = deduplicateSortedDiagnostics(diagnostics);\r\n\r\n        return {\r\n            errors: diagnostics,\r\n            sourceMaps: sourceMapDataList\r\n        };\r\n    }\r\n}\r\n\r\n // file: src/compiler/checker.ts\r\n/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"scanner.ts\"/>\r\n/// <reference path=\"parser.ts\"/>\r\n/// <reference path=\"binder.ts\"/>\r\n/// <reference path=\"emitter.ts\"/>\r\n\r\nmodule ts {\r\n\r\n    var nextSymbolId = 1;\r\n    var nextNodeId = 1;\r\n    var nextMergeId = 1;\r\n\r\n    /// fullTypeCheck denotes if this instance of the typechecker will be used to get semantic diagnostics.\r\n    /// If fullTypeCheck === true - then typechecker should do every possible check to produce all errors\r\n    /// If fullTypeCheck === false - typechecker can shortcut and skip checks that only produce errors.\r\n    /// NOTE: checks that somehow affects decisions being made during typechecking should be executed in both cases.\r\n    export function createTypeChecker(program: Program, fullTypeCheck: boolean): TypeChecker {\r\n\r\n        var Symbol = objectAllocator.getSymbolConstructor();\r\n        var Type = objectAllocator.getTypeConstructor();\r\n        var Signature = objectAllocator.getSignatureConstructor();\r\n\r\n        var typeCount = 0;\r\n\r\n        var emptyArray: any[] = [];\r\n        var emptySymbols: SymbolTable = {};\r\n        \r\n        var checker: TypeChecker = {\r\n            getProgram: () => program,\r\n            getDiagnostics: getDiagnostics,\r\n            getGlobalDiagnostics: getGlobalDiagnostics,\r\n            getNodeCount: () => sum(program.getSourceFiles(), \"nodeCount\"),\r\n            getIdentifierCount: () => sum(program.getSourceFiles(), \"identifierCount\"),\r\n            getSymbolCount: () => sum(program.getSourceFiles(), \"symbolCount\"),\r\n            getTypeCount: () => typeCount,\r\n            checkProgram: checkProgram,\r\n            emitFiles: invokeEmitter,\r\n            getParentOfSymbol: getParentOfSymbol,\r\n            getTypeOfSymbol: getTypeOfSymbol,\r\n            getPropertiesOfType: getPropertiesOfType,\r\n            getPropertyOfType: getPropertyOfType,\r\n            getSignaturesOfType: getSignaturesOfType,\r\n            getIndexTypeOfType: getIndexTypeOfType,\r\n            getReturnTypeOfSignature: getReturnTypeOfSignature,\r\n            getSymbolsInScope: getSymbolsInScope,\r\n            getSymbolInfo: getSymbolInfo,\r\n            getTypeOfNode: getTypeOfNode,\r\n            getApparentType: getApparentType,\r\n            typeToString: typeToString,\r\n            symbolToString: symbolToString,\r\n            getAugmentedPropertiesOfApparentType: getAugmentedPropertiesOfApparentType\r\n        };\r\n\r\n        var undefinedSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.Transient, \"undefined\");\r\n        var argumentsSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.Transient, \"arguments\");\r\n        var unknownSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.Transient, \"unknown\");\r\n        var resolvingSymbol = createSymbol(SymbolFlags.Transient, \"__resolving__\");\r\n\r\n        var anyType = createIntrinsicType(TypeFlags.Any, \"any\");\r\n        var stringType = createIntrinsicType(TypeFlags.String, \"string\");\r\n        var numberType = createIntrinsicType(TypeFlags.Number, \"number\");\r\n        var booleanType = createIntrinsicType(TypeFlags.Boolean, \"boolean\");\r\n        var voidType = createIntrinsicType(TypeFlags.Void, \"void\");\r\n        var undefinedType = createIntrinsicType(TypeFlags.Undefined, \"undefined\");\r\n        var nullType = createIntrinsicType(TypeFlags.Null, \"null\");\r\n        var unknownType = createIntrinsicType(TypeFlags.Any, \"unknown\");\r\n        var resolvingType = createIntrinsicType(TypeFlags.Any, \"__resolving__\");\r\n\r\n        var emptyObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\r\n        var anyFunctionType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\r\n        var noConstraintType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\r\n\r\n        var anySignature = createSignature(undefined, undefined, emptyArray, anyType, 0, false, false);\r\n        var unknownSignature = createSignature(undefined, undefined, emptyArray, unknownType, 0, false, false);\r\n\r\n        var globals: SymbolTable = {};\r\n\r\n        var globalArraySymbol: Symbol;\r\n\r\n        var globalObjectType: ObjectType;\r\n        var globalFunctionType: ObjectType;\r\n        var globalArrayType: ObjectType;\r\n        var globalStringType: ObjectType;\r\n        var globalNumberType: ObjectType;\r\n        var globalBooleanType: ObjectType;\r\n        var globalRegExpType: ObjectType;\r\n\r\n        var stringLiteralTypes: Map<StringLiteralType> = {};\r\n        var emitExtends = false;\r\n\r\n        var mergedSymbols: Symbol[] = [];\r\n        var symbolLinks: SymbolLinks[] = [];\r\n        var nodeLinks: NodeLinks[] = [];\r\n        var potentialThisCollisions: Node[] = [];\r\n\r\n        var diagnostics: Diagnostic[] = [];\r\n        var diagnosticsModified: boolean = false;\r\n\r\n        function addDiagnostic(diagnostic: Diagnostic) {\r\n            diagnostics.push(diagnostic);\r\n            diagnosticsModified = true;\r\n        }\r\n\r\n        function error(location: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): void {\r\n            var diagnostic = location\r\n                ? createDiagnosticForNode(location, message, arg0, arg1, arg2)\r\n                : createCompilerDiagnostic(message, arg0, arg1, arg2);\r\n            addDiagnostic(diagnostic);\r\n        }\r\n\r\n        function createSymbol(flags: SymbolFlags, name: string): Symbol {\r\n            return new Symbol(flags, name);\r\n        }\r\n\r\n        function getExcludedSymbolFlags(flags: SymbolFlags): SymbolFlags {\r\n            var result: SymbolFlags = 0;\r\n            if (flags & SymbolFlags.Variable) result |= SymbolFlags.VariableExcludes;\r\n            if (flags & SymbolFlags.Property) result |= SymbolFlags.PropertyExcludes;\r\n            if (flags & SymbolFlags.EnumMember) result |= SymbolFlags.EnumMemberExcludes;\r\n            if (flags & SymbolFlags.Function) result |= SymbolFlags.FunctionExcludes;\r\n            if (flags & SymbolFlags.Class) result |= SymbolFlags.ClassExcludes;\r\n            if (flags & SymbolFlags.Interface) result |= SymbolFlags.InterfaceExcludes;\r\n            if (flags & SymbolFlags.Enum) result |= SymbolFlags.EnumExcludes;\r\n            if (flags & SymbolFlags.ValueModule) result |= SymbolFlags.ValueModuleExcludes;\r\n            if (flags & SymbolFlags.Method) result |= SymbolFlags.MethodExcludes;\r\n            if (flags & SymbolFlags.GetAccessor) result |= SymbolFlags.GetAccessorExcludes;\r\n            if (flags & SymbolFlags.SetAccessor) result |= SymbolFlags.SetAccessorExcludes;\r\n            if (flags & SymbolFlags.TypeParameter) result |= SymbolFlags.TypeParameterExcludes;\r\n            if (flags & SymbolFlags.Import) result |= SymbolFlags.ImportExcludes;\r\n            return result;\r\n        }\r\n\r\n        function recordMergedSymbol(target: Symbol, source: Symbol) {\r\n            if (!source.mergeId) source.mergeId = nextMergeId++;\r\n            mergedSymbols[source.mergeId] = target;\r\n        }\r\n\r\n        function cloneSymbol(symbol: Symbol): Symbol {\r\n            var result = createSymbol(symbol.flags | SymbolFlags.Merged, symbol.name);\r\n            result.declarations = symbol.declarations.slice(0);\r\n            result.parent = symbol.parent;\r\n            if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;\r\n            if (symbol.members) result.members = cloneSymbolTable(symbol.members);\r\n            if (symbol.exports) result.exports = cloneSymbolTable(symbol.exports);\r\n            recordMergedSymbol(result, symbol);\r\n            return result;\r\n        }\r\n\r\n        function extendSymbol(target: Symbol, source: Symbol) {\r\n            if (!(target.flags & getExcludedSymbolFlags(source.flags))) {\r\n                target.flags |= source.flags;\r\n                if (!target.valueDeclaration && source.valueDeclaration) target.valueDeclaration = source.valueDeclaration;\r\n                forEach(source.declarations, node => {\r\n                    target.declarations.push(node);\r\n                });\r\n                if (source.members) {\r\n                    if (!target.members) target.members = {};\r\n                    extendSymbolTable(target.members, source.members);\r\n                }\r\n                if (source.exports) {\r\n                    if (!target.exports) target.exports = {};\r\n                    extendSymbolTable(target.exports, source.exports);\r\n                }\r\n                recordMergedSymbol(target, source);\r\n            }\r\n            else {\r\n                forEach(source.declarations, node => {\r\n                    error(node.name ? node.name : node, Diagnostics.Duplicate_identifier_0, symbolToString(source));\r\n                });\r\n            }\r\n        }\r\n\r\n        function cloneSymbolTable(symbolTable: SymbolTable): SymbolTable {\r\n            var result: SymbolTable = {};\r\n            for (var id in symbolTable) {\r\n                if (hasProperty(symbolTable, id)) {\r\n                    result[id] = symbolTable[id];\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function extendSymbolTable(target: SymbolTable, source: SymbolTable) {\r\n            for (var id in source) {\r\n                if (hasProperty(source, id)) {\r\n                    if (!hasProperty(target, id)) {\r\n                        target[id] = source[id];\r\n                    }\r\n                    else {\r\n                        var symbol = target[id];\r\n                        if (!(symbol.flags & SymbolFlags.Merged)) {\r\n                            target[id] = symbol = cloneSymbol(symbol);\r\n                        }\r\n                        extendSymbol(symbol, source[id]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function getSymbolLinks(symbol: Symbol): SymbolLinks {\r\n            if (symbol.flags & SymbolFlags.Transient) return <TransientSymbol>symbol;\r\n            if (!symbol.id) symbol.id = nextSymbolId++;\r\n            return symbolLinks[symbol.id] || (symbolLinks[symbol.id] = {});\r\n        }\r\n\r\n        function getNodeLinks(node: Node): NodeLinks {\r\n            if (!node.id) node.id = nextNodeId++;\r\n            return nodeLinks[node.id] || (nodeLinks[node.id] = {});\r\n        }\r\n\r\n        function getSourceFile(node: Node): SourceFile {\r\n            return <SourceFile>getAncestor(node, SyntaxKind.SourceFile);\r\n        }\r\n\r\n        function isGlobalSourceFile(node: Node) {\r\n            return node.kind === SyntaxKind.SourceFile && !isExternalModule(<SourceFile>node);\r\n        }\r\n\r\n        function getSymbol(symbols: SymbolTable, name: string, meaning: SymbolFlags): Symbol {\r\n            if (meaning && hasProperty(symbols, name)) {\r\n                var symbol = symbols[name];\r\n                Debug.assert((symbol.flags & SymbolFlags.Instantiated) === 0, \"Should never get an instantiated symbol here.\");\r\n                if (symbol.flags & meaning) {\r\n                    return symbol;\r\n                }\r\n\r\n                if (symbol.flags & SymbolFlags.Import) {\r\n                    var target = resolveImport(symbol);\r\n                    // unknown symbol will mean that there were reported error during import resolution\r\n                    // treat it as positive answer to avoid cascading errors\r\n                    if (target === unknownSymbol || target.flags & meaning) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // return undefined if we can't find a symbol.\r\n        }\r\n\r\n        function resolveName(location: Node, name: string, meaning: SymbolFlags, nameNotFoundMessage: DiagnosticMessage, nameArg: string): Symbol {\r\n            var errorLocation = location;\r\n            var result: Symbol;\r\n            var lastLocation: Node;\r\n\r\n            var memberWithInitializerThatReferencesIdentifierFromConstructor: Node;\r\n\r\n            function returnResolvedSymbol(s: Symbol) {\r\n                // we've seen member with initializer that references identifier defined in constructor during the search.\r\n                // if this was the only result with given name then just report default 'nameNotFound' message.\r\n                // however if we met something else that was 'shadowed' by the identifier in constructor - report more specific error\r\n                if (s && memberWithInitializerThatReferencesIdentifierFromConstructor) {\r\n                    var propertyName = (<PropertyDeclaration>memberWithInitializerThatReferencesIdentifierFromConstructor).name;\r\n                    error(errorLocation, Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, identifierToString(propertyName), nameArg);\r\n                    return undefined;\r\n                }\r\n                if (!s && nameNotFoundMessage) {\r\n                    error(errorLocation, nameNotFoundMessage, nameArg);\r\n                }\r\n                return s;\r\n            }\r\n\r\n            while (location) {\r\n                // Locals of a source file are not in scope (because they get merged into the global symbol table)\r\n                if (location.locals && !isGlobalSourceFile(location)) {\r\n                    if (result = getSymbol(location.locals, name, meaning)) {\r\n                        return returnResolvedSymbol(result);\r\n                    }\r\n                }\r\n                switch (location.kind) {\r\n                    case SyntaxKind.SourceFile:\r\n                        if (!isExternalModule(<SourceFile>location)) break;\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & SymbolFlags.ModuleMember)) {\r\n                            return returnResolvedSymbol(result);\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.EnumDeclaration:\r\n                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & SymbolFlags.EnumMember)) {\r\n                            return returnResolvedSymbol(result);\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.Property:\r\n                        // TypeScript 1.0 spec (April 2014): 8.4.1\r\n                        // Initializer expressions for instance member variables are evaluated in the scope \r\n                        // of the class constructor body but are not permitted to reference parameters or \r\n                        // local variables of the constructor.This effectively means that entities from outer scopes \r\n                        // by the same name as a constructor parameter or local variable are inaccessible \r\n                        // in initializer expressions for instance member variables.\r\n                        if (location.parent.kind === SyntaxKind.ClassDeclaration && !(location.flags & NodeFlags.Static)) {\r\n                            var ctor = findConstructorDeclaration(<ClassDeclaration>location.parent);\r\n                            if (ctor && ctor.locals) {\r\n                                if (getSymbol(ctor.locals, name, meaning & SymbolFlags.Value)) {\r\n                                    // save the property node - later it will be used by 'returnResolvedSymbol' to report appropriate error\r\n                                    memberWithInitializerThatReferencesIdentifierFromConstructor = location;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                        if (result = getSymbol(getSymbolOfNode(location).members, name, meaning & SymbolFlags.Type)) {\r\n                            if (lastLocation && lastLocation.flags & NodeFlags.Static) {\r\n                                // TypeScript 1.0 spec (April 2014): 3.4.1\r\n                                // The scope of a type parameter extends over the entire declaration \r\n                                // with which the type parameter list is associated, with the exception of static member declarations in classes.\r\n                                error(errorLocation, Diagnostics.Static_members_cannot_reference_class_type_parameters);\r\n                                return undefined;\r\n                            }\r\n                            else {\r\n                                return returnResolvedSymbol(result);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.Method:\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.ArrowFunction:\r\n                        if (name === \"arguments\") {\r\n                            return returnResolvedSymbol(argumentsSymbol);\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.FunctionExpression:\r\n                        if (name === \"arguments\") {\r\n                            return returnResolvedSymbol(argumentsSymbol);\r\n                        }\r\n                        var id = (<FunctionExpression>location).name;\r\n                        if (id && name === id.text) {\r\n                            return returnResolvedSymbol(location.symbol);\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.CatchBlock:\r\n                        var id = (<CatchBlock>location).variable;\r\n                        if (name === id.text) {\r\n                            return returnResolvedSymbol(location.symbol);\r\n                        }\r\n                        break;\r\n                }\r\n                lastLocation = location;\r\n                location = location.parent;\r\n            }\r\n            if (result = getSymbol(globals, name, meaning)) {\r\n                return returnResolvedSymbol(result);\r\n            }\r\n\r\n            return returnResolvedSymbol(undefined);\r\n        }\r\n\r\n        function resolveImport(symbol: Symbol): Symbol {\r\n            Debug.assert((symbol.flags & SymbolFlags.Import) !== 0, \"Should only get Imports here.\");\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.target) {\r\n                links.target = resolvingSymbol;\r\n                var node = <ImportDeclaration>getDeclarationOfKind(symbol, SyntaxKind.ImportDeclaration);\r\n                var target = node.externalModuleName ?\r\n                    resolveExternalModuleName(node, node.externalModuleName) :\r\n                    getSymbolOfPartOfRightHandSideOfImport(node.entityName, node);\r\n                if (links.target === resolvingSymbol) {\r\n                    links.target = target || unknownSymbol;\r\n                }\r\n                else {\r\n                    error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));\r\n                }\r\n            }\r\n            else if (links.target === resolvingSymbol) {\r\n                links.target = unknownSymbol;\r\n            }\r\n            return links.target;\r\n        }\r\n\r\n        // This function is only for imports with entity names\r\n        function getSymbolOfPartOfRightHandSideOfImport(entityName: EntityName, importDeclaration?: ImportDeclaration): Symbol {\r\n            if (!importDeclaration) {\r\n                importDeclaration = getAncestor(entityName, SyntaxKind.ImportDeclaration);\r\n                Debug.assert(importDeclaration);\r\n            }\r\n            // There are three things we might try to look for. In the following examples,\r\n            // the search term is enclosed in |...|:\r\n            //\r\n            //     import a = |b|; // Namespace\r\n            //     import a = |b.c|; // Value, type, namespace\r\n            //     import a = |b.c|.d; // Namespace\r\n            if (entityName.kind === SyntaxKind.Identifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {\r\n                entityName = entityName.parent;\r\n            }\r\n            // Check for case 1 and 3 in the above example\r\n            if (entityName.kind === SyntaxKind.Identifier || entityName.parent.kind === SyntaxKind.QualifiedName) {\r\n                return resolveEntityName(importDeclaration, entityName, SymbolFlags.Namespace);\r\n            }\r\n            else {\r\n                // Case 2 in above example\r\n                // entityName.kind could be a QualifiedName or a Missing identifier\r\n                Debug.assert(entityName.parent.kind === SyntaxKind.ImportDeclaration);\r\n                return resolveEntityName(importDeclaration, entityName, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace);\r\n            }\r\n        }\r\n\r\n        function getFullyQualifiedName(symbol: Symbol) {\r\n            return symbol.parent ? getFullyQualifiedName(symbol.parent) + \".\" + symbolToString(symbol) : symbolToString(symbol);\r\n        }\r\n\r\n        // Resolves a qualified name and any involved import aliases\r\n        function resolveEntityName(location: Node, name: EntityName, meaning: SymbolFlags): Symbol {\r\n            if (name.kind === SyntaxKind.Identifier) {\r\n                // TODO: Investigate error recovery for symbols not found\r\n                var symbol = resolveName(location, (<Identifier>name).text, meaning, Diagnostics.Cannot_find_name_0, identifierToString(<Identifier>name));\r\n                if (!symbol) {\r\n                    return;\r\n                }\r\n            }\r\n            else if (name.kind === SyntaxKind.QualifiedName) {\r\n                var namespace = resolveEntityName(location, (<QualifiedName>name).left, SymbolFlags.Namespace);\r\n                if (!namespace || namespace === unknownSymbol || (<QualifiedName>name).right.kind === SyntaxKind.Missing) return;\r\n                var symbol = getSymbol(namespace.exports, (<QualifiedName>name).right.text, meaning);\r\n                if (!symbol) {\r\n                    error(location, Diagnostics.Module_0_has_no_exported_member_1, getFullyQualifiedName(namespace),\r\n                        identifierToString((<QualifiedName>name).right));\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                // Missing identifier\r\n                return;\r\n            }\r\n            Debug.assert((symbol.flags & SymbolFlags.Instantiated) === 0, \"Should never get an instantiated symbol here.\");\r\n            return symbol.flags & meaning ? symbol : resolveImport(symbol);\r\n        }\r\n\r\n        function isExternalModuleNameRelative(moduleName: string): boolean {\r\n            // TypeScript 1.0 spec (April 2014): 11.2.1\r\n            // An external module name is \"relative\" if the first term is \".\" or \"..\".\r\n            return moduleName.substr(0, 2) === \"./\" || moduleName.substr(0, 3) === \"../\" || moduleName.substr(0, 2) === \".\\\\\" || moduleName.substr(0, 3) === \"..\\\\\";\r\n        }\r\n\r\n        function resolveExternalModuleName(location: Node, moduleLiteral: LiteralExpression): Symbol {\r\n            var searchPath = getDirectoryPath(getSourceFile(location).filename);\r\n            var moduleName = moduleLiteral.text;\r\n            if (!moduleName) return;\r\n            var isRelative = isExternalModuleNameRelative(moduleName);\r\n            if (!isRelative) {\r\n                var symbol = getSymbol(globals, '\"' + moduleName + '\"', SymbolFlags.ValueModule);\r\n                if (symbol) {\r\n                    return getResolvedExportSymbol(symbol);\r\n                }\r\n            }\r\n            while (true) {\r\n                var filename = normalizePath(combinePaths(searchPath, moduleName));\r\n                var sourceFile = program.getSourceFile(filename + \".ts\") || program.getSourceFile(filename + \".d.ts\");\r\n                if (sourceFile || isRelative) break;\r\n                var parentPath = getDirectoryPath(searchPath);\r\n                if (parentPath === searchPath) break;\r\n                searchPath = parentPath;\r\n            }\r\n            if (sourceFile) {\r\n                if (sourceFile.symbol) {\r\n                    return getResolvedExportSymbol(sourceFile.symbol);\r\n                }\r\n                error(moduleLiteral, Diagnostics.File_0_is_not_an_external_module, sourceFile.filename);\r\n                return;\r\n            }\r\n            error(moduleLiteral, Diagnostics.Cannot_find_external_module_0, moduleName);\r\n        }\r\n\r\n        function getResolvedExportSymbol(moduleSymbol: Symbol): Symbol {\r\n            var symbol = getExportAssignmentSymbol(moduleSymbol);\r\n            if (symbol) {\r\n                if (symbol.flags & (SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace)) {\r\n                    return symbol;\r\n                }\r\n                if (symbol.flags & SymbolFlags.Import) {\r\n                    return resolveImport(symbol);\r\n                }\r\n            }\r\n            return moduleSymbol;\r\n        }\r\n\r\n        function getExportAssignmentSymbol(symbol: Symbol): Symbol {\r\n            checkTypeOfExportAssignmentSymbol(symbol);\r\n            var symbolLinks = getSymbolLinks(symbol);\r\n            return symbolLinks.exportAssignSymbol === unknownSymbol ? undefined : symbolLinks.exportAssignSymbol;\r\n        }\r\n\r\n        function checkTypeOfExportAssignmentSymbol(containerSymbol: Symbol): void {\r\n            var symbolLinks = getSymbolLinks(containerSymbol);\r\n            if (!symbolLinks.exportAssignSymbol) {\r\n                var exportInformation = collectExportInformationForSourceFileOrModule(containerSymbol);\r\n                if (exportInformation.exportAssignments.length) {\r\n                    if (exportInformation.exportAssignments.length > 1) {\r\n                        // TypeScript 1.0 spec (April 2014): 11.2.4\r\n                        // It is an error for an external module to contain more than one export assignment.\r\n                        forEach(exportInformation.exportAssignments, node => error(node, Diagnostics.A_module_cannot_have_more_than_one_export_assignment));\r\n                    }\r\n                    var node = exportInformation.exportAssignments[0];\r\n                    if (exportInformation.hasExportedMember) {\r\n                        // TypeScript 1.0 spec (April 2014): 11.2.3\r\n                        // If an external module contains an export assignment it is an error \r\n                        // for the external module to also contain export declarations.\r\n                        // The two types of exports are mutually exclusive.\r\n                        error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);\r\n                    }\r\n                    if (node.exportName.text) {\r\n                        var meaning = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace;\r\n                        var exportSymbol = resolveName(node, node.exportName.text, meaning, Diagnostics.Cannot_find_name_0, identifierToString(node.exportName));\r\n                    }\r\n                }\r\n                symbolLinks.exportAssignSymbol = exportSymbol || unknownSymbol;\r\n            }\r\n        }\r\n\r\n        function collectExportInformationForSourceFileOrModule(symbol: Symbol) {\r\n            var seenExportedMember = false;\r\n            var result: ExportAssignment[] = [];\r\n            forEach(symbol.declarations, declaration => {\r\n                var block = <Block>(declaration.kind === SyntaxKind.SourceFile ? declaration : (<ModuleDeclaration>declaration).body);\r\n                forEach(block.statements, node => {\r\n                    if (node.kind === SyntaxKind.ExportAssignment) {\r\n                        result.push(<ExportAssignment>node);\r\n                    }\r\n                    else {\r\n                        seenExportedMember = seenExportedMember || (node.flags & NodeFlags.Export) !== 0;\r\n                    }\r\n                });\r\n            });\r\n            return {\r\n                hasExportedMember: seenExportedMember,\r\n                exportAssignments: result\r\n            };\r\n        }\r\n\r\n        function getMergedSymbol(symbol: Symbol): Symbol {\r\n            var merged: Symbol;\r\n            return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;\r\n        }\r\n\r\n        function getSymbolOfNode(node: Node): Symbol {\r\n            return getMergedSymbol(node.symbol);\r\n        }\r\n\r\n        function getParentOfSymbol(symbol: Symbol): Symbol {\r\n            return getMergedSymbol(symbol.parent);\r\n        }\r\n\r\n        function getExportSymbolOfValueSymbolIfExported(symbol: Symbol): Symbol {\r\n            return symbol && (symbol.flags & SymbolFlags.ExportValue) !== 0\r\n                ? getMergedSymbol(symbol.exportSymbol)\r\n                : symbol;\r\n        }\r\n\r\n        function symbolIsValue(symbol: Symbol): boolean {\r\n            // If the symbol has the value flag, it is trivially a value.\r\n            if (symbol.flags & SymbolFlags.Value) {\r\n                return true;\r\n            }\r\n\r\n            // If it is an import, then it is a value if the symbol it resolves to is a value.\r\n            if (symbol.flags & SymbolFlags.Import) {\r\n                return (resolveImport(symbol).flags & SymbolFlags.Value) !== 0;\r\n            }\r\n\r\n            // If it is an instantiated symbol, then it is a value if hte symbol it is an \r\n            // instantiation of is a value.\r\n            if (symbol.flags & SymbolFlags.Instantiated) {\r\n                return (getSymbolLinks(symbol).target.flags & SymbolFlags.Value) !== 0;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function getDeclarationOfKind(symbol: Symbol, kind: SyntaxKind): Declaration {\r\n            var declarations = symbol.declarations;\r\n            for (var i = 0; i < declarations.length; i++) {\r\n                var declaration = declarations[i];\r\n                if (declaration.kind === kind) {\r\n                    return declaration;\r\n                }\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function findConstructorDeclaration(node: ClassDeclaration): ConstructorDeclaration {\r\n            var members = node.members;\r\n            for (var i = 0; i < members.length; i++) {\r\n                var member = members[i];\r\n                if (member.kind === SyntaxKind.Constructor && (<ConstructorDeclaration>member).body) {\r\n                    return <ConstructorDeclaration>member;\r\n                }\r\n            }\r\n        }\r\n\r\n        function createType(flags: TypeFlags): Type {\r\n            var result = new Type(checker, flags);\r\n            result.id = typeCount++;\r\n            return result;\r\n        }\r\n\r\n        function createIntrinsicType(kind: TypeFlags, intrinsicName: string): IntrinsicType {\r\n            var type = <IntrinsicType>createType(kind);\r\n            type.intrinsicName = intrinsicName;\r\n            return type;\r\n        }\r\n\r\n        function createObjectType(kind: TypeFlags, symbol?: Symbol): ObjectType {\r\n            var type = <ObjectType>createType(kind);\r\n            type.symbol = symbol;\r\n            return type;\r\n        }\r\n\r\n        // A reserved member name starts with two underscores followed by a non-underscore\r\n        function isReservedMemberName(name: string) {\r\n            return name.charCodeAt(0) === CharacterCodes._ && name.charCodeAt(1) === CharacterCodes._ && name.charCodeAt(2) !== CharacterCodes._;\r\n        }\r\n\r\n        function getNamedMembers(members: SymbolTable): Symbol[] {\r\n            var result: Symbol[];\r\n            for (var id in members) {\r\n                if (hasProperty(members, id)) {\r\n                    if (!isReservedMemberName(id)) {\r\n                        if (!result) result = [];\r\n                        var symbol = members[id];\r\n                        if (symbolIsValue(symbol)) {\r\n                            result.push(symbol);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result || emptyArray;\r\n        }\r\n\r\n        function setObjectTypeMembers(type: ObjectType, members: SymbolTable, callSignatures: Signature[], constructSignatures: Signature[], stringIndexType: Type, numberIndexType: Type): ResolvedObjectType {\r\n            (<ResolvedObjectType>type).members = members;\r\n            (<ResolvedObjectType>type).properties = getNamedMembers(members);\r\n            (<ResolvedObjectType>type).callSignatures = callSignatures;\r\n            (<ResolvedObjectType>type).constructSignatures = constructSignatures;\r\n            if (stringIndexType) (<ResolvedObjectType>type).stringIndexType = stringIndexType;\r\n            if (numberIndexType) (<ResolvedObjectType>type).numberIndexType = numberIndexType;\r\n            return <ResolvedObjectType>type;\r\n        }\r\n\r\n        function createAnonymousType(symbol: Symbol, members: SymbolTable, callSignatures: Signature[], constructSignatures: Signature[], stringIndexType: Type, numberIndexType: Type): ResolvedObjectType {\r\n            return setObjectTypeMembers(createObjectType(TypeFlags.Anonymous, symbol),\r\n                members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\r\n        }\r\n\r\n        function isOptionalProperty(propertySymbol: Symbol): boolean {\r\n            if (propertySymbol.flags & SymbolFlags.Prototype) {\r\n                return false;\r\n            }\r\n            //  class C {\r\n            //      constructor(public x?) { }\r\n            //  }\r\n            //\r\n            // x is an optional parameter, but it is a required property.\r\n            return (propertySymbol.valueDeclaration.flags & NodeFlags.QuestionMark) && propertySymbol.valueDeclaration.kind !== SyntaxKind.Parameter;\r\n        }\r\n\r\n        function forEachSymbolTableInScope<T>(enclosingDeclaration: Node, callback: (symbolTable: SymbolTable) => T): T {\r\n            var result: T;\r\n            for (var location = enclosingDeclaration; location; location = location.parent) {\r\n                // Locals of a source file are not in scope (because they get merged into the global symbol table)\r\n                if (location.locals && !isGlobalSourceFile(location)) {\r\n                    if (result = callback(location.locals)) {\r\n                        return result;\r\n                    }\r\n                }\r\n                switch (location.kind) {\r\n                    case SyntaxKind.SourceFile:\r\n                        if (!isExternalModule(<SourceFile>location)) {\r\n                            break;\r\n                        }\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                        if (result = callback(getSymbolOfNode(location).exports)) {\r\n                            return result;\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                        if (result = callback(getSymbolOfNode(location).members)) {\r\n                            return result;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return callback(globals);\r\n        }\r\n\r\n        function getQualifiedLeftMeaning(rightMeaning: SymbolFlags) {\r\n            // If we are looking in value space, the parent meaning is value, other wise it is namespace\r\n            return rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace;\r\n        }\r\n\r\n        function getAccessibleSymbolChain(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags): Symbol[] {\r\n            function getAccessibleSymbolChainFromSymbolTable(symbols: SymbolTable): Symbol[] {\r\n                function canQualifySymbol(symbolFromSymbolTable: Symbol, meaning: SymbolFlags) {\r\n                    // If the symbol is equivalent and doesnt need futher qualification, this symbol is accessible\r\n                    if (!needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning)) {\r\n                        return true;\r\n                    }\r\n\r\n                    // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too\r\n                    var accessibleParent = getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning));\r\n                    return !!accessibleParent;\r\n                }\r\n\r\n                function isAccessible(symbolFromSymbolTable: Symbol, resolvedAliasSymbol?: Symbol) {\r\n                    if (symbol === (resolvedAliasSymbol || symbolFromSymbolTable)) {\r\n                        // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)\r\n                        // and if symbolfrom symbolTable or alias resolution matches the symbol, \r\n                        // check the symbol can be qualified, it is only then this symbol is accessible\r\n                        return !forEach(symbolFromSymbolTable.declarations, declaration => hasExternalModuleSymbol(declaration)) &&\r\n                            canQualifySymbol(symbolFromSymbolTable, meaning);\r\n                    }\r\n                }\r\n\r\n                // If symbol is directly available by its name in the symbol table\r\n                if (isAccessible(lookUp(symbols, symbol.name))) {\r\n                    return [symbol];\r\n                }\r\n\r\n                // Check if symbol is any of the alias\r\n                return forEachValue(symbols, symbolFromSymbolTable => {\r\n                    if (symbolFromSymbolTable.flags & SymbolFlags.Import) {\r\n                        var resolvedImportedSymbol = resolveImport(symbolFromSymbolTable);\r\n                        if (isAccessible(symbolFromSymbolTable, resolveImport(symbolFromSymbolTable))) {\r\n                            return [symbolFromSymbolTable];\r\n                        }\r\n\r\n                        // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain\r\n                        // but only if the symbolFromSymbolTable can be qualified\r\n                        var accessibleSymbolsFromExports = resolvedImportedSymbol.exports ? getAccessibleSymbolChainFromSymbolTable(resolvedImportedSymbol.exports) : undefined;\r\n                        if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {\r\n                            return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (symbol) {\r\n                return forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);\r\n            }\r\n        }\r\n\r\n        function needsQualification(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags) {\r\n            var qualify = false;\r\n            forEachSymbolTableInScope(enclosingDeclaration, symbolTable => {\r\n                // If symbol of this name is not available in the symbol table we are ok\r\n                if (!hasProperty(symbolTable, symbol.name)) {\r\n                    // Continue to the next symbol table\r\n                    return false;\r\n                }\r\n                // If the symbol with this name is present it should refer to the symbol\r\n                var symbolFromSymbolTable = symbolTable[symbol.name];\r\n                if (symbolFromSymbolTable === symbol) {\r\n                    // No need to qualify\r\n                    return true;\r\n                }\r\n\r\n                // Qualify if the symbol from symbol table has same meaning as expected\r\n                symbolFromSymbolTable = (symbolFromSymbolTable.flags & SymbolFlags.Import) ? resolveImport(symbolFromSymbolTable) : symbolFromSymbolTable;\r\n                if (symbolFromSymbolTable.flags & meaning) {\r\n                    qualify = true;\r\n                    return true;\r\n                }\r\n\r\n                // Continue to the next symbol table\r\n                return false;\r\n            });\r\n\r\n            return qualify;\r\n        }\r\n\r\n        function isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags): SymbolAccessiblityResult {\r\n            if (symbol && enclosingDeclaration && !(symbol.flags & SymbolFlags.TypeParameter)) {\r\n                var initialSymbol = symbol;\r\n                var meaningToLook = meaning;\r\n                while (symbol) {\r\n                    // Symbol is accessible if it by itself is accessible\r\n                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaningToLook);\r\n                    if (accessibleSymbolChain) {\r\n                        var hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0]);\r\n                        if (!hasAccessibleDeclarations) {\r\n                            return {\r\n                                accessibility: SymbolAccessibility.NotAccessible,\r\n                                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),\r\n                                errorModuleName: symbol !== initialSymbol ? symbolToString(symbol, enclosingDeclaration, SymbolFlags.Namespace) : undefined,\r\n                            };\r\n                        }\r\n                        return { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible: hasAccessibleDeclarations.aliasesToMakeVisible };\r\n                    }\r\n\r\n                    // If we havent got the accessible symbol doesnt mean the symbol is actually inaccessible. \r\n                    // It could be qualified symbol and hence verify the path\r\n                    // eg:\r\n                    // module m {\r\n                    //     export class c {\r\n                    //     }\r\n                    // }\r\n                    // var x: typeof m.c\r\n                    // In the above example when we start with checking if typeof m.c symbol is accessible,\r\n                    // we are going to see if c can be accessed in scope directly. \r\n                    // But it cant, hence the accessible is going to be undefined, but that doesnt mean m.c is accessible\r\n                    // It is accessible if the parent m is accessible because then m.c can be accessed through qualification\r\n                    meaningToLook = getQualifiedLeftMeaning(meaning);\r\n                    symbol = getParentOfSymbol(symbol);\r\n                }\r\n\r\n                // This could be a symbol that is not exported in the external module \r\n                // or it could be a symbol from different external module that is not aliased and hence cannot be named\r\n                var symbolExternalModule = forEach(initialSymbol.declarations, declaration => getExternalModuleContainer(declaration));\r\n                if (symbolExternalModule) {\r\n                    var enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);\r\n                    if (symbolExternalModule !== enclosingExternalModule) {\r\n                        // name from different external module that is not visibile\r\n                        return {\r\n                            accessibility: SymbolAccessibility.CannotBeNamed,\r\n                            errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),\r\n                            errorModuleName: symbolToString(symbolExternalModule)\r\n                        };\r\n                    }\r\n                }\r\n\r\n                // Just a local name that is not accessible\r\n                return {\r\n                    accessibility: SymbolAccessibility.NotAccessible,\r\n                    errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),\r\n                };\r\n            }\r\n\r\n            return { accessibility: SymbolAccessibility.Accessible };\r\n\r\n            function getExternalModuleContainer(declaration: Declaration) {\r\n                for (; declaration; declaration = declaration.parent) {\r\n                    if (hasExternalModuleSymbol(declaration)) {\r\n                        return getSymbolOfNode(declaration);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function hasExternalModuleSymbol(declaration: Declaration) {\r\n            return (declaration.kind === SyntaxKind.ModuleDeclaration && declaration.name.kind === SyntaxKind.StringLiteral) ||\r\n                (declaration.kind === SyntaxKind.SourceFile && isExternalModule(<SourceFile>declaration));\r\n        }\r\n\r\n        function hasVisibleDeclarations(symbol: Symbol): { aliasesToMakeVisible?: ImportDeclaration[]; } {\r\n            var aliasesToMakeVisible: ImportDeclaration[];\r\n            if (forEach(symbol.declarations, declaration => !getIsDeclarationVisible(declaration))) {\r\n                return undefined;\r\n            }\r\n            return { aliasesToMakeVisible: aliasesToMakeVisible };\r\n\r\n            function getIsDeclarationVisible(declaration: Declaration) {\r\n                if (!isDeclarationVisible(declaration)) {\r\n                    // Mark the unexported alias as visible if its parent is visible \r\n                    // because these kind of aliases can be used to name types in declaration file\r\n                    if (declaration.kind === SyntaxKind.ImportDeclaration &&\r\n                        !(declaration.flags & NodeFlags.Export) &&\r\n                        isDeclarationVisible(declaration.parent)) {\r\n                        getNodeLinks(declaration).isVisible = true;\r\n                        if (aliasesToMakeVisible) {\r\n                            if (!contains(aliasesToMakeVisible, declaration)) {\r\n                                aliasesToMakeVisible.push(declaration);\r\n                            }\r\n                        }\r\n                        else {\r\n                            aliasesToMakeVisible = [declaration];\r\n                        }\r\n                        return true;\r\n                    }\r\n\r\n                    // Declaration is not visible\r\n                    return false;\r\n                }\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        function isImportDeclarationEntityNameReferenceDeclarationVisibile(entityName: EntityName): SymbolAccessiblityResult {\r\n            var firstIdentifier = getFirstIdentifier(entityName);\r\n            var firstIdentifierName = identifierToString(<Identifier>firstIdentifier);\r\n            var symbolOfNameSpace = resolveName(entityName.parent, (<Identifier>firstIdentifier).text, SymbolFlags.Namespace, Diagnostics.Cannot_find_name_0, firstIdentifierName);\r\n            // Verify if the symbol is accessible\r\n            var hasNamespaceDeclarationsVisibile = hasVisibleDeclarations(symbolOfNameSpace);\r\n            return hasNamespaceDeclarationsVisibile ?\r\n                { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible: hasNamespaceDeclarationsVisibile.aliasesToMakeVisible } :\r\n                { accessibility: SymbolAccessibility.NotAccessible, errorSymbolName: firstIdentifierName };\r\n        }\r\n\r\n        // Enclosing declaration is optional when we dont want to get qualified name in the enclosing declaration scope\r\n        // Meaning needs to be specified if the enclosing declaration is given\r\n        function symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags) {\r\n            function getSymbolName(symbol: Symbol) {\r\n                if (symbol.declarations && symbol.declarations.length > 0) {\r\n                    var declaration = symbol.declarations[0];\r\n                    if (declaration.name) {\r\n                        return identifierToString(declaration.name);\r\n                    }\r\n                }\r\n                return symbol.name;\r\n            }\r\n\r\n            // Get qualified name \r\n            if (enclosingDeclaration &&\r\n                // Properties/methods/Signatures/Constructors/TypeParameters do not need qualification\r\n                !(symbol.flags & SymbolFlags.PropertyOrAccessor & SymbolFlags.Signature & SymbolFlags.Constructor & SymbolFlags.Method & SymbolFlags.TypeParameter)) {\r\n                var symbolName: string;\r\n                while (symbol) {\r\n                    var isFirstName = !symbolName;\r\n                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning);\r\n\r\n                    var currentSymbolName: string;\r\n                    if (accessibleSymbolChain) {\r\n                        currentSymbolName = ts.map(accessibleSymbolChain, accessibleSymbol => getSymbolName(accessibleSymbol)).join(\".\");\r\n                    }\r\n                    else {\r\n                        // If we didnt find accessible symbol chain for this symbol, break if this is external module\r\n                        if (!isFirstName && ts.forEach(symbol.declarations, declaration => hasExternalModuleSymbol(declaration))) {\r\n                            break;\r\n                        }\r\n                        currentSymbolName = getSymbolName(symbol);\r\n                    }\r\n                    symbolName = currentSymbolName + (isFirstName ? \"\" : (\".\" + symbolName));\r\n                    if (accessibleSymbolChain && !needsQualification(accessibleSymbolChain[0], enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {\r\n                        break;\r\n                    }\r\n                    symbol = getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol);\r\n                    meaning = getQualifiedLeftMeaning(meaning);\r\n                }\r\n\r\n                return symbolName;\r\n            }\r\n\r\n            return getSymbolName(symbol);\r\n        }\r\n\r\n        function writeSymbolToTextWriter(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags, writer: TextWriter) {\r\n            writer.write(symbolToString(symbol, enclosingDeclaration, meaning));\r\n        }\r\n\r\n        function createSingleLineTextWriter() {\r\n            var result = \"\";\r\n            return {\r\n                write(s: string) { result += s; },\r\n                writeSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags) { writeSymbolToTextWriter(symbol, enclosingDeclaration, meaning, this); },\r\n                writeLine() { result += \" \"; },\r\n                increaseIndent() { },\r\n                decreaseIndent() { },\r\n                getText() { return result; }\r\n            };\r\n        }\r\n\r\n        function typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string {\r\n            var stringWriter = createSingleLineTextWriter();\r\n            // TODO(shkamat): typeToString should take enclosingDeclaration as input, once we have implemented enclosingDeclaration\r\n            writeTypeToTextWriter(type, enclosingDeclaration, flags, stringWriter);\r\n            return stringWriter.getText();\r\n        }\r\n\r\n        function writeTypeToTextWriter(type: Type, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: TextWriter) {\r\n            var typeStack: Type[];\r\n            return writeType(type, /*allowFunctionOrConstructorTypeLiteral*/ true);\r\n\r\n            function writeType(type: Type, allowFunctionOrConstructorTypeLiteral: boolean) {\r\n                if (type.flags & TypeFlags.Intrinsic) {\r\n                    writer.write((<IntrinsicType>type).intrinsicName);\r\n                }\r\n                else if (type.flags & TypeFlags.Reference) {\r\n                    writeTypeReference(<TypeReference>type);\r\n                }\r\n                else if (type.flags & (TypeFlags.Class | TypeFlags.Interface | TypeFlags.Enum | TypeFlags.TypeParameter)) {\r\n                    writer.writeSymbol(type.symbol, enclosingDeclaration, SymbolFlags.Type);\r\n                }\r\n                else if (type.flags & TypeFlags.Anonymous) {\r\n                    writeAnonymousType(<ObjectType>type, allowFunctionOrConstructorTypeLiteral);\r\n                }\r\n                else if (type.flags & TypeFlags.StringLiteral) {\r\n                    writer.write((<StringLiteralType>type).text);\r\n                }\r\n                else {\r\n                    // Should never get here\r\n                    writer.write(\"{ ... }\");\r\n                }\r\n            }\r\n\r\n            function writeTypeReference(type: TypeReference) {\r\n                if (type.target === globalArrayType && !(flags & TypeFormatFlags.WriteArrayAsGenericType)) {\r\n                    // If we are writing array element type the arrow style signatures are not allowed as \r\n                    // we need to surround it by curlies, eg. { (): T; }[]; as () => T[] would mean something different\r\n                    writeType(type.typeArguments[0], /*allowFunctionOrConstructorTypeLiteral*/ false);\r\n                    writer.write(\"[]\");\r\n                }\r\n                else {\r\n                    writer.writeSymbol(type.target.symbol, enclosingDeclaration, SymbolFlags.Type);\r\n                    writer.write(\"<\");\r\n                    for (var i = 0; i < type.typeArguments.length; i++) {\r\n                        if (i > 0) {\r\n                            writer.write(\", \");\r\n                        }\r\n                        writeType(type.typeArguments[i], /*allowFunctionOrConstructorTypeLiteral*/ true);\r\n                    }\r\n                    writer.write(\">\");\r\n                }\r\n            }\r\n\r\n            function writeAnonymousType(type: ObjectType, allowFunctionOrConstructorTypeLiteral: boolean) {\r\n                // Always use 'typeof T' for type of class, enum, and module objects\r\n                if (type.symbol && type.symbol.flags & (SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) {\r\n                    writeTypeofSymbol(type);\r\n                }\r\n                // Use 'typeof T' for types of functions and methods that circularly reference themselves\r\n                else if (shouldWriteTypeOfFunctionSymbol()) {\r\n                    writeTypeofSymbol(type);\r\n                }\r\n                else if (typeStack && contains(typeStack, type)) {\r\n                    // Recursive usage, use any\r\n                    writer.write(\"any\");\r\n                }\r\n                else {\r\n                    if (!typeStack) {\r\n                        typeStack = [];\r\n                    }\r\n                    typeStack.push(type);\r\n                    writeLiteralType(type, allowFunctionOrConstructorTypeLiteral);\r\n                    typeStack.pop();\r\n                }\r\n\r\n                function shouldWriteTypeOfFunctionSymbol() {\r\n                    if (type.symbol) {\r\n                        var isStaticMethodSymbol = !!(type.symbol.flags & SymbolFlags.Method &&  // typeof static method\r\n                            ts.forEach(type.symbol.declarations, declaration => declaration.flags & NodeFlags.Static));\r\n                        var isNonLocalFunctionSymbol = !!(type.symbol.flags & SymbolFlags.Function) &&\r\n                            (type.symbol.parent || // is exported function symbol\r\n                            ts.forEach(type.symbol.declarations, declaration =>\r\n                                declaration.parent.kind === SyntaxKind.SourceFile || declaration.parent.kind === SyntaxKind.ModuleBlock));\r\n\r\n                        if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {\r\n                            // typeof is allowed only for static/non local functions\r\n                            return !!(flags & TypeFormatFlags.UseTypeOfFunction) || // use typeof if format flags specify it\r\n                                (typeStack && contains(typeStack, type)); // it is type of the symbol uses itself recursively\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            function writeTypeofSymbol(type: ObjectType) {\r\n                writer.write(\"typeof \");\r\n                writer.writeSymbol(type.symbol, enclosingDeclaration, SymbolFlags.Value);\r\n            }\r\n\r\n            function writeLiteralType(type: ObjectType, allowFunctionOrConstructorTypeLiteral: boolean) {\r\n                var resolved = resolveObjectTypeMembers(type);\r\n                if (!resolved.properties.length && !resolved.stringIndexType && !resolved.numberIndexType) {\r\n                    if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {\r\n                        writer.write(\"{}\");\r\n                        return;\r\n                    }\r\n\r\n                    if (allowFunctionOrConstructorTypeLiteral) {\r\n                        if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {\r\n                            writeSignature(resolved.callSignatures[0], /*arrowStyle*/ true);\r\n                            return;\r\n                        }\r\n                        if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {\r\n                            writer.write(\"new \");\r\n                            writeSignature(resolved.constructSignatures[0], /*arrowStyle*/ true);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                writer.write(\"{\");\r\n                writer.writeLine();\r\n                writer.increaseIndent();\r\n                for (var i = 0; i < resolved.callSignatures.length; i++) {\r\n                    writeSignature(resolved.callSignatures[i]);\r\n                    writer.write(\";\");\r\n                    writer.writeLine();\r\n                }\r\n                for (var i = 0; i < resolved.constructSignatures.length; i++) {\r\n                    writer.write(\"new \");\r\n                    writeSignature(resolved.constructSignatures[i]);\r\n                    writer.write(\";\");\r\n                    writer.writeLine();\r\n                }\r\n                if (resolved.stringIndexType) {\r\n                    writer.write(\"[x: string]: \");\r\n                    writeType(resolved.stringIndexType, /*allowFunctionOrConstructorTypeLiteral*/ true);\r\n                    writer.write(\";\");\r\n                    writer.writeLine();\r\n                }\r\n                if (resolved.numberIndexType) {\r\n                    writer.write(\"[x: number]: \");\r\n                    writeType(resolved.numberIndexType, /*allowFunctionOrConstructorTypeLiteral*/ true);\r\n                    writer.write(\";\");\r\n                    writer.writeLine();\r\n                }\r\n                for (var i = 0; i < resolved.properties.length; i++) {\r\n                    var p = resolved.properties[i];\r\n                    var t = getTypeOfSymbol(p);\r\n                    if (p.flags & (SymbolFlags.Function | SymbolFlags.Method) && !getPropertiesOfType(t).length) {\r\n                        var signatures = getSignaturesOfType(t, SignatureKind.Call);\r\n                        for (var j = 0; j < signatures.length; j++) {\r\n                            writer.writeSymbol(p);\r\n                            if (isOptionalProperty(p)) {\r\n                                writer.write(\"?\");\r\n                            }\r\n                            writeSignature(signatures[j]);\r\n                            writer.write(\";\");\r\n                            writer.writeLine();\r\n                        }\r\n                    }\r\n                    else {\r\n                        writer.writeSymbol(p);\r\n                        if (isOptionalProperty(p)) {\r\n                            writer.write(\"?\");\r\n                        }\r\n                        writer.write(\": \");\r\n                        writeType(t, /*allowFunctionOrConstructorTypeLiteral*/ true);\r\n                        writer.write(\";\");\r\n                        writer.writeLine();\r\n                    }\r\n                }\r\n                writer.decreaseIndent();\r\n                writer.write(\"}\");\r\n            }\r\n\r\n            function writeSignature(signature: Signature, arrowStyle?: boolean) {\r\n                if (signature.typeParameters) {\r\n                    writer.write(\"<\");\r\n                    for (var i = 0; i < signature.typeParameters.length; i++) {\r\n                        if (i > 0) {\r\n                            writer.write(\", \");\r\n                        }\r\n                        var tp = signature.typeParameters[i];\r\n                        writer.writeSymbol(tp.symbol);\r\n                        var constraint = getConstraintOfTypeParameter(tp);\r\n                        if (constraint) {\r\n                            writer.write(\" extends \");\r\n                            writeType(constraint, /*allowFunctionOrConstructorTypeLiteral*/ true);\r\n                        }\r\n                    }\r\n                    writer.write(\">\");\r\n                }\r\n                writer.write(\"(\");\r\n                for (var i = 0; i < signature.parameters.length; i++) {\r\n                    if (i > 0) {\r\n                        writer.write(\", \");\r\n                    }\r\n                    var p = signature.parameters[i];\r\n                    if (getDeclarationFlagsFromSymbol(p) & NodeFlags.Rest) {\r\n                        writer.write(\"...\");\r\n                    }\r\n                    writer.writeSymbol(p);\r\n                    if (p.valueDeclaration.flags & NodeFlags.QuestionMark || (<VariableDeclaration>p.valueDeclaration).initializer) {\r\n                        writer.write(\"?\");\r\n                    }\r\n                    writer.write(\": \");\r\n                    writeType(getTypeOfSymbol(p), /*allowFunctionOrConstructorTypeLiteral*/ true);\r\n                }\r\n                writer.write(arrowStyle ? \") => \" : \"): \");\r\n                writeType(getReturnTypeOfSignature(signature), /*allowFunctionOrConstructorTypeLiteral*/ true);\r\n            }\r\n        }\r\n\r\n        function isDeclarationVisible(node: Declaration): boolean {\r\n            function getContainingExternalModule(node: Node) {\r\n                for (; node; node = node.parent) {\r\n                    if (node.kind === SyntaxKind.ModuleDeclaration) {\r\n                        if ((<ModuleDeclaration>node).name.kind === SyntaxKind.StringLiteral) {\r\n                            return node;\r\n                        }\r\n                    }\r\n                    else if (node.kind === SyntaxKind.SourceFile) {\r\n                        return isExternalModule(<SourceFile>node) ? node : undefined;\r\n                    }\r\n                }\r\n                Debug.fail(\"getContainingModule cant reach here\");\r\n            }\r\n\r\n            function isUsedInExportAssignment(node: Node) {\r\n                // Get source File and see if it is external module and has export assigned symbol\r\n                var externalModule = getContainingExternalModule(node);\r\n                if (externalModule) {\r\n                    // This is export assigned symbol node\r\n                    var externalModuleSymbol = getSymbolOfNode(externalModule);\r\n                    var exportAssignmentSymbol = getExportAssignmentSymbol(externalModuleSymbol);\r\n                    var resolvedExportSymbol: Symbol;\r\n                    var symbolOfNode = getSymbolOfNode(node);\r\n                    if (isSymbolUsedInExportAssignment(symbolOfNode)) {\r\n                        return true;\r\n                    }\r\n\r\n                    // if symbolOfNode is import declaration, resolve the symbol declaration and check\r\n                    if (symbolOfNode.flags & SymbolFlags.Import) {\r\n                        return isSymbolUsedInExportAssignment(resolveImport(symbolOfNode));\r\n                    }\r\n                }\r\n\r\n                // Check if the symbol is used in export assignment\r\n                function isSymbolUsedInExportAssignment(symbol: Symbol) {\r\n                    if (exportAssignmentSymbol === symbol) {\r\n                        return true;\r\n                    }\r\n\r\n                    if (exportAssignmentSymbol && !!(exportAssignmentSymbol.flags & SymbolFlags.Import)) {\r\n                        // if export assigned symbol is import declaration, resolve the import\r\n                        resolvedExportSymbol = resolvedExportSymbol || resolveImport(exportAssignmentSymbol);\r\n                        if (resolvedExportSymbol === symbol) {\r\n                            return true;\r\n                        }\r\n\r\n                        // Container of resolvedExportSymbol is visible\r\n                        return forEach(resolvedExportSymbol.declarations, declaration => {\r\n                            while (declaration) {\r\n                                if (declaration === node) {\r\n                                    return true;\r\n                                }\r\n                                declaration = declaration.parent;\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            function determineIfDeclarationIsVisible() {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.VariableDeclaration:\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.EnumDeclaration:\r\n                    case SyntaxKind.ImportDeclaration:\r\n                        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent\r\n                        var parent = node.kind === SyntaxKind.VariableDeclaration ? node.parent.parent : node.parent;\r\n                        // If the node is not exported or it is not ambient module element (except import declaration)\r\n                        if (!(node.flags & NodeFlags.Export) &&\r\n                            !(node.kind !== SyntaxKind.ImportDeclaration && parent.kind !== SyntaxKind.SourceFile && isInAmbientContext(parent))) {\r\n                            return isGlobalSourceFile(parent) || isUsedInExportAssignment(node);\r\n                        }\r\n                        // Exported members/ambient module elements (exception import declaraiton) are visible if parent is visible\r\n                        return isDeclarationVisible(parent);\r\n\r\n                    case SyntaxKind.Property:\r\n                    case SyntaxKind.Method:\r\n                        if (node.flags & NodeFlags.Private) {\r\n                            // Private properties/methods are not visible\r\n                            return false;\r\n                        }\r\n                    // Public properties/methods are visible if its parents are visible, so let it fall into next case statement\r\n\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.ConstructSignature:\r\n                    case SyntaxKind.CallSignature:\r\n                    case SyntaxKind.IndexSignature:\r\n                    case SyntaxKind.Parameter:\r\n                    case SyntaxKind.ModuleBlock:\r\n                        return isDeclarationVisible(node.parent);\r\n\r\n                    // Source file is always visible\r\n                    case SyntaxKind.SourceFile:\r\n                        return true;\r\n\r\n                    default:\r\n                        Debug.fail(\"isDeclarationVisible unknown: SyntaxKind: \" + SyntaxKind[node.kind]);\r\n                }\r\n            }\r\n\r\n            if (node) {\r\n                var links = getNodeLinks(node);\r\n                if (links.isVisible === undefined) {\r\n                    links.isVisible = !!determineIfDeclarationIsVisible();\r\n                }\r\n                return links.isVisible;\r\n            }\r\n        }\r\n\r\n        function getApparentType(type: Type): ApparentType {\r\n            if (type.flags & TypeFlags.TypeParameter) {\r\n                do {\r\n                    type = getConstraintOfTypeParameter(<TypeParameter>type);\r\n                } while (type && type.flags & TypeFlags.TypeParameter);\r\n                if (!type) type = emptyObjectType;\r\n            }\r\n            if (type.flags & TypeFlags.StringLike) {\r\n                type = globalStringType;\r\n            }\r\n            else if (type.flags & TypeFlags.NumberLike) {\r\n                type = globalNumberType;\r\n            }\r\n            else if (type.flags & TypeFlags.Boolean) {\r\n                type = globalBooleanType;\r\n            }\r\n            return <ApparentType>type;\r\n        }\r\n\r\n        function getTypeOfPrototypeProperty(prototype: Symbol): Type {\r\n            // TypeScript 1.0 spec (April 2014): 8.4\r\n            // Every class automatically contains a static property member named 'prototype', \r\n            // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.\r\n            // It is an error to explicitly declare a static property member with the name 'prototype'.\r\n            var classType = <InterfaceType>getDeclaredTypeOfSymbol(prototype.parent);\r\n            return classType.typeParameters ? createTypeReference(<GenericType>classType, map(classType.typeParameters, _ => anyType)) : classType;\r\n        }\r\n\r\n        function getTypeOfVariableDeclaration(declaration: VariableDeclaration): Type {\r\n            // A variable declared in a for..in statement is always of type any\r\n            if (declaration.parent.kind === SyntaxKind.ForInStatement) {\r\n                return anyType;\r\n            }\r\n            // Use type from type annotation if one is present\r\n            if (declaration.type) {\r\n                return getTypeFromTypeNode(declaration.type);\r\n            }\r\n            if (declaration.kind === SyntaxKind.Parameter) {\r\n                var func = <FunctionDeclaration>declaration.parent;\r\n                // For a parameter of a set accessor, use the type of the get accessor if one is present\r\n                if (func.kind === SyntaxKind.SetAccessor) {\r\n                    var getter = <AccessorDeclaration>getDeclarationOfKind(declaration.parent.symbol, SyntaxKind.GetAccessor);\r\n                    if (getter) {\r\n                        return getReturnTypeOfSignature(getSignatureFromDeclaration(getter));\r\n                    }\r\n                }\r\n                // Use contextual parameter type if one is available\r\n                var type = getContextuallyTypedParameterType(declaration);\r\n                if (type) {\r\n                    return type;\r\n                }\r\n            }\r\n            // Use the type of the initializer expression if one is present\r\n            if (declaration.initializer) {\r\n                var unwidenedType = checkAndMarkExpression(declaration.initializer);\r\n                var type = getWidenedType(unwidenedType);\r\n                if (type !== unwidenedType) {\r\n                    checkImplicitAny(type);\r\n                }\r\n                return type;\r\n            }\r\n            // Rest parameters default to type any[], other parameters default to type any\r\n            var type = declaration.flags & NodeFlags.Rest ? createArrayType(anyType) : anyType;\r\n            checkImplicitAny(type);\r\n            return type;\r\n\r\n            function checkImplicitAny(type: Type) {\r\n                if (!fullTypeCheck || !program.getCompilerOptions().noImplicitAny) {\r\n                    return;\r\n                }\r\n                // We need to have ended up with 'any', 'any[]', 'any[][]', etc.\r\n                if (getInnermostTypeOfNestedArrayTypes(type) !== anyType) {\r\n                    return;\r\n                }\r\n                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.\r\n                // (e.g. privates within .d.ts files do not expose type information)\r\n                if (isPrivateWithinAmbient(declaration) || (declaration.kind === SyntaxKind.Parameter && isPrivateWithinAmbient(declaration.parent))) {\r\n                    return;\r\n                }\r\n                switch (declaration.kind) {\r\n                    case SyntaxKind.Property:\r\n                        var diagnostic = Diagnostics.Member_0_implicitly_has_an_1_type;\r\n                        break;\r\n                    case SyntaxKind.Parameter:\r\n                        var diagnostic = declaration.flags & NodeFlags.Rest ?\r\n                            Diagnostics.Rest_parameter_0_implicitly_has_an_any_type :\r\n                            Diagnostics.Parameter_0_implicitly_has_an_1_type;\r\n                        break;\r\n                    default:\r\n                        var diagnostic = Diagnostics.Variable_0_implicitly_has_an_1_type;\r\n                }\r\n                error(declaration, diagnostic, identifierToString(declaration.name), typeToString(type));\r\n            }\r\n        }\r\n\r\n        function getTypeOfVariableOrParameterOrProperty(symbol: Symbol): Type {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.type) {\r\n                // Handle prototype property\r\n                if (symbol.flags & SymbolFlags.Prototype) {\r\n                    return links.type = getTypeOfPrototypeProperty(symbol);\r\n                }\r\n                // Handle catch clause variables\r\n                var declaration = symbol.valueDeclaration;\r\n                if (declaration.kind === SyntaxKind.CatchBlock) {\r\n                    return links.type = anyType;\r\n                }\r\n                // Handle variable, parameter or property\r\n                links.type = resolvingType;\r\n                var type = getTypeOfVariableDeclaration(<VariableDeclaration>declaration);\r\n                if (links.type === resolvingType) {\r\n                    links.type = type;\r\n                }\r\n            }\r\n            else if (links.type === resolvingType) {\r\n                links.type = anyType;\r\n            }\r\n            return links.type;\r\n        }\r\n\r\n        function getSetAccessorTypeAnnotationNode(accessor: AccessorDeclaration): TypeNode {\r\n            return accessor && accessor.parameters.length > 0 && accessor.parameters[0].type;\r\n        }\r\n\r\n        function getAnnotatedAccessorType(accessor: AccessorDeclaration): Type {\r\n            if (accessor) {\r\n                if (accessor.kind === SyntaxKind.GetAccessor) {\r\n                    return accessor.type && getTypeFromTypeNode(accessor.type);\r\n                }\r\n                else {\r\n                    var setterTypeAnnotation = getSetAccessorTypeAnnotationNode(accessor);\r\n                    return setterTypeAnnotation && getTypeFromTypeNode(setterTypeAnnotation);\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getTypeOfAccessors(symbol: Symbol): Type {\r\n            var links = getSymbolLinks(symbol);\r\n            checkAndStoreTypeOfAccessors(symbol, links);\r\n            return links.type;\r\n        }\r\n\r\n        function checkAndStoreTypeOfAccessors(symbol: Symbol, links?: SymbolLinks) {\r\n            links = links || getSymbolLinks(symbol);\r\n            if (!links.type) {\r\n                links.type = resolvingType;\r\n                var getter = <AccessorDeclaration>getDeclarationOfKind(symbol, SyntaxKind.GetAccessor);\r\n                var setter = <AccessorDeclaration>getDeclarationOfKind(symbol, SyntaxKind.SetAccessor);\r\n\r\n                var type: Type;\r\n\r\n                // First try to see if the user specified a return type on the get-accessor.\r\n                var getterReturnType = getAnnotatedAccessorType(getter);\r\n                if (getterReturnType) {\r\n                    type = getterReturnType;\r\n                }\r\n                else {\r\n                    // If the user didn't specify a return type, try to use the set-accessor's parameter type.\r\n                    var setterParameterType = getAnnotatedAccessorType(setter);\r\n                    if (setterParameterType) {\r\n                        type = setterParameterType;\r\n                    }\r\n                    else {\r\n                        // If there are no specified types, try to infer it from the body of the get accessor if it exists.\r\n                        if (getter) {\r\n                            type = getReturnTypeFromBody(getter);\r\n                        }\r\n                        // Otherwise, fall back to 'any'.\r\n                        else {\r\n                            if (program.getCompilerOptions().noImplicitAny) {\r\n                                error(setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation, symbol.name);\r\n                            }\r\n\r\n                            type = anyType;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (links.type === resolvingType) {\r\n                    links.type = type;\r\n                }\r\n            }\r\n            else if (links.type === resolvingType) {\r\n                links.type = anyType;\r\n            }\r\n        }\r\n\r\n        function getTypeOfFuncClassEnumModule(symbol: Symbol): Type {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.type) {\r\n                links.type = createObjectType(TypeFlags.Anonymous, symbol);\r\n            }\r\n            return links.type;\r\n        }\r\n\r\n        function getTypeOfEnumMember(symbol: Symbol): Type {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.type) {\r\n                links.type = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));\r\n            }\r\n            return links.type;\r\n        }\r\n\r\n        function getTypeOfImport(symbol: Symbol): Type {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.type) {\r\n                links.type = getTypeOfSymbol(resolveImport(symbol));\r\n            }\r\n            return links.type;\r\n        }\r\n\r\n        function getTypeOfInstantiatedSymbol(symbol: Symbol): Type {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.type) {\r\n                links.type = instantiateType(getTypeOfSymbol(links.target), links.mapper);\r\n            }\r\n            return links.type;\r\n        }\r\n\r\n        function getTypeOfSymbol(symbol: Symbol): Type {\r\n            if (symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property)) {\r\n                return getTypeOfVariableOrParameterOrProperty(symbol);\r\n            }\r\n            if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) {\r\n                return getTypeOfFuncClassEnumModule(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.EnumMember) {\r\n                return getTypeOfEnumMember(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.Accessor) {\r\n                return getTypeOfAccessors(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.Import) {\r\n                return getTypeOfImport(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.Instantiated) {\r\n                return getTypeOfInstantiatedSymbol(symbol);\r\n            }\r\n            return unknownType;\r\n        }\r\n\r\n        function getTargetType(type: ObjectType): Type {\r\n            return type.flags & TypeFlags.Reference ? (<TypeReference>type).target : type;\r\n        }\r\n\r\n        function hasBaseType(type: InterfaceType, checkBase: InterfaceType) {\r\n            return check(type);\r\n            function check(type: InterfaceType) {\r\n                var target = <InterfaceType>getTargetType(type);\r\n                return target === checkBase || forEach(target.baseTypes, check);\r\n            }\r\n        }\r\n\r\n        // Return combined list of type parameters from all declarations of a class or interface. Elsewhere we check they're all\r\n        // the same, but even if they're not we still need the complete list to ensure instantiations supply type arguments\r\n        // for all type parameters.\r\n        function getTypeParametersOfClassOrInterface(symbol: Symbol): TypeParameter[] {\r\n            var result: TypeParameter[];\r\n            forEach(symbol.declarations, node => {\r\n                if (node.kind === SyntaxKind.InterfaceDeclaration || node.kind === SyntaxKind.ClassDeclaration) {\r\n                    var declaration = <InterfaceDeclaration>node;\r\n                    if (declaration.typeParameters && declaration.typeParameters.length) {\r\n                        forEach(declaration.typeParameters, node => {\r\n                            var tp = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));\r\n                            if (!result) {\r\n                                result = [tp];\r\n                            }\r\n                            else if (!contains(result, tp)) {\r\n                                result.push(tp);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n            return result;\r\n        }\r\n\r\n        function getDeclaredTypeOfClass(symbol: Symbol): InterfaceType {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.declaredType) {\r\n                var type = links.declaredType = <InterfaceType>createObjectType(TypeFlags.Class, symbol);\r\n                var typeParameters = getTypeParametersOfClassOrInterface(symbol);\r\n                if (typeParameters) {\r\n                    type.flags |= TypeFlags.Reference;\r\n                    type.typeParameters = typeParameters;\r\n                    (<GenericType>type).instantiations = {};\r\n                    (<GenericType>type).instantiations[getTypeListId(type.typeParameters)] = <GenericType>type;\r\n                    (<GenericType>type).target = <GenericType>type;\r\n                    (<GenericType>type).typeArguments = type.typeParameters;\r\n                }\r\n                type.baseTypes = [];\r\n                var declaration = <ClassDeclaration>getDeclarationOfKind(symbol, SyntaxKind.ClassDeclaration);\r\n                if (declaration.baseType) {\r\n                    var baseType = getTypeFromTypeReferenceNode(declaration.baseType);\r\n                    if (baseType !== unknownType) {\r\n                        if (getTargetType(baseType).flags & TypeFlags.Class) {\r\n                            if (type !== baseType && !hasBaseType(<InterfaceType>baseType, type)) {\r\n                                type.baseTypes.push(baseType);\r\n                            }\r\n                            else {\r\n                                error(declaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType));\r\n                            }\r\n                        }\r\n                        else {\r\n                            error(declaration.baseType, Diagnostics.A_class_may_only_extend_another_class);\r\n                        }\r\n                    }\r\n                }\r\n                type.declaredProperties = getNamedMembers(symbol.members);\r\n                type.declaredCallSignatures = emptyArray;\r\n                type.declaredConstructSignatures = emptyArray;\r\n                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, IndexKind.String);\r\n                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, IndexKind.Number);\r\n            }\r\n            return <InterfaceType>links.declaredType;\r\n        }\r\n\r\n        function getDeclaredTypeOfInterface(symbol: Symbol): InterfaceType {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.declaredType) {\r\n                var type = links.declaredType = <InterfaceType>createObjectType(TypeFlags.Interface, symbol);\r\n                var typeParameters = getTypeParametersOfClassOrInterface(symbol);\r\n                if (typeParameters) {\r\n                    type.flags |= TypeFlags.Reference;\r\n                    type.typeParameters = typeParameters;\r\n                    (<GenericType>type).instantiations = {};\r\n                    (<GenericType>type).instantiations[getTypeListId(type.typeParameters)] = <GenericType>type;\r\n                    (<GenericType>type).target = <GenericType>type;\r\n                    (<GenericType>type).typeArguments = type.typeParameters;\r\n                }\r\n                type.baseTypes = [];\r\n                forEach(symbol.declarations, declaration => {\r\n                    if (declaration.kind === SyntaxKind.InterfaceDeclaration && (<InterfaceDeclaration>declaration).baseTypes) {\r\n                        forEach((<InterfaceDeclaration>declaration).baseTypes, node => {\r\n                            var baseType = getTypeFromTypeReferenceNode(node);\r\n                            if (baseType !== unknownType) {\r\n                                if (getTargetType(baseType).flags & (TypeFlags.Class | TypeFlags.Interface)) {\r\n                                    if (type !== baseType && !hasBaseType(<InterfaceType>baseType, type)) {\r\n                                        type.baseTypes.push(baseType);\r\n                                    }\r\n                                    else {\r\n                                        error(declaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    error(node, Diagnostics.An_interface_may_only_extend_a_class_or_another_interface);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                type.declaredProperties = getNamedMembers(symbol.members);\r\n                type.declaredCallSignatures = getSignaturesOfSymbol(symbol.members[\"__call\"]);\r\n                type.declaredConstructSignatures = getSignaturesOfSymbol(symbol.members[\"__new\"]);\r\n                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, IndexKind.String);\r\n                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, IndexKind.Number);\r\n            }\r\n            return <InterfaceType>links.declaredType;\r\n        }\r\n\r\n        function getDeclaredTypeOfEnum(symbol: Symbol): Type {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.declaredType) {\r\n                var type = createType(TypeFlags.Enum);\r\n                type.symbol = symbol;\r\n                links.declaredType = type;\r\n            }\r\n            return links.declaredType;\r\n        }\r\n\r\n        function getDeclaredTypeOfTypeParameter(symbol: Symbol): TypeParameter {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.declaredType) {\r\n                var type = <TypeParameter>createType(TypeFlags.TypeParameter);\r\n                type.symbol = symbol;\r\n                if (!(<TypeParameterDeclaration>getDeclarationOfKind(symbol, SyntaxKind.TypeParameter)).constraint) {\r\n                    type.constraint = noConstraintType;\r\n                }\r\n                links.declaredType = type;\r\n            }\r\n            return <TypeParameter>links.declaredType;\r\n        }\r\n\r\n        function getDeclaredTypeOfImport(symbol: Symbol): Type {\r\n            var links = getSymbolLinks(symbol);\r\n            if (!links.declaredType) {\r\n                links.declaredType = getDeclaredTypeOfSymbol(resolveImport(symbol));\r\n            }\r\n            return links.declaredType;\r\n        }\r\n\r\n        function getDeclaredTypeOfSymbol(symbol: Symbol): Type {\r\n            if (symbol.flags & SymbolFlags.Class) {\r\n                return getDeclaredTypeOfClass(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.Interface) {\r\n                return getDeclaredTypeOfInterface(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.Enum) {\r\n                return getDeclaredTypeOfEnum(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.TypeParameter) {\r\n                return getDeclaredTypeOfTypeParameter(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.Import) {\r\n                return getDeclaredTypeOfImport(symbol);\r\n            }\r\n            Debug.assert((symbol.flags & SymbolFlags.Instantiated) === 0);\r\n            return unknownType;\r\n        }\r\n\r\n        function createSymbolTable(symbols: Symbol[]): SymbolTable {\r\n            var result: SymbolTable = {};\r\n            for (var i = 0; i < symbols.length; i++) {\r\n                var symbol = symbols[i];\r\n                result[symbol.name] = symbol;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function createInstantiatedSymbolTable(symbols: Symbol[], mapper: TypeMapper): SymbolTable {\r\n            var result: SymbolTable = {};\r\n            for (var i = 0; i < symbols.length; i++) {\r\n                var symbol = symbols[i];\r\n                result[symbol.name] = instantiateSymbol(symbol, mapper);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function addInheritedMembers(symbols: SymbolTable, baseSymbols: Symbol[]) {\r\n            for (var i = 0; i < baseSymbols.length; i++) {\r\n                var s = baseSymbols[i];\r\n                if (!hasProperty(symbols, s.name)) {\r\n                    symbols[s.name] = s;\r\n                }\r\n            }\r\n        }\r\n\r\n        function addInheritedSignatures(signatures: Signature[], baseSignatures: Signature[]) {\r\n            if (baseSignatures) {\r\n                for (var i = 0; i < baseSignatures.length; i++) {\r\n                    signatures.push(baseSignatures[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        function resolveClassOrInterfaceMembers(type: InterfaceType): void {\r\n            var members = type.symbol.members;\r\n            var callSignatures = type.declaredCallSignatures;\r\n            var constructSignatures = type.declaredConstructSignatures;\r\n            var stringIndexType = type.declaredStringIndexType;\r\n            var numberIndexType = type.declaredNumberIndexType;\r\n            if (type.baseTypes.length) {\r\n                members = createSymbolTable(type.declaredProperties);\r\n                forEach(type.baseTypes, baseType => {\r\n                    addInheritedMembers(members, getPropertiesOfType(baseType));\r\n                    callSignatures = concatenate(callSignatures, getSignaturesOfType(baseType, SignatureKind.Call));\r\n                    constructSignatures = concatenate(constructSignatures, getSignaturesOfType(baseType, SignatureKind.Construct));\r\n                    stringIndexType = stringIndexType || getIndexTypeOfType(baseType, IndexKind.String);\r\n                    numberIndexType = numberIndexType || getIndexTypeOfType(baseType, IndexKind.Number);\r\n                });\r\n            }\r\n            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\r\n        }\r\n\r\n        function resolveTypeReferenceMembers(type: TypeReference): void {\r\n            var target = type.target;\r\n            var mapper = createTypeMapper(target.typeParameters, type.typeArguments);\r\n            var members = createInstantiatedSymbolTable(target.declaredProperties, mapper);\r\n            var callSignatures = instantiateList(target.declaredCallSignatures, mapper, instantiateSignature);\r\n            var constructSignatures = instantiateList(target.declaredConstructSignatures, mapper, instantiateSignature);\r\n            var stringIndexType = target.declaredStringIndexType ? instantiateType(target.declaredStringIndexType, mapper) : undefined;\r\n            var numberIndexType = target.declaredNumberIndexType ? instantiateType(target.declaredNumberIndexType, mapper) : undefined;\r\n            forEach(target.baseTypes, baseType => {\r\n                var instantiatedBaseType = instantiateType(baseType, mapper);\r\n                addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));\r\n                callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Call));\r\n                constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Construct));\r\n                stringIndexType = stringIndexType || getIndexTypeOfType(instantiatedBaseType, IndexKind.String);\r\n                numberIndexType = numberIndexType || getIndexTypeOfType(instantiatedBaseType, IndexKind.Number);\r\n            });\r\n            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\r\n        }\r\n\r\n        function createSignature(declaration: SignatureDeclaration, typeParameters: TypeParameter[], parameters: Symbol[],\r\n            resolvedReturnType: Type, minArgumentCount: number, hasRestParameter: boolean, hasStringLiterals: boolean): Signature {\r\n            var sig = new Signature(checker);\r\n            sig.declaration = declaration;\r\n            sig.typeParameters = typeParameters;\r\n            sig.parameters = parameters;\r\n            sig.resolvedReturnType = resolvedReturnType;\r\n            sig.minArgumentCount = minArgumentCount;\r\n            sig.hasRestParameter = hasRestParameter;\r\n            sig.hasStringLiterals = hasStringLiterals;\r\n            return sig;\r\n        }\r\n\r\n        function cloneSignature(sig: Signature): Signature {\r\n            return createSignature(sig.declaration, sig.typeParameters, sig.parameters, sig.resolvedReturnType,\r\n                sig.minArgumentCount, sig.hasRestParameter, sig.hasStringLiterals);\r\n        }\r\n\r\n        function getDefaultConstructSignatures(classType: InterfaceType): Signature[] {\r\n            if (classType.baseTypes.length) {\r\n                var baseType = classType.baseTypes[0];\r\n                var baseSignatures = getSignaturesOfType(getTypeOfSymbol(baseType.symbol), SignatureKind.Construct);\r\n                return map(baseSignatures, baseSignature => {\r\n                    var signature = baseType.flags & TypeFlags.Reference ?\r\n                        getSignatureInstantiation(baseSignature, (<TypeReference>baseType).typeArguments) : cloneSignature(baseSignature);\r\n                    signature.typeParameters = classType.typeParameters;\r\n                    signature.resolvedReturnType = classType;\r\n                    return signature;\r\n                });\r\n            }\r\n            return [createSignature(undefined, classType.typeParameters, emptyArray, classType, 0, false, false)];\r\n        }\r\n\r\n        function resolveAnonymousTypeMembers(type: ObjectType) {\r\n            var symbol = type.symbol;\r\n            var members = emptySymbols;\r\n            var callSignatures = emptyArray;\r\n            var constructSignatures = emptyArray;\r\n            if (symbol.flags & SymbolFlags.HasExports) {\r\n                members = symbol.exports;\r\n            }\r\n            if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method)) {\r\n                callSignatures = getSignaturesOfSymbol(symbol);\r\n            }\r\n            if (symbol.flags & SymbolFlags.Class) {\r\n                var classType = getDeclaredTypeOfClass(symbol);\r\n                constructSignatures = getSignaturesOfSymbol(symbol.members[\"__constructor\"]);\r\n                if (!constructSignatures.length) constructSignatures = getDefaultConstructSignatures(classType);\r\n                if (classType.baseTypes.length) {\r\n                    var members = createSymbolTable(getNamedMembers(members));\r\n                    addInheritedMembers(members, getPropertiesOfType(getTypeOfSymbol(classType.baseTypes[0].symbol)));\r\n                }\r\n            }\r\n            var numberIndexType = (symbol.flags & SymbolFlags.Enum) ? stringType : undefined;\r\n\r\n            setObjectTypeMembers(type, members, callSignatures, constructSignatures, /* stringIndexType */ undefined, numberIndexType);\r\n        }\r\n\r\n        function resolveObjectTypeMembers(type: ObjectType): ResolvedObjectType {\r\n            if (!(<ResolvedObjectType>type).members) {\r\n                if (type.flags & (TypeFlags.Class | TypeFlags.Interface)) {\r\n                    resolveClassOrInterfaceMembers(<InterfaceType>type);\r\n                }\r\n                else if (type.flags & TypeFlags.Anonymous) {\r\n                    resolveAnonymousTypeMembers(<ObjectType>type);\r\n                }\r\n                else {\r\n                    resolveTypeReferenceMembers(<TypeReference>type);\r\n                }\r\n            }\r\n            return <ResolvedObjectType>type;\r\n        }\r\n\r\n        function getPropertiesOfType(type: Type): Symbol[] {\r\n            if (type.flags & TypeFlags.ObjectType) {\r\n                return resolveObjectTypeMembers(<ObjectType>type).properties;\r\n            }\r\n            return emptyArray;\r\n        }\r\n\r\n        function getPropertyOfType(type: Type, name: string): Symbol {\r\n            if (type.flags & TypeFlags.ObjectType) {\r\n                var resolved = resolveObjectTypeMembers(<ObjectType>type);\r\n                if (hasProperty(resolved.members, name)) {\r\n                    var symbol = resolved.members[name];\r\n                    if (symbolIsValue(symbol)) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function getPropertyOfApparentType(type: ApparentType, name: string): Symbol {\r\n            if (type.flags & TypeFlags.ObjectType) {\r\n                var resolved = resolveObjectTypeMembers(<ObjectType>type);\r\n                if (hasProperty(resolved.members, name)) {\r\n                    var symbol = resolved.members[name];\r\n                    if (symbolIsValue(symbol)) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n                if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {\r\n                    var symbol = getPropertyOfType(globalFunctionType, name);\r\n                    if (symbol) return symbol;\r\n                }\r\n                return getPropertyOfType(globalObjectType, name);\r\n            }\r\n        }\r\n\r\n        function getSignaturesOfType(type: Type, kind: SignatureKind): Signature[] {\r\n            if (type.flags & TypeFlags.ObjectType) {\r\n                var resolved = resolveObjectTypeMembers(<ObjectType>type);\r\n                return kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures;\r\n            }\r\n            return emptyArray;\r\n        }\r\n\r\n        function getIndexTypeOfType(type: Type, kind: IndexKind): Type {\r\n            if (type.flags & TypeFlags.ObjectType) {\r\n                var resolved = resolveObjectTypeMembers(<ObjectType>type);\r\n                return kind === IndexKind.String ? resolved.stringIndexType : resolved.numberIndexType;\r\n            }\r\n        }\r\n\r\n        // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual\r\n        // type checking functions).\r\n        function getTypeParametersFromDeclaration(typeParameterDeclarations: TypeParameterDeclaration[]): TypeParameter[] {\r\n            var result: TypeParameter[] = [];\r\n            forEach(typeParameterDeclarations, node => {\r\n                var tp = getDeclaredTypeOfTypeParameter(node.symbol);\r\n                if (!contains(result, tp)) {\r\n                    result.push(tp);\r\n                }\r\n            });\r\n            return result;\r\n        }\r\n\r\n        function getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature {\r\n            var links = getNodeLinks(declaration);\r\n            if (!links.resolvedSignature) {\r\n                var classType = declaration.kind === SyntaxKind.Constructor ? getDeclaredTypeOfClass((<ClassDeclaration>declaration.parent).symbol) : undefined;\r\n                var typeParameters = classType ? classType.typeParameters :\r\n                    declaration.typeParameters ? getTypeParametersFromDeclaration(declaration.typeParameters) : undefined;\r\n                var parameters: Symbol[] = [];\r\n                var hasStringLiterals = false;\r\n                var minArgumentCount = -1;\r\n                for (var i = 0, n = declaration.parameters.length; i < n; i++) {\r\n                    var param = declaration.parameters[i];\r\n                    parameters.push(param.symbol);\r\n                    if (param.type && param.type.kind === SyntaxKind.StringLiteral) {\r\n                        hasStringLiterals = true;\r\n                    }\r\n                    if (minArgumentCount < 0) {\r\n                        if (param.initializer || param.flags & (NodeFlags.QuestionMark | NodeFlags.Rest)) {\r\n                            minArgumentCount = i;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (minArgumentCount < 0) {\r\n                    minArgumentCount = declaration.parameters.length;\r\n                }\r\n\r\n                var returnType: Type;\r\n                if (classType) {\r\n                    returnType = classType;\r\n                }\r\n                else if (declaration.type) {\r\n                    returnType = getTypeFromTypeNode(declaration.type);\r\n                }\r\n                else {\r\n                    // TypeScript 1.0 spec (April 2014):\r\n                    // If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.\r\n                    if (declaration.kind === SyntaxKind.GetAccessor) {\r\n                        var setter = <AccessorDeclaration>getDeclarationOfKind(declaration.symbol, SyntaxKind.SetAccessor);\r\n                        returnType = getAnnotatedAccessorType(setter);\r\n                    }\r\n\r\n                    if (!returnType && !(<FunctionDeclaration>declaration).body) {\r\n                        returnType = anyType;\r\n                    }\r\n                }\r\n\r\n                links.resolvedSignature = createSignature(declaration, typeParameters, parameters, returnType,\r\n                    minArgumentCount, hasRestParameters(declaration), hasStringLiterals);\r\n            }\r\n            return links.resolvedSignature;\r\n        }\r\n\r\n        function getSignaturesOfSymbol(symbol: Symbol): Signature[] {\r\n            if (!symbol) return emptyArray;\r\n            var result: Signature[] = [];\r\n            for (var i = 0, len = symbol.declarations.length; i < len; i++) {\r\n                var node = symbol.declarations[i];\r\n                switch (node.kind) {\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.Method:\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.CallSignature:\r\n                    case SyntaxKind.ConstructSignature:\r\n                    case SyntaxKind.IndexSignature:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.ArrowFunction:\r\n                        // Don't include signature if node is the implementation of an overloaded function. A node is considered\r\n                        // an implementation node if it has a body and the previous node is of the same kind and immediately\r\n                        // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).\r\n                        if (i > 0 && (<FunctionDeclaration>node).body) {\r\n                            var previous = symbol.declarations[i - 1];\r\n                            if (node.parent === previous.parent && node.kind === previous.kind && node.pos === previous.end) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        result.push(getSignatureFromDeclaration(<SignatureDeclaration>node));\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function getReturnTypeOfSignature(signature: Signature): Type {\r\n            if (!signature.resolvedReturnType) {\r\n                signature.resolvedReturnType = resolvingType;\r\n                if (signature.target) {\r\n                    var type = instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper);\r\n                }\r\n                else {\r\n                    var type = getReturnTypeFromBody(<FunctionDeclaration>signature.declaration);\r\n                }\r\n                if (signature.resolvedReturnType === resolvingType) {\r\n                    signature.resolvedReturnType = type;\r\n                }\r\n            }\r\n            else if (signature.resolvedReturnType === resolvingType) {\r\n                signature.resolvedReturnType = anyType;\r\n            }\r\n            return signature.resolvedReturnType;\r\n        }\r\n\r\n        function getRestTypeOfSignature(signature: Signature): Type {\r\n            if (signature.hasRestParameter) {\r\n                var type = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);\r\n                if (type.flags & TypeFlags.Reference && (<TypeReference>type).target === globalArrayType) {\r\n                    return (<TypeReference>type).typeArguments[0];\r\n                }\r\n            }\r\n            return anyType;\r\n        }\r\n\r\n        function getSignatureInstantiation(signature: Signature, typeArguments: Type[]): Signature {\r\n            return instantiateSignature(signature, createTypeMapper(signature.typeParameters, typeArguments), true);\r\n        }\r\n\r\n        function getErasedSignature(signature: Signature): Signature {\r\n            if (!signature.typeParameters) return signature;\r\n            if (!signature.erasedSignatureCache) {\r\n                if (signature.target) {\r\n                    signature.erasedSignatureCache = instantiateSignature(getErasedSignature(signature.target), signature.mapper);\r\n                }\r\n                else {\r\n                    signature.erasedSignatureCache = instantiateSignature(signature, createTypeEraser(signature.typeParameters), true);\r\n                }\r\n            }\r\n            return signature.erasedSignatureCache;\r\n        }\r\n\r\n        function getOrCreateTypeFromSignature(signature: Signature): ObjectType {\r\n            // There are two ways to declare a construct signature, one is by declaring a class constructor\r\n            // using the constructor keyword, and the other is declaring a bare construct signature in an\r\n            // object type literal or interface (using the new keyword). Each way of declaring a constructor\r\n            // will result in a different declaration kind.\r\n            if (!signature.isolatedSignatureType) {\r\n                var isConstructor = signature.declaration.kind === SyntaxKind.Constructor || signature.declaration.kind === SyntaxKind.ConstructSignature;\r\n                var type = <ResolvedObjectType>createObjectType(TypeFlags.Anonymous | TypeFlags.FromSignature);\r\n                type.members = emptySymbols;\r\n                type.properties = emptyArray;\r\n                type.callSignatures = !isConstructor ? [signature] : emptyArray;\r\n                type.constructSignatures = isConstructor ? [signature] : emptyArray;\r\n                signature.isolatedSignatureType = type;\r\n            }\r\n\r\n            return signature.isolatedSignatureType;\r\n        }\r\n\r\n        function getIndexSymbol(symbol: Symbol): Symbol {\r\n            return symbol.members[\"__index\"];\r\n        }\r\n\r\n        function getIndexDeclarationOfSymbol(symbol: Symbol, kind: IndexKind): SignatureDeclaration {\r\n            var syntaxKind = kind === IndexKind.Number ? SyntaxKind.NumberKeyword : SyntaxKind.StringKeyword;\r\n            var indexSymbol = getIndexSymbol(symbol);\r\n            if (indexSymbol) {\r\n                var len = indexSymbol.declarations.length;\r\n                for (var i = 0; i < len; i++) {\r\n                    var node = <SignatureDeclaration>indexSymbol.declarations[i];\r\n                    if (node.parameters.length === 1) {\r\n                        var parameter = node.parameters[0];\r\n                        if (parameter && parameter.type && parameter.type.kind === syntaxKind) {\r\n                            return node;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function getIndexTypeOfSymbol(symbol: Symbol, kind: IndexKind): Type {\r\n            var declaration = getIndexDeclarationOfSymbol(symbol, kind);\r\n            return declaration\r\n                ? declaration.type ? getTypeFromTypeNode(declaration.type) : anyType\r\n                : undefined;\r\n        }\r\n\r\n        function getConstraintOfTypeParameter(type: TypeParameter): Type {\r\n            if (!type.constraint) {\r\n                if (type.target) {\r\n                    var targetConstraint = getConstraintOfTypeParameter(type.target);\r\n                    type.constraint = targetConstraint ? instantiateType(targetConstraint, type.mapper) : noConstraintType;\r\n                }\r\n                else {\r\n                    type.constraint = getTypeFromTypeNode((<TypeParameterDeclaration>getDeclarationOfKind(type.symbol, SyntaxKind.TypeParameter)).constraint);\r\n                }\r\n            }\r\n            return type.constraint === noConstraintType ? undefined : type.constraint;\r\n        }\r\n\r\n        function getTypeListId(types: Type[]) {\r\n            switch (types.length) {\r\n                case 1:\r\n                    return \"\" + types[0].id;\r\n                case 2:\r\n                    return types[0].id + \",\" + types[1].id;\r\n                default:\r\n                    var result = \"\";\r\n                    for (var i = 0; i < types.length; i++) {\r\n                        if (i > 0) result += \",\";\r\n                        result += types[i].id;\r\n                    }\r\n                    return result;\r\n            }\r\n        }\r\n\r\n        function createTypeReference(target: GenericType, typeArguments: Type[]): TypeReference {\r\n            var id = getTypeListId(typeArguments);\r\n            var type = target.instantiations[id];\r\n            if (!type) {\r\n                type = target.instantiations[id] = <TypeReference>createObjectType(TypeFlags.Reference, target.symbol);\r\n                type.target = target;\r\n                type.typeArguments = typeArguments;\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function isTypeParameterReferenceIllegalInConstraint(typeReferenceNode: TypeReferenceNode, typeParameterSymbol: Symbol): boolean {\r\n            var links = getNodeLinks(typeReferenceNode);\r\n            if (links.isIllegalTypeReferenceInConstraint !== undefined) {\r\n                return links.isIllegalTypeReferenceInConstraint;\r\n            }\r\n\r\n            // bubble up to the declaration\r\n            var currentNode: Node = typeReferenceNode;\r\n            // forEach === exists\r\n            while (!forEach(typeParameterSymbol.declarations, d => d.parent === currentNode.parent)) {\r\n                currentNode = currentNode.parent;\r\n            }\r\n            // if last step was made from the type parameter this means that path has started somewhere in constraint which is illegal\r\n            links.isIllegalTypeReferenceInConstraint = currentNode.kind === SyntaxKind.TypeParameter;\r\n            return links.isIllegalTypeReferenceInConstraint;\r\n        }\r\n\r\n        function checkTypeParameterHasIllegalReferencesInConstraint(typeParameter: TypeParameterDeclaration): void {\r\n            var typeParameterSymbol: Symbol;\r\n            function check(n: Node): void {\r\n                if (n.kind === SyntaxKind.TypeReference && (<TypeReferenceNode>n).typeName.kind === SyntaxKind.Identifier) {\r\n                    var links = getNodeLinks(n);\r\n                    if (links.isIllegalTypeReferenceInConstraint === undefined) {\r\n                        var symbol = resolveName(typeParameter, (<Identifier>(<TypeReferenceNode>n).typeName).text, SymbolFlags.Type, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined);\r\n                        if (symbol && (symbol.flags & SymbolFlags.TypeParameter)) {\r\n                            // TypeScript 1.0 spec (April 2014): 3.4.1\r\n                            // Type parameters declared in a particular type parameter list \r\n                            // may not be referenced in constraints in that type parameter list\r\n                            \r\n                            // symbol.declaration.parent === typeParameter.parent\r\n                            // -> typeParameter and symbol.declaration originate from the same type parameter list \r\n                            // -> illegal for all declarations in symbol\r\n                            // forEach === exists\r\n                            links.isIllegalTypeReferenceInConstraint = forEach(symbol.declarations, d => d.parent == typeParameter.parent);\r\n                        }\r\n                    }\r\n                    if (links.isIllegalTypeReferenceInConstraint) {\r\n                        error(typeParameter, Diagnostics.Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list);\r\n                    }\r\n                }\r\n                forEachChild(n, check);\r\n            }\r\n\r\n            if (typeParameter.constraint) {\r\n                typeParameterSymbol = getSymbolOfNode(typeParameter);\r\n                check(typeParameter.constraint);\r\n            }\r\n        }\r\n\r\n        function getTypeFromTypeReferenceNode(node: TypeReferenceNode): Type {\r\n            var links = getNodeLinks(node);\r\n            if (!links.resolvedType) {\r\n                var symbol = resolveEntityName(node, node.typeName, SymbolFlags.Type);\r\n                if (symbol) {\r\n                    var type: Type;\r\n                    if ((symbol.flags & SymbolFlags.TypeParameter) && isTypeParameterReferenceIllegalInConstraint(node, symbol)) {\r\n                        // TypeScript 1.0 spec (April 2014): 3.4.1\r\n                        // Type parameters declared in a particular type parameter list \r\n                        // may not be referenced in constraints in that type parameter list\r\n                        // Implementation: such type references are resolved to 'unknown' type that usually denotes error\r\n                        type = unknownType;\r\n                    }\r\n                    else {\r\n                        type = getDeclaredTypeOfSymbol(symbol);\r\n                        if (type.flags & (TypeFlags.Class | TypeFlags.Interface) && type.flags & TypeFlags.Reference) {\r\n                            var typeParameters = (<InterfaceType>type).typeParameters;\r\n                            if (node.typeArguments && node.typeArguments.length === typeParameters.length) {\r\n                                type = createTypeReference(<GenericType>type, map(node.typeArguments, t => getTypeFromTypeNode(t)));\r\n                            }\r\n                            else {\r\n                                error(node, Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(type, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType), typeParameters.length);\r\n                                type = undefined;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (node.typeArguments) {\r\n                                error(node, Diagnostics.Type_0_is_not_generic, typeToString(type));\r\n                                type = undefined;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                links.resolvedType = type || unknownType;\r\n            }\r\n            return links.resolvedType;\r\n        }\r\n\r\n        function getTypeFromTypeQueryNode(node: TypeQueryNode): Type {\r\n            var links = getNodeLinks(node);\r\n            if (!links.resolvedType) {\r\n                // TypeScript 1.0 spec (April 2014): 3.6.3\r\n                // The expression is processed as an identifier expression (section 4.3)\r\n                // or property access expression(section 4.10),\r\n                // the widened type(section 3.9) of which becomes the result. \r\n                links.resolvedType = getWidenedType(checkExpression(node.exprName));\r\n            }\r\n            return links.resolvedType;\r\n        }\r\n\r\n        function getTypeOfGlobalSymbol(symbol: Symbol, arity: number): ObjectType {\r\n\r\n            function getTypeDeclaration(symbol: Symbol): Declaration {\r\n                var declarations = symbol.declarations;\r\n                for (var i = 0; i < declarations.length; i++) {\r\n                    var declaration = declarations[i];\r\n                    switch (declaration.kind) {\r\n                        case SyntaxKind.ClassDeclaration:\r\n                        case SyntaxKind.InterfaceDeclaration:\r\n                        case SyntaxKind.EnumDeclaration:\r\n                            return declaration;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!symbol) {\r\n                return emptyObjectType;\r\n            }\r\n            var type = getDeclaredTypeOfSymbol(symbol);\r\n            var name = symbol.name;\r\n            if (!(type.flags & TypeFlags.ObjectType)) {\r\n                error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, name);\r\n                return emptyObjectType;\r\n            }\r\n            if (((<InterfaceType>type).typeParameters ? (<InterfaceType>type).typeParameters.length : 0) !== arity) {\r\n                error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, name, arity);\r\n                return emptyObjectType;\r\n            }\r\n            return <ObjectType>type;\r\n        }\r\n\r\n        function getGlobalSymbol(name: string): Symbol {\r\n            return resolveName(undefined, name, SymbolFlags.Type, Diagnostics.Cannot_find_global_type_0, name);\r\n        }\r\n\r\n        function getGlobalType(name: string): ObjectType {\r\n            return getTypeOfGlobalSymbol(getGlobalSymbol(name), 0);\r\n        }\r\n\r\n        function createArrayType(elementType: Type): Type {\r\n            // globalArrayType will be undefined if we get here during creation of the Array type. This for example happens if\r\n            // user code augments the Array type with call or construct signatures that have an array type as the return type.\r\n            // We instead use globalArraySymbol to obtain the (not yet fully constructed) Array type.\r\n            var arrayType = globalArrayType || getDeclaredTypeOfSymbol(globalArraySymbol);\r\n            return arrayType !== emptyObjectType ? createTypeReference(<GenericType>arrayType, [elementType]) : emptyObjectType;\r\n        }\r\n\r\n        function getTypeFromArrayTypeNode(node: ArrayTypeNode): Type {\r\n            var links = getNodeLinks(node);\r\n            if (!links.resolvedType) {\r\n                links.resolvedType = createArrayType(getTypeFromTypeNode(node.elementType));\r\n            }\r\n            return links.resolvedType;\r\n        }\r\n\r\n        function getTypeFromTypeLiteralNode(node: TypeLiteralNode): Type {\r\n            var links = getNodeLinks(node);\r\n            if (!links.resolvedType) {\r\n                var symbol = node.symbol;\r\n                var members = symbol.members;\r\n                var callSignatures = getSignaturesOfSymbol(members[\"__call\"]);\r\n                var constructSignatures = getSignaturesOfSymbol(members[\"__new\"]);\r\n                var stringIndexType = getIndexTypeOfSymbol(symbol, IndexKind.String);\r\n                var numberIndexType = getIndexTypeOfSymbol(symbol, IndexKind.Number);\r\n                links.resolvedType = createAnonymousType(symbol, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\r\n            }\r\n            return links.resolvedType;\r\n        }\r\n\r\n        function getStringLiteralType(node: StringLiteralTypeNode): StringLiteralType {\r\n            if (hasProperty(stringLiteralTypes, node.text)) return stringLiteralTypes[node.text];\r\n            var type = stringLiteralTypes[node.text] = <StringLiteralType>createType(TypeFlags.StringLiteral);\r\n            type.text = getSourceTextOfNode(node);\r\n            return type;\r\n        }\r\n\r\n        function getTypeFromStringLiteral(node: StringLiteralTypeNode): Type {\r\n            var links = getNodeLinks(node);\r\n            if (!links.resolvedType) {\r\n                links.resolvedType = getStringLiteralType(node);\r\n            }\r\n            return links.resolvedType;\r\n        }\r\n\r\n        function getTypeFromTypeNode(node: TypeNode): Type {\r\n            switch (node.kind) {\r\n                case SyntaxKind.AnyKeyword:\r\n                    return anyType;\r\n                case SyntaxKind.StringKeyword:\r\n                    return stringType;\r\n                case SyntaxKind.NumberKeyword:\r\n                    return numberType;\r\n                case SyntaxKind.BooleanKeyword:\r\n                    return booleanType;\r\n                case SyntaxKind.VoidKeyword:\r\n                    return voidType;\r\n                case SyntaxKind.StringLiteral:\r\n                    return getTypeFromStringLiteral(<StringLiteralTypeNode>node);\r\n                case SyntaxKind.TypeReference:\r\n                    return getTypeFromTypeReferenceNode(<TypeReferenceNode>node);\r\n                case SyntaxKind.TypeQuery:\r\n                    return getTypeFromTypeQueryNode(<TypeQueryNode>node);\r\n                case SyntaxKind.ArrayType:\r\n                    return getTypeFromArrayTypeNode(<ArrayTypeNode>node);\r\n                case SyntaxKind.TypeLiteral:\r\n                    return getTypeFromTypeLiteralNode(<TypeLiteralNode>node);\r\n                // This function assumes that an identifier or qualified name is a type expression\r\n                // Callers should first ensure this by calling isTypeNode\r\n                case SyntaxKind.Identifier:\r\n                case SyntaxKind.QualifiedName:\r\n                    var symbol = getSymbolInfo(node);\r\n                    return getDeclaredTypeOfSymbol(symbol);\r\n                default:\r\n                    return unknownType;\r\n            }\r\n        }\r\n\r\n        function instantiateList<T>(items: T[], mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): T[] {\r\n            if (items && items.length) {\r\n                var result: T[] = [];\r\n                for (var i = 0; i < items.length; i++) {\r\n                    result.push(instantiator(items[i], mapper));\r\n                }\r\n                return result;\r\n            }\r\n            return items;\r\n        }\r\n\r\n        function createUnaryTypeMapper(source: Type, target: Type): TypeMapper {\r\n            return t => t === source ? target : t;\r\n        }\r\n\r\n        function createBinaryTypeMapper(source1: Type, target1: Type, source2: Type, target2: Type): TypeMapper {\r\n            return t => t === source1 ? target1 : t === source2 ? target2 : t;\r\n        }\r\n\r\n        function createTypeMapper(sources: Type[], targets: Type[]): TypeMapper {\r\n            switch (sources.length) {\r\n                case 1: return createUnaryTypeMapper(sources[0], targets[0]);\r\n                case 2: return createBinaryTypeMapper(sources[0], targets[0], sources[1], targets[1]);\r\n            }\r\n            return t => {\r\n                for (var i = 0; i < sources.length; i++) {\r\n                    if (t === sources[i]) return targets[i];\r\n                }\r\n                return t;\r\n            };\r\n        }\r\n\r\n        function createUnaryTypeEraser(source: Type): TypeMapper {\r\n            return t => t === source ? anyType : t;\r\n        }\r\n\r\n        function createBinaryTypeEraser(source1: Type, source2: Type): TypeMapper {\r\n            return t => t === source1 || t === source2 ? anyType : t;\r\n        }\r\n\r\n        function createTypeEraser(sources: Type[]): TypeMapper {\r\n            switch (sources.length) {\r\n                case 1: return createUnaryTypeEraser(sources[0]);\r\n                case 2: return createBinaryTypeEraser(sources[0], sources[1]);\r\n            }\r\n            return t => {\r\n                for (var i = 0; i < sources.length; i++) {\r\n                    if (t === sources[i]) return anyType;\r\n                }\r\n                return t;\r\n            };\r\n        }\r\n\r\n        function createInferenceMapper(context: InferenceContext): TypeMapper {\r\n            return t => {\r\n                for (var i = 0; i < context.typeParameters.length; i++) {\r\n                    if (t === context.typeParameters[i]) {\r\n                        return getInferredType(context, i);\r\n                    }\r\n                }\r\n                return t;\r\n            }\r\n        }\r\n\r\n        function identityMapper(type: Type): Type {\r\n            return type;\r\n        }\r\n\r\n        function combineTypeMappers(mapper1: TypeMapper, mapper2: TypeMapper): TypeMapper {\r\n            return t => mapper2(mapper1(t));\r\n        }\r\n\r\n        function instantiateTypeParameter(typeParameter: TypeParameter, mapper: TypeMapper): TypeParameter {\r\n            var result = <TypeParameter>createType(TypeFlags.TypeParameter);\r\n            result.symbol = typeParameter.symbol;\r\n            if (typeParameter.constraint) {\r\n                result.constraint = instantiateType(typeParameter.constraint, mapper);\r\n            }\r\n            else {\r\n                result.target = typeParameter;\r\n                result.mapper = mapper;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function instantiateSignature(signature: Signature, mapper: TypeMapper, eraseTypeParameters?: boolean): Signature {\r\n            if (signature.typeParameters && !eraseTypeParameters) {\r\n                var freshTypeParameters = instantiateList(signature.typeParameters, mapper, instantiateTypeParameter);\r\n                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);\r\n            }\r\n            var result = createSignature(signature.declaration, freshTypeParameters,\r\n                instantiateList(signature.parameters, mapper, instantiateSymbol),\r\n                signature.resolvedReturnType ? instantiateType(signature.resolvedReturnType, mapper) : undefined,\r\n                signature.minArgumentCount, signature.hasRestParameter, signature.hasStringLiterals);\r\n            result.target = signature;\r\n            result.mapper = mapper;\r\n            return result;\r\n        }\r\n\r\n        function instantiateSymbol(symbol: Symbol, mapper: TypeMapper): Symbol {\r\n            if (symbol.flags & SymbolFlags.Instantiated) {\r\n                var links = getSymbolLinks(symbol);\r\n                // If symbol being instantiated is itself a instantiation, fetch the original target and combine the\r\n                // type mappers. This ensures that original type identities are properly preserved and that aliases\r\n                // always reference a non-aliases.\r\n                symbol = links.target;\r\n                mapper = combineTypeMappers(links.mapper, mapper);\r\n            }\r\n\r\n            // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and \r\n            // also transient so that we can just store data on it directly.\r\n            var result = <TransientSymbol>createSymbol(SymbolFlags.Instantiated | SymbolFlags.Transient, symbol.name);\r\n            result.declarations = symbol.declarations;\r\n            result.parent = symbol.parent;\r\n            result.target = symbol;\r\n            result.mapper = mapper;\r\n            if (symbol.valueDeclaration) {\r\n                result.valueDeclaration = symbol.valueDeclaration;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function instantiateAnonymousType(type: ObjectType, mapper: TypeMapper): ObjectType {\r\n            var result = <ResolvedObjectType>createObjectType(TypeFlags.Anonymous, type.symbol);\r\n            result.properties = instantiateList(getPropertiesOfType(type), mapper, instantiateSymbol);\r\n            result.members = createSymbolTable(result.properties);\r\n            result.callSignatures = instantiateList(getSignaturesOfType(type, SignatureKind.Call), mapper, instantiateSignature);\r\n            result.constructSignatures = instantiateList(getSignaturesOfType(type, SignatureKind.Construct), mapper, instantiateSignature);\r\n            var stringIndexType = getIndexTypeOfType(type, IndexKind.String);\r\n            var numberIndexType = getIndexTypeOfType(type, IndexKind.Number);\r\n            if (stringIndexType) result.stringIndexType = instantiateType(stringIndexType, mapper);\r\n            if (numberIndexType) result.numberIndexType = instantiateType(numberIndexType, mapper);\r\n            return result;\r\n        }\r\n\r\n        function instantiateType(type: Type, mapper: TypeMapper): Type {\r\n            if (mapper !== identityMapper) {\r\n                if (type.flags & TypeFlags.TypeParameter) {\r\n                    return mapper(type);\r\n                }\r\n                if (type.flags & TypeFlags.Anonymous) {\r\n                    return type.symbol && type.symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral) ?\r\n                        instantiateAnonymousType(<ObjectType>type, mapper) : type;\r\n                }\r\n                if (type.flags & TypeFlags.Reference) {\r\n                    return createTypeReference((<TypeReference>type).target, instantiateList((<TypeReference>type).typeArguments, mapper, instantiateType));\r\n                }\r\n            }\r\n            return type;\r\n        }\r\n\r\n        // Returns true if the given expression contains (at any level of nesting) a function or arrow expression\r\n        // that is subject to contextual typing.\r\n        function isContextSensitiveExpression(node: Expression): boolean {\r\n            switch (node.kind) {\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ArrowFunction:\r\n                    return !(<FunctionExpression>node).typeParameters && !forEach((<FunctionExpression>node).parameters, p => p.type);\r\n                case SyntaxKind.ObjectLiteral:\r\n                    return forEach((<ObjectLiteral>node).properties, p =>\r\n                        p.kind === SyntaxKind.PropertyAssignment && isContextSensitiveExpression((<PropertyDeclaration>p).initializer));\r\n                case SyntaxKind.ArrayLiteral:\r\n                    return forEach((<ArrayLiteral>node).elements, e => isContextSensitiveExpression(e));\r\n                case SyntaxKind.ConditionalExpression:\r\n                    return isContextSensitiveExpression((<ConditionalExpression>node).whenTrue) ||\r\n                        isContextSensitiveExpression((<ConditionalExpression>node).whenFalse);\r\n                case SyntaxKind.BinaryExpression:\r\n                    return (<BinaryExpression>node).operator === SyntaxKind.BarBarToken &&\r\n                        (isContextSensitiveExpression((<BinaryExpression>node).left) || isContextSensitiveExpression((<BinaryExpression>node).right));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function getTypeWithoutConstructors(type: Type): Type {\r\n            if (type.flags & TypeFlags.ObjectType) {\r\n                var resolved = resolveObjectTypeMembers(<ObjectType>type);\r\n                if (resolved.constructSignatures.length) {\r\n                    var result = <ResolvedObjectType>createObjectType(TypeFlags.Anonymous, type.symbol);\r\n                    result.members = resolved.members;\r\n                    result.properties = resolved.properties;\r\n                    result.callSignatures = resolved.callSignatures;\r\n                    result.constructSignatures = emptyArray;\r\n                    type = result;\r\n                }\r\n            }\r\n            return type;\r\n        }\r\n\r\n        // TYPE CHECKING\r\n\r\n        var subtypeRelation: Map<boolean> = {};\r\n        var assignableRelation: Map<boolean> = {};\r\n        var identityRelation: Map<boolean> = {};\r\n\r\n        function isTypeIdenticalTo(source: Type, target: Type): boolean {\r\n            return checkTypeRelatedTo(source, target, identityRelation, /*errorNode*/ undefined, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n        }\r\n\r\n        function isTypeSubtypeOf(source: Type, target: Type): boolean {\r\n            return checkTypeSubtypeOf(source, target, /*errorNode*/ undefined, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n        }\r\n\r\n        function checkTypeSubtypeOf(source: Type, target: Type, errorNode: Node, chainedMessage: DiagnosticMessage, terminalMessage: DiagnosticMessage): boolean {\r\n            return checkTypeRelatedTo(source, target, subtypeRelation, errorNode, chainedMessage, terminalMessage);\r\n        }\r\n\r\n        function isTypeAssignableTo(source: Type, target: Type): boolean {\r\n            return checkTypeAssignableTo(source, target, /*errorNode*/ undefined, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n        }\r\n\r\n        function checkTypeAssignableTo(source: Type, target: Type, errorNode: Node, chainedMessage: DiagnosticMessage, terminalMessage: DiagnosticMessage): boolean {\r\n            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, chainedMessage, terminalMessage);\r\n        }\r\n\r\n        function isTypeRelatedTo(source: Type, target: Type, relation: Map<boolean>): boolean {\r\n            return checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n        }\r\n\r\n        function isSignatureAssignableTo(source: Signature, target: Signature): boolean {\r\n            var sourceType = getOrCreateTypeFromSignature(source);\r\n            var targetType = getOrCreateTypeFromSignature(target);\r\n            return checkTypeRelatedTo(sourceType, targetType, assignableRelation, /*errorNode*/ undefined, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n        }\r\n\r\n        function isPropertyIdenticalTo(sourceProp: Symbol, targetProp: Symbol): boolean {\r\n            return isPropertyIdenticalToRecursive(sourceProp, targetProp, /*reportErrors*/ false, (s, t, _reportErrors) => isTypeIdenticalTo(s, t));\r\n        }\r\n\r\n        function checkInheritedPropertiesAreIdentical(type: InterfaceType, typeNode: Node): boolean {\r\n            if (!type.baseTypes.length || type.baseTypes.length === 1) {\r\n                return true;\r\n            }\r\n\r\n            var seen: Map<{ prop: Symbol; containingType: Type }> = {};\r\n            forEach(type.declaredProperties, p => { seen[p.name] = { prop: p, containingType: type }; });\r\n            var ok = true;\r\n\r\n            for (var i = 0, len = type.baseTypes.length; i < len; ++i) {\r\n                var base = type.baseTypes[i];\r\n                var properties = getPropertiesOfType(base);\r\n                for (var j = 0, proplen = properties.length; j < proplen; ++j) {\r\n                    var prop = properties[j];\r\n                    if (!hasProperty(seen, prop.name)) {\r\n                        seen[prop.name] = { prop: prop, containingType: base };\r\n                    }\r\n                    else {\r\n                        var existing = seen[prop.name];\r\n                        var isInheritedProperty = existing.containingType !== type;\r\n                        if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {\r\n                            ok = false;\r\n\r\n                            var typeName1 = typeToString(existing.containingType);\r\n                            var typeName2 = typeToString(base);\r\n\r\n                            var errorInfo = chainDiagnosticMessages(undefined, Diagnostics.Named_properties_0_of_types_1_and_2_are_not_identical, prop.name, typeName1, typeName2);\r\n                            errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2_Colon, typeToString(type), typeName1, typeName2);\r\n                            addDiagnostic(createDiagnosticForNodeFromMessageChain(typeNode, errorInfo, program.getCompilerHost().getNewLine()));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return ok;\r\n        }\r\n\r\n        function isPropertyIdenticalToRecursive(sourceProp: Symbol, targetProp: Symbol, reportErrors: boolean, relate: (source: Type, target: Type, reportErrors: boolean) => boolean): boolean {\r\n            Debug.assert(sourceProp);\r\n            if (!targetProp) {\r\n                return false;\r\n            }\r\n\r\n            // Two members are considered identical when\r\n            // - they are public properties with identical names, optionality, and types,\r\n            // - they are private properties originating in the same declaration and having identical types\r\n            var sourcePropIsPrivate = getDeclarationFlagsFromSymbol(sourceProp) & NodeFlags.Private;\r\n            var targetPropIsPrivate = getDeclarationFlagsFromSymbol(targetProp) & NodeFlags.Private;\r\n            if (sourcePropIsPrivate !== targetPropIsPrivate) {\r\n                return false;\r\n            }\r\n\r\n            if (sourcePropIsPrivate) {\r\n                return (getTargetSymbol(sourceProp).parent === getTargetSymbol(targetProp).parent) && relate(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);\r\n            }\r\n            else {\r\n                return isOptionalProperty(sourceProp) === isOptionalProperty(targetProp) && relate(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);\r\n            }\r\n        }\r\n\r\n        function checkTypeRelatedTo(source: Type, target: Type, relation: Map<boolean>, errorNode: Node, chainedMessage: DiagnosticMessage, terminalMessage: DiagnosticMessage): boolean {\r\n            var errorInfo: DiagnosticMessageChain;\r\n            var sourceStack: ObjectType[];\r\n            var targetStack: ObjectType[];\r\n            var expandingFlags: number;\r\n            var depth = 0;\r\n            var overflow = false;\r\n\r\n            Debug.assert(relation !== identityRelation || !errorNode, \"no error reporting in identity checking\");\r\n\r\n            var result = isRelatedToWithCustomErrors(source, target, errorNode !== undefined, chainedMessage, terminalMessage);\r\n            if (overflow) {\r\n                error(errorNode, Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));\r\n            }\r\n            else if (errorInfo) {\r\n                addDiagnostic(createDiagnosticForNodeFromMessageChain(errorNode, errorInfo, program.getCompilerHost().getNewLine()));\r\n            }\r\n            return result;\r\n\r\n            function reportError(message: DiagnosticMessage, arg0?: string, arg1?: string): void {\r\n                errorInfo = chainDiagnosticMessages(errorInfo, message, arg0, arg1);\r\n            }\r\n\r\n            function isRelatedTo(source: Type, target: Type, reportErrors: boolean): boolean {\r\n                return isRelatedToWithCustomErrors(source, target, reportErrors, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n            }\r\n\r\n            function isRelatedToWithCustomErrors(source: Type, target: Type, reportErrors: boolean, chainedMessage: DiagnosticMessage, terminalMessage: DiagnosticMessage): boolean {\r\n                if (relation === identityRelation) {\r\n                    // both types are the same - covers 'they are the same primitive type or both are Any' or the same type parameter cases\r\n                    if (source === target) return true;\r\n                }\r\n                else {\r\n                    if (source === target) return true;\r\n                    if (target.flags & TypeFlags.Any) return true;\r\n                    if (source === undefinedType) return true;\r\n                    if (source === nullType && target !== undefinedType) return true;\r\n                    if (source.flags & TypeFlags.Enum && target === numberType) return true;\r\n                    if (source.flags & TypeFlags.StringLiteral && target === stringType) return true;\r\n                    if (relation === assignableRelation) {\r\n                        if (source.flags & TypeFlags.Any) return true;\r\n                        if (source === numberType && target.flags & TypeFlags.Enum) return true;\r\n                    }\r\n                }\r\n\r\n                if (source.flags & TypeFlags.TypeParameter && target.flags & TypeFlags.TypeParameter) {\r\n                    if (typeParameterRelatedTo(<TypeParameter>source, <TypeParameter>target, reportErrors)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    var saveErrorInfo = errorInfo;\r\n                    if (source.flags & TypeFlags.Reference && target.flags & TypeFlags.Reference && (<TypeReference>source).target === (<TypeReference>target).target) {\r\n                        // We have type references to same target type, see if relationship holds for all type arguments\r\n                        if (typesRelatedTo((<TypeReference>source).typeArguments, (<TypeReference>target).typeArguments, reportErrors)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    // Even if relationship doesn't hold for type arguments, it may hold in a structural comparison\r\n                    // Report structural errors only if we haven't reported any errors yet\r\n                    var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo;\r\n                    // identity relation does not use apparent type\r\n                    var sourceOrApparentType =  relation === identityRelation ? source : getApparentType(source);\r\n                    if (sourceOrApparentType.flags & TypeFlags.ObjectType && target.flags & TypeFlags.ObjectType &&\r\n                        objectTypeRelatedTo(sourceOrApparentType, <ObjectType>target, reportStructuralErrors)) {\r\n                        errorInfo = saveErrorInfo;\r\n                        return true;\r\n                    }\r\n                }\r\n                if (reportErrors) {\r\n                    // The error should end in a period when this is the deepest error in the chain\r\n                    // (when errorInfo is undefined). Otherwise, it has a colon before the nested\r\n                    // error.\r\n\r\n                    chainedMessage = chainedMessage || Diagnostics.Type_0_is_not_assignable_to_type_1_Colon;\r\n                    terminalMessage = terminalMessage || Diagnostics.Type_0_is_not_assignable_to_type_1;\r\n                    var diagnosticKey = errorInfo ? chainedMessage : terminalMessage;\r\n                    Debug.assert(diagnosticKey);\r\n                    reportError(diagnosticKey, typeToString(source), typeToString(target));\r\n                }\r\n                return false;\r\n            }\r\n\r\n            function typesRelatedTo(sources: Type[], targets: Type[], reportErrors: boolean): boolean {\r\n                for (var i = 0, len = sources.length; i < len; i++) {\r\n                    if (!isRelatedTo(sources[i], targets[i], reportErrors)) return false;\r\n                }\r\n                return true;\r\n            }\r\n\r\n            function typeParameterRelatedTo(source: TypeParameter, target: TypeParameter, reportErrors: boolean): boolean {\r\n                if (relation === identityRelation) {\r\n                    if (source.symbol.name !== target.symbol.name) {\r\n                        return false;\r\n                    }\r\n\r\n                    // covers case when both type parameters does not have constraint (both equal to noConstraintType)\r\n                    if (source.constraint === target.constraint) {\r\n                        return true;\r\n                    }\r\n\r\n                    if (source.constraint === noConstraintType || target.constraint === noConstraintType) {\r\n                        return false;\r\n                    }\r\n\r\n                    return isRelatedTo(source.constraint, target.constraint, reportErrors);\r\n                }\r\n                else {\r\n                    while (true) {\r\n                        var constraint = getConstraintOfTypeParameter(source);\r\n                        if (constraint === target) return true;\r\n                        if (!(constraint && constraint.flags & TypeFlags.TypeParameter)) break;\r\n                        source = <TypeParameter>constraint;\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Determine if two object types are related by structure. First, check if the result is already available in the global cache.\r\n            // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.\r\n            // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are\r\n            // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion\r\n            // and issue an error. Otherwise, actually compare the structure of the two types.\r\n            function objectTypeRelatedTo(source: ObjectType, target: ObjectType, reportErrors: boolean): boolean {\r\n                if (overflow) return false;\r\n                var result: boolean;\r\n                var id = source.id + \",\" + target.id;\r\n                if ((result = relation[id]) !== undefined) return result;\r\n                if (depth > 0) {\r\n                    for (var i = 0; i < depth; i++) {\r\n                        if (source === sourceStack[i] && target === targetStack[i]) return true;\r\n                    }\r\n                    if (depth === 100) {\r\n                        overflow = true;\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    sourceStack = [];\r\n                    targetStack = [];\r\n                    expandingFlags = 0;\r\n                }\r\n                sourceStack[depth] = source;\r\n                targetStack[depth] = target;\r\n                depth++;\r\n                var saveExpandingFlags = expandingFlags;\r\n                if (!(expandingFlags & 1) && isDeeplyNestedGeneric(source, sourceStack)) expandingFlags |= 1;\r\n                if (!(expandingFlags & 2) && isDeeplyNestedGeneric(target, targetStack)) expandingFlags |= 2;\r\n                result = expandingFlags === 3 ||\r\n                    propertiesRelatedTo(source, target, reportErrors) &&\r\n                    signaturesRelatedTo(source, target, SignatureKind.Call, reportErrors) &&\r\n                    signaturesRelatedTo(source, target, SignatureKind.Construct, reportErrors) &&\r\n                    stringIndexTypesRelatedTo(source, target, reportErrors) &&\r\n                    numberIndexTypesRelatedTo(source, target, reportErrors);\r\n                expandingFlags = saveExpandingFlags;\r\n                depth--;\r\n                if (depth === 0) {\r\n                    relation[id] = result;\r\n                }\r\n                return result;\r\n            }\r\n\r\n            // Return true if the given type is part of a deeply nested chain of generic instantiations. We consider this to be the case\r\n            // when structural type comparisons have been started for 10 or more instantiations of the same generic type. It is possible,\r\n            // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely expanding.\r\n            // Effectively, we will generate a false positive when two types are structurally equal to at least 10 levels, but unequal at\r\n            // some level beyond that.\r\n            function isDeeplyNestedGeneric(type: ObjectType, stack: ObjectType[]): boolean {\r\n                if (type.flags & TypeFlags.Reference && depth >= 10) {\r\n                    var target = (<TypeReference>type).target;\r\n                    var count = 0;\r\n                    for (var i = 0; i < depth; i++) {\r\n                        var t = stack[i];\r\n                        if (t.flags & TypeFlags.Reference && (<TypeReference>t).target === target) {\r\n                            count++;\r\n                            if (count >= 10) return true;\r\n                        }\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            function propertiesRelatedTo(source: ObjectType, target: ObjectType, reportErrors: boolean): boolean {\r\n                if (relation === identityRelation) {\r\n                    return propertiesAreIdenticalTo(source, target, reportErrors);\r\n                }\r\n                else {\r\n                    return propertiesAreSubtypeOrAssignableTo(<ApparentType>source, target, reportErrors);\r\n                }\r\n            }\r\n\r\n            function propertiesAreIdenticalTo(source: ObjectType, target: ObjectType, reportErrors: boolean): boolean {\r\n                if (source === target) {\r\n                    return true;\r\n                }\r\n\r\n                var sourceProperties = getPropertiesOfType(source);\r\n                var targetProperties = getPropertiesOfType(target);\r\n                if (sourceProperties.length !== targetProperties.length) {\r\n                    return false;\r\n                }\r\n\r\n                for (var i = 0, len = sourceProperties.length; i < len; ++i) {\r\n                    var sourceProp = sourceProperties[i];\r\n                    var targetProp = getPropertyOfType(target, sourceProp.name);\r\n\r\n                    if (!isPropertyIdenticalToRecursive(sourceProp, targetProp, reportErrors, isRelatedTo)) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            function propertiesAreSubtypeOrAssignableTo(source: ApparentType, target: ObjectType, reportErrors: boolean): boolean {\r\n                var properties = getPropertiesOfType(target);\r\n                for (var i = 0; i < properties.length; i++) {\r\n                    var targetProp = properties[i];\r\n                    var sourceProp = getPropertyOfApparentType(source, targetProp.name);\r\n                    if (sourceProp === targetProp) {\r\n                        continue;\r\n                    }\r\n\r\n                    var targetPropIsOptional = isOptionalProperty(targetProp);\r\n                    if (!sourceProp) {\r\n                        if (!targetPropIsOptional) {\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Property_0_is_missing_in_type_1, symbolToString(targetProp), typeToString(source));\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else if (sourceProp !== targetProp) {\r\n                        if (targetProp.flags & SymbolFlags.Prototype) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (getDeclarationFlagsFromSymbol(sourceProp) & NodeFlags.Private || getDeclarationFlagsFromSymbol(targetProp) & NodeFlags.Private) {\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Private_property_0_cannot_be_reimplemented, symbolToString(targetProp));\r\n                            }\r\n                            return false;\r\n                        }\r\n                        if (!isRelatedTo(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors)) {\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Types_of_property_0_are_incompatible_Colon, symbolToString(targetProp));\r\n                            }\r\n                            return false;\r\n                        }\r\n                        else if (isOptionalProperty(sourceProp) && !targetPropIsOptional) {\r\n                            // TypeScript 1.0 spec (April 2014): 3.8.3\r\n                            // S is a subtype of a type T, and T is a supertype of S if ...\r\n                            // S' and T are object types and, for each member M in T..\r\n                            // M is a property and S' contains a property N where\r\n                            // if M is a required property, N is also a required property \r\n                            // (M - property in T)\r\n                            // (N - property in S)\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Required_property_0_cannot_be_reimplemented_with_optional_property_in_1, targetProp.name, typeToString(source));\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n\r\n            function signaturesRelatedTo(source: ObjectType, target: ObjectType, kind: SignatureKind, reportErrors: boolean): boolean {\r\n                if (relation === identityRelation) {\r\n                    return areSignaturesIdenticalTo(source, target, kind, reportErrors);\r\n                }\r\n                else {\r\n                    return areSignaturesSubtypeOrAssignableTo(source, target, kind, reportErrors);\r\n                }\r\n            }\r\n\r\n            function areSignaturesIdenticalTo(source: ObjectType, target: ObjectType, kind: SignatureKind, reportErrors: boolean): boolean {\r\n                var sourceSignatures = getSignaturesOfType(source, kind);\r\n                var targetSignatures = getSignaturesOfType(target, kind);\r\n                if (sourceSignatures.length !== targetSignatures.length) {\r\n                    return false;\r\n                }\r\n\r\n                for (var i = 0, len = sourceSignatures.length; i < len; ++i) {\r\n                    if (!isSignatureIdenticalTo(sourceSignatures[i], targetSignatures[i], reportErrors)) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            function isSignatureIdenticalTo(source: Signature, target: Signature, reportErrors: boolean): boolean {\r\n                if (source === target) {\r\n                    return true;\r\n                }\r\n\r\n                if (source.hasRestParameter !== target.hasRestParameter) {\r\n                    return false;\r\n                }\r\n\r\n                if (source.parameters.length !== target.parameters.length) {\r\n                    return false;\r\n                }\r\n\r\n                if (source.minArgumentCount !== target.minArgumentCount) {\r\n                    return false;\r\n                }\r\n\r\n                if (source.typeParameters && target.typeParameters) {\r\n                    if (source.typeParameters.length !== target.typeParameters.length) {\r\n                        return false;\r\n                    }\r\n\r\n                    for (var i = 0, len = source.typeParameters.length; i < len; ++i) {\r\n                        if (!isRelatedTo(source.typeParameters[i], target.typeParameters[i], reportErrors)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                else if (source.typeParameters || source.typeParameters) {\r\n                    return false;\r\n                }\r\n\r\n                // Spec 1.0 Section 3.8.3 & 3.8.4:\r\n                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N\r\n                source = getErasedSignature(source);\r\n                target = getErasedSignature(target);\r\n                for (var i = 0, len = source.parameters.length; i < len; i++) {\r\n                    var s = source.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(source) : getTypeOfSymbol(source.parameters[i]);\r\n                    var t = target.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(target) : getTypeOfSymbol(target.parameters[i]);\r\n                    if (!isRelatedTo(s, t, reportErrors)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                var t = getReturnTypeOfSignature(target);\r\n                var s = getReturnTypeOfSignature(source);\r\n                return isRelatedTo(s, t, reportErrors);\r\n            }\r\n\r\n            function areSignaturesSubtypeOrAssignableTo(source: ObjectType, target: ObjectType, kind: SignatureKind, reportErrors: boolean): boolean {\r\n                if (target === anyFunctionType || source === anyFunctionType) return true;\r\n                var sourceSignatures = getSignaturesOfType(source, kind);\r\n                var targetSignatures = getSignaturesOfType(target, kind);\r\n                var saveErrorInfo = errorInfo;\r\n                outer: for (var i = 0; i < targetSignatures.length; i++) {\r\n                    var t = targetSignatures[i];\r\n                    if (!t.hasStringLiterals || target.flags & TypeFlags.FromSignature) {\r\n                        var localErrors = reportErrors;\r\n                        for (var j = 0; j < sourceSignatures.length; j++) {\r\n                            var s = sourceSignatures[j];\r\n                            if (!s.hasStringLiterals || source.flags & TypeFlags.FromSignature) {\r\n                                if (isSignatureSubtypeOrAssignableTo(s, t, localErrors)) {\r\n                                    errorInfo = saveErrorInfo;\r\n                                    continue outer;\r\n                                }\r\n                                // Only report errors from the first failure\r\n                                localErrors = false;\r\n                            }\r\n                        }\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n\r\n            function isSignatureSubtypeOrAssignableTo(source: Signature, target: Signature, reportErrors: boolean): boolean {\r\n                if (source === target) {\r\n                    return true;\r\n                }\r\n\r\n                if (!target.hasRestParameter && source.minArgumentCount > target.parameters.length) {\r\n                    return false;\r\n                }\r\n\r\n                var sourceMax = source.parameters.length;\r\n                var targetMax = target.parameters.length;\r\n                var checkCount: number;\r\n                if (source.hasRestParameter && target.hasRestParameter) {\r\n                    checkCount = sourceMax > targetMax ? sourceMax : targetMax;\r\n                    sourceMax--;\r\n                    targetMax--;\r\n                }\r\n                else if (source.hasRestParameter) {\r\n                    sourceMax--;\r\n                    checkCount = targetMax;\r\n                }\r\n                else if (target.hasRestParameter) {\r\n                    targetMax--;\r\n                    checkCount = sourceMax;\r\n                }\r\n                else {\r\n                    checkCount = sourceMax < targetMax ? sourceMax : targetMax;\r\n                }\r\n                // Spec 1.0 Section 3.8.3 & 3.8.4:\r\n                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N\r\n                source = getErasedSignature(source);\r\n                target = getErasedSignature(target);\r\n                for (var i = 0; i < checkCount; i++) {\r\n                    var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);\r\n                    var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);\r\n                    var saveErrorInfo = errorInfo;\r\n                    if (!isRelatedTo(s, t, reportErrors)) {\r\n                        if (!isRelatedTo(t, s, false)) {\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Types_of_parameters_0_and_1_are_incompatible_Colon,\r\n                                    source.parameters[i < sourceMax ? i : sourceMax].name,\r\n                                    target.parameters[i < targetMax ? i : targetMax].name);\r\n                            }\r\n                            return false;\r\n                        }\r\n                        errorInfo = saveErrorInfo;\r\n                    }\r\n                }\r\n                var t = getReturnTypeOfSignature(target);\r\n                if (t === voidType) return true;\r\n                var s = getReturnTypeOfSignature(source);\r\n                return isRelatedTo(s, t, reportErrors);\r\n            }\r\n\r\n            function stringIndexTypesRelatedTo(source: ObjectType, target: ObjectType, reportErrors: boolean): boolean {\r\n                if (relation === identityRelation) {\r\n                    return areIndexTypesIdenticalTo(IndexKind.String, source, target, reportErrors);\r\n                }\r\n                else {\r\n                    var targetType = getIndexTypeOfType(target, IndexKind.String);\r\n                    if (targetType) {\r\n                        var sourceType = getIndexTypeOfType(source, IndexKind.String);\r\n                        if (!sourceType) {\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));\r\n                            }\r\n                            return false;\r\n                        }\r\n                        if (!isRelatedTo(sourceType, targetType, reportErrors)) {\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Index_signatures_are_incompatible_Colon);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n            } \r\n\r\n            function numberIndexTypesRelatedTo(source: ObjectType, target: ObjectType, reportErrors: boolean): boolean {\r\n                if (relation === identityRelation) {\r\n                    return areIndexTypesIdenticalTo(IndexKind.Number, source, target, reportErrors);\r\n                }\r\n                else {\r\n                    var targetType = getIndexTypeOfType(target, IndexKind.Number);\r\n                    if (targetType) {\r\n                        var sourceStringType = getIndexTypeOfType(source, IndexKind.String);\r\n                        var sourceNumberType = getIndexTypeOfType(source, IndexKind.Number);\r\n                        if (!(sourceStringType || sourceNumberType)) {\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));\r\n                            }\r\n                            return false;\r\n                        }\r\n                        if (sourceStringType && sourceNumberType) {\r\n                            // If we know for sure we're testing both string and numeric index types then only report errors from the second one\r\n                            var compatible = isRelatedTo(sourceStringType, targetType, false) || isRelatedTo(sourceNumberType, targetType, reportErrors);\r\n                        }\r\n                        else {\r\n                            var compatible = isRelatedTo(sourceStringType || sourceNumberType, targetType, reportErrors);\r\n                        }\r\n                        if (!compatible) {\r\n                            if (reportErrors) {\r\n                                reportError(Diagnostics.Index_signatures_are_incompatible_Colon);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            function areIndexTypesIdenticalTo(indexKind: IndexKind, source: ObjectType, target: ObjectType, reportErrors: boolean): boolean {\r\n                var targetType = getIndexTypeOfType(target, indexKind);\r\n                var sourceType = getIndexTypeOfType(source, indexKind);\r\n                return (!sourceType && !targetType) || (sourceType && targetType && isRelatedTo(sourceType, targetType, reportErrors));\r\n            }\r\n        }\r\n\r\n        function isSupertypeOfEach(candidate: Type, types: Type[]): boolean {\r\n            for (var i = 0, len = types.length; i < len; i++) {\r\n                if (candidate !== types[i] && !isTypeSubtypeOf(types[i], candidate)) return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function getBestCommonType(types: Type[], contextualType?: Type, candidatesOnly?: boolean): Type {\r\n            if (contextualType && isSupertypeOfEach(contextualType, types)) return contextualType;\r\n            return forEach(types, t => isSupertypeOfEach(t, types) ? t : undefined) || (candidatesOnly ? undefined : emptyObjectType);\r\n        }\r\n\r\n        function isTypeOfObjectLiteral(type: Type): boolean {\r\n            return (type.flags & TypeFlags.Anonymous) && type.symbol && (type.symbol.flags & SymbolFlags.ObjectLiteral) ? true : false;\r\n        }\r\n\r\n        function getWidenedTypeOfObjectLiteral(type: Type): Type {\r\n            var properties = getPropertiesOfType(type);\r\n            if (properties.length) {\r\n                var widenedTypes: Type[] = [];\r\n                var propTypeWasWidened: boolean = false;\r\n                forEach(properties, p => {\r\n                    var propType = getTypeOfSymbol(p);\r\n                    var widenedType = getWidenedType(propType);\r\n                    if (propType !== widenedType) {\r\n                        propTypeWasWidened = true;\r\n\r\n                        if (program.getCompilerOptions().noImplicitAny && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {\r\n                            error(p.valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, p.name, typeToString(widenedType));\r\n                        }\r\n                    }\r\n                    widenedTypes.push(widenedType);\r\n                });\r\n                if (propTypeWasWidened) {\r\n                    var members: SymbolTable = {};\r\n                    var index = 0;\r\n                    forEach(properties, p => {\r\n                        var symbol = <TransientSymbol>createSymbol(SymbolFlags.Property | SymbolFlags.Transient, p.name);\r\n                        symbol.declarations = p.declarations;\r\n                        symbol.parent = p.parent;\r\n                        symbol.type = widenedTypes[index++];\r\n                        if (p.valueDeclaration) symbol.valueDeclaration = p.valueDeclaration;\r\n                        members[symbol.name] = symbol;\r\n                    });\r\n                    var stringIndexType = getIndexTypeOfType(type, IndexKind.String);\r\n                    var numberIndexType = getIndexTypeOfType(type, IndexKind.Number);\r\n                    if (stringIndexType) stringIndexType = getWidenedType(stringIndexType);\r\n                    if (numberIndexType) numberIndexType = getWidenedType(numberIndexType);\r\n                    type = createAnonymousType(type.symbol, members, emptyArray, emptyArray, stringIndexType, numberIndexType);\r\n                }\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function isArrayType(type: Type): boolean {\r\n            return type.flags & TypeFlags.Reference && (<TypeReference>type).target === globalArrayType;\r\n        }\r\n\r\n        function getInnermostTypeOfNestedArrayTypes(type: Type): Type {\r\n            while (isArrayType(type)) {\r\n                type = (<GenericType>type).typeArguments[0];\r\n            }\r\n\r\n            return type;\r\n        }\r\n\r\n        function getWidenedTypeOfArrayLiteral(type: Type): Type {\r\n            var elementType = (<TypeReference>type).typeArguments[0];\r\n            var widenedType = getWidenedType(elementType);\r\n\r\n            type = elementType !== widenedType ? createArrayType(widenedType) : type;\r\n\r\n            return type;\r\n        }\r\n\r\n        /* If we are widening on a literal, then we may need to the 'node' parameter for reporting purposes */\r\n        function getWidenedType(type: Type): Type {\r\n            if (type.flags & (TypeFlags.Undefined | TypeFlags.Null)) {\r\n                return anyType;\r\n            }\r\n            if (isTypeOfObjectLiteral(type)) {\r\n                return getWidenedTypeOfObjectLiteral(type);\r\n            }\r\n            if (isArrayType(type)) {\r\n                return getWidenedTypeOfArrayLiteral(type);\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function forEachMatchingParameterType(source: Signature, target: Signature, callback: (s: Type, t: Type) => void) {\r\n            var sourceMax = source.parameters.length;\r\n            var targetMax = target.parameters.length;\r\n            var count: number;\r\n            if (source.hasRestParameter && target.hasRestParameter) {\r\n                count = sourceMax > targetMax ? sourceMax : targetMax;\r\n                sourceMax--;\r\n                targetMax--;\r\n            }\r\n            else if (source.hasRestParameter) {\r\n                sourceMax--;\r\n                count = targetMax;\r\n            }\r\n            else if (target.hasRestParameter) {\r\n                targetMax--;\r\n                count = sourceMax;\r\n            }\r\n            else {\r\n                count = sourceMax < targetMax ? sourceMax : targetMax;\r\n            }\r\n            for (var i = 0; i < count; i++) {\r\n                var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);\r\n                var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);\r\n                callback(s, t);\r\n            }\r\n        }\r\n\r\n        function createInferenceContext(typeParameters: TypeParameter[]): InferenceContext {\r\n            var inferences: Type[][] = [];\r\n            for (var i = 0; i < typeParameters.length; i++) inferences.push([]);\r\n            return {\r\n                typeParameters: typeParameters,\r\n                inferences: inferences,\r\n                inferredTypes: new Array(typeParameters.length),\r\n            };\r\n        }\r\n\r\n        function inferTypes(context: InferenceContext, source: Type, target: Type) {\r\n            var sourceStack: Type[];\r\n            var targetStack: Type[];\r\n            var depth = 0;\r\n            inferFromTypes(source, target);\r\n\r\n            function isInProcess(source: Type, target: Type) {\r\n                for (var i = 0; i < depth; i++) {\r\n                    if (source === sourceStack[i] && target === targetStack[i]) return true;\r\n                }\r\n                return false;\r\n            }\r\n\r\n            function isWithinDepthLimit(type: Type, stack: Type[]) {\r\n                if (depth >= 5) {\r\n                    var target = (<TypeReference>type).target;\r\n                    var count = 0;\r\n                    for (var i = 0; i < depth; i++) {\r\n                        var t = stack[i];\r\n                        if (t.flags & TypeFlags.Reference && (<TypeReference>t).target === target) count++;\r\n                    }\r\n                    return count < 5;\r\n                }\r\n                return true;\r\n            }\r\n\r\n            function inferFromTypes(source: Type, target: Type) {\r\n                if (target.flags & TypeFlags.TypeParameter) {\r\n                    // If target is a type parameter, make an inference\r\n                    var typeParameters = context.typeParameters;\r\n                    for (var i = 0; i < typeParameters.length; i++) {\r\n                        if (target === typeParameters[i]) {\r\n                            var inferences = context.inferences[i];\r\n                            if (!contains(inferences, source)) inferences.push(source);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                else if (source.flags & TypeFlags.Reference && target.flags & TypeFlags.Reference && (<TypeReference>source).target === (<TypeReference>target).target) {\r\n                    // If source and target are references to the same generic type, infer from type arguments\r\n                    var sourceTypes = (<TypeReference>source).typeArguments;\r\n                    var targetTypes = (<TypeReference>target).typeArguments;\r\n                    for (var i = 0; i < sourceTypes.length; i++) {\r\n                        inferFromTypes(sourceTypes[i], targetTypes[i]);\r\n                    }\r\n                }\r\n                else if (source.flags & TypeFlags.ObjectType && (target.flags & TypeFlags.Reference || (target.flags & TypeFlags.Anonymous) &&\r\n                    target.symbol && target.symbol.flags & (SymbolFlags.Method | SymbolFlags.TypeLiteral))) {\r\n                    // If source is an object type, and target is a type reference, the type of a method, or a type literal, infer from members\r\n                    if (!isInProcess(source, target) && isWithinDepthLimit(source, sourceStack) && isWithinDepthLimit(target, targetStack)) {\r\n                        if (depth === 0) {\r\n                            sourceStack = [];\r\n                            targetStack = [];\r\n                        }\r\n                        sourceStack[depth] = source;\r\n                        targetStack[depth] = target;\r\n                        depth++;\r\n                        inferFromProperties(source, target);\r\n                        inferFromSignatures(source, target, SignatureKind.Call);\r\n                        inferFromSignatures(source, target, SignatureKind.Construct);\r\n                        inferFromIndexTypes(source, target, IndexKind.String, IndexKind.String);\r\n                        inferFromIndexTypes(source, target, IndexKind.Number, IndexKind.Number);\r\n                        inferFromIndexTypes(source, target, IndexKind.String, IndexKind.Number);\r\n                        depth--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            function inferFromProperties(source: Type, target: Type) {\r\n                var properties = getPropertiesOfType(target);\r\n                for (var i = 0; i < properties.length; i++) {\r\n                    var targetProp = properties[i];\r\n                    var sourceProp = getPropertyOfType(source, targetProp.name);\r\n                    if (sourceProp) {\r\n                        inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));\r\n                    }\r\n                }\r\n            }\r\n\r\n            function inferFromSignatures(source: Type, target: Type, kind: SignatureKind) {\r\n                var sourceSignatures = getSignaturesOfType(source, kind);\r\n                var targetSignatures = getSignaturesOfType(target, kind);\r\n                var sourceLen = sourceSignatures.length;\r\n                var targetLen = targetSignatures.length;\r\n                var len = sourceLen < targetLen ? sourceLen : targetLen;\r\n                for (var i = 0; i < len; i++) {\r\n                    inferFromSignature(getErasedSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]));\r\n                }\r\n            }\r\n\r\n            function inferFromSignature(source: Signature, target: Signature) {\r\n                forEachMatchingParameterType(source, target, inferFromTypes);\r\n                inferFromTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));\r\n            }\r\n\r\n            function inferFromIndexTypes(source: Type, target: Type, sourceKind: IndexKind, targetKind: IndexKind) {\r\n                var targetIndexType = getIndexTypeOfType(target, targetKind);\r\n                if (targetIndexType) {\r\n                    var sourceIndexType = getIndexTypeOfType(source, sourceKind);\r\n                    if (sourceIndexType) {\r\n                        inferFromTypes(sourceIndexType, targetIndexType);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function getInferredType(context: InferenceContext, index: number): Type {\r\n            var result = context.inferredTypes[index];\r\n            if (!result) {\r\n                var commonType = getWidenedType(getBestCommonType(context.inferences[index]));\r\n                var constraint = getConstraintOfTypeParameter(context.typeParameters[index]);\r\n                var result = constraint && !isTypeAssignableTo(commonType, constraint) ? constraint : commonType;\r\n                context.inferredTypes[index] = result;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function getInferredTypes(context: InferenceContext): Type[] {\r\n            for (var i = 0; i < context.inferredTypes.length; i++) {\r\n                getInferredType(context, i);\r\n            }\r\n            context.inferences = undefined;\r\n            return context.inferredTypes;\r\n        }\r\n\r\n        function hasAncestor(node: Node, kind: SyntaxKind): boolean {\r\n            return getAncestor(node, kind) !== undefined;\r\n        }\r\n\r\n        function getAncestor(node: Node, kind: SyntaxKind): Node {\r\n            switch (kind) {\r\n                // special-cases that can be come first\r\n                case SyntaxKind.ClassDeclaration:\r\n                    while (node) {\r\n                        switch (node.kind) {\r\n                            case SyntaxKind.ClassDeclaration:\r\n                                return <ClassDeclaration>node;\r\n                            case SyntaxKind.EnumDeclaration:\r\n                            case SyntaxKind.InterfaceDeclaration:\r\n                            case SyntaxKind.ModuleDeclaration:\r\n                            case SyntaxKind.ImportDeclaration:\r\n                                // early exit cases - declarations cannot be nested in classes\r\n                                return undefined;\r\n                            default:\r\n                                node = node.parent;\r\n                                continue;\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    while (node) {\r\n                        if (node.kind === kind) {\r\n                            return node;\r\n                        }\r\n                        else {\r\n                            node = node.parent;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        // EXPRESSION TYPE CHECKING\r\n\r\n        function checkIdentifier(node: Identifier): Type {\r\n            function isInTypeQuery(node: Node): boolean {\r\n                // TypeScript 1.0 spec (April 2014): 3.6.3\r\n                // A type query consists of the keyword typeof followed by an expression.\r\n                // The expression is restricted to a single identifier or a sequence of identifiers separated by periods\r\n                while (node) {\r\n                    switch (node.kind) {\r\n                        case SyntaxKind.TypeQuery:\r\n                            return true;\r\n                        case SyntaxKind.Identifier:\r\n                        case SyntaxKind.QualifiedName:\r\n                            node = node.parent;\r\n                            continue;\r\n                        default:\r\n                            return false;\r\n                    }\r\n                }\r\n                Debug.fail(\"should not get here\");\r\n            }\r\n\r\n            var symbol = resolveName(node, node.text, SymbolFlags.Value | SymbolFlags.ExportValue, Diagnostics.Cannot_find_name_0, identifierToString(node));\r\n            if (!symbol) {\r\n                symbol = unknownSymbol;\r\n            }\r\n\r\n            if (symbol.flags & SymbolFlags.Import) {\r\n                // Mark the import as referenced so that we emit it in the final .js file.\r\n                // exception: identifiers that appear in type queries\r\n                getSymbolLinks(symbol).referenced = !isInTypeQuery(node);\r\n            }\r\n\r\n            getNodeLinks(node).resolvedSymbol = symbol;\r\n\r\n            checkCollisionWithCapturedSuperVariable(node, node);\r\n            checkCollisionWithCapturedThisVariable(node, node);\r\n            checkCollisionWithIndexVariableInGeneratedCode(node, node);\r\n\r\n            return getTypeOfSymbol(getExportSymbolOfValueSymbolIfExported(symbol));\r\n        }\r\n\r\n        function getThisContainer(node: Node): Node {\r\n            while (true) {\r\n                node = node.parent;\r\n                if (!node) {\r\n                    return node;\r\n                }\r\n                switch (node.kind) {\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                    case SyntaxKind.Property:\r\n                    case SyntaxKind.Method:\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                    case SyntaxKind.EnumDeclaration:\r\n                    case SyntaxKind.SourceFile:\r\n                    case SyntaxKind.ArrowFunction:\r\n                        return node;\r\n                }\r\n            }\r\n        }\r\n\r\n        function captureLexicalThis(node: Node, container: Node): void {\r\n            var classNode = container.parent && container.parent.kind === SyntaxKind.ClassDeclaration ? container.parent : undefined;\r\n            getNodeLinks(node).flags |= NodeCheckFlags.LexicalThis;\r\n            if (container.kind === SyntaxKind.Property || container.kind === SyntaxKind.Constructor) {\r\n                getNodeLinks(classNode).flags |= NodeCheckFlags.CaptureThis;\r\n            }\r\n            else {\r\n                getNodeLinks(container).flags |= NodeCheckFlags.CaptureThis;\r\n            }\r\n        }\r\n\r\n        function checkThisExpression(node: Node): Type {\r\n            var container = getThisContainer(node);\r\n            var needToCaptureLexicalThis = false;\r\n            // skip arrow functions\r\n            while (container.kind === SyntaxKind.ArrowFunction) {\r\n                container = getThisContainer(container);\r\n                needToCaptureLexicalThis = true;\r\n            }\r\n\r\n            switch (container.kind) {\r\n                case SyntaxKind.ModuleDeclaration:\r\n                    error(node, Diagnostics.this_cannot_be_referenced_in_a_module_body);\r\n                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks\r\n                    break;\r\n                case SyntaxKind.EnumDeclaration:\r\n                    error(node, Diagnostics.this_cannot_be_referenced_in_current_location);\r\n                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks\r\n                    break;\r\n                case SyntaxKind.Constructor:\r\n                    if (isInConstructorArgumentInitializer(node, container)) {\r\n                        error(node, Diagnostics.this_cannot_be_referenced_in_constructor_arguments);\r\n                        // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks\r\n                    }\r\n                    break;\r\n                case SyntaxKind.Property:\r\n                    if (container.flags & NodeFlags.Static) {\r\n                        error(node, Diagnostics.this_cannot_be_referenced_in_a_static_property_initializer);\r\n                        // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if (needToCaptureLexicalThis) {\r\n                captureLexicalThis(node, container);\r\n            }\r\n\r\n            var classNode = container.parent && container.parent.kind === SyntaxKind.ClassDeclaration ? container.parent : undefined;\r\n            if (classNode) {\r\n                var symbol = getSymbolOfNode(classNode);\r\n                return container.flags & NodeFlags.Static ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol);\r\n            }\r\n            return anyType;\r\n        }\r\n\r\n        function getSuperContainer(node: Node): Node {\r\n            while (true) {\r\n                node = node.parent;\r\n                if (!node) return node;\r\n                switch (node.kind) {\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.ArrowFunction:\r\n                    case SyntaxKind.Property:\r\n                    case SyntaxKind.Method:\r\n                    case SyntaxKind.Constructor:\r\n                    case SyntaxKind.GetAccessor:\r\n                    case SyntaxKind.SetAccessor:\r\n                        return node;\r\n                }\r\n            }\r\n        }\r\n\r\n        function isInConstructorArgumentInitializer(node: Node, constructorDecl: Node): boolean {\r\n            for (var n = node; n && n !== constructorDecl; n = n.parent) {\r\n                if (n.kind === SyntaxKind.Parameter) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function checkSuperExpression(node: Node, isCallExpression: boolean): Type {\r\n            var enclosingClass = <ClassDeclaration>getAncestor(node, SyntaxKind.ClassDeclaration);\r\n            var baseClass: Type;\r\n            if (enclosingClass && enclosingClass.baseType) {\r\n                var classType = <InterfaceType>getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingClass));\r\n                baseClass = classType.baseTypes.length && classType.baseTypes[0];\r\n            }\r\n\r\n            if (!baseClass) {\r\n                error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class);\r\n                return unknownType;\r\n            }\r\n\r\n            var container = getSuperContainer(node);\r\n\r\n            if (container) {\r\n                var canUseSuperExpression = false;\r\n                if (isCallExpression) {\r\n                    // TS 1.0 SPEC (April 2014): 4.8.1\r\n                    // Super calls are only permitted in constructors of derived classes\r\n                    canUseSuperExpression = container.kind === SyntaxKind.Constructor;\r\n                }\r\n                else {\r\n                    // TS 1.0 SPEC (April 2014)\r\n                    // 'super' property access is allowed\r\n                    // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance\r\n                    // - In a static member function or static member accessor\r\n\r\n                    // super property access might appear in arrow functions with arbitrary deep nesting\r\n                    var needToCaptureLexicalThis = false;\r\n                    while (container && container.kind === SyntaxKind.ArrowFunction) {\r\n                        container = getSuperContainer(container);\r\n                        needToCaptureLexicalThis = true;\r\n                    }\r\n\r\n                    // topmost container must be something that is directly nested in the class declaration\r\n                    if (container && container.parent && container.parent.kind === SyntaxKind.ClassDeclaration) {\r\n                        if (container.flags & NodeFlags.Static) {\r\n                            canUseSuperExpression =\r\n                                container.kind === SyntaxKind.Method ||\r\n                                container.kind === SyntaxKind.GetAccessor ||\r\n                                container.kind === SyntaxKind.SetAccessor;\r\n                        }\r\n                        else {\r\n                            canUseSuperExpression =\r\n                                container.kind === SyntaxKind.Method ||\r\n                                container.kind === SyntaxKind.GetAccessor ||\r\n                                container.kind === SyntaxKind.SetAccessor ||\r\n                                container.kind === SyntaxKind.Property ||\r\n                                container.kind === SyntaxKind.Constructor;\r\n                        }\r\n                    }                    \r\n                }\r\n\r\n                if (canUseSuperExpression) {\r\n                    var returnType: Type;\r\n\r\n                    if ((container.flags & NodeFlags.Static) || isCallExpression) {\r\n                        getNodeLinks(node).flags |= NodeCheckFlags.SuperStatic;\r\n                        returnType = getTypeOfSymbol(baseClass.symbol);\r\n                    }\r\n                    else {\r\n                        getNodeLinks(node).flags |= NodeCheckFlags.SuperInstance;\r\n                        returnType = baseClass;\r\n                    }\r\n\r\n                    if (container.kind === SyntaxKind.Constructor && isInConstructorArgumentInitializer(node, container)) {\r\n                        // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)\r\n                        error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments);\r\n                        returnType = unknownType;\r\n                    }\r\n\r\n                    if (!isCallExpression && needToCaptureLexicalThis) {\r\n                        // call expressions are allowed only in constructors so they should always capture correct 'this'\r\n                        // super property access expressions can also appear in arrow functions -\r\n                        // in this case they should also use correct lexical this\r\n                        captureLexicalThis(node.parent, container);\r\n                    }\r\n\r\n                    return returnType;\r\n                }\r\n            }\r\n\r\n            if (isCallExpression) {\r\n                error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);\r\n            }\r\n            else {\r\n                error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);\r\n            }\r\n\r\n            return unknownType;\r\n        }\r\n\r\n        // Return contextual type of parameter or undefined if no contextual type is available\r\n        function getContextuallyTypedParameterType(parameter: ParameterDeclaration): Type {\r\n            var func = <FunctionDeclaration>parameter.parent;\r\n            if (func.kind === SyntaxKind.FunctionExpression || func.kind === SyntaxKind.ArrowFunction) {\r\n                if (isContextSensitiveExpression(func)) {\r\n                    var signature = getContextualSignature(func);\r\n                    if (signature) {\r\n                        return getTypeAtPosition(signature, indexOf(func.parameters, parameter));\r\n                    }\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getContextualTypeForInitializerExpression(node: Expression): Type {\r\n            var declaration = <VariableDeclaration>node.parent;\r\n            if (node === declaration.initializer) {\r\n                if (declaration.type) {\r\n                    return getTypeFromTypeNode(declaration.type);\r\n                }\r\n                if (declaration.kind === SyntaxKind.Parameter) {\r\n                    return getContextuallyTypedParameterType(declaration);\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getContextualTypeForReturnExpression(node: Expression): Type {\r\n            var func = getContainingFunction(node);\r\n            if (func) {\r\n                // If the containing function has a return type annotation, is a constructor, or is a get accessor whose\r\n                // corresponding set accessor has a type annotation, return statements in the function are contextually typed\r\n                if (func.type || func.kind === SyntaxKind.Constructor || func.kind === SyntaxKind.GetAccessor && getSetAccessorTypeAnnotationNode(<AccessorDeclaration>getDeclarationOfKind(func.symbol, SyntaxKind.SetAccessor))) {\r\n                    return getReturnTypeOfSignature(getSignatureFromDeclaration(func));\r\n                }\r\n                // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature\r\n                // and that call signature is non-generic, return statements are contextually typed by the return type of the signature\r\n                var signature = getContextualSignature(func);\r\n                if (signature) {\r\n                    return getReturnTypeOfSignature(signature);\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getContextualTypeForArgument(node: Expression): Type {\r\n            var callExpression = <CallExpression>node.parent;\r\n            var argIndex = indexOf(callExpression.arguments, node);\r\n            if (argIndex >= 0) {\r\n                var signature = getResolvedSignature(callExpression);\r\n                return getTypeAtPosition(signature, argIndex);\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getContextualTypeForBinaryOperand(node: Expression): Type {\r\n            var binaryExpression = <BinaryExpression>node.parent;\r\n            var operator = binaryExpression.operator;\r\n            if (operator >= SyntaxKind.FirstAssignment && operator <= SyntaxKind.LastAssignment) {\r\n                if (node === binaryExpression.right) {\r\n                    return checkExpression(binaryExpression.left);\r\n                }\r\n            }\r\n            else if (operator === SyntaxKind.BarBarToken) {\r\n                var type = getContextualType(binaryExpression);\r\n                if (!type && node === binaryExpression.right) {\r\n                    type = checkExpression(binaryExpression.left);\r\n                }\r\n                return type;\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getContextualTypeForPropertyExpression(node: Expression): Type {\r\n            var declaration = <PropertyDeclaration>node.parent;\r\n            var objectLiteral = <ObjectLiteral>declaration.parent;\r\n            var type = getContextualType(objectLiteral);\r\n            var name = declaration.name.text;\r\n            if (type && name) {\r\n                var prop = getPropertyOfType(type, name);\r\n                if (prop) {\r\n                    return getTypeOfSymbol(prop);\r\n                }\r\n                return isNumericName(name) && getIndexTypeOfType(type, IndexKind.Number) || getIndexTypeOfType(type, IndexKind.String);\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getContextualTypeForElementExpression(node: Expression): Type {\r\n            var arrayLiteral = <ArrayLiteral>node.parent;\r\n            var type = getContextualType(arrayLiteral);\r\n            return type ? getIndexTypeOfType(type, IndexKind.Number) : undefined;\r\n        }\r\n\r\n        function getContextualTypeForConditionalOperand(node: Expression): Type {\r\n            var conditional = <ConditionalExpression>node.parent;\r\n            return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional) : undefined; \r\n        }\r\n\r\n        function getContextualType(node: Expression): Type {\r\n            if (node.contextualType) {\r\n                return node.contextualType;\r\n            }\r\n            var parent = node.parent;\r\n            switch (parent.kind) {\r\n                case SyntaxKind.VariableDeclaration:\r\n                case SyntaxKind.Parameter:\r\n                case SyntaxKind.Property:\r\n                    return getContextualTypeForInitializerExpression(node);\r\n                case SyntaxKind.ArrowFunction:\r\n                case SyntaxKind.ReturnStatement:\r\n                    return getContextualTypeForReturnExpression(node);\r\n                case SyntaxKind.CallExpression:\r\n                case SyntaxKind.NewExpression:\r\n                    return getContextualTypeForArgument(node);\r\n                case SyntaxKind.TypeAssertion:\r\n                    return getTypeFromTypeNode((<TypeAssertion>parent).type);\r\n                case SyntaxKind.BinaryExpression:\r\n                    return getContextualTypeForBinaryOperand(node);\r\n                case SyntaxKind.PropertyAssignment:\r\n                    return getContextualTypeForPropertyExpression(node);\r\n                case SyntaxKind.ArrayLiteral:\r\n                    return getContextualTypeForElementExpression(node);\r\n                case SyntaxKind.ConditionalExpression:\r\n                    return getContextualTypeForConditionalOperand(node);\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getContextualSignature(node: Expression): Signature {\r\n            var type = getContextualType(node);\r\n            if (type) {\r\n                var signatures = getSignaturesOfType(type, SignatureKind.Call);\r\n                if (signatures.length === 1) {\r\n                    var signature = signatures[0];\r\n                    if (!signature.typeParameters) {\r\n                        return signature;\r\n                    }\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        // Presence of a contextual type mapper indicates inferential typing, except the identityMapper object is\r\n        // used as a special marker for other purposes.\r\n        function isInferentialContext(mapper: TypeMapper) {\r\n            return mapper && mapper !== identityMapper;\r\n        }\r\n\r\n        function checkArrayLiteral(node: ArrayLiteral, contextualMapper?: TypeMapper): Type {\r\n            var elementTypes: Type[] = [];\r\n            forEach(node.elements, element => {\r\n                if (element.kind !== SyntaxKind.OmittedExpression) {\r\n                    var type = checkExpression(element, contextualMapper);\r\n                    if (!contains(elementTypes, type)) elementTypes.push(type);\r\n                }\r\n            });\r\n            var contextualType = isInferentialContext(contextualMapper) ? undefined : getContextualType(node);\r\n            var contextualElementType = contextualType && getIndexTypeOfType(contextualType, IndexKind.Number);\r\n            var elementType = getBestCommonType(elementTypes, contextualElementType, true);\r\n            if (!elementType) elementType = elementTypes.length ? emptyObjectType : undefinedType;\r\n            return createArrayType(elementType);\r\n        }\r\n\r\n        function isNumericName(name: string) {\r\n            return !isNaN(<number><any>name);\r\n        }\r\n\r\n        function checkObjectLiteral(node: ObjectLiteral, contextualMapper?: TypeMapper): Type {\r\n            var members = node.symbol.members;\r\n            var properties: SymbolTable = {};\r\n            var contextualType = getContextualType(node);\r\n\r\n            for (var id in members) {\r\n                if (hasProperty(members, id)) {\r\n                    var member = members[id];\r\n                    if (member.flags & SymbolFlags.Property) {\r\n                        var type = checkExpression((<PropertyDeclaration>member.declarations[0]).initializer, contextualMapper);\r\n                        var prop = <TransientSymbol>createSymbol(SymbolFlags.Property | SymbolFlags.Transient, member.name);\r\n                        prop.declarations = member.declarations;\r\n                        prop.parent = member.parent;\r\n                        if (member.valueDeclaration) prop.valueDeclaration = member.valueDeclaration;\r\n                        prop.type = type;\r\n                        member = prop;\r\n                    }\r\n                    else {\r\n                        // TypeScript 1.0 spec (April 2014)\r\n                        // A get accessor declaration is processed in the same manner as \r\n                        // an ordinary function declaration(section 6.1) with no parameters.\r\n                        // A set accessor declaration is processed in the same manner \r\n                        // as an ordinary function declaration with a single parameter and a Void return type.\r\n                        var getAccessor = <AccessorDeclaration>getDeclarationOfKind(member, SyntaxKind.GetAccessor);\r\n                        if (getAccessor) {\r\n                            checkAccessorDeclaration(getAccessor);\r\n                        }\r\n\r\n                        var setAccessor = <AccessorDeclaration>getDeclarationOfKind(member, SyntaxKind.SetAccessor);\r\n                        if (setAccessor) {\r\n                            checkAccessorDeclaration(setAccessor);\r\n                        }\r\n                    }\r\n                    properties[member.name] = member;\r\n                }\r\n            }\r\n            var stringIndexType = getIndexType(IndexKind.String);\r\n            var numberIndexType = getIndexType(IndexKind.Number);\r\n            return createAnonymousType(node.symbol, properties, emptyArray, emptyArray, stringIndexType, numberIndexType);\r\n\r\n            function getIndexType(kind: IndexKind) {\r\n                if (contextualType) {\r\n                    var indexType = getIndexTypeOfType(contextualType, kind);\r\n                    if (indexType) {\r\n                        var propTypes: Type[] = [];\r\n                        for (var id in properties) {\r\n                            if (hasProperty(properties, id)) {\r\n                                if (kind === IndexKind.String || isNumericName(id)) {\r\n                                    var type = getTypeOfSymbol(properties[id]);\r\n                                    if (!contains(propTypes, type)) propTypes.push(type);\r\n                                }\r\n                            }\r\n                        }\r\n                        return getBestCommonType(propTypes, isInferentialContext(contextualMapper) ? undefined : indexType);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function getDeclarationKindFromSymbol(s: Symbol) {\r\n            return s.flags & SymbolFlags.Prototype ? SyntaxKind.Property : s.valueDeclaration.kind;\r\n        }\r\n\r\n        function getDeclarationFlagsFromSymbol(s: Symbol) {\r\n            return s.flags & SymbolFlags.Prototype ? NodeFlags.Public | NodeFlags.Static : s.valueDeclaration.flags;\r\n        }\r\n\r\n        function checkPropertyAccess(node: PropertyAccess) {\r\n            var type = checkExpression(node.left);\r\n            if (type === unknownType) return type;\r\n            if (type !== anyType) {\r\n                var apparentType = getApparentType(getWidenedType(type));\r\n                if (<Type>apparentType === unknownType) {\r\n                    // handle cases when type is Type parameter with invalid constraint\r\n                    return unknownType;\r\n                }\r\n                var prop = getPropertyOfApparentType(apparentType, node.right.text);\r\n                if (!prop) {\r\n                    if (node.right.text) {\r\n                        error(node.right, Diagnostics.Property_0_does_not_exist_on_type_1, identifierToString(node.right), typeToString(type));\r\n                    }\r\n                    return unknownType;\r\n                }\r\n                getNodeLinks(node).resolvedSymbol = prop;\r\n                if (prop.parent && prop.parent.flags & SymbolFlags.Class) {\r\n\r\n                    // TS 1.0 spec (April 2014): 4.8.2\r\n                    // - In a constructor, instance member function, instance member accessor, or \r\n                    //   instance member variable initializer where this references a derived class instance, \r\n                    //   a super property access is permitted and must specify a public instance member function of the base class.\r\n                    // - In a static member function or static member accessor \r\n                    //   where this references the constructor function object of a derived class, \r\n                    //   a super property access is permitted and must specify a public static member function of the base class.\r\n                    if (node.left.kind === SyntaxKind.SuperKeyword && getDeclarationKindFromSymbol(prop) !== SyntaxKind.Method) {\r\n                        error(node.right, Diagnostics.Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword);\r\n                    }\r\n                    else if (getDeclarationFlagsFromSymbol(prop) & NodeFlags.Private) {\r\n                        var classDeclaration = getAncestor(node, SyntaxKind.ClassDeclaration);\r\n                        if (!classDeclaration || !contains(prop.parent.declarations, classDeclaration)) {\r\n                            error(node, Diagnostics.Property_0_is_inaccessible, getFullyQualifiedName(prop));\r\n                        }\r\n                    }\r\n                }\r\n                return getTypeOfSymbol(prop);\r\n            }\r\n            return anyType;\r\n        }\r\n\r\n        function checkIndexedAccess(node: IndexedAccess): Type {\r\n            var objectType = checkExpression(node.object);\r\n            var indexType = checkExpression(node.index);\r\n            if (objectType === unknownType) return unknownType;\r\n\r\n            // TypeScript 1.0 spec (April 2014): 4.10 Property Access\r\n            // - If IndexExpr is a string literal or a numeric literal and ObjExpr's apparent type has a property with the name \r\n            //    given by that literal(converted to its string representation in the case of a numeric literal), the property access is of the type of that property.\r\n            // - Otherwise, if ObjExpr's apparent type has a numeric index signature and IndexExpr is of type Any, the Number primitive type, or an enum type, \r\n            //    the property access is of the type of that index signature.\r\n            // - Otherwise, if ObjExpr's apparent type has a string index signature and IndexExpr is of type Any, the String or Number primitive type, or an enum type, \r\n            //    the property access is of the type of that index signature.\r\n            // - Otherwise, if IndexExpr is of type Any, the String or Number primitive type, or an enum type, the property access is of type Any.\r\n\r\n            // See if we can index as a property.\r\n            var apparentType = getApparentType(objectType);\r\n            if (<Type>apparentType === unknownType) {\r\n                // handle cases when objectType is type parameter with invalid type\r\n                return unknownType;\r\n            }\r\n            if (node.index.kind === SyntaxKind.StringLiteral || node.index.kind === SyntaxKind.NumericLiteral) {\r\n                var name = (<LiteralExpression>node.index).text;\r\n                var prop = getPropertyOfApparentType(apparentType, name);\r\n                if (prop) {\r\n                    return getTypeOfSymbol(prop);\r\n                }\r\n            }\r\n\r\n            // Check for compatible indexer types.\r\n            if (indexType.flags & (TypeFlags.Any | TypeFlags.StringLike | TypeFlags.NumberLike)) { \r\n\r\n                // Try to use a number indexer.\r\n                if (indexType.flags & (TypeFlags.Any | TypeFlags.NumberLike)) {\r\n                    var numberIndexType = getIndexTypeOfType(apparentType, IndexKind.Number);\r\n                    if (numberIndexType) {\r\n                        return numberIndexType;\r\n                    }\r\n                }\r\n\r\n                // Try to use string indexing.\r\n                var stringIndexType = getIndexTypeOfType(apparentType, IndexKind.String);\r\n                if (stringIndexType) {\r\n                    return stringIndexType;\r\n                }\r\n\r\n                // Fall back to any.\r\n                if (program.getCompilerOptions().noImplicitAny && objectType !== anyType) {\r\n                    error(node, Diagnostics.Index_signature_of_object_type_implicitly_has_an_any_type);\r\n                }\r\n\r\n                return anyType;\r\n            }\r\n\r\n            // REVIEW: Users should know the type that was actually used.\r\n            error(node, Diagnostics.An_index_expression_argument_must_be_of_type_string_number_or_any);\r\n\r\n            return unknownType;\r\n        }\r\n\r\n        function resolveUntypedCall(node: CallExpression): Signature {\r\n            forEach(node.arguments, argument => {\r\n                checkExpression(argument);\r\n            });\r\n            return anySignature;\r\n        }\r\n\r\n        function resolveErrorCall(node: CallExpression): Signature {\r\n            resolveUntypedCall(node);\r\n            return unknownSignature;\r\n        }\r\n\r\n        function isCandidateSignature(node: CallExpression, signature: Signature) {\r\n            var args = node.arguments || emptyArray;\r\n            return args.length >= signature.minArgumentCount &&\r\n                (signature.hasRestParameter || args.length <= signature.parameters.length) &&\r\n                (!node.typeArguments || signature.typeParameters && node.typeArguments.length === signature.typeParameters.length);\r\n        }\r\n\r\n        // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order\r\n        // A nit here is that we reorder only signatures that belong to the same symbol,\r\n        // so order how inherited signatures are processed is still preserved.\r\n        // interface A { (x: string): void }\r\n        // interface B extends A { (x: 'foo'): string }\r\n        // var b: B;\r\n        // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]\r\n        function collectCandidates(node: CallExpression, signatures: Signature[]): Signature[]{\r\n            var result: Signature[] = [];\r\n            var lastParent: Node;\r\n            var lastSymbol: Symbol;\r\n            var cutoffPos: number = 0;\r\n            var pos: number;\r\n            for (var i = 0; i < signatures.length; i++) {\r\n                var signature = signatures[i];\r\n                if (isCandidateSignature(node, signature)) {\r\n                    var symbol = signature.declaration && getSymbolOfNode(signature.declaration);\r\n                    var parent = signature.declaration && signature.declaration.parent;\r\n                    if (!lastSymbol || symbol === lastSymbol) {                        \r\n                        if (lastParent && parent === lastParent) {\r\n                            pos++;\r\n                        }\r\n                        else {\r\n                            lastParent = parent;\r\n                            pos = cutoffPos;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // current declaration belongs to a different symbol\r\n                        // set cutoffPos so reorderings in the future won't change result set from 0 to cutoffPos\r\n                        pos = cutoffPos = result.length;\r\n                        lastParent = parent;\r\n                    }\r\n                    lastSymbol = symbol;\r\n\r\n                    for (var j = result.length; j > pos; j--) {\r\n                        result[j] = result[j - 1];\r\n                    }\r\n                    result[pos] = signature;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.\r\n        function getSingleCallSignature(type: Type): Signature {\r\n            if (type.flags & TypeFlags.ObjectType) {\r\n                var resolved = resolveObjectTypeMembers(<ObjectType>type);\r\n                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 &&\r\n                    resolved.properties.length === 0 && !resolved.stringIndexType && !resolved.numberIndexType) {\r\n                    return resolved.callSignatures[0];\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)\r\n        function instantiateSignatureInContextOf(signature: Signature, contextualSignature: Signature, contextualMapper: TypeMapper): Signature {\r\n            var context = createInferenceContext(signature.typeParameters);\r\n            forEachMatchingParameterType(contextualSignature, signature, (source, target) => {\r\n                // Type parameters from outer context referenced by source type are fixed by instantiation of the source type\r\n                inferTypes(context, instantiateType(source, contextualMapper), target);\r\n            });\r\n            return getSignatureInstantiation(signature, getInferredTypes(context));\r\n        }\r\n\r\n        // Inferentially type an expression by a contextual parameter type (section 4.12.2 in TypeScript spec)\r\n        function inferentiallyTypeExpession(expr: Expression, contextualType: Type, contextualMapper: TypeMapper): Type {\r\n            var type = checkExpressionWithContextualType(expr, contextualType, contextualMapper);\r\n            var signature = getSingleCallSignature(type);\r\n            if (signature && signature.typeParameters) {\r\n                var contextualSignature = getSingleCallSignature(contextualType);\r\n                if (contextualSignature && !contextualSignature.typeParameters) {\r\n                    type = getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper));\r\n                }\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function inferTypeArguments(signature: Signature, args: Expression[], excludeArgument?: boolean[]): Type[] {\r\n            var typeParameters = signature.typeParameters;\r\n            var context = createInferenceContext(typeParameters);\r\n            var mapper = createInferenceMapper(context);\r\n            // First infer from arguments that are not context sensitive\r\n            for (var i = 0; i < args.length; i++) {\r\n                if (!excludeArgument || excludeArgument[i] === undefined) {\r\n                    var parameterType = getTypeAtPosition(signature, i);\r\n                    inferTypes(context, inferentiallyTypeExpession(args[i], parameterType, mapper), parameterType);\r\n                }\r\n            }\r\n            // Next, infer from those context sensitive arguments that are no longer excluded\r\n            if (excludeArgument) {\r\n                for (var i = 0; i < args.length; i++) {\r\n                    if (excludeArgument[i] === false) {\r\n                        var parameterType = getTypeAtPosition(signature, i);\r\n                        inferTypes(context, inferentiallyTypeExpession(args[i], parameterType, mapper), parameterType);\r\n                    }\r\n                }\r\n            }\r\n            return getInferredTypes(context);\r\n        }\r\n\r\n        function checkTypeArguments(signature: Signature, typeArguments: TypeNode[]): Type[] {\r\n            var typeParameters = signature.typeParameters;\r\n            var result: Type[] = [];\r\n            for (var i = 0; i < typeParameters.length; i++) {\r\n                var typeArgNode = typeArguments[i];\r\n                var typeArgument = getTypeFromTypeNode(typeArgNode);\r\n                var constraint = getConstraintOfTypeParameter(typeParameters[i]);\r\n                if (constraint && fullTypeCheck) {\r\n                    checkTypeAssignableTo(typeArgument, constraint, typeArgNode, Diagnostics.Type_0_does_not_satisfy_the_constraint_1_Colon, Diagnostics.Type_0_does_not_satisfy_the_constraint_1);\r\n                }\r\n                result.push(typeArgument);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function checkApplicableSignature(node: CallExpression, signature: Signature, relation: Map<boolean>, excludeArgument: boolean[], reportErrors: boolean) {\r\n            if (node.arguments) {\r\n                for (var i = 0; i < node.arguments.length; i++) {\r\n                    var arg = node.arguments[i];\r\n                    var paramType = getTypeAtPosition(signature, i);\r\n                    // String literals get string literal types unless we're reporting errors\r\n                    var argType = arg.kind === SyntaxKind.StringLiteral && !reportErrors ?\r\n                        getStringLiteralType(<LiteralExpression>arg) :\r\n                        checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);\r\n                    // Use argument expression as error location when reporting errors\r\n                    var isValidArgument = checkTypeRelatedTo(argType, paramType, relation, reportErrors ? arg : undefined,\r\n                        Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1,\r\n                        Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1);\r\n                    if (!isValidArgument) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function resolveCall(node: CallExpression, signatures: Signature[]): Signature {\r\n            forEach(node.typeArguments, checkSourceElement);\r\n            var candidates = collectCandidates(node, signatures);\r\n            if (!candidates.length) {\r\n                error(node, Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);\r\n                return resolveErrorCall(node);\r\n            }\r\n            var args = node.arguments || emptyArray;\r\n            var excludeArgument: boolean[];\r\n            for (var i = 0; i < args.length; i++) {\r\n                if (isContextSensitiveExpression(args[i])) {\r\n                    if (!excludeArgument) excludeArgument = new Array(args.length);\r\n                    excludeArgument[i] = true;\r\n                }\r\n            }\r\n            var relation = candidates.length === 1 ? assignableRelation : subtypeRelation;\r\n            while (true) {\r\n                for (var i = 0; i < candidates.length; i++) {\r\n                    while (true) {\r\n                        var candidate = candidates[i];\r\n                        if (candidate.typeParameters) {\r\n                            var typeArguments = node.typeArguments ?\r\n                                checkTypeArguments(candidate, node.typeArguments) :\r\n                                inferTypeArguments(candidate, args, excludeArgument);\r\n                            candidate = getSignatureInstantiation(candidate, typeArguments);\r\n                        }\r\n                        if (!checkApplicableSignature(node, candidate, relation, excludeArgument, /*reportErrors*/ false)) {\r\n                            break;\r\n                        }\r\n                        var index = excludeArgument ? indexOf(excludeArgument, true) : -1;\r\n                        if (index < 0) {\r\n                            return candidate;\r\n                        }\r\n                        excludeArgument[index] = false;\r\n                    }\r\n                }\r\n                if (relation === assignableRelation) {\r\n                    break;\r\n                }\r\n                relation = assignableRelation;\r\n            }\r\n            // No signatures were applicable. Now report errors based on the last applicable signature with\r\n            // no arguments excluded from assignability checks.\r\n            checkApplicableSignature(node, candidate, relation, undefined, /*reportErrors*/ true);\r\n            return resolveErrorCall(node);\r\n        }\r\n\r\n        function resolveCallExpression(node: CallExpression): Signature {\r\n            if (node.func.kind === SyntaxKind.SuperKeyword) {\r\n                var superType = checkSuperExpression(node.func, true);\r\n                if (superType !== unknownType) {\r\n                    return resolveCall(node, getSignaturesOfType(superType, SignatureKind.Construct));\r\n                }\r\n                return resolveUntypedCall(node);\r\n            }\r\n\r\n            var funcType = checkExpression(node.func);\r\n            if (funcType === unknownType) {\r\n                // Another error has already been reported\r\n                return resolveErrorCall(node);\r\n            }\r\n            \r\n            var apparentType = getApparentType(funcType);\r\n            if (<Type>apparentType === unknownType) {\r\n                // handler cases when funcType is type parameter with invalid constraint\r\n                // Another error was already reported\r\n                return resolveErrorCall(node);\r\n            }\r\n\r\n            // Technically, this signatures list may be incomplete. We are taking the apparent type,\r\n            // but we are not including call signatures that may have been added to the Object or\r\n            // Function interface, since they have none by default. This is a bit of a leap of faith\r\n            // that the user will not add any.\r\n            var callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);\r\n\r\n            var constructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct);\r\n            // TS 1.0 spec: 4.12\r\n            // If FuncExpr is of type Any, or of an object type that has no call or construct signatures\r\n            // but is a subtype of the Function interface, the call is an untyped function call. In an\r\n            // untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual\r\n            // types are provided for the argument expressions, and the result is always of type Any.\r\n            if ((funcType === anyType) || (!callSignatures.length && !constructSignatures.length && isTypeAssignableTo(funcType, globalFunctionType))) {\r\n                if (node.typeArguments) {\r\n                    error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);\r\n                }\r\n                return resolveUntypedCall(node);\r\n            }\r\n            // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.\r\n            // TypeScript employs overload resolution in typed function calls in order to support functions\r\n            // with multiple call signatures.\r\n            if (!callSignatures.length) {\r\n                if (constructSignatures.length) {\r\n                    error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));\r\n                }\r\n                else {\r\n                    error(node, Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);\r\n                }\r\n                return resolveErrorCall(node);\r\n            }\r\n            return resolveCall(node, callSignatures);\r\n        }\r\n\r\n        function resolveNewExpression(node: NewExpression): Signature {\r\n            var expressionType = checkExpression(node.func);\r\n            if (expressionType === unknownType) {\r\n                // Another error has already been reported\r\n                return resolveErrorCall(node);\r\n            }\r\n            // TS 1.0 spec: 4.11\r\n            // If ConstructExpr is of type Any, Args can be any argument\r\n            // list and the result of the operation is of type Any.\r\n            if (expressionType === anyType) {\r\n                if (node.typeArguments) {\r\n                    error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);\r\n                }\r\n\r\n                return resolveUntypedCall(node);\r\n            }\r\n\r\n            // If ConstructExpr's apparent type(section 3.8.1) is an object type with one or\r\n            // more construct signatures, the expression is processed in the same manner as a\r\n            // function call, but using the construct signatures as the initial set of candidate\r\n            // signatures for overload resolution.The result type of the function call becomes\r\n            // the result type of the operation.\r\n            expressionType = getApparentType(expressionType);\r\n            if (<Type>expressionType === unknownType) {\r\n                // handler cases when original expressionType is a type parameter with invalid constraint\r\n                // another error has already been reported\r\n                return resolveErrorCall(node);\r\n            }\r\n\r\n            // Technically, this signatures list may be incomplete. We are taking the apparent type,\r\n            // but we are not including construct signatures that may have been added to the Object or\r\n            // Function interface, since they have none by default. This is a bit of a leap of faith\r\n            // that the user will not add any.\r\n            var constructSignatures = getSignaturesOfType(expressionType, SignatureKind.Construct);\r\n            if (constructSignatures.length) {\r\n                return resolveCall(node, constructSignatures);\r\n            }\r\n\r\n            // If ConstructExpr's apparent type is an object type with no construct signatures but\r\n            // one or more call signatures, the expression is processed as a function call. A compile-time\r\n            // error occurs if the result of the function call is not Void. The type of the result of the\r\n            // operation is Any.\r\n            var callSignatures = getSignaturesOfType(expressionType, SignatureKind.Call);\r\n            if (callSignatures.length) {\r\n                var signature = resolveCall(node, callSignatures);\r\n                if (getReturnTypeOfSignature(signature) !== voidType) {\r\n                    error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);\r\n                }\r\n                return signature;\r\n            }\r\n\r\n            error(node, Diagnostics.Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature);\r\n            return resolveErrorCall(node);\r\n        }\r\n\r\n        function getResolvedSignature(node: CallExpression): Signature {\r\n            var links = getNodeLinks(node);\r\n            if (!links.resolvedSignature) {\r\n                links.resolvedSignature = anySignature;\r\n                links.resolvedSignature = node.kind === SyntaxKind.CallExpression ? resolveCallExpression(node) : resolveNewExpression(node);\r\n            }\r\n            return links.resolvedSignature;\r\n        }\r\n\r\n        function checkCallExpression(node: CallExpression): Type {\r\n            var signature = getResolvedSignature(node);\r\n            if (node.func.kind === SyntaxKind.SuperKeyword) {\r\n                return voidType;\r\n            }\r\n            if (node.kind === SyntaxKind.NewExpression) {\r\n                var declaration = signature.declaration;\r\n                if (declaration && (declaration.kind !== SyntaxKind.Constructor && declaration.kind !== SyntaxKind.ConstructSignature)) {\r\n                    // When resolved signature is a call signature (and not a construct signature) the result type is any\r\n                    if (program.getCompilerOptions().noImplicitAny) {\r\n                        error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);\r\n                    }\r\n                    return anyType;\r\n                }\r\n            }\r\n            return getReturnTypeOfSignature(signature);\r\n        }\r\n\r\n        function checkTypeAssertion(node: TypeAssertion): Type {\r\n            var exprType = checkExpression(node.operand);\r\n            var targetType = getTypeFromTypeNode(node.type);\r\n            if (fullTypeCheck && targetType !== unknownType) {\r\n                var widenedType = getWidenedType(exprType);\r\n                if (!(isTypeAssignableTo(exprType, targetType) || isTypeAssignableTo(targetType, widenedType))) {\r\n                    checkTypeAssignableTo(targetType, widenedType, node, Diagnostics.Neither_type_0_nor_type_1_is_assignable_to_the_other_Colon, Diagnostics.Neither_type_0_nor_type_1_is_assignable_to_the_other);\r\n                }\r\n            }\r\n            return targetType;\r\n        }\r\n\r\n        function getTypeAtPosition(signature: Signature, pos: number): Type {\r\n            return signature.hasRestParameter ?\r\n                pos < signature.parameters.length - 1 ? getTypeOfSymbol(signature.parameters[pos]) : getRestTypeOfSignature(signature) :\r\n                pos < signature.parameters.length ? getTypeOfSymbol(signature.parameters[pos]) : anyType;\r\n        }\r\n\r\n        function assignContextualParameterTypes(signature: Signature, context: Signature, mapper: TypeMapper) {\r\n            var len = signature.parameters.length - (signature.hasRestParameter ? 1 : 0);\r\n            for (var i = 0; i < len; i++) {\r\n                var parameter = signature.parameters[i];\r\n                var links = getSymbolLinks(parameter);\r\n                links.type = instantiateType(getTypeAtPosition(context, i), mapper);\r\n            }\r\n            if (signature.hasRestParameter && context.hasRestParameter && signature.parameters.length >= context.parameters.length) {\r\n                var parameter = signature.parameters[signature.parameters.length - 1];\r\n                var links = getSymbolLinks(parameter);\r\n                links.type = instantiateType(getTypeOfSymbol(context.parameters[context.parameters.length - 1]), mapper);\r\n            }\r\n        }\r\n\r\n        function getReturnTypeFromBody(func: FunctionDeclaration, contextualMapper?: TypeMapper): Type {\r\n            if (func.body.kind !== SyntaxKind.FunctionBlock) {\r\n                var unwidenedType = checkAndMarkExpression(func.body, contextualMapper);\r\n                var widenedType = getWidenedType(unwidenedType);\r\n\r\n                if (fullTypeCheck && program.getCompilerOptions().noImplicitAny && widenedType !== unwidenedType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {\r\n                    error(func, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeToString(widenedType));\r\n                }\r\n\r\n                return widenedType;\r\n            }\r\n\r\n            // Aggregate the types of expressions within all the return statements.\r\n            var types = checkAndAggregateReturnExpressionTypes(<Block>func.body, contextualMapper);\r\n\r\n            // Try to return the best common type if we have any return expressions.\r\n            if (types.length > 0) {\r\n                var commonType = getBestCommonType(types, /*contextualType:*/ undefined, /*candidatesOnly:*/ true);\r\n                if (!commonType) {\r\n                    error(func, Diagnostics.No_best_common_type_exists_among_return_expressions);\r\n                    \r\n                    return unknownType;\r\n                }\r\n\r\n                var widenedType = getWidenedType(commonType);\r\n\r\n                // Check and report for noImplicitAny if the best common type implicitly gets widened to an 'any'/arrays-of-'any' type.\r\n                if (fullTypeCheck && program.getCompilerOptions().noImplicitAny && widenedType !== commonType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {\r\n                    var typeName = typeToString(widenedType);\r\n\r\n                    if (func.name) {\r\n                        error(func, Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, identifierToString(func.name), typeName);\r\n                    }\r\n                    else {\r\n                        error(func, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);\r\n                    }\r\n                }\r\n\r\n                return widenedType;\r\n            }\r\n\r\n            return voidType;\r\n        }\r\n\r\n        // WARNING: This has the same semantics as the forEach family of functions,\r\n        //          in that traversal terminates in the event that 'visitor' supplies a truthy value.\r\n        function forEachReturnStatement<T>(body: Block, visitor: (stmt: ReturnStatement) => T): T {\r\n\r\n            return traverse(body);\r\n\r\n            function traverse(node: Node): T {\r\n                switch (node.kind) {\r\n                    case SyntaxKind.ReturnStatement:\r\n                        return visitor(node);\r\n                    case SyntaxKind.Block:\r\n                    case SyntaxKind.FunctionBlock:\r\n                    case SyntaxKind.IfStatement:\r\n                    case SyntaxKind.DoStatement:\r\n                    case SyntaxKind.WhileStatement:\r\n                    case SyntaxKind.ForStatement:\r\n                    case SyntaxKind.ForInStatement:\r\n                    case SyntaxKind.WithStatement:\r\n                    case SyntaxKind.SwitchStatement:\r\n                    case SyntaxKind.CaseClause:\r\n                    case SyntaxKind.DefaultClause:\r\n                    case SyntaxKind.LabelledStatement:\r\n                    case SyntaxKind.TryStatement:\r\n                    case SyntaxKind.TryBlock:\r\n                    case SyntaxKind.CatchBlock:\r\n                    case SyntaxKind.FinallyBlock:\r\n                        return forEachChild(node, traverse);\r\n                }\r\n            }\r\n        }\r\n\r\n        /// Returns a set of types relating to every return expression relating to a function block.\r\n        function checkAndAggregateReturnExpressionTypes(body: Block, contextualMapper?: TypeMapper): Type[] {\r\n            var aggregatedTypes: Type[] = [];\r\n\r\n            forEachReturnStatement(body, returnStatement => {\r\n                var expr = returnStatement.expression;\r\n                if (expr) {\r\n                    var type = checkAndMarkExpression(expr, contextualMapper);\r\n                    if (!contains(aggregatedTypes, type)) {\r\n                        aggregatedTypes.push(type);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return aggregatedTypes;\r\n        }\r\n\r\n        function bodyContainsAReturnStatement(funcBody: Block) {\r\n            return forEachReturnStatement(funcBody, returnStatement => {\r\n                return true;\r\n            });\r\n        }\r\n\r\n        function bodyContainsSingleThrowStatement(body: Block) {\r\n            return (body.statements.length === 1) && (body.statements[0].kind === SyntaxKind.ThrowStatement);\r\n        }\r\n\r\n        // TypeScript Specification 1.0 (6.3) - July 2014\r\n        // An explicitly typed function whose return type isn't the Void or the Any type\r\n        // must have at least one return statement somewhere in its body.\r\n        // An exception to this rule is if the function implementation consists of a single 'throw' statement.\r\n        function checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(func: FunctionDeclaration, returnType: Type): void {\r\n            if (!fullTypeCheck) {\r\n                return;\r\n            }\r\n\r\n            // Functions that return 'void' or 'any' don't need any return expressions.\r\n            if (returnType === voidType || returnType === anyType) {\r\n                return;\r\n            }\r\n\r\n            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.\r\n            if (!func.body || func.body.kind !== SyntaxKind.FunctionBlock) {\r\n                return;\r\n            }\r\n\r\n            var bodyBlock = <Block>func.body;\r\n\r\n            // Ensure the body has at least one return expression.\r\n            if (bodyContainsAReturnStatement(bodyBlock)) {\r\n                return;\r\n            }\r\n\r\n            // If there are no return expressions, then we need to check if\r\n            // the function body consists solely of a throw statement;\r\n            // this is to make an exception for unimplemented functions.\r\n            if (bodyContainsSingleThrowStatement(bodyBlock)) {\r\n                return;\r\n            }\r\n\r\n            // This function does not conform to the specification.\r\n            error(func.type, Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement);\r\n        }\r\n\r\n        function checkFunctionExpression(node: FunctionExpression, contextualMapper?: TypeMapper): Type {\r\n            // The identityMapper object is used to indicate that function expressions are wildcards\r\n            if (contextualMapper === identityMapper) {\r\n                return anyFunctionType;\r\n            }\r\n            var links = getNodeLinks(node);\r\n            var type = getTypeOfSymbol(node.symbol);\r\n            // Check if function expression is contextually typed and assign parameter types if so\r\n            if (!(links.flags & NodeCheckFlags.ContextChecked)) {\r\n                var contextualSignature = getContextualSignature(node);\r\n                // If a type check is started at a function expression that is an argument of a function call, obtaining the\r\n                // contextual type may recursively get back to here during overload resolution of the call. If so, we will have\r\n                // already assigned contextual types.\r\n                if (!(links.flags & NodeCheckFlags.ContextChecked)) {\r\n                    links.flags |= NodeCheckFlags.ContextChecked;\r\n                    if (contextualSignature) {\r\n                        var signature = getSignaturesOfType(type, SignatureKind.Call)[0];\r\n                        if (isContextSensitiveExpression(node)) {\r\n                            assignContextualParameterTypes(signature, contextualSignature, contextualMapper || identityMapper);\r\n                        }\r\n                        if (!node.type) {\r\n                            signature.resolvedReturnType = resolvingType;\r\n                            var returnType = getReturnTypeFromBody(node, contextualMapper);\r\n                            if (signature.resolvedReturnType === resolvingType) {\r\n                                signature.resolvedReturnType = returnType;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (fullTypeCheck && !(links.flags & NodeCheckFlags.TypeChecked)) {\r\n                checkSignatureDeclaration(node);\r\n                if (node.type) {\r\n                    checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));\r\n                }\r\n                if (node.body.kind === SyntaxKind.FunctionBlock) {\r\n                    checkSourceElement(node.body);\r\n                }\r\n                else {\r\n                    var exprType = checkExpression(node.body);\r\n                    if (node.type) {\r\n                        checkTypeAssignableTo(exprType, getTypeFromTypeNode(node.type), node.body, undefined, undefined);\r\n                    }\r\n                }\r\n                links.flags |= NodeCheckFlags.TypeChecked;\r\n            }\r\n            return type;\r\n        }\r\n\r\n        function checkArithmeticOperandType(operand: Node, type: Type, diagnostic: DiagnosticMessage): boolean {\r\n            if (!(type.flags & (TypeFlags.Any | TypeFlags.NumberLike))) {\r\n                error(operand, diagnostic);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function checkReferenceExpression(n: Node, message: DiagnosticMessage): boolean {\r\n            function findSymbol(n: Node): Symbol {\r\n                var symbol = getNodeLinks(n).resolvedSymbol;\r\n                // Because we got the symbol from the resolvedSymbol property, it might be of kind\r\n                // SymbolFlags.ExportValue. In this case it is necessary to get the actual export\r\n                // symbol, which will have the correct flags set on it.\r\n                return symbol && getExportSymbolOfValueSymbolIfExported(symbol);\r\n            }\r\n\r\n            function isReferenceOrErrorExpression(n: Node): boolean {\r\n                // TypeScript 1.0 spec (April 2014):\r\n                // Expressions are classified as values or references. \r\n                // References are the subset of expressions that are permitted as the target of an assignment.\r\n                // Specifically, references are combinations of identifiers(section 4.3), parentheses(section 4.7), \r\n                // and property accesses(section 4.10).\r\n                // All other expression constructs described in this chapter are classified as values.\r\n                switch (n.kind) {\r\n                    case SyntaxKind.Identifier:\r\n                        var symbol = findSymbol(n);\r\n                        // TypeScript 1.0 spec (April 2014): 4.3\r\n                        // An identifier expression that references a variable or parameter is classified as a reference. \r\n                        // An identifier expression that references any other kind of entity is classified as a value(and therefore cannot be the target of an assignment).\r\n                        return !symbol || symbol === unknownSymbol || symbol === argumentsSymbol || (symbol.flags & SymbolFlags.Variable) !== 0;\r\n                    case SyntaxKind.PropertyAccess:\r\n                        var symbol = findSymbol(n);\r\n                        // TypeScript 1.0 spec (April 2014): 4.10\r\n                        // A property access expression is always classified as a reference.\r\n                        // NOTE (not in spec): assignment to enum members should not be allowed\r\n                        return !symbol || symbol === unknownSymbol || (symbol.flags & ~SymbolFlags.EnumMember) !== 0;\r\n                    case SyntaxKind.IndexedAccess:\r\n                        //  old compiler doesn't check indexed assess\r\n                        return true;\r\n                    case SyntaxKind.ParenExpression:\r\n                        return isReferenceOrErrorExpression((<ParenExpression>n).expression);\r\n                    default:\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            if (!isReferenceOrErrorExpression(n)) {\r\n                error(n, message);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function checkPrefixExpression(node: UnaryExpression): Type {\r\n            var operandType = checkExpression(node.operand);\r\n            switch (node.operator) {\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.TildeToken:\r\n                    return numberType;\r\n                case SyntaxKind.ExclamationToken:\r\n                case SyntaxKind.DeleteKeyword:\r\n                    return booleanType;\r\n                case SyntaxKind.TypeOfKeyword:\r\n                    return stringType;\r\n                case SyntaxKind.VoidKeyword:\r\n                    return undefinedType;\r\n                case SyntaxKind.PlusPlusToken:\r\n                case SyntaxKind.MinusMinusToken:\r\n                    var ok = checkArithmeticOperandType(node.operand, operandType, Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);\r\n                    if (ok) {\r\n                        // run check only if former checks succeeded to avoid reporting cascading errors\r\n                        checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer);\r\n                    }\r\n                    return numberType;\r\n            }\r\n            return unknownType;\r\n        }\r\n\r\n        function checkPostfixExpression(node: UnaryExpression): Type {\r\n            var operandType = checkExpression(node.operand);\r\n            var ok = checkArithmeticOperandType(node.operand, operandType, Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);\r\n            if (ok) {\r\n                // run check only if former checks succeeded to avoid reporting cascading errors\r\n                checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer);\r\n            }\r\n            return numberType;\r\n        }\r\n\r\n        function isTypeAnyTypeObjectTypeOrTypeParameter(type: Type): boolean {\r\n            return type === anyType || ((type.flags & (TypeFlags.ObjectType | TypeFlags.TypeParameter)) !== 0);\r\n        }\r\n\r\n        function checkInstanceOfExpression(node: BinaryExpression, leftType: Type, rightType: Type): Type {\r\n            // TypeScript 1.0 spec (April 2014): 4.15.4\r\n            // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,\r\n            // and the right operand to be of type Any or a subtype of the 'Function' interface type. \r\n            // The result is always of the Boolean primitive type.\r\n            if (!isTypeAnyTypeObjectTypeOrTypeParameter(leftType)) {\r\n                error(node.left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);\r\n            }\r\n            if (rightType !== anyType && !isTypeSubtypeOf(rightType, globalFunctionType)) {\r\n                error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);\r\n            }\r\n            return booleanType;\r\n        }\r\n\r\n        function checkInExpression(node: BinaryExpression, leftType: Type, rightType: Type): Type {\r\n            // TypeScript 1.0 spec (April 2014): 4.15.5\r\n            // The in operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type,\r\n            // and the right operand to be of type Any, an object type, or a type parameter type.\r\n            // The result is always of the Boolean primitive type.\r\n            if (leftType !== anyType && leftType !== stringType && leftType !== numberType) {\r\n                error(node.left, Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number);\r\n            }\r\n            if (!isTypeAnyTypeObjectTypeOrTypeParameter(rightType)) {\r\n                error(node.right, Diagnostics.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);\r\n            }\r\n            return booleanType;\r\n        }\r\n\r\n        function checkBinaryExpression(node: BinaryExpression, contextualMapper?: TypeMapper) {\r\n            var operator = node.operator;\r\n            var leftType = checkExpression(node.left, contextualMapper);\r\n            var rightType = checkExpression(node.right, contextualMapper);\r\n            switch (operator) {\r\n                case SyntaxKind.AsteriskToken:\r\n                case SyntaxKind.AsteriskEqualsToken:\r\n                case SyntaxKind.SlashToken:\r\n                case SyntaxKind.SlashEqualsToken:\r\n                case SyntaxKind.PercentToken:\r\n                case SyntaxKind.PercentEqualsToken:\r\n                case SyntaxKind.MinusToken:\r\n                case SyntaxKind.MinusEqualsToken:\r\n                case SyntaxKind.LessThanLessThanToken:\r\n                case SyntaxKind.LessThanLessThanEqualsToken:\r\n                case SyntaxKind.GreaterThanGreaterThanToken:\r\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\r\n                case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\r\n                case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\r\n                case SyntaxKind.BarToken:\r\n                case SyntaxKind.BarEqualsToken:\r\n                case SyntaxKind.CaretToken:\r\n                case SyntaxKind.CaretEqualsToken:\r\n                case SyntaxKind.AmpersandToken:\r\n                case SyntaxKind.AmpersandEqualsToken:\r\n                    // TypeScript 1.0 spec (April 2014): 4.15.1\r\n                    // These operators require their operands to be of type Any, the Number primitive type,\r\n                    // or an enum type. Operands of an enum type are treated \r\n                    // as having the primitive type Number. If one operand is the null or undefined value,\r\n                    // it is treated as having the type of the other operand.\r\n                    // The result is always of the Number primitive type.\r\n                    if (leftType.flags & (TypeFlags.Undefined | TypeFlags.Null)) leftType = rightType;\r\n                    if (rightType.flags & (TypeFlags.Undefined | TypeFlags.Null)) rightType = leftType;\r\n\r\n                    var leftOk = checkArithmeticOperandType(node.left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);\r\n                    var rightOk = checkArithmeticOperandType(node.right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);\r\n                    if (leftOk && rightOk) {\r\n                        checkAssignmentOperator(numberType);\r\n                    }\r\n\r\n                    return numberType;\r\n                case SyntaxKind.PlusToken:\r\n                case SyntaxKind.PlusEqualsToken:\r\n                    // TypeScript 1.0 spec (April 2014): 4.15.2\r\n                    // The binary + operator requires both operands to be of the Number primitive type or an enum type,\r\n                    // or at least one of the operands to be of type Any or the String primitive type.\r\n\r\n                    // If one operand is the null or undefined value, it is treated as having the type of the other operand.\r\n                    if (leftType.flags & (TypeFlags.Undefined | TypeFlags.Null)) leftType = rightType;\r\n                    if (rightType.flags & (TypeFlags.Undefined | TypeFlags.Null)) rightType = leftType;\r\n\r\n                    var resultType: Type;\r\n                    if (leftType.flags & TypeFlags.NumberLike && rightType.flags & TypeFlags.NumberLike) {\r\n                        // Operands of an enum type are treated as having the primitive type Number.\r\n                        // If both operands are of the Number primitive type, the result is of the Number primitive type.\r\n                        resultType = numberType;\r\n                    }\r\n                    else if (leftType.flags & TypeFlags.StringLike || rightType.flags & TypeFlags.StringLike) {\r\n                        // If one or both operands are of the String primitive type, the result is of the String primitive type.\r\n                        resultType = stringType;\r\n                    }\r\n                    else if (leftType.flags & TypeFlags.Any || leftType === unknownType || rightType.flags & TypeFlags.Any || rightType === unknownType) {\r\n                        // Otherwise, the result is of type Any.\r\n                        // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.\r\n                        resultType = anyType;\r\n                    }\r\n\r\n                    if (!resultType) {\r\n                        reportOperatorError();\r\n                        return anyType;\r\n                    }\r\n\r\n                    if (operator === SyntaxKind.PlusEqualsToken) {\r\n                        checkAssignmentOperator(resultType);\r\n                    }\r\n                    return resultType;\r\n                case SyntaxKind.EqualsEqualsToken:\r\n                case SyntaxKind.ExclamationEqualsToken:\r\n                case SyntaxKind.EqualsEqualsEqualsToken:\r\n                case SyntaxKind.ExclamationEqualsEqualsToken:\r\n                case SyntaxKind.LessThanToken:\r\n                case SyntaxKind.GreaterThanToken:\r\n                case SyntaxKind.LessThanEqualsToken:\r\n                case SyntaxKind.GreaterThanEqualsToken:\r\n                    if (!isTypeSubtypeOf(leftType, rightType) && !isTypeSubtypeOf(rightType, leftType)) {\r\n                        reportOperatorError();\r\n                    }\r\n                    return booleanType;\r\n                case SyntaxKind.InstanceOfKeyword:\r\n                    return checkInstanceOfExpression(node, leftType, rightType);\r\n                case SyntaxKind.InKeyword:\r\n                    return checkInExpression(node, leftType, rightType);\r\n                case SyntaxKind.AmpersandAmpersandToken:\r\n                    return rightType;\r\n                case SyntaxKind.BarBarToken:\r\n                    return getBestCommonType([leftType, rightType], isInferentialContext(contextualMapper) ? undefined : getContextualType(node));\r\n                case SyntaxKind.EqualsToken:\r\n                    checkAssignmentOperator(rightType);\r\n                    return rightType;\r\n                case SyntaxKind.CommaToken:\r\n                    return rightType;\r\n            }\r\n\r\n            function checkAssignmentOperator(valueType: Type): void {\r\n                if (fullTypeCheck && operator >= SyntaxKind.FirstAssignment && operator <= SyntaxKind.LastAssignment) {\r\n                    // TypeScript 1.0 spec (April 2014): 4.17\r\n                    // An assignment of the form\r\n                    //    VarExpr = ValueExpr\r\n                    // requires VarExpr to be classified as a reference\r\n                    // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1) \r\n                    // and the type of the non - compound operation to be assignable to the type of VarExpr.\r\n                    var ok = checkReferenceExpression(node.left, Diagnostics.Invalid_left_hand_side_of_assignment_expression);\r\n                    // Use default messages\r\n                    if (ok) {\r\n                        // to avoid cascading errors check assignability only if 'isReference' check succeded and no errors were reported\r\n                        checkTypeAssignableTo(valueType, leftType, node.left, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n                    }\r\n                }\r\n            }\r\n\r\n            function reportOperatorError() {\r\n                error(node, Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, tokenToString(node.operator), typeToString(leftType), typeToString(rightType));\r\n            }\r\n        }\r\n\r\n        function checkConditionalExpression(node: ConditionalExpression, contextualMapper?: TypeMapper): Type {\r\n            checkExpression(node.condition);\r\n            var type1 = checkExpression(node.whenTrue, contextualMapper);\r\n            var type2 = checkExpression(node.whenFalse, contextualMapper);\r\n            var contextualType = isInferentialContext(contextualMapper) ? undefined : getContextualType(node);\r\n            var resultType = getBestCommonType([type1, type2], contextualType, true);\r\n            if (!resultType) {\r\n                if (contextualType) {\r\n                    error(node, Diagnostics.No_best_common_type_exists_between_0_1_and_2, typeToString(contextualType), typeToString(type1), typeToString(type2));\r\n                }\r\n                else {\r\n                    error(node, Diagnostics.No_best_common_type_exists_between_0_and_1, typeToString(type1), typeToString(type2));\r\n                }\r\n                resultType = emptyObjectType;\r\n            }\r\n            return resultType;\r\n        }\r\n\r\n        function checkExpressionWithContextualType(node: Expression, contextualType: Type, contextualMapper?: TypeMapper): Type {\r\n            var saveContextualType = node.contextualType;\r\n            node.contextualType = contextualType;\r\n            var result = checkExpression(node, contextualMapper);\r\n            node.contextualType = saveContextualType;\r\n            return result;\r\n        }\r\n\r\n        function checkAndMarkExpression(node: Expression, contextualMapper?: TypeMapper): Type {\r\n            var result = checkExpression(node, contextualMapper);\r\n            getNodeLinks(node).flags |= NodeCheckFlags.TypeChecked;\r\n            return result;\r\n        }\r\n\r\n        // Checks an expression and returns its type. The contextualMapper parameter serves two purposes: When\r\n        // contextualMapper is not undefined and not equal to the identityMapper function object it indicates that the\r\n        // expression is being inferentially typed (section 4.12.2 in spec) and provides the type mapper to use in\r\n        // conjuction with the generic contextual type. When contextualMapper is equal to the identityMapper function\r\n        // object, it serves as an indicator that all contained function and arrow expressions should be considered to\r\n        // have the wildcard function type; this form of type check is used during overload resolution to exclude\r\n        // contextually typed function and arrow expressions in the initial phase.\r\n        function checkExpression(node: Expression, contextualMapper?: TypeMapper): Type {\r\n            switch (node.kind) {\r\n                case SyntaxKind.Identifier:\r\n                    return checkIdentifier(<Identifier>node);\r\n                case SyntaxKind.ThisKeyword:\r\n                    return checkThisExpression(node);\r\n                case SyntaxKind.SuperKeyword:\r\n                    return checkSuperExpression(node, false);\r\n                case SyntaxKind.NullKeyword:\r\n                    return nullType;\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                    return booleanType;\r\n                case SyntaxKind.NumericLiteral:\r\n                    return numberType;\r\n                case SyntaxKind.StringLiteral:\r\n                    return stringType;\r\n                case SyntaxKind.RegularExpressionLiteral:\r\n                    return globalRegExpType;\r\n                case SyntaxKind.QualifiedName:\r\n                    return checkPropertyAccess(<QualifiedName>node);\r\n                case SyntaxKind.ArrayLiteral:\r\n                    return checkArrayLiteral(<ArrayLiteral>node, contextualMapper);\r\n                case SyntaxKind.ObjectLiteral:\r\n                    return checkObjectLiteral(<ObjectLiteral>node, contextualMapper);\r\n                case SyntaxKind.PropertyAccess:\r\n                    return checkPropertyAccess(<PropertyAccess>node);\r\n                case SyntaxKind.IndexedAccess:\r\n                    return checkIndexedAccess(<IndexedAccess>node);\r\n                case SyntaxKind.CallExpression:\r\n                case SyntaxKind.NewExpression:\r\n                    return checkCallExpression(<CallExpression>node);\r\n                case SyntaxKind.TypeAssertion:\r\n                    return checkTypeAssertion(<TypeAssertion>node);\r\n                case SyntaxKind.ParenExpression:\r\n                    return checkExpression((<ParenExpression>node).expression);\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ArrowFunction:\r\n                    return checkFunctionExpression(<FunctionExpression>node, contextualMapper);\r\n                case SyntaxKind.PrefixOperator:\r\n                    return checkPrefixExpression(<UnaryExpression>node);\r\n                case SyntaxKind.PostfixOperator:\r\n                    return checkPostfixExpression(<UnaryExpression>node);\r\n                case SyntaxKind.BinaryExpression:\r\n                    return checkBinaryExpression(<BinaryExpression>node, contextualMapper);\r\n                case SyntaxKind.ConditionalExpression:\r\n                    return checkConditionalExpression(<ConditionalExpression>node, contextualMapper);\r\n            }\r\n            return unknownType;\r\n        }\r\n\r\n        // DECLARATION AND STATEMENT TYPE CHECKING\r\n\r\n        function checkTypeParameter(node: TypeParameterDeclaration) {\r\n            checkSourceElement(node.constraint);\r\n            if (fullTypeCheck) {\r\n                checkTypeParameterHasIllegalReferencesInConstraint(node);\r\n                checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0);\r\n            }\r\n            // TODO: Check multiple declarations are identical\r\n        }\r\n\r\n        function checkParameter(parameterDeclaration: ParameterDeclaration) {\r\n            checkVariableDeclaration(parameterDeclaration);\r\n\r\n            if (fullTypeCheck) {\r\n                checkCollisionWithIndexVariableInGeneratedCode(parameterDeclaration, parameterDeclaration.name);\r\n\r\n                if (parameterDeclaration.flags & (NodeFlags.Public | NodeFlags.Private) && !(parameterDeclaration.parent.kind === SyntaxKind.Constructor && (<ConstructorDeclaration>parameterDeclaration.parent).body)) {\r\n                    error(parameterDeclaration, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);\r\n                }\r\n                if (parameterDeclaration.flags & NodeFlags.Rest) {\r\n                    if (!isArrayType(getTypeOfSymbol(parameterDeclaration.symbol))) {\r\n                        error(parameterDeclaration, Diagnostics.A_rest_parameter_must_be_of_an_array_type);\r\n                    }\r\n                }\r\n                else {\r\n                    if (parameterDeclaration.initializer && !(<FunctionDeclaration>parameterDeclaration.parent).body) {\r\n                        error(parameterDeclaration, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);\r\n                    }\r\n                }\r\n            }\r\n\r\n            function checkReferencesInInitializer(n: Node): void {\r\n                if (n.kind === SyntaxKind.Identifier) {\r\n                    var referencedSymbol = getNodeLinks(n).resolvedSymbol;\r\n                    // check FunctionDeclaration.locals (stores parameters\\function local variable) \r\n                    // if it contains entry with a specified name and if this entry matches the resolved symbol\r\n                    if (referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol(parameterDeclaration.parent.locals, referencedSymbol.name, SymbolFlags.Value) === referencedSymbol) {\r\n                        if (referencedSymbol.valueDeclaration.kind === SyntaxKind.Parameter) {\r\n                            if (referencedSymbol.valueDeclaration === parameterDeclaration) {\r\n                                error(n, Diagnostics.Parameter_0_cannot_be_referenced_in_its_initializer, identifierToString(parameterDeclaration.name));\r\n                                return;\r\n                            }\r\n                            var enclosingOrReferencedParameter =\r\n                                forEach((<FunctionDeclaration>parameterDeclaration.parent).parameters, p => p === parameterDeclaration || p === referencedSymbol.valueDeclaration ? p : undefined);\r\n\r\n                            if (enclosingOrReferencedParameter === referencedSymbol.valueDeclaration) {\r\n                                // legal case - parameter initializer references some parameter strictly on left of current parameter declaration\r\n                                return;\r\n                            }\r\n                            // fallthrough to error reporting\r\n                        }\r\n\r\n                        error(n, Diagnostics.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, identifierToString(parameterDeclaration.name), identifierToString(<Identifier>n));\r\n                    }\r\n                }\r\n                else {\r\n                    forEachChild(n, checkReferencesInInitializer);\r\n                }\r\n            }\r\n\r\n            if (parameterDeclaration.initializer) {\r\n                checkReferencesInInitializer(parameterDeclaration.initializer);\r\n            }\r\n        }\r\n\r\n        function checkSignatureDeclaration(node: SignatureDeclaration) {\r\n            checkTypeParameters(node.typeParameters);\r\n            forEach(node.parameters, checkParameter);\r\n            if (node.type) {\r\n                checkSourceElement(node.type);\r\n            }\r\n            if (fullTypeCheck) {\r\n                checkCollisionWithCapturedSuperVariable(node, node.name);\r\n                checkCollisionWithCapturedThisVariable(node, node.name);\r\n                checkCollisionWithArgumentsInGeneratedCode(node);\r\n                if (program.getCompilerOptions().noImplicitAny && !node.type) {\r\n                    switch (node.kind) {\r\n                        case SyntaxKind.ConstructSignature:\r\n                            error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);\r\n                            break;\r\n                        case SyntaxKind.CallSignature:\r\n                            error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            checkSpecializedSignatureDeclaration(node);\r\n        }\r\n\r\n        function checkTypeForDuplicateIndexSignatures(node: Node) {\r\n            if (node.kind === SyntaxKind.InterfaceDeclaration) {\r\n                var nodeSymbol = getSymbolOfNode(node);\r\n                // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration\r\n                // to prevent this run check only for the first declaration of a given kind\r\n                if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // TypeScript 1.0 spec (April 2014)\r\n            // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.\r\n            // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration\r\n            var indexSymbol = getIndexSymbol(getSymbolOfNode(node));\r\n            if (indexSymbol) {\r\n                var seenNumericIndexer = false;\r\n                var seenStringIndexer = false;\r\n                for (var i = 0, len = indexSymbol.declarations.length; i < len; ++i) {\r\n                    var declaration = <SignatureDeclaration>indexSymbol.declarations[i];\r\n                    if (declaration.parameters.length  == 1 && declaration.parameters[0].type) {\r\n                        switch (declaration.parameters[0].type.kind) {\r\n                            case SyntaxKind.StringKeyword:\r\n                                if (!seenStringIndexer) {\r\n                                    seenStringIndexer = true;\r\n                                }\r\n                                else {\r\n                                    error(declaration, Diagnostics.Duplicate_string_index_signature);\r\n                                }\r\n                                break;\r\n                            case SyntaxKind.NumberKeyword:\r\n                                if (!seenNumericIndexer) {\r\n                                    seenNumericIndexer = true;\r\n                                }\r\n                                else {\r\n                                    error(declaration, Diagnostics.Duplicate_number_index_signature);\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkPropertyDeclaration(node: PropertyDeclaration) {\r\n            // TODO\r\n            checkVariableDeclaration(node);\r\n        }\r\n\r\n        function checkMethodDeclaration(node: MethodDeclaration) {\r\n            // TODO\r\n            checkFunctionDeclaration(node);\r\n        }\r\n\r\n        function checkConstructorDeclaration(node: ConstructorDeclaration) {\r\n            // TODO\r\n            checkSignatureDeclaration(node);\r\n            checkSourceElement(node.body);\r\n\r\n            var symbol = getSymbolOfNode(node);\r\n            var firstDeclaration = getDeclarationOfKind(symbol, node.kind);\r\n            // Only type check the symbol once\r\n            if (node === firstDeclaration) {\r\n                checkFunctionOrConstructorSymbol(symbol);\r\n            }\r\n\r\n            // exit early in the case of signature - super checks are not relevant to them\r\n            if (!node.body) {\r\n                return;\r\n            }\r\n\r\n            if (!fullTypeCheck) {\r\n                return;\r\n            }\r\n\r\n            function isSuperCallExpression(n: Node): boolean {\r\n                return n.kind === SyntaxKind.CallExpression && (<CallExpression>n).func.kind === SyntaxKind.SuperKeyword;\r\n            }\r\n\r\n            function containsSuperCall(n: Node): boolean {\r\n                if (isSuperCallExpression(n)) {\r\n                    return true;\r\n                }\r\n                switch (n.kind) {\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.ArrowFunction:\r\n                    case SyntaxKind.ObjectLiteral: return false;\r\n                    default: return forEachChild(n, containsSuperCall);\r\n                }\r\n            }\r\n\r\n            function markThisReferencesAsErrors(n: Node): void {\r\n                if (n.kind === SyntaxKind.ThisKeyword) {\r\n                    error(n, Diagnostics.this_cannot_be_referenced_in_current_location);\r\n                }\r\n                else if (n.kind !== SyntaxKind.FunctionExpression && n.kind !== SyntaxKind.FunctionDeclaration) {\r\n                    forEachChild(n, markThisReferencesAsErrors);\r\n                }\r\n            }\r\n\r\n            function isInstancePropertyWithInitializer(n: Node): boolean {\r\n                return n.kind === SyntaxKind.Property &&\r\n                    !(n.flags & NodeFlags.Static) &&\r\n                    !!(<PropertyDeclaration>n).initializer;\r\n            }\r\n\r\n            // TS 1.0 spec (April 2014): 8.3.2\r\n            // Constructors of classes with no extends clause may not contain super calls, whereas \r\n            // constructors of derived classes must contain at least one super call somewhere in their function body.\r\n            if ((<ClassDeclaration>node.parent).baseType) {\r\n                \r\n                if (containsSuperCall(node.body)) {\r\n                    // The first statement in the body of a constructor must be a super call if both of the following are true:\r\n                    // - The containing class is a derived class.\r\n                    // - The constructor declares parameter properties \r\n                    //   or the containing class declares instance member variables with initializers.\r\n                    var superCallShouldBeFirst =\r\n                        forEach((<ClassDeclaration>node.parent).members, isInstancePropertyWithInitializer) ||\r\n                        forEach(node.parameters, p => p.flags & (NodeFlags.Public | NodeFlags.Private));\r\n\r\n                    if (superCallShouldBeFirst) {\r\n                        var statements = (<Block>node.body).statements;\r\n                        if (!statements.length || statements[0].kind !== SyntaxKind.ExpressionStatement || !isSuperCallExpression((<ExpressionStatement>statements[0]).expression)) {\r\n                            error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties);\r\n                        }\r\n                        else {\r\n                            // In such a required super call, it is a compile-time error for argument expressions to reference this.\r\n                            markThisReferencesAsErrors((<ExpressionStatement>statements[0]).expression);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkAccessorDeclaration(node: AccessorDeclaration) {\r\n            if (fullTypeCheck) {\r\n                if (node.kind === SyntaxKind.GetAccessor) {\r\n                    if (!isInAmbientContext(node) && node.body && !(bodyContainsAReturnStatement(<Block>node.body) || bodyContainsSingleThrowStatement(<Block>node.body))) {\r\n                        error(node.name, Diagnostics.A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement);\r\n                    }\r\n                }\r\n\r\n                // TypeScript 1.0 spec (April 2014): 8.4.3\r\n                // Accessors for the same member name must specify the same accessibility.\r\n                var otherKind = node.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor;\r\n                var otherAccessor = <AccessorDeclaration>getDeclarationOfKind(node.symbol, otherKind);\r\n                if (otherAccessor) {\r\n                    var visibilityFlags = NodeFlags.Private | NodeFlags.Public;\r\n                    if (((node.flags & visibilityFlags) !== (otherAccessor.flags & visibilityFlags))) {\r\n                        error(node.name, Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);\r\n                    }\r\n\r\n                    var thisType = getAnnotatedAccessorType(node);\r\n                    var otherType = getAnnotatedAccessorType(otherAccessor);\r\n                    // TypeScript 1.0 spec (April 2014): 4.5\r\n                    // If both accessors include type annotations, the specified types must be identical.\r\n                    if (thisType && otherType) {\r\n                        if (!isTypeIdenticalTo(thisType, otherType)) {\r\n                            error(node, Diagnostics.get_and_set_accessor_must_have_the_same_type);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            checkFunctionDeclaration(node);\r\n            checkAndStoreTypeOfAccessors(getSymbolOfNode(node));\r\n        }\r\n\r\n        function checkTypeReference(node: TypeReferenceNode) {\r\n            var type = getTypeFromTypeReferenceNode(node);\r\n            if (type !== unknownType && node.typeArguments) {\r\n                // Do type argument local checks only if referenced type is successfully resolved\r\n                var len = node.typeArguments.length;\r\n                for (var i = 0; i < len; i++) {\r\n                    checkSourceElement(node.typeArguments[i]);\r\n                    var constraint = getConstraintOfTypeParameter((<TypeReference>type).target.typeParameters[i]);\r\n                    if (fullTypeCheck && constraint) {\r\n                        var typeArgument = (<TypeReference>type).typeArguments[i];\r\n                        checkTypeAssignableTo(typeArgument, constraint, node, Diagnostics.Type_0_does_not_satisfy_the_constraint_1_Colon, Diagnostics.Type_0_does_not_satisfy_the_constraint_1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkTypeQuery(node: TypeQueryNode) {\r\n            getTypeFromTypeQueryNode(node);\r\n        }\r\n\r\n        function checkTypeLiteral(node: TypeLiteralNode) {\r\n            forEach(node.members, checkSourceElement);\r\n            if (fullTypeCheck) {\r\n                var type = getTypeFromTypeLiteralNode(node);\r\n                checkIndexConstraints(type);\r\n                checkTypeForDuplicateIndexSignatures(node);\r\n            }\r\n        }\r\n\r\n        function checkArrayType(node: ArrayTypeNode) {\r\n            getTypeFromArrayTypeNode(node);\r\n        }\r\n\r\n        function isPrivateWithinAmbient(node: Node): boolean {\r\n            return (node.flags & NodeFlags.Private) && isInAmbientContext(node);\r\n        }\r\n\r\n        function checkSpecializedSignatureDeclaration(signatureDeclarationNode: SignatureDeclaration): void {\r\n            if (!fullTypeCheck) {\r\n                return;\r\n            }\r\n            var signature = getSignatureFromDeclaration(signatureDeclarationNode);\r\n            if (!signature.hasStringLiterals) {\r\n                return;\r\n            }\r\n\r\n            // TypeScript 1.0 spec (April 2014): 3.7.2.2\r\n            // Specialized signatures are not permitted in conjunction with a function body\r\n            if ((<FunctionDeclaration>signatureDeclarationNode).body) {\r\n                error(signatureDeclarationNode, Diagnostics.A_signature_with_an_implementation_cannot_use_a_string_literal_type);\r\n                return;\r\n            }\r\n\r\n            var symbol = getSymbolOfNode(signatureDeclarationNode);\r\n            // TypeScript 1.0 spec (April 2014): 3.7.2.4\r\n            // Every specialized call or construct signature in an object type must be assignable\r\n            // to at least one non-specialized call or construct signature in the same object type\r\n            var signaturesToCheck: Signature[];\r\n            // Unnamed (call\\construct) signatures in interfaces are inherited and not shadowed so examining just node symbol won't give complete answer.\r\n            // Use declaring type to obtain full list of signatures.\r\n            if (!signatureDeclarationNode.name && signatureDeclarationNode.parent && signatureDeclarationNode.parent.kind === SyntaxKind.InterfaceDeclaration) {\r\n                Debug.assert(signatureDeclarationNode.kind === SyntaxKind.CallSignature || signatureDeclarationNode.kind === SyntaxKind.ConstructSignature);\r\n                var signatureKind = signatureDeclarationNode.kind === SyntaxKind.CallSignature ? SignatureKind.Call : SignatureKind.Construct;\r\n                var containingSymbol = getSymbolOfNode(signatureDeclarationNode.parent);\r\n                var containingType = getDeclaredTypeOfSymbol(containingSymbol);\r\n                signaturesToCheck = getSignaturesOfType(containingType, signatureKind);\r\n            }\r\n            else {\r\n                signaturesToCheck = getSignaturesOfSymbol(getSymbolOfNode(signatureDeclarationNode));\r\n            }\r\n\r\n            for (var i = 0; i < signaturesToCheck.length; i++) {\r\n                var otherSignature = signaturesToCheck[i];\r\n                if (!otherSignature.hasStringLiterals && isSignatureAssignableTo(signature, otherSignature)) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            error(signatureDeclarationNode, Diagnostics.Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature);\r\n        }\r\n\r\n        function getEffectiveDeclarationFlags(n: Node, flagsToCheck: NodeFlags) {\r\n            var flags = n.flags;\r\n            if (n.parent.kind !== SyntaxKind.InterfaceDeclaration && isInAmbientContext(n)) {\r\n                if (!(flags & NodeFlags.Ambient)) {\r\n                    // It is nested in an ambient context, which means it is automatically exported\r\n                    flags |= NodeFlags.Export;\r\n                }\r\n                flags |= NodeFlags.Ambient;\r\n            }\r\n\r\n            return flags & flagsToCheck;\r\n        }\r\n\r\n        function checkFunctionOrConstructorSymbol(symbol: Symbol): void {\r\n            if (!fullTypeCheck) {\r\n                return;\r\n            }\r\n\r\n            function checkFlagAgreementBetweenOverloads(overloads: Declaration[], implementation: FunctionDeclaration, flagsToCheck: NodeFlags, someOverloadFlags: NodeFlags, allOverloadFlags: NodeFlags): void {\r\n                // Error if some overloads have a flag that is not shared by all overloads. To find the\r\n                // deviations, we XOR someOverloadFlags with allOverloadFlags\r\n                var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;\r\n                if (someButNotAllOverloadFlags !== 0) {\r\n                    // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration\r\n                    // Error on all deviations from this canonical set of flags\r\n                    // The caveat is that if some overloads are defined in lib.d.ts, we don't want to\r\n                    // report the errors on those. To achieve this, we will say that the implementation is\r\n                    // the canonical signature only if it is in the same container as the first overload\r\n                    var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;\r\n                    var canonicalFlags = implementationSharesContainerWithFirstOverload\r\n                        ? getEffectiveDeclarationFlags(implementation, flagsToCheck)\r\n                        : getEffectiveDeclarationFlags(overloads[0], flagsToCheck);\r\n                    forEach(overloads, o => {\r\n                        var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;\r\n                        if (deviation & NodeFlags.Export) {\r\n                            error(o.name, Diagnostics.Overload_signatures_must_all_be_exported_or_not_exported);\r\n                        }\r\n                        else if (deviation & NodeFlags.Ambient) {\r\n                            error(o.name, Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);\r\n                        }\r\n                        else if (deviation & NodeFlags.Private) {\r\n                            error(o.name, Diagnostics.Overload_signatures_must_all_be_public_or_private);\r\n                        }\r\n                        else if (deviation & NodeFlags.QuestionMark) {\r\n                            error(o.name, Diagnostics.Overload_signatures_must_all_be_optional_or_required);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n            var flagsToCheck: NodeFlags = NodeFlags.Export | NodeFlags.Ambient | NodeFlags.Private | NodeFlags.QuestionMark;\r\n            var someNodeFlags: NodeFlags = 0;\r\n            var allNodeFlags = flagsToCheck;\r\n            var hasOverloads = false;\r\n            var bodyDeclaration: FunctionDeclaration;\r\n            var lastSeenNonAmbientDeclaration: FunctionDeclaration;\r\n            var previousDeclaration: FunctionDeclaration;\r\n\r\n            var declarations = symbol.declarations;\r\n            var isConstructor = (symbol.flags & SymbolFlags.Constructor) !== 0;\r\n\r\n            function reportImplementationExpectedError(node: FunctionDeclaration): void {\r\n                var seen = false;\r\n                var subsequentNode = forEachChild(node.parent, c => {\r\n                    if (seen) {\r\n                        return c;\r\n                    }\r\n                    else {\r\n                        seen = c === node;\r\n                    }\r\n                });\r\n                if (subsequentNode) {\r\n                    if (subsequentNode.kind === node.kind) {\r\n                        var errorNode: Node = (<FunctionDeclaration>subsequentNode).name || subsequentNode;\r\n                        if (node.name && (<FunctionDeclaration>subsequentNode).name && node.name.text === (<FunctionDeclaration>subsequentNode).name.text) {\r\n                            // the only situation when this is possible (same kind\\same name but different symbol) - mixed static and instance class members\r\n                            Debug.assert(node.kind === SyntaxKind.Method);\r\n                            Debug.assert((node.flags & NodeFlags.Static) !== (subsequentNode.flags & NodeFlags.Static));\r\n                            var diagnostic = node.flags & NodeFlags.Static ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static;\r\n                            error(errorNode, diagnostic);\r\n                            return;\r\n                        }\r\n                        else if ((<FunctionDeclaration>subsequentNode).body) {\r\n                            error(errorNode, Diagnostics.Function_implementation_name_must_be_0, identifierToString(node.name));\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                var errorNode: Node = node.name || node;\r\n                if (isConstructor) {\r\n                    error(errorNode, Diagnostics.Constructor_implementation_is_missing);\r\n                }\r\n                else {\r\n                    error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);\r\n                }\r\n            }\r\n\r\n            // when checking exported function declarations across modules check only duplicate implementations\r\n            // names and consistensy of modifiers are verified when we check local symbol\r\n            var isExportSymbolInsideModule = symbol.parent && symbol.parent.flags & SymbolFlags.Module;\r\n            for (var i = 0; i < declarations.length; i++) {\r\n                var node = <FunctionDeclaration>declarations[i];\r\n                var inAmbientContext = isInAmbientContext(node);\r\n                var inAmbientContextOrInterface = node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral || inAmbientContext;\r\n                if (inAmbientContextOrInterface) {\r\n                    // check if declarations are consecutive only if they are non-ambient\r\n                    // 1. ambient declarations can be interleaved\r\n                    // i.e. this is legal\r\n                    //     declare function foo();\r\n                    //     declare function bar();\r\n                    //     declare function foo();\r\n                    // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one\r\n                    previousDeclaration = undefined;\r\n                }\r\n\r\n                if (node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.Method || node.kind === SyntaxKind.Constructor) {\r\n                    var currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);\r\n                    someNodeFlags |= currentNodeFlags;\r\n                    allNodeFlags &= currentNodeFlags;\r\n\r\n                    if (node.body && bodyDeclaration) {\r\n                        if (isConstructor) {\r\n                            error(node, Diagnostics.Multiple_constructor_implementations_are_not_allowed);\r\n                        }\r\n                        else {\r\n                            error(node, Diagnostics.Duplicate_function_implementation);\r\n                        }\r\n                    }\r\n                    else if (!isExportSymbolInsideModule && previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {\r\n                        reportImplementationExpectedError(previousDeclaration);\r\n                    }\r\n\r\n                    if (node.body) {\r\n                        if (!bodyDeclaration) {\r\n                            bodyDeclaration = node;\r\n                        }\r\n                    }\r\n                    else {\r\n                        hasOverloads = true;\r\n                    }\r\n\r\n                    previousDeclaration = node;\r\n\r\n                    if (!inAmbientContextOrInterface) {\r\n                        lastSeenNonAmbientDeclaration = node;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!isExportSymbolInsideModule && lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body) {\r\n                reportImplementationExpectedError(lastSeenNonAmbientDeclaration);\r\n            }\r\n\r\n            if (hasOverloads) {\r\n                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);\r\n                if (bodyDeclaration) {\r\n                    var signatures = getSignaturesOfSymbol(symbol);\r\n                    var bodySignature = getSignatureFromDeclaration(bodyDeclaration);\r\n                    // If the implementation signature has string literals, we will have reported an error in\r\n                    // checkSpecializedSignatureDeclaration\r\n                    if (!bodySignature.hasStringLiterals) {\r\n                        // TypeScript 1.0 spec (April 2014): 6.1\r\n                        // If a function declaration includes overloads, the overloads determine the call \r\n                        // signatures of the type given to the function object \r\n                        // and the function implementation signature must be assignable to that type\r\n                        //\r\n                        // TypeScript 1.0 spec (April 2014): 3.8.4\r\n                        // Note that specialized call and construct signatures (section 3.7.2.4) are not significant when determining assignment compatibility\r\n                        // Consider checking against specialized signatures too. Not doing so creates a type hole:\r\n                        //\r\n                        // function g(x: \"hi\", y: boolean);\r\n                        // function g(x: string, y: {});\r\n                        // function g(x: string, y: string) { }\r\n                        //\r\n                        // The implementation is completely unrelated to the specialized signature, yet we do not check this.\r\n                        for (var i = 0, len = signatures.length; i < len; ++i) {\r\n                            if (!signatures[i].hasStringLiterals && !isSignatureAssignableTo(bodySignature, signatures[i])) {\r\n                                error(signatures[i].declaration, Diagnostics.Overload_signature_is_not_compatible_with_function_implementation);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkExportsOnMergedDeclarations(node: Node): void {\r\n            if (!fullTypeCheck) {\r\n                return;\r\n            }\r\n\r\n            var symbol: Symbol;\r\n\r\n            // Exports should be checked only if enclosing module contains both exported and non exported declarations.\r\n            // In case if all declarations are non-exported check is unnecesary.\r\n\r\n            // if localSymbol is defined on node then node itself is exported - check is required\r\n            var symbol = node.localSymbol;\r\n            if (!symbol) {\r\n                // local symbol is undefined => this declaration is non-exported.\r\n                // however symbol might contain other declarations that are exported\r\n                symbol = getSymbolOfNode(node);\r\n                if (!(symbol.flags & SymbolFlags.Export)) {\r\n                    // this is a pure local symbol (all declarations are non-exported) - no need to check anything\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // run the check only for the first declaration in the list\r\n            if (getDeclarationOfKind(symbol, node.kind) !== node) {\r\n                return;\r\n            }\r\n\r\n            // we use SymbolFlags.ExportValue, SymbolFlags.ExportType and SymbolFlags.ExportNamespace \r\n            // to denote disjoint declarationSpaces (without making new enum type).\r\n            var exportedDeclarationSpaces: SymbolFlags = 0;\r\n            var nonExportedDeclarationSpaces: SymbolFlags = 0;\r\n            forEach(symbol.declarations, d => {\r\n                var declarationSpaces = getDeclarationSpaces(d);\r\n                if (getEffectiveDeclarationFlags(d, NodeFlags.Export)) {\r\n                    exportedDeclarationSpaces |= declarationSpaces;\r\n                }\r\n                else {\r\n                    nonExportedDeclarationSpaces |= declarationSpaces;\r\n                }\r\n            });\r\n\r\n            var commonDeclarationSpace = exportedDeclarationSpaces & nonExportedDeclarationSpaces;\r\n\r\n            if (commonDeclarationSpace) {\r\n                // declaration spaces for exported and non-exported declarations intersect\r\n                forEach(symbol.declarations, d => {\r\n                    if (getDeclarationSpaces(d) & commonDeclarationSpace) {\r\n                        error(d.name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, identifierToString(d.name));\r\n                    }\r\n                });\r\n            }\r\n\r\n            function getDeclarationSpaces(d: Declaration): SymbolFlags {\r\n                switch (d.kind) {\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                        return SymbolFlags.ExportType;\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                        return (<ModuleDeclaration>d).name.kind === SyntaxKind.StringLiteral || isInstantiated(d)\r\n                            ? SymbolFlags.ExportNamespace | SymbolFlags.ExportValue\r\n                            : SymbolFlags.ExportNamespace;\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.EnumDeclaration:\r\n                        return SymbolFlags.ExportType | SymbolFlags.ExportValue;\r\n                    case SyntaxKind.ImportDeclaration:\r\n                        var result: SymbolFlags = 0;\r\n                        var target = resolveImport(getSymbolOfNode(d));\r\n                        forEach(target.declarations, d => { result |= getDeclarationSpaces(d); } );\r\n                        return result;\r\n                    default:\r\n                        return SymbolFlags.ExportValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkFunctionDeclaration(node: FunctionDeclaration): void {\r\n            checkSignatureDeclaration(node);\r\n\r\n            var symbol = getSymbolOfNode(node);\r\n            // first we want to check the local symbol that contain this declaration\r\n            // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol\r\n            // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode\r\n            var localSymbol = node.localSymbol || symbol;\r\n\r\n            var firstDeclaration = getDeclarationOfKind(localSymbol, node.kind);\r\n            // Only type check the symbol once\r\n            if (node === firstDeclaration) {\r\n                checkFunctionOrConstructorSymbol(localSymbol);\r\n            }\r\n\r\n            if (symbol.parent) {\r\n                // run check once for the first declaration\r\n                if (getDeclarationOfKind(symbol, node.kind) === node) {\r\n                    // run check on export symbol to check that modifiers agree across all exported declarations\r\n                    checkFunctionOrConstructorSymbol(symbol);\r\n                }\r\n            }\r\n\r\n            checkSourceElement(node.body);\r\n            if (node.type && !isAccessor(node.kind)) {\r\n                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));\r\n            }\r\n\r\n            // If there is no body and no explicit return type, then report an error.\r\n            if (fullTypeCheck && program.getCompilerOptions().noImplicitAny && !node.body && !node.type) {\r\n                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.\r\n                // (e.g. privates within .d.ts files do not expose type information)\r\n                if (!isPrivateWithinAmbient(node)) {\r\n                    var typeName = typeToString(anyType);\r\n\r\n                    if (node.name) {\r\n                        error(node, Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, identifierToString(node.name), typeName);\r\n                    }\r\n                    else {\r\n                        error(node, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkBlock(node: Block) {\r\n            forEach(node.statements, checkSourceElement);\r\n        }\r\n\r\n        function checkCollisionWithArgumentsInGeneratedCode(node: SignatureDeclaration) {\r\n            // no rest parameters \\ declaration context \\ overload - no codegen impact\r\n            if (!hasRestParameters(node) || isInAmbientContext(node) || !(<FunctionDeclaration>node).body) {\r\n                return;\r\n            }\r\n\r\n            forEach(node.parameters, p => {\r\n                if (p.name && p.name.text === argumentsSymbol.name) {\r\n                    error(p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);\r\n                }\r\n            });\r\n        }\r\n\r\n        function checkCollisionWithIndexVariableInGeneratedCode(node: Node, name: Identifier) {\r\n            if (!(name && name.text === \"_i\")) {\r\n                return;\r\n            }\r\n\r\n            if (node.kind === SyntaxKind.Parameter) {\r\n                // report error if parameter has name '_i' when:\r\n                // - function has implementation (not a signature)\r\n                // - function has rest parameters\r\n                // - context is not ambient (otherwise no codegen impact)\r\n                if ((<FunctionDeclaration>node.parent).body && hasRestParameters(<FunctionDeclaration>node.parent) && !isInAmbientContext(node)) {\r\n                    error(node, Diagnostics.Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter);                    \r\n                }\r\n                return;\r\n            }\r\n\r\n            var symbol = getNodeLinks(node).resolvedSymbol;\r\n            if (symbol === unknownSymbol) {\r\n                return;\r\n            }\r\n\r\n            // we would like to discover cases like one below:\r\n            //\r\n            // var _i = \"!\";\r\n            // function foo(...a) {\r\n            //    function bar() {\r\n            //        var x = { get baz() { return _i; } }\r\n            //    }\r\n            // }\r\n            // \r\n            // at runtime '_i' referenced in getter will be resolved to the generated index variable '_i' used to initialize rest parameters.\r\n            // legitimate case: when '_i' is defined inside the function declaration with rest parameters.\r\n            // \r\n            // function foo(...a) {\r\n            //    var _i = \"!\";\r\n            //    function bar() {\r\n            //        var x = { get baz() { return _i; } }\r\n            //    }\r\n            // }\r\n\r\n            ////  if resolved symbol for node has more than one declaration - this is definitely an error\r\n            ////  (there is nothing value-like in the language that can be nested in function and consists of multiple declarations)\r\n            //if (symbol.declarations.length > 1) {\r\n            //    error(node, Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);\r\n            //    return;\r\n            //}\r\n\r\n            // short gist of the check:\r\n            // - otherwise\r\n            // - walk to the top of the tree starting from the 'node'\r\n            // - at every step check if 'current' node contains any declaration of original node\r\n            //   yes - return\r\n            //   no - check if current declaration is function with rest parameters\r\n            //        yes - report error since '_i' from this function will shadow '_i' defined in the outer scope\r\n            //        no - go up to the next level\r\n            var current = node;\r\n            while (current) {\r\n                var definedOnCurrentLevel = forEach(symbol.declarations, d => d.parent === current ? d : undefined);\r\n                if (definedOnCurrentLevel) {\r\n                    return;\r\n                }\r\n                switch (current.kind) {\r\n                    // all kinds that might have rest parameters\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.Method:\r\n                    case SyntaxKind.ArrowFunction:\r\n                    case SyntaxKind.Constructor:\r\n                        if (hasRestParameters(<FunctionDeclaration>current)) {\r\n                            error(node, Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);\r\n                            return;\r\n                        }\r\n                        break;\r\n                }\r\n                current = current.parent;\r\n            }\r\n        }\r\n\r\n        function needCollisionCheckForIdentifier(node: Node, identifier: Identifier, name: string): boolean {\r\n            if (!(identifier && identifier.text === name)) {\r\n                return false;\r\n            }\r\n\r\n            if (node.kind === SyntaxKind.Property ||\r\n                node.kind === SyntaxKind.Method ||\r\n                node.kind === SyntaxKind.GetAccessor ||\r\n                node.kind === SyntaxKind.SetAccessor) {\r\n                // it is ok to have member named '_super' or '_this' - member access is always qualified\r\n                return false;\r\n            }\r\n\r\n            if (isInAmbientContext(node)) {\r\n                // ambient context - no codegen impact\r\n                return false;\r\n            }\r\n\r\n            if (node.kind === SyntaxKind.Parameter && !(<FunctionDeclaration>node.parent).body) {\r\n                // just an overload - no codegen impact\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function checkCollisionWithCapturedThisVariable(node: Node, name: Identifier): void {\r\n            if (!needCollisionCheckForIdentifier(node, name, \"_this\")) {\r\n                return;\r\n            }\r\n            potentialThisCollisions.push(node);\r\n        }\r\n\r\n        // this function will run after checking the source file so 'CaptureThis' is correct for all nodes\r\n        function checkIfThisIsCapturedInEnclosingScope(node: Node): void {\r\n            var current = node;\r\n            while (current) {                \r\n                if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureThis) {\r\n                    var isDeclaration = node.kind !== SyntaxKind.Identifier;\r\n                    if (isDeclaration) {\r\n                        error((<Declaration>node).name, Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);\r\n                    }\r\n                    else {\r\n                        error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);\r\n                    }\r\n                    return;\r\n                }\r\n                current = current.parent;\r\n            }\r\n        }\r\n\r\n        function checkCollisionWithCapturedSuperVariable(node: Node, name: Identifier) {\r\n            if (!needCollisionCheckForIdentifier(node, name, \"_super\")) {\r\n                return;\r\n            }\r\n\r\n            // bubble up and find containing type\r\n            var enclosingClass = <ClassDeclaration>getAncestor(node, SyntaxKind.ClassDeclaration);\r\n            // if containing type was not found or it is ambient - exit (no codegen)\r\n            if (!enclosingClass || isInAmbientContext(enclosingClass)) {\r\n                return;\r\n            }\r\n\r\n            if (enclosingClass.baseType) {\r\n                var isDeclaration = node.kind !== SyntaxKind.Identifier;\r\n                if (isDeclaration) {\r\n                    error(node, Diagnostics.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference);\r\n                }\r\n                else {\r\n                    error(node, Diagnostics.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference);\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkVariableDeclaration(node: VariableDeclaration) {\r\n            checkSourceElement(node.type);\r\n            checkExportsOnMergedDeclarations(node);\r\n\r\n            if (fullTypeCheck) {\r\n                var symbol = getSymbolOfNode(node);\r\n\r\n                var typeOfValueDeclaration = getTypeOfVariableOrParameterOrProperty(symbol);\r\n                var type: Type;\r\n                var useTypeFromValueDeclaration = node === symbol.valueDeclaration;\r\n                if (useTypeFromValueDeclaration) {\r\n                    type = typeOfValueDeclaration;\r\n                }\r\n                else {\r\n                    type = getTypeOfVariableDeclaration(node);\r\n                }\r\n\r\n\r\n                if (node.initializer) {\r\n                    if (!(getNodeLinks(node.initializer).flags & NodeCheckFlags.TypeChecked)) {\r\n                        // Use default messages\r\n                        checkTypeAssignableTo(checkAndMarkExpression(node.initializer), type, node, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n                    }\r\n                }\r\n\r\n                checkCollisionWithCapturedSuperVariable(node, node.name);\r\n                checkCollisionWithCapturedThisVariable(node, node.name);\r\n                if (!useTypeFromValueDeclaration) {\r\n                    // TypeScript 1.0 spec (April 2014): 5.1\r\n                    // Multiple declarations for the same variable name in the same declaration space are permitted,\r\n                    // provided that each declaration associates the same type with the variable.\r\n                    if (typeOfValueDeclaration !== unknownType && type !== unknownType && !isTypeIdenticalTo(typeOfValueDeclaration, type)) {\r\n                        error(node.name, Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, identifierToString(node.name), typeToString(typeOfValueDeclaration), typeToString(type));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkVariableStatement(node: VariableStatement) {\r\n            forEach(node.declarations, checkVariableDeclaration);\r\n        }\r\n\r\n        function checkExpressionStatement(node: ExpressionStatement) {\r\n            checkExpression(node.expression);\r\n        }\r\n\r\n        function checkIfStatement(node: IfStatement) {\r\n            checkExpression(node.expression);\r\n            checkSourceElement(node.thenStatement);\r\n            checkSourceElement(node.elseStatement);\r\n        }\r\n\r\n        function checkDoStatement(node: DoStatement) {\r\n            checkSourceElement(node.statement);\r\n            checkExpression(node.expression);\r\n        }\r\n\r\n        function checkWhileStatement(node: WhileStatement) {\r\n            checkExpression(node.expression);\r\n            checkSourceElement(node.statement);\r\n        }\r\n\r\n        function checkForStatement(node: ForStatement) {\r\n            if (node.declarations) forEach(node.declarations, checkVariableDeclaration);\r\n            if (node.initializer) checkExpression(node.initializer);\r\n            if (node.condition) checkExpression(node.condition);\r\n            if (node.iterator) checkExpression(node.iterator);\r\n            checkSourceElement(node.statement);\r\n        }\r\n\r\n        function checkForInStatement(node: ForInStatement) {\r\n\r\n            // TypeScript 1.0 spec  (April 2014): 5.4\r\n            // In a 'for-in' statement of the form\r\n            // for (var VarDecl in Expr) Statement\r\n            //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,\r\n            //   and Expr must be an expression of type Any, an object type, or a type parameter type.                        \r\n            if (node.declaration) {\r\n                checkVariableDeclaration(node.declaration);\r\n                if (node.declaration.type) {\r\n                    error(node.declaration, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation);\r\n                }\r\n            }\r\n\r\n            // In a 'for-in' statement of the form\r\n            // for (Var in Expr) Statement\r\n            //   Var must be an expression classified as a reference of type Any or the String primitive type,\r\n            //   and Expr must be an expression of type Any, an object type, or a type parameter type.\r\n            if (node.variable) {\r\n                var exprType = checkExpression(node.variable);\r\n                if (exprType !== anyType && exprType !== stringType) {\r\n                    error(node.variable, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);\r\n                }\r\n                else {\r\n                    // run check only former check succeeded to avoid cascading errors\r\n                    checkReferenceExpression(node.variable, Diagnostics.Invalid_left_hand_side_in_for_in_statement); \r\n                }\r\n            }\r\n\r\n            var exprType = checkExpression(node.expression);\r\n            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved\r\n            // in this case error about missing name is already reported - do not report extra one\r\n            if (!isTypeAnyTypeObjectTypeOrTypeParameter(exprType) && exprType !== unknownType) {\r\n                error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);\r\n            }\r\n\r\n            checkSourceElement(node.statement);\r\n        }\r\n\r\n        function checkBreakOrContinueStatement(node: BreakOrContinueStatement) {\r\n            // TODO: Check that target label is valid\r\n        }\r\n\r\n        function getContainingFunction(node: Node): SignatureDeclaration {\r\n            while (true) {\r\n                node = node.parent;\r\n                if (!node || node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.FunctionExpression ||\r\n                    node.kind === SyntaxKind.ArrowFunction || node.kind === SyntaxKind.Method || node.kind === SyntaxKind.Constructor ||\r\n                    node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor) {\r\n                    return <SignatureDeclaration>node;\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkReturnStatement(node: ReturnStatement) {\r\n            if (node.expression && !(getNodeLinks(node.expression).flags & NodeCheckFlags.TypeChecked)) {\r\n                var func = getContainingFunction(node);\r\n                if (func) {\r\n                    if (func.kind === SyntaxKind.SetAccessor) {\r\n                        if (node.expression) {\r\n                            error(node.expression, Diagnostics.Setters_cannot_return_a_value);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var returnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));\r\n                        // do assignability check only if we short circuited in determining return type\r\n                        // - function has explicit type annotation\r\n                        // - function is getter with no type annotation and setter parameter type is used\r\n                        // - function is a constructor (will be special cased below)\r\n                        var checkAssignability =\r\n                            func.type ||\r\n                            (func.kind === SyntaxKind.GetAccessor && getSetAccessorTypeAnnotationNode(<AccessorDeclaration>getDeclarationOfKind(func.symbol, SyntaxKind.SetAccessor)));\r\n                        if (checkAssignability) {\r\n                            checkTypeAssignableTo(checkExpression(node.expression), returnType, node.expression, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n                        }\r\n                        else if (func.kind == SyntaxKind.Constructor) {\r\n                            // constructor doesn't have explicit return type annontation and yet its return type is known - declaring type\r\n                            // handle constructors and issue specialized error message for them.\r\n                            if (!isTypeAssignableTo(checkExpression(node.expression), returnType)) {\r\n                                error(node.expression, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkWithStatement(node: WithStatement) {\r\n            checkExpression(node.expression);\r\n            error(node.expression, Diagnostics.All_symbols_within_a_with_block_will_be_resolved_to_any);\r\n        }\r\n\r\n        function checkSwitchStatement(node: SwitchStatement) {\r\n            var expressionType = checkExpression(node.expression);\r\n            forEach(node.clauses, clause => {\r\n                if (fullTypeCheck && clause.expression) {\r\n                    // TypeScript 1.0 spec (April 2014):5.9\r\n                    // In a 'switch' statement, each 'case' expression must be of a type that is assignable to or from the type of the 'switch' expression.\r\n                    var caseType = checkExpression(clause.expression);\r\n                    if (!isTypeAssignableTo(expressionType, caseType)) {\r\n                        // check 'expressionType isAssignableTo caseType' failed, try the reversed check and report errors if it fails\r\n                        checkTypeAssignableTo(caseType, expressionType, clause.expression, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n                    }\r\n                }\r\n                checkBlock(clause);\r\n            });\r\n        }\r\n\r\n        function checkLabelledStatement(node: LabelledStatement) {\r\n            checkSourceElement(node.statement);\r\n        }\r\n\r\n        function checkThrowStatement(node: ThrowStatement) {\r\n            checkExpression(node.expression);\r\n        }\r\n\r\n        function checkTryStatement(node: TryStatement) {\r\n            checkBlock(node.tryBlock);\r\n            if (node.catchBlock) checkBlock(node.catchBlock);\r\n            if (node.finallyBlock) checkBlock(node.finallyBlock);\r\n        }\r\n\r\n        function checkIndexConstraints(type: Type) { \r\n\r\n            function checkIndexConstraintForProperty(prop: Symbol, propertyType: Type, indexDeclaration: Declaration, indexType: Type, indexKind: IndexKind): void {\r\n                if (!indexType) {\r\n                    return;\r\n                }\r\n\r\n                // index is numeric and property name is not valid numeric literal\r\n                if (indexKind === IndexKind.Number && !isNumericName(prop.name)) {\r\n                    return;\r\n                }\r\n\r\n                // perform property check if property or indexer is declared in 'type'\r\n                // this allows to rule out cases when both property and indexer are inherited from the base class\r\n                var errorNode: Node;\r\n                if (prop.parent === type.symbol) {\r\n                    errorNode = prop.valueDeclaration;\r\n                }\r\n                else if (indexDeclaration) {\r\n                    errorNode = indexDeclaration;\r\n                }\r\n\r\n                else if (type.flags & TypeFlags.Interface) {\r\n                    // for interfaces property and indexer might be inherited from different bases\r\n                    // check if any base class already has both property and indexer.\r\n                    // check should be performed only if 'type' is the first type that brings property\\indexer together\r\n                    var someBaseClassHasBothPropertyAndIndexer = forEach((<InterfaceType>type).baseTypes, base => getPropertyOfType(base, prop.name) && getIndexTypeOfType(base, indexKind));\r\n                    errorNode = someBaseClassHasBothPropertyAndIndexer ? undefined : type.symbol.declarations[0];\r\n                }\r\n\r\n                if (errorNode && !isTypeAssignableTo(propertyType, indexType)) {\r\n                    var errorMessage =\r\n                        indexKind === IndexKind.String\r\n                        ? Diagnostics.Property_0_of_type_1_is_not_assignable_to_string_index_type_2\r\n                        : Diagnostics.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;\r\n                    error(errorNode, errorMessage, symbolToString(prop), typeToString(propertyType), typeToString(indexType));\r\n                }\r\n            }\r\n\r\n            var declaredNumberIndexer = getIndexDeclarationOfSymbol(type.symbol, IndexKind.Number);\r\n            var declaredStringIndexer = getIndexDeclarationOfSymbol(type.symbol, IndexKind.String);\r\n\r\n            var stringIndexType = getIndexTypeOfType(type, IndexKind.String);\r\n            var numberIndexType = getIndexTypeOfType(type, IndexKind.Number);\r\n\r\n            if (stringIndexType || numberIndexType) {\r\n                forEach(getPropertiesOfType(type), prop => {\r\n                    var propType = getTypeOfSymbol(prop);\r\n                    checkIndexConstraintForProperty(prop, propType, declaredStringIndexer, stringIndexType, IndexKind.String);\r\n                    checkIndexConstraintForProperty(prop, propType, declaredNumberIndexer, numberIndexType, IndexKind.Number);\r\n                });\r\n            }\r\n\r\n            var errorNode: Node;\r\n            if (stringIndexType && numberIndexType) {\r\n                errorNode = declaredNumberIndexer || declaredStringIndexer;\r\n                // condition 'errorNode === undefined' may appear if types does not declare nor string neither number indexer\r\n                if (!errorNode && (type.flags & TypeFlags.Interface)) {\r\n                    var someBaseTypeHasBothIndexers = forEach((<InterfaceType>type).baseTypes, base => getIndexTypeOfType(base, IndexKind.String) && getIndexTypeOfType(base, IndexKind.Number));\r\n                    errorNode = someBaseTypeHasBothIndexers ? undefined : type.symbol.declarations[0];\r\n                }\r\n            }\r\n\r\n            if (errorNode && !isTypeAssignableTo(numberIndexType, stringIndexType)) {                \r\n                error(errorNode, Diagnostics.Numeric_index_type_0_is_not_assignable_to_string_index_type_1,\r\n                    typeToString(numberIndexType), typeToString(stringIndexType));\r\n            }\r\n        }\r\n\r\n        function checkTypeNameIsReserved(name: Identifier, message: DiagnosticMessage): void {\r\n            // TS 1.0 spec (April 2014): 3.6.1\r\n            // The predefined type keywords are reserved and cannot be used as names of user defined types.\r\n            switch (name.text) {\r\n                case \"any\":\r\n                case \"number\":\r\n                case \"boolean\":\r\n                case \"string\":\r\n                case \"void\":\r\n                    error(name, message, name.text);\r\n            }\r\n        }\r\n\r\n        // Check each type parameter and check that list has no duplicate type parameter declarations\r\n        function checkTypeParameters(typeParameterDeclarations: TypeParameterDeclaration[]) {\r\n            if (typeParameterDeclarations) {\r\n                for (var i = 0; i < typeParameterDeclarations.length; i++) {\r\n                    var node = typeParameterDeclarations[i];\r\n                    checkTypeParameter(node);\r\n\r\n                    if (fullTypeCheck) {\r\n                        for (var j = 0; j < i; j++) {\r\n                            if (typeParameterDeclarations[j].symbol === node.symbol) {\r\n                                error(node.name, Diagnostics.Duplicate_identifier_0, identifierToString(node.name));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkClassDeclaration(node: ClassDeclaration) {\r\n            checkTypeNameIsReserved(node.name, Diagnostics.Class_name_cannot_be_0);\r\n            checkTypeParameters(node.typeParameters);\r\n            checkCollisionWithCapturedThisVariable(node, node.name);\r\n            checkExportsOnMergedDeclarations(node);\r\n            var symbol = getSymbolOfNode(node);\r\n            var type = <InterfaceType>getDeclaredTypeOfSymbol(symbol);\r\n            var staticType = <ObjectType>getTypeOfSymbol(symbol);\r\n            if (node.baseType) {\r\n                emitExtends = emitExtends || !isInAmbientContext(node);\r\n                checkTypeReference(node.baseType);\r\n            }\r\n            if (type.baseTypes.length) {\r\n                if (fullTypeCheck) {\r\n                    var baseType = type.baseTypes[0];\r\n                    checkTypeAssignableTo(type, baseType, node.name, Diagnostics.Class_0_incorrectly_extends_base_class_1_Colon, Diagnostics.Class_0_incorrectly_extends_base_class_1);\r\n                    var staticBaseType = getTypeOfSymbol(baseType.symbol);\r\n                    checkTypeAssignableTo(staticType, getTypeWithoutConstructors(staticBaseType), node.name,\r\n                        Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1_Colon, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);\r\n                    if (baseType.symbol !== resolveEntityName(node, node.baseType.typeName, SymbolFlags.Value)) {\r\n                        error(node.baseType, Diagnostics.Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0, typeToString(baseType));\r\n                    }\r\n\r\n                    checkKindsOfPropertyMemberOverrides(type, baseType);\r\n                }\r\n                \r\n                // Check that base type can be evaluated as expression\r\n                checkExpression(node.baseType.typeName);\r\n            }\r\n            if (node.implementedTypes) {\r\n                forEach(node.implementedTypes, typeRefNode => {\r\n                    checkTypeReference(typeRefNode);\r\n                    if (fullTypeCheck) {\r\n                        var t = getTypeFromTypeReferenceNode(typeRefNode);\r\n                        if (t !== unknownType) {\r\n                            var declaredType = (t.flags & TypeFlags.Reference) ? (<TypeReference>t).target : t;\r\n                            if (declaredType.flags & (TypeFlags.Class | TypeFlags.Interface)) {\r\n                                checkTypeAssignableTo(type, t, node.name, Diagnostics.Class_0_incorrectly_implements_interface_1_Colon, Diagnostics.Class_0_incorrectly_implements_interface_1);\r\n                            }\r\n                            else {\r\n                                error(typeRefNode, Diagnostics.A_class_may_only_implement_another_class_or_interface);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            forEach(node.members, checkSourceElement);\r\n            if (fullTypeCheck) {\r\n                checkIndexConstraints(type);\r\n                checkTypeForDuplicateIndexSignatures(node);\r\n            }\r\n        }\r\n\r\n        function getTargetSymbol(s: Symbol) {\r\n            // if symbol is instantiated it's flags are not copied from the 'target'\r\n            // so we'll need to get back original 'target' symbol to work with correct set of flags\r\n            return s.flags & SymbolFlags.Instantiated ? getSymbolLinks(s).target : s;\r\n        }\r\n\r\n        function checkKindsOfPropertyMemberOverrides(type: InterfaceType, baseType: ObjectType): void {\r\n\r\n            // TypeScript 1.0 spec (April 2014): 8.2.3\r\n            // A derived class inherits all members from its base class it doesn't override.\r\n            // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.\r\n            // Both public and private property members are inherited, but only public property members can be overridden.\r\n            // A property member in a derived class is said to override a property member in a base class\r\n            // when the derived class property member has the same name and kind(instance or static) \r\n            // as the base class property member.\r\n            // The type of an overriding property member must be assignable(section 3.8.4)\r\n            // to the type of the overridden property member, or otherwise a compile - time error occurs.\r\n            // Base class instance member functions can be overridden by derived class instance member functions,\r\n            // but not by other kinds of members.\r\n            // Base class instance member variables and accessors can be overridden by \r\n            // derived class instance member variables and accessors, but not by other kinds of members.\r\n\r\n            // NOTE: assignability is checked in checkClassDeclaration\r\n            var baseProperties = getPropertiesOfType(baseType);\r\n            for (var i = 0, len = baseProperties.length; i < len; ++i) {\r\n                var base = getTargetSymbol(baseProperties[i]);\r\n\r\n                if (base.flags & SymbolFlags.Prototype) {\r\n                    continue;\r\n                }\r\n\r\n                var derived = getTargetSymbol(getPropertyOfType(type, base.name));\r\n                if (derived) {\r\n                    var baseDeclarationFlags = getDeclarationFlagsFromSymbol(base);\r\n                    var derivedDeclarationFlags = getDeclarationFlagsFromSymbol(derived);\r\n                    if ((baseDeclarationFlags & NodeFlags.Private)  || (derivedDeclarationFlags & NodeFlags.Private)) {\r\n                        // either base or derived property is private - not override, skip it\r\n                        continue;\r\n                    }\r\n\r\n                    if ((baseDeclarationFlags & NodeFlags.Static) !== (derivedDeclarationFlags & NodeFlags.Static)) {\r\n                        // value of 'static' is not the same for properties - not override, skip it\r\n                        continue;\r\n                    }\r\n\r\n                    if ((base.flags & derived.flags & SymbolFlags.Method) || ((base.flags & SymbolFlags.PropertyOrAccessor) && (derived.flags & SymbolFlags.PropertyOrAccessor))) {\r\n                        // method is overridden with method or property\\accessor is overridden with property\\accessor - correct case\r\n                        continue;\r\n                    }\r\n\r\n                    var errorMessage: DiagnosticMessage;\r\n                    if (base.flags & SymbolFlags.Method) {\r\n                        if (derived.flags & SymbolFlags.Accessor) {\r\n                            errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;\r\n                        }\r\n                        else {\r\n                            Debug.assert(derived.flags & SymbolFlags.Property);\r\n                            errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;\r\n                        }\r\n                    }\r\n                    else if (base.flags & SymbolFlags.Property) {\r\n                        Debug.assert(derived.flags & SymbolFlags.Method);\r\n                        errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;\r\n                    }\r\n                    else {\r\n                        Debug.assert(base.flags & SymbolFlags.Accessor);\r\n                        Debug.assert(derived.flags & SymbolFlags.Method);\r\n                        errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;\r\n                    }\r\n\r\n                    error(derived.valueDeclaration.name, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));\r\n                }\r\n            }\r\n        }\r\n\r\n        function isAccessor(kind: SyntaxKind): boolean {\r\n            return kind === SyntaxKind.GetAccessor || kind === SyntaxKind.SetAccessor;\r\n        }\r\n\r\n        function areTypeParametersIdentical(list1: TypeParameterDeclaration[], list2: TypeParameterDeclaration[]) {\r\n            if (!list1 && !list2) {\r\n                return true;\r\n            }\r\n            if (!list1 || !list2 || list1.length !== list2.length) {\r\n                return false;\r\n            }\r\n            // TypeScript 1.0 spec (April 2014):\r\n            // When a generic interface has multiple declarations,  all declarations must have identical type parameter\r\n            // lists, i.e. identical type parameter names with identical constraints in identical order.\r\n            for (var i = 0, len = list1.length; i < len; i++) {\r\n                var tp1 = list1[i];\r\n                var tp2 = list2[i];\r\n                if (tp1.name.text !== tp2.name.text) {\r\n                    return false;\r\n                }\r\n                if (!tp1.constraint && !tp2.constraint) {\r\n                    continue;\r\n                }\r\n                if (!tp1.constraint || !tp2.constraint) {\r\n                    return false;\r\n                }\r\n                if (!isTypeIdenticalTo(getTypeFromTypeNode(tp1.constraint), getTypeFromTypeNode(tp2.constraint))) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function checkInterfaceDeclaration(node: InterfaceDeclaration) {\r\n            checkTypeParameters(node.typeParameters);\r\n            if (fullTypeCheck) {\r\n                checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0);\r\n\r\n                checkExportsOnMergedDeclarations(node);\r\n                var symbol = getSymbolOfNode(node);\r\n                var firstInterfaceDecl = <InterfaceDeclaration>getDeclarationOfKind(symbol, SyntaxKind.InterfaceDeclaration);\r\n                if (symbol.declarations.length > 1) {\r\n                    if (node !== firstInterfaceDecl && !areTypeParametersIdentical(firstInterfaceDecl.typeParameters, node.typeParameters)) {\r\n                        error(node.name, Diagnostics.All_declarations_of_an_interface_must_have_identical_type_parameters);\r\n                    }\r\n                }\r\n\r\n                // Only check this symbol once\r\n                if (node === firstInterfaceDecl) {\r\n                    var type = <InterfaceType>getDeclaredTypeOfSymbol(symbol);\r\n                    // run subsequent checks only if first set succeeded\r\n                    if (checkInheritedPropertiesAreIdentical(type, node.name)) {\r\n                        forEach(type.baseTypes, baseType => {\r\n                            checkTypeAssignableTo(type, baseType, node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1_Colon, Diagnostics.Interface_0_incorrectly_extends_interface_1);\r\n                        });\r\n                        checkIndexConstraints(type);\r\n                    }\r\n                }\r\n            }\r\n            forEach(node.baseTypes, checkTypeReference);\r\n            forEach(node.members, checkSourceElement);\r\n\r\n            if (fullTypeCheck) {\r\n                checkTypeForDuplicateIndexSignatures(node);\r\n            }\r\n        }\r\n\r\n        function getConstantValue(node: Expression): number {\r\n            var isNegative = false;\r\n            if (node.kind === SyntaxKind.PrefixOperator) {\r\n                var unaryExpression = <UnaryExpression>node;\r\n                if (unaryExpression.operator === SyntaxKind.MinusToken || unaryExpression.operator === SyntaxKind.PlusToken) {\r\n                    node = unaryExpression.operand;\r\n                    isNegative = unaryExpression.operator === SyntaxKind.MinusToken;\r\n                }\r\n            }\r\n            if (node.kind === SyntaxKind.NumericLiteral) {\r\n                var literalText = (<LiteralExpression>node).text;\r\n                return isNegative ? -literalText : +literalText;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        function checkEnumDeclaration(node: EnumDeclaration) {\r\n            if (!fullTypeCheck) {\r\n                return;\r\n            }\r\n            checkTypeNameIsReserved(node.name, Diagnostics.Enum_name_cannot_be_0);\r\n            checkCollisionWithCapturedThisVariable(node, node.name);\r\n            checkExportsOnMergedDeclarations(node);\r\n            var enumSymbol = getSymbolOfNode(node);\r\n            var enumType = getDeclaredTypeOfSymbol(enumSymbol);\r\n            var autoValue = 0;\r\n            var ambient = isInAmbientContext(node);\r\n            forEach(node.members, member => {\r\n                var initializer = member.initializer;\r\n                if (initializer) {\r\n                    autoValue = getConstantValue(initializer);\r\n                    if (autoValue === undefined && !ambient) {\r\n                        // Only here do we need to check that the initializer is assignable to the enum type.\r\n                        // If it is a constant value (not undefined), it is syntactically constrained to be a number. \r\n                        // Also, we do not need to check this for ambients because there is already\r\n                        // a syntax error if it is not a constant.\r\n                        checkTypeAssignableTo(checkExpression(initializer), enumType, initializer, /*chainedMessage*/ undefined, /*terminalMessage*/ undefined);\r\n                    }\r\n                }\r\n                else if (ambient) {\r\n                    autoValue = undefined;\r\n                }\r\n\r\n                if (autoValue !== undefined) {\r\n                    getNodeLinks(member).enumMemberValue = autoValue++;\r\n                }\r\n            });\r\n\r\n            // Spec 2014 - Section 9.3:\r\n            // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,\r\n            // and when an enum type has multiple declarations, only one declaration is permitted to omit a value\r\n            // for the first member.\r\n            //\r\n            // Only perform this check once per symbol\r\n            var firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);\r\n            if (node === firstDeclaration) {\r\n                var seenEnumMissingInitialInitializer = false;\r\n                forEach(enumSymbol.declarations, declaration => {\r\n                    // return true if we hit a violation of the rule, false otherwise\r\n                    if (declaration.kind !== SyntaxKind.EnumDeclaration) {\r\n                        return false;\r\n                    }\r\n\r\n                    var enumDeclaration = <EnumDeclaration>declaration;\r\n                    if (!enumDeclaration.members.length) {\r\n                        return false;\r\n                    }\r\n\r\n                    var firstEnumMember = enumDeclaration.members[0];\r\n                    if (!firstEnumMember.initializer) {\r\n                        if (seenEnumMissingInitialInitializer) {\r\n                            error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);\r\n                        }\r\n                        else {\r\n                            seenEnumMissingInitialInitializer = true;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        function getFirstNonAmbientClassOrFunctionDeclaration(symbol: Symbol): Declaration {\r\n            var declarations = symbol.declarations;\r\n            for (var i = 0; i < declarations.length; i++) {\r\n                var declaration = declarations[i];\r\n                if ((declaration.kind === SyntaxKind.ClassDeclaration || (declaration.kind === SyntaxKind.FunctionDeclaration && (<FunctionDeclaration>declaration).body)) && !isInAmbientContext(declaration)) {\r\n                    return declaration;\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function checkModuleDeclaration(node: ModuleDeclaration) {\r\n            if (fullTypeCheck) {\r\n                checkCollisionWithCapturedThisVariable(node, node.name);\r\n                checkExportsOnMergedDeclarations(node);\r\n                var symbol = getSymbolOfNode(node);\r\n                if (symbol.flags & SymbolFlags.ValueModule && symbol.declarations.length > 1 && !isInAmbientContext(node)) {\r\n                    var classOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);\r\n                    if (classOrFunc) {\r\n                        if (getSourceFileOfNode(node) !== getSourceFileOfNode(classOrFunc)) {\r\n                            error(node.name, Diagnostics.A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);\r\n                        }\r\n                        else if (node.pos < classOrFunc.pos) {\r\n                            error(node.name, Diagnostics.A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);\r\n                        }\r\n                    }\r\n                }\r\n                if (node.name.kind === SyntaxKind.StringLiteral) {\r\n                    if (!isGlobalSourceFile(node.parent)) {\r\n                        error(node.name, Diagnostics.Ambient_external_modules_cannot_be_nested_in_other_modules);\r\n                    }\r\n                    if (isExternalModuleNameRelative(node.name.text)) {\r\n                        error(node.name, Diagnostics.Ambient_external_module_declaration_cannot_specify_relative_module_name);\r\n                    }\r\n                }\r\n            }\r\n            checkSourceElement(node.body);\r\n        }\r\n\r\n        function getFirstIdentifier(node: EntityName): Identifier {\r\n            while (node.kind === SyntaxKind.QualifiedName) {\r\n                node = (<QualifiedName>node).left;\r\n            }\r\n            return <Identifier>node;\r\n        }\r\n\r\n        function checkImportDeclaration(node: ImportDeclaration) {\r\n            checkCollisionWithCapturedThisVariable(node, node.name);\r\n            var symbol = getSymbolOfNode(node);\r\n            var target: Symbol;\r\n            \r\n            if (node.entityName) {\r\n                target = resolveImport(symbol);\r\n                // Import declaration for an internal module\r\n                if (target !== unknownSymbol) {\r\n                    if (target.flags & SymbolFlags.Value) {\r\n                        // Target is a value symbol, check that it is not hidden by a local declaration with the same name and\r\n                        // ensure it can be evaluated as an expression\r\n                        var moduleName = getFirstIdentifier(node.entityName);\r\n                        if (resolveEntityName(node, moduleName, SymbolFlags.Value | SymbolFlags.Namespace).flags & SymbolFlags.Namespace) {\r\n                            checkExpression(node.entityName);\r\n                        }\r\n                        else {\r\n                            error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, identifierToString(moduleName));\r\n                        }\r\n                    }\r\n                    if (target.flags & SymbolFlags.Type) {\r\n                        checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Import declaration for an external module\r\n                if (node.parent.kind === SyntaxKind.SourceFile) {\r\n                    target = resolveImport(symbol);\r\n                }\r\n                else if (node.parent.kind === SyntaxKind.ModuleBlock && (<ModuleDeclaration>node.parent.parent).name.kind === SyntaxKind.StringLiteral) {\r\n                    // TypeScript 1.0 spec (April 2013): 12.1.6\r\n                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference \r\n                    // other external modules only through top - level external module names.\r\n                    // Relative external module names are not permitted.\r\n                    if (isExternalModuleNameRelative(node.externalModuleName.text)) {\r\n                        error(node, Diagnostics.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name);\r\n                        target = unknownSymbol;\r\n                    }\r\n                    else {\r\n                        target = resolveImport(symbol);\r\n                    }\r\n                }\r\n                else {\r\n                    // Parent is an internal module (syntax error is already reported)\r\n                    target = unknownSymbol;\r\n                }\r\n            }\r\n            if (target !== unknownSymbol) {\r\n                var excludedMeanings =\r\n                    (symbol.flags & SymbolFlags.Value ? SymbolFlags.Value : 0) |\r\n                    (symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0) |\r\n                    (symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0);\r\n                if (target.flags & excludedMeanings) {\r\n                    error(node, Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0, symbolToString(symbol));\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkExportAssignment(node: ExportAssignment) {\r\n            var container = node.parent;\r\n            if (container.kind !== SyntaxKind.SourceFile) {\r\n                // In a module, the immediate parent will be a block, so climb up one more parent\r\n                container = container.parent;\r\n            }\r\n            checkTypeOfExportAssignmentSymbol(getSymbolOfNode(container));\r\n        }\r\n\r\n        function checkSourceElement(node: Node): void {\r\n            if (!node) return;\r\n            switch (node.kind) {\r\n                case SyntaxKind.TypeParameter:\r\n                    return checkTypeParameter(<TypeParameterDeclaration>node);\r\n                case SyntaxKind.Parameter:\r\n                    return checkParameter(<ParameterDeclaration>node);\r\n                case SyntaxKind.Property:\r\n                    return checkPropertyDeclaration(<PropertyDeclaration>node);\r\n                case SyntaxKind.CallSignature:\r\n                case SyntaxKind.ConstructSignature:\r\n                case SyntaxKind.IndexSignature:\r\n                    return checkSignatureDeclaration(<SignatureDeclaration>node);\r\n                case SyntaxKind.Method:\r\n                    return checkMethodDeclaration(<MethodDeclaration>node);\r\n                case SyntaxKind.Constructor:\r\n                    return checkConstructorDeclaration(<ConstructorDeclaration>node);\r\n                case SyntaxKind.GetAccessor:\r\n                case SyntaxKind.SetAccessor:\r\n                    return checkAccessorDeclaration(<AccessorDeclaration>node);\r\n                case SyntaxKind.TypeReference:\r\n                    return checkTypeReference(<TypeReferenceNode>node);\r\n                case SyntaxKind.TypeQuery:\r\n                    return checkTypeQuery(<TypeQueryNode>node);\r\n                case SyntaxKind.TypeLiteral:\r\n                    return checkTypeLiteral(<TypeLiteralNode>node);\r\n                case SyntaxKind.ArrayType:\r\n                    return checkArrayType(<ArrayTypeNode>node);\r\n                case SyntaxKind.FunctionDeclaration:\r\n                    return checkFunctionDeclaration(<FunctionDeclaration>node);\r\n                case SyntaxKind.Block:\r\n                case SyntaxKind.FunctionBlock:\r\n                case SyntaxKind.ModuleBlock:\r\n                    return checkBlock(<Block>node);\r\n                case SyntaxKind.VariableStatement:\r\n                    return checkVariableStatement(<VariableStatement>node);\r\n                case SyntaxKind.ExpressionStatement:\r\n                    return checkExpressionStatement(<ExpressionStatement>node);\r\n                case SyntaxKind.IfStatement:\r\n                    return checkIfStatement(<IfStatement>node);\r\n                case SyntaxKind.DoStatement:\r\n                    return checkDoStatement(<DoStatement>node);\r\n                case SyntaxKind.WhileStatement:\r\n                    return checkWhileStatement(<WhileStatement>node);\r\n                case SyntaxKind.ForStatement:\r\n                    return checkForStatement(<ForStatement>node);\r\n                case SyntaxKind.ForInStatement:\r\n                    return checkForInStatement(<ForInStatement>node);\r\n                case SyntaxKind.ContinueStatement:\r\n                case SyntaxKind.BreakStatement:\r\n                    return checkBreakOrContinueStatement(<BreakOrContinueStatement>node);\r\n                case SyntaxKind.ReturnStatement:\r\n                    return checkReturnStatement(<ReturnStatement>node);\r\n                case SyntaxKind.WithStatement:\r\n                    return checkWithStatement(<WithStatement>node);\r\n                case SyntaxKind.SwitchStatement:\r\n                    return checkSwitchStatement(<SwitchStatement>node);\r\n                case SyntaxKind.LabelledStatement:\r\n                    return checkLabelledStatement(<LabelledStatement>node);\r\n                case SyntaxKind.ThrowStatement:\r\n                    return checkThrowStatement(<ThrowStatement>node);\r\n                case SyntaxKind.TryStatement:\r\n                    return checkTryStatement(<TryStatement>node);\r\n                case SyntaxKind.VariableDeclaration:\r\n                    return Debug.fail(\"Checker encountered variable declaration\");\r\n                case SyntaxKind.ClassDeclaration:\r\n                    return checkClassDeclaration(<ClassDeclaration>node);\r\n                case SyntaxKind.InterfaceDeclaration:\r\n                    return checkInterfaceDeclaration(<InterfaceDeclaration>node);\r\n                case SyntaxKind.EnumDeclaration:\r\n                    return checkEnumDeclaration(<EnumDeclaration>node);\r\n                case SyntaxKind.ModuleDeclaration:\r\n                    return checkModuleDeclaration(<ModuleDeclaration>node);\r\n                case SyntaxKind.ImportDeclaration:\r\n                    return checkImportDeclaration(<ImportDeclaration>node);\r\n                case SyntaxKind.ExportAssignment:\r\n                    return checkExportAssignment(<ExportAssignment>node);\r\n            }\r\n        }\r\n\r\n        // Fully type check a source file and collect the relevant diagnostics.\r\n        function checkSourceFile(node: SourceFile) {\r\n            var links = getNodeLinks(node);\r\n            if (!(links.flags & NodeCheckFlags.TypeChecked)) {\r\n                emitExtends = false;\r\n                potentialThisCollisions.length = 0;\r\n                forEach(node.statements, checkSourceElement);\r\n                if (isExternalModule(node)) {\r\n                    var symbol = getExportAssignmentSymbol(node.symbol);\r\n                    if (symbol && symbol.flags & SymbolFlags.Import) {\r\n                        // Mark the import as referenced so that we emit it in the final .js file.\r\n                        getSymbolLinks(symbol).referenced = true;\r\n                    }\r\n                }\r\n                if (potentialThisCollisions.length) {\r\n                    forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);\r\n                    potentialThisCollisions.length = 0;\r\n                }\r\n                if (emitExtends) links.flags |= NodeCheckFlags.EmitExtends;\r\n                links.flags |= NodeCheckFlags.TypeChecked;\r\n            }\r\n        }\r\n\r\n        function checkProgram() {\r\n            forEach(program.getSourceFiles(), checkSourceFile);\r\n        }\r\n\r\n        function getSortedDiagnostics(): Diagnostic[]{\r\n            Debug.assert(fullTypeCheck, \"diagnostics are available only in the full typecheck mode\");\r\n\r\n            if (diagnosticsModified) {\r\n                diagnostics.sort(compareDiagnostics);\r\n                diagnostics = deduplicateSortedDiagnostics(diagnostics);\r\n                diagnosticsModified = false;\r\n            }\r\n            return diagnostics;\r\n        }\r\n\r\n        function getDiagnostics(sourceFile?: SourceFile): Diagnostic[]{\r\n\r\n            if (sourceFile) {\r\n                checkSourceFile(sourceFile);\r\n                return filter(getSortedDiagnostics(), d => d.file === sourceFile);\r\n            }\r\n            checkProgram();\r\n            return getSortedDiagnostics();\r\n        }\r\n\r\n        function getGlobalDiagnostics(): Diagnostic[] {\r\n            return filter(getSortedDiagnostics(), d => !d.file);\r\n        }\r\n\r\n        // Language service support\r\n\r\n        function getNodeAtPosition(sourceFile: SourceFile, position: number): Node {\r\n            function findChildAtPosition(parent: Node) {\r\n                var child = forEachChild(parent, node => {\r\n                    if (position >= node.pos && position <= node.end && position >= getTokenPosOfNode(node)) {\r\n                        return findChildAtPosition(node);\r\n                    }\r\n                });\r\n                return child || parent;\r\n            }\r\n            if (position < sourceFile.pos) position = sourceFile.pos;\r\n            if (position > sourceFile.end) position = sourceFile.end;\r\n            return findChildAtPosition(sourceFile);\r\n        }\r\n\r\n        function getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[] {\r\n            var symbols: SymbolTable = {};\r\n            var memberFlags: NodeFlags = 0;\r\n            function copySymbol(symbol: Symbol, meaning: SymbolFlags) {\r\n                if (symbol.flags & meaning) {\r\n                    var id = symbol.name;\r\n                    if (!isReservedMemberName(id) && !hasProperty(symbols, id)) {\r\n                        symbols[id] = symbol;\r\n                    }\r\n                }\r\n            }\r\n            function copySymbols(source: SymbolTable, meaning: SymbolFlags) {\r\n                if (meaning) {\r\n                    for (var id in source) {\r\n                        if (hasProperty(source, id)) {\r\n                            copySymbol(source[id], meaning);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            while (location) {\r\n                if (location.locals && !isGlobalSourceFile(location)) {\r\n                    copySymbols(location.locals, meaning);\r\n                }\r\n                switch (location.kind) {\r\n                    case SyntaxKind.SourceFile:\r\n                        if (!isExternalModule(<SourceFile>location)) break;\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                        copySymbols(getSymbolOfNode(location).exports, meaning & SymbolFlags.ModuleMember);\r\n                        break;\r\n                    case SyntaxKind.EnumDeclaration:\r\n                        copySymbols(getSymbolOfNode(location).exports, meaning & SymbolFlags.EnumMember);\r\n                        break;\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                        if (!(memberFlags & NodeFlags.Static)) {\r\n                            copySymbols(getSymbolOfNode(location).members, meaning & SymbolFlags.Type);\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.FunctionExpression:\r\n                        if ((<FunctionExpression>location).name) {\r\n                            copySymbol(location.symbol, meaning);\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.CatchBlock:\r\n                        if ((<CatchBlock>location).variable.text) {\r\n                            copySymbol(location.symbol, meaning);\r\n                        }\r\n                        break;\r\n                }\r\n                memberFlags = location.flags;\r\n                location = location.parent;\r\n            }\r\n            copySymbols(globals, meaning);\r\n            return mapToArray(symbols);\r\n        }\r\n\r\n        // True if the given identifier is the name of a type declaration node (class, interface, enum, type parameter, etc)\r\n        function isTypeDeclarationName(name: Node): boolean {\r\n            return name.kind == SyntaxKind.Identifier &&\r\n                isTypeDeclaration(name.parent) &&\r\n                (<Declaration>name.parent).name === name;\r\n        }\r\n\r\n        // True if the given identifier, string literal, or number literal is the name of a declaration node\r\n        function isDeclarationOrFunctionExpressionOrCatchVariableName(name: Node): boolean {\r\n            if (name.kind !== SyntaxKind.Identifier && name.kind !== SyntaxKind.StringLiteral && name.kind !== SyntaxKind.NumericLiteral) {\r\n                return false;\r\n            }\r\n\r\n            var parent = name.parent;\r\n            if (isDeclaration(parent) || parent.kind === SyntaxKind.FunctionExpression) {\r\n                return (<Declaration>parent).name === name;\r\n            }\r\n\r\n            if (parent.kind === SyntaxKind.CatchBlock) {\r\n                return (<CatchBlock>parent).variable === name;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isTypeDeclaration(node: Node): boolean {\r\n            switch (node.kind) {\r\n                case SyntaxKind.TypeParameter:\r\n                case SyntaxKind.ClassDeclaration:\r\n                case SyntaxKind.InterfaceDeclaration:\r\n                case SyntaxKind.EnumDeclaration:\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        function isDeclaration(node: Node): boolean {\r\n            switch (node.kind) {\r\n                case SyntaxKind.TypeParameter:\r\n                case SyntaxKind.Parameter:\r\n                case SyntaxKind.VariableDeclaration:\r\n                case SyntaxKind.Property:\r\n                case SyntaxKind.PropertyAssignment:\r\n                case SyntaxKind.EnumMember:\r\n                case SyntaxKind.Method:\r\n                case SyntaxKind.FunctionDeclaration:\r\n                case SyntaxKind.GetAccessor:\r\n                case SyntaxKind.SetAccessor:\r\n                case SyntaxKind.ClassDeclaration:\r\n                case SyntaxKind.InterfaceDeclaration:\r\n                case SyntaxKind.EnumDeclaration:\r\n                case SyntaxKind.ModuleDeclaration:\r\n                case SyntaxKind.ImportDeclaration:\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // True if the given identifier is part of a type reference\r\n        function isTypeReferenceIdentifier(entityName: EntityName): boolean {\r\n            var node: Node = entityName;\r\n            while (node.parent && node.parent.kind === SyntaxKind.QualifiedName) node = node.parent;\r\n            return node.parent && node.parent.kind === SyntaxKind.TypeReference;\r\n        }\r\n\r\n        function isExpression(node: Node): boolean {\r\n            switch (node.kind) {\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.SuperKeyword:\r\n                case SyntaxKind.NullKeyword:\r\n                case SyntaxKind.TrueKeyword:\r\n                case SyntaxKind.FalseKeyword:\r\n                case SyntaxKind.RegularExpressionLiteral:\r\n                case SyntaxKind.ArrayLiteral:\r\n                case SyntaxKind.ObjectLiteral:\r\n                case SyntaxKind.PropertyAccess:\r\n                case SyntaxKind.IndexedAccess:\r\n                case SyntaxKind.CallExpression:\r\n                case SyntaxKind.NewExpression:\r\n                case SyntaxKind.TypeAssertion:\r\n                case SyntaxKind.ParenExpression:\r\n                case SyntaxKind.FunctionExpression:\r\n                case SyntaxKind.ArrowFunction:\r\n                case SyntaxKind.PrefixOperator:\r\n                case SyntaxKind.PostfixOperator:\r\n                case SyntaxKind.BinaryExpression:\r\n                case SyntaxKind.ConditionalExpression:\r\n                case SyntaxKind.OmittedExpression:\r\n                    return true;\r\n                case SyntaxKind.QualifiedName:\r\n                    while (node.parent.kind === SyntaxKind.QualifiedName) node = node.parent;\r\n                    return node.parent.kind === SyntaxKind.TypeQuery;\r\n                case SyntaxKind.Identifier:\r\n                    if (node.parent.kind === SyntaxKind.TypeQuery) {\r\n                        return true;\r\n                    }\r\n                // Fall through\r\n                case SyntaxKind.NumericLiteral:\r\n                case SyntaxKind.StringLiteral:\r\n                    var parent = node.parent;\r\n                    switch (parent.kind) {\r\n                        case SyntaxKind.VariableDeclaration:\r\n                        case SyntaxKind.Parameter:\r\n                        case SyntaxKind.Property:\r\n                        case SyntaxKind.EnumMember:\r\n                            return (<VariableDeclaration>parent).initializer === node;\r\n                        case SyntaxKind.ExpressionStatement:\r\n                        case SyntaxKind.IfStatement:\r\n                        case SyntaxKind.DoStatement:\r\n                        case SyntaxKind.WhileStatement:\r\n                        case SyntaxKind.ReturnStatement:\r\n                        case SyntaxKind.WithStatement:\r\n                        case SyntaxKind.SwitchStatement:\r\n                        case SyntaxKind.CaseClause:\r\n                        case SyntaxKind.ThrowStatement:\r\n                        case SyntaxKind.SwitchStatement:\r\n                            return (<ExpressionStatement>parent).expression === node;\r\n                        case SyntaxKind.ForStatement:\r\n                            return (<ForStatement>parent).initializer === node ||\r\n                                (<ForStatement>parent).condition === node ||\r\n                                (<ForStatement>parent).iterator === node;\r\n                        case SyntaxKind.ForInStatement:\r\n                            return (<ForInStatement>parent).variable === node ||\r\n                                (<ForInStatement>parent).expression === node;\r\n                        case SyntaxKind.TypeAssertion:\r\n                            return node === (<TypeAssertion>parent).operand;\r\n                        default:\r\n                            if (isExpression(parent)) {\r\n                                return true;\r\n                            }\r\n                    }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isTypeNode(node: Node): boolean {\r\n            if (node.kind >= SyntaxKind.FirstTypeNode && node.kind <= SyntaxKind.LastTypeNode) {\r\n                return true;\r\n            }\r\n\r\n            switch (node.kind) {\r\n                case SyntaxKind.AnyKeyword:\r\n                case SyntaxKind.NumberKeyword:\r\n                case SyntaxKind.StringKeyword:\r\n                case SyntaxKind.BooleanKeyword:\r\n                    return true;\r\n                case SyntaxKind.VoidKeyword:\r\n                    return node.parent.kind !== SyntaxKind.PrefixOperator;\r\n                case SyntaxKind.StringLiteral:\r\n                    // Specialized signatures can have string literals as their parameters' type names\r\n                    return node.parent.kind === SyntaxKind.Parameter;\r\n                // Identifiers and qualified names may be type nodes, depending on their context. Climb\r\n                // above them to find the lowest container\r\n                case SyntaxKind.Identifier:\r\n                    // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.\r\n                    if (node.parent.kind === SyntaxKind.QualifiedName) {\r\n                        node = node.parent;\r\n                    }\r\n                    // Fall through\r\n                case SyntaxKind.QualifiedName:\r\n                    // At this point, node is either a qualified name or an identifier\r\n                    var parent = node.parent;\r\n                    if (parent.kind === SyntaxKind.TypeQuery) {\r\n                        return false;\r\n                    }\r\n                    // Do not recursively call isTypeNode on the parent. In the example:\r\n                    //\r\n                    //     var a: A.B.C;\r\n                    //\r\n                    // Calling isTypeNode would consider the qualified name A.B a type node. Only C or\r\n                    // A.B.C is a type node.\r\n                    if (parent.kind >= SyntaxKind.FirstTypeNode && parent.kind <= SyntaxKind.LastTypeNode) {\r\n                        return true;\r\n                    }\r\n                    switch (parent.kind) {\r\n                        case SyntaxKind.TypeParameter:\r\n                            return node === (<TypeParameterDeclaration>parent).constraint;\r\n                        case SyntaxKind.Property:\r\n                        case SyntaxKind.Parameter:\r\n                        case SyntaxKind.VariableDeclaration:\r\n                            return node === (<VariableDeclaration>parent).type;\r\n                        case SyntaxKind.FunctionDeclaration:\r\n                        case SyntaxKind.FunctionExpression:\r\n                        case SyntaxKind.ArrowFunction:\r\n                        case SyntaxKind.Constructor:\r\n                        case SyntaxKind.Method:\r\n                        case SyntaxKind.GetAccessor:\r\n                        case SyntaxKind.SetAccessor:\r\n                            return node === (<FunctionDeclaration>parent).type;\r\n                        case SyntaxKind.CallSignature:\r\n                        case SyntaxKind.ConstructSignature:\r\n                        case SyntaxKind.IndexSignature:\r\n                            return node === (<SignatureDeclaration>parent).type;\r\n                        case SyntaxKind.TypeAssertion:\r\n                            return node === (<TypeAssertion>parent).type;\r\n                        case SyntaxKind.CallExpression:\r\n                        case SyntaxKind.NewExpression:\r\n                            return (<CallExpression>parent).typeArguments.indexOf(node) >= 0;\r\n                    }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isInRightSideOfImportOrExportAssignment(node: EntityName) {\r\n            while (node.parent.kind === SyntaxKind.QualifiedName) {\r\n                node = node.parent;\r\n            }\r\n\r\n            if (node.parent.kind === SyntaxKind.ImportDeclaration) {\r\n                return (<ImportDeclaration>node.parent).entityName === node;\r\n            }\r\n            if (node.parent.kind === SyntaxKind.ExportAssignment) {\r\n                return (<ExportAssignment>node.parent).exportName === node;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function isRightSideOfQualifiedNameOrPropertyAccess(node: Node) {\r\n            return (node.parent.kind === SyntaxKind.QualifiedName || node.parent.kind === SyntaxKind.PropertyAccess) &&\r\n                (<QualifiedName>node.parent).right === node;\r\n        }\r\n\r\n        function getSymbolOfEntityName(entityName: EntityName): Symbol {\r\n            if (isDeclarationOrFunctionExpressionOrCatchVariableName(entityName)) {\r\n                return getSymbolOfNode(entityName.parent);\r\n            }\r\n\r\n            if (entityName.parent.kind === SyntaxKind.ExportAssignment) {\r\n                return resolveEntityName(/*location*/ entityName.parent.parent, entityName,\r\n                    /*all meanings*/ SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Import);\r\n            }\r\n\r\n            if (isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {\r\n                entityName = entityName.parent;\r\n            }\r\n\r\n            if (isExpression(entityName)) {\r\n                if (entityName.kind === SyntaxKind.Identifier) {\r\n                    // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead\r\n                    // return the alias symbol.\r\n                    var meaning: SymbolFlags = SymbolFlags.Value | SymbolFlags.Import;\r\n                    return resolveEntityName(entityName, entityName, meaning);\r\n                }\r\n                else if (entityName.kind === SyntaxKind.QualifiedName || entityName.kind === SyntaxKind.PropertyAccess) {\r\n                    var symbol = getNodeLinks(entityName).resolvedSymbol;\r\n                    if (!symbol) {\r\n                        checkPropertyAccess(<PropertyAccess>entityName);\r\n                    }\r\n                    return getNodeLinks(entityName).resolvedSymbol;\r\n                }\r\n                else {\r\n                    // Missing identifier\r\n                    return;\r\n                }\r\n            }\r\n            else if (isTypeReferenceIdentifier(entityName)) {\r\n                var meaning = entityName.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace;\r\n                // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead\r\n                // return the alias symbol.\r\n                meaning |= SymbolFlags.Import;\r\n                return resolveEntityName(entityName, entityName, meaning);\r\n            }\r\n\r\n            // Do we want to return undefined here?\r\n            return undefined;\r\n        }\r\n\r\n        function getSymbolInfo(node: Node) {\r\n            switch (node.kind) {\r\n                case SyntaxKind.Identifier:\r\n                case SyntaxKind.PropertyAccess:\r\n                case SyntaxKind.QualifiedName:\r\n                    return getSymbolOfEntityName(<Identifier>node);\r\n\r\n                case SyntaxKind.ThisKeyword:\r\n                case SyntaxKind.SuperKeyword:\r\n                    var type = checkExpression(node);\r\n                    return type.symbol;\r\n                    \r\n                case SyntaxKind.ConstructorKeyword:\r\n                    // constructor keyword for an overload, should take us to the definition if it exist\r\n                    var constructorDeclaration = node.parent;\r\n                    if (constructorDeclaration && constructorDeclaration.kind === SyntaxKind.Constructor) {\r\n                        return (<ClassDeclaration>constructorDeclaration.parent).symbol;\r\n                    }\r\n                    return undefined;\r\n\r\n                case SyntaxKind.StringLiteral:\r\n                    // Property access\r\n                    if (node.parent.kind === SyntaxKind.IndexedAccess && (<IndexedAccess>node.parent).index === node) {\r\n                        var objectType = checkExpression((<IndexedAccess>node.parent).object);\r\n                        if (objectType === unknownType) return undefined;\r\n                        var apparentType = getApparentType(objectType);\r\n                        if (<Type>apparentType === unknownType) return undefined;\r\n                        return getPropertyOfApparentType(apparentType, (<LiteralExpression>node).text);\r\n                    }\r\n                    // External module name in an import declaration\r\n                    else if (node.parent.kind === SyntaxKind.ImportDeclaration && (<ImportDeclaration>node.parent).externalModuleName === node) {\r\n                        var importSymbol = getSymbolOfNode(node.parent);\r\n                        var moduleType = getTypeOfSymbol(importSymbol);\r\n                        return moduleType ? moduleType.symbol : undefined;\r\n                    }\r\n                    // External module name in an ambient declaration\r\n                    else if (node.parent.kind === SyntaxKind.ModuleDeclaration) {\r\n                        return getSymbolOfNode(node.parent);\r\n                    }\r\n                    break;\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function getTypeOfNode(node: Node): Type {\r\n            if (isExpression(node)) {\r\n                return getTypeOfExpression(<Expression>node);\r\n            }\r\n            if (isTypeNode(node)) {\r\n                return getTypeFromTypeNode(<TypeNode>node);\r\n            }\r\n\r\n            if (isTypeDeclaration(node)) {\r\n                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration\r\n                var symbol = getSymbolOfNode(node);\r\n                return getDeclaredTypeOfSymbol(symbol);\r\n            }\r\n\r\n            if (isTypeDeclarationName(node)) {\r\n                var symbol = getSymbolInfo(node);\r\n                return getDeclaredTypeOfSymbol(symbol);\r\n            }\r\n\r\n            if (isDeclaration(node)) {\r\n                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration\r\n                var symbol = getSymbolOfNode(node);\r\n                return getTypeOfSymbol(symbol);\r\n            }\r\n\r\n            if (isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {\r\n                var symbol = getSymbolInfo(node);\r\n                return getTypeOfSymbol(symbol);\r\n            }\r\n\r\n            if (isInRightSideOfImportOrExportAssignment(node)) {\r\n                var symbol: Symbol;\r\n                symbol = node.parent.kind === SyntaxKind.ExportAssignment\r\n                    ? getSymbolInfo(node)\r\n                    : getSymbolOfPartOfRightHandSideOfImport(node);\r\n\r\n                var declaredType = getDeclaredTypeOfSymbol(symbol);\r\n                return declaredType !== unknownType ? declaredType : getTypeOfSymbol(symbol);\r\n            }\r\n\r\n            return unknownType;\r\n        }\r\n\r\n        function getTypeOfExpression(expr: Expression): Type {\r\n            if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {\r\n                expr = expr.parent;\r\n            }\r\n            return checkExpression(expr);\r\n        }\r\n\r\n        function getAugmentedPropertiesOfApparentType(type: Type): Symbol[]{\r\n            var apparentType = getApparentType(type);\r\n\r\n            if (apparentType.flags & TypeFlags.ObjectType) {\r\n                // Augment the apprent type with Function and Object memeber as applicaple\r\n                var propertiesByName: Map<Symbol> = {};\r\n                var results: Symbol[] = [];\r\n\r\n                forEach(getPropertiesOfType(apparentType), s => {\r\n                    propertiesByName[s.name] = s;\r\n                    results.push(s);\r\n                });\r\n\r\n                var resolved = resolveObjectTypeMembers(<ObjectType>type);\r\n                forEachValue(resolved.members, s => {\r\n                    if (symbolIsValue(s) && !propertiesByName[s.name]) {\r\n                        propertiesByName[s.name] = s;\r\n                        results.push(s);\r\n                    }\r\n                });\r\n\r\n                if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {\r\n                    forEach(getPropertiesOfType(globalFunctionType), s => {\r\n                        if (!propertiesByName[s.name]) {\r\n                            propertiesByName[s.name] = s;\r\n                            results.push(s);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                return results;\r\n            }\r\n            else {\r\n                return getPropertiesOfType(<Type>apparentType);\r\n            }\r\n        }\r\n\r\n        // Emitter support\r\n\r\n        function isExternalModuleSymbol(symbol: Symbol): boolean {\r\n            return symbol.flags & SymbolFlags.ValueModule && symbol.declarations.length === 1 && symbol.declarations[0].kind === SyntaxKind.SourceFile;\r\n        }\r\n\r\n        function isNodeDescendentOf(node: Node, ancestor: Node): boolean {\r\n            while (node) {\r\n                if (node === ancestor) return true;\r\n                node = node.parent;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isUniqueLocalName(name: string, container: Node): boolean {\r\n            for (var node = container; isNodeDescendentOf(node, container); node = node.nextContainer) {\r\n                if (node.locals && hasProperty(node.locals, name) && node.locals[name].flags & (SymbolFlags.Value | SymbolFlags.ExportValue)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function getLocalNameOfContainer(container: Declaration): string {\r\n            var links = getNodeLinks(container);\r\n            if (!links.localModuleName) {\r\n                var prefix = \"\";\r\n                var name = unescapeIdentifier(container.name.text);\r\n                while (!isUniqueLocalName(escapeIdentifier(prefix + name), container)) {\r\n                    prefix += \"_\";\r\n                }\r\n                links.localModuleName = prefix + getSourceTextOfNode(container.name);\r\n            }\r\n            return links.localModuleName;\r\n        }\r\n\r\n        function getLocalNameForSymbol(symbol: Symbol, location: Node): string {\r\n            var node = location;\r\n            while (node) {\r\n                if ((node.kind === SyntaxKind.ModuleDeclaration || node.kind === SyntaxKind.EnumDeclaration) && getSymbolOfNode(node) === symbol) {\r\n                    return getLocalNameOfContainer(node);\r\n                }\r\n                node = node.parent;\r\n            }\r\n            Debug.fail(\"getLocalNameForSymbol failed\");\r\n        }\r\n\r\n        function getExpressionNamePrefix(node: Identifier): string {\r\n            var symbol = getNodeLinks(node).resolvedSymbol;\r\n            if (symbol) {\r\n                // In general, we need to prefix an identifier with its parent name if it references\r\n                // an exported entity from another module declaration. If we reference an exported\r\n                // entity within the same module declaration, then whether we prefix depends on the\r\n                // kind of entity. SymbolFlags.ExportHasLocal encompasses all the kinds that we\r\n                // do NOT prefix.\r\n                var exportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);\r\n                if (symbol !== exportSymbol && !(exportSymbol.flags & SymbolFlags.ExportHasLocal)) {\r\n                    symbol = exportSymbol;\r\n                }\r\n                if (symbol.parent) {\r\n                    return isExternalModuleSymbol(symbol.parent) ? \"exports\" : getLocalNameForSymbol(getParentOfSymbol(symbol), node.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        function getPropertyAccessSubstitution(node: PropertyAccess): string {\r\n            var symbol = getNodeLinks(node).resolvedSymbol;\r\n            if (symbol && (symbol.flags & SymbolFlags.EnumMember)) {\r\n                var declaration = symbol.valueDeclaration;\r\n                var constantValue: number;\r\n                if (declaration.kind === SyntaxKind.EnumMember && (constantValue = getNodeLinks(declaration).enumMemberValue) !== undefined) {\r\n                    return constantValue.toString() + \" /* \" + identifierToString(declaration.name) + \" */\";\r\n                }\r\n            }\r\n        }\r\n\r\n        function getExportAssignmentName(node: SourceFile): string {\r\n            var symbol = getExportAssignmentSymbol(getSymbolOfNode(node));\r\n            return symbol && symbolIsValue(symbol) ? symbolToString(symbol): undefined;\r\n        }\r\n\r\n        function isTopLevelValueImportedViaEntityName(node: ImportDeclaration): boolean {\r\n            if (node.parent.kind !== SyntaxKind.SourceFile || !node.entityName) {\r\n                // parent is not source file or it is not reference to internal module\r\n                return false;\r\n            }\r\n            var symbol = getSymbolOfNode(node);\r\n            var target = resolveImport(symbol);\r\n            return target !== unknownSymbol && ((target.flags & SymbolFlags.Value) !== 0);\r\n        }\r\n\r\n        function shouldEmitDeclarations() {\r\n            // If the declaration emit and there are no errors being reported in program or by checker\r\n            // declarations can be emitted\r\n            return program.getCompilerOptions().declaration &&\r\n                !program.getDiagnostics().length &&\r\n                !getDiagnostics().length;\r\n        }\r\n\r\n        function isReferencedImportDeclaration(node: ImportDeclaration): boolean {\r\n            var symbol = getSymbolOfNode(node);\r\n            if (getSymbolLinks(symbol).referenced) {\r\n                return true;\r\n            }\r\n            // logic below will answer 'true' for exported import declaration in a nested module that itself is not exported.\r\n            // As a consequence this might cause emitting extra.\r\n            if (node.flags & NodeFlags.Export) {\r\n                var target = resolveImport(symbol);\r\n                if (target !== unknownSymbol && target.flags & SymbolFlags.Value) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isImplementationOfOverload(node: FunctionDeclaration) {\r\n            if (node.body) {\r\n                var symbol = getSymbolOfNode(node);\r\n                return getSignaturesOfSymbol(symbol).length > 1;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function getNodeCheckFlags(node: Node): NodeCheckFlags {\r\n            return getNodeLinks(node).flags;\r\n        }\r\n\r\n        function getEnumMemberValue(node: EnumMember): number {\r\n            return getNodeLinks(node).enumMemberValue;\r\n        }\r\n\r\n        function writeTypeAtLocation(location: Node, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: TextWriter) {\r\n            // Get type of the symbol if this is the valid symbol otherwise get type at location\r\n            var symbol = getSymbolOfNode(location);\r\n            var type = symbol && !(symbol.flags & SymbolFlags.TypeLiteral) ? getTypeOfSymbol(symbol) : getTypeFromTypeNode(location);\r\n\r\n            writeTypeToTextWriter(type, enclosingDeclaration, flags, writer);\r\n        }\r\n\r\n        function writeReturnTypeOfSignatureDeclaration(signatureDeclaration: SignatureDeclaration, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: TextWriter) {\r\n            var signature = getSignatureFromDeclaration(signatureDeclaration);\r\n            writeTypeToTextWriter(getReturnTypeOfSignature(signature), enclosingDeclaration, flags , writer);\r\n        }\r\n\r\n        function invokeEmitter() {\r\n            var resolver: EmitResolver = {\r\n                getProgram: () => program,\r\n                getLocalNameOfContainer: getLocalNameOfContainer,\r\n                getExpressionNamePrefix: getExpressionNamePrefix,\r\n                getPropertyAccessSubstitution: getPropertyAccessSubstitution,\r\n                getExportAssignmentName: getExportAssignmentName,\r\n                isReferencedImportDeclaration: isReferencedImportDeclaration,\r\n                getNodeCheckFlags: getNodeCheckFlags,\r\n                getEnumMemberValue: getEnumMemberValue,\r\n                isTopLevelValueImportedViaEntityName: isTopLevelValueImportedViaEntityName,\r\n                shouldEmitDeclarations: shouldEmitDeclarations,\r\n                isDeclarationVisible: isDeclarationVisible,\r\n                isImplementationOfOverload: isImplementationOfOverload,\r\n                writeTypeAtLocation: writeTypeAtLocation,\r\n                writeReturnTypeOfSignatureDeclaration: writeReturnTypeOfSignatureDeclaration,\r\n                writeSymbol: writeSymbolToTextWriter,\r\n                isSymbolAccessible: isSymbolAccessible,\r\n                isImportDeclarationEntityNameReferenceDeclarationVisibile: isImportDeclarationEntityNameReferenceDeclarationVisibile\r\n            };\r\n            checkProgram();\r\n            return emitFiles(resolver);\r\n        }\r\n\r\n        function initializeTypeChecker() {\r\n            // Bind all source files and propagate errors\r\n            forEach(program.getSourceFiles(), file => {\r\n                bindSourceFile(file);\r\n                forEach(file.semanticErrors, addDiagnostic);\r\n            });\r\n            // Initialize global symbol table\r\n            forEach(program.getSourceFiles(), file => {\r\n                if (!isExternalModule(file)) {\r\n                    extendSymbolTable(globals, file.locals);\r\n                }\r\n            });\r\n            // Initialize special symbols\r\n            getSymbolLinks(undefinedSymbol).type = undefinedType;\r\n            getSymbolLinks(argumentsSymbol).type = getGlobalType(\"IArguments\");\r\n            getSymbolLinks(unknownSymbol).type = unknownType;\r\n            globals[undefinedSymbol.name] = undefinedSymbol;\r\n            // Initialize special types\r\n            globalArraySymbol = getGlobalSymbol(\"Array\");\r\n            globalArrayType = getTypeOfGlobalSymbol(globalArraySymbol, 1);\r\n            globalObjectType = getGlobalType(\"Object\");\r\n            globalFunctionType = getGlobalType(\"Function\");\r\n            globalStringType = getGlobalType(\"String\");\r\n            globalNumberType = getGlobalType(\"Number\");\r\n            globalBooleanType = getGlobalType(\"Boolean\");\r\n            globalRegExpType = getGlobalType(\"RegExp\");\r\n        }\r\n\r\n        initializeTypeChecker();\r\n\r\n        return checker;\r\n    }\r\n}\r\n\r\n // file: src/compiler/commandLineParser.ts\r\n/// <reference path=\"sys.ts\"/>\r\n/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"scanner.ts\"/>\r\n\r\nmodule ts {\r\n    export var optionDeclarations: CommandLineOption[] = [\r\n        {\r\n            name: \"charset\",\r\n            type: \"string\",\r\n        },\r\n        {\r\n            name: \"codepage\",\r\n            type: \"number\",\r\n        },\r\n        {\r\n            name: \"declaration\",\r\n            shortName: \"d\",\r\n            type: \"boolean\",\r\n            description: Diagnostics.Generates_corresponding_d_ts_file,\r\n        },\r\n        {\r\n            name: \"diagnostics\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"emitBOM\", \r\n            type: \"boolean\"\r\n        },\r\n        {\r\n            name: \"help\",\r\n            shortName: \"h\",\r\n            type: \"boolean\",\r\n            description: Diagnostics.Print_this_message,\r\n        },\r\n        {\r\n            name: \"locale\",\r\n            type: \"string\",\r\n        },\r\n        {\r\n            name: \"mapRoot\",\r\n            type: \"string\",\r\n            description: Diagnostics.Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations,\r\n            paramType: Diagnostics.LOCATION,\r\n        },\r\n        {\r\n            name: \"module\",\r\n            shortName: \"m\",\r\n            type: {\r\n                \"commonjs\": ModuleKind.CommonJS,\r\n                \"amd\": ModuleKind.AMD\r\n            },\r\n            description: Diagnostics.Specify_module_code_generation_Colon_commonjs_or_amd,\r\n            paramType: Diagnostics.KIND,\r\n            error: Diagnostics.Argument_for_module_option_must_be_commonjs_or_amd\r\n        },\r\n        {\r\n            name: \"noImplicitAny\",\r\n            type: \"boolean\",\r\n            description: Diagnostics.Warn_on_expressions_and_declarations_with_an_implied_any_type,\r\n        },\r\n        {\r\n            name: \"noLib\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"noLibCheck\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"noResolve\",\r\n            type: \"boolean\",\r\n        },\r\n        {\r\n            name: \"out\",\r\n            type: \"string\",\r\n            description: Diagnostics.Concatenate_and_emit_output_to_single_file,\r\n            paramType: Diagnostics.FILE,\r\n        },\r\n        {\r\n            name: \"outDir\",\r\n            type: \"string\",\r\n            description: Diagnostics.Redirect_output_structure_to_the_directory,\r\n            paramType: Diagnostics.DIRECTORY,\r\n        },\r\n        {\r\n            name: \"removeComments\",\r\n            type: \"boolean\",\r\n            description: Diagnostics.Do_not_emit_comments_to_output,\r\n        },\r\n        {\r\n            name: \"sourceMap\",\r\n            type: \"boolean\",\r\n            description: Diagnostics.Generates_corresponding_map_file,\r\n        },\r\n        {\r\n            name: \"sourceRoot\",\r\n            type: \"string\",\r\n            description: Diagnostics.Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations,\r\n            paramType: Diagnostics.LOCATION,\r\n        },\r\n        {\r\n            name: \"target\",\r\n            shortName: \"t\",\r\n            type: { \"es3\": ScriptTarget.ES3, \"es5\": ScriptTarget.ES5 },\r\n            description: Diagnostics.Specify_ECMAScript_target_version_Colon_ES3_default_or_ES5,\r\n            paramType: Diagnostics.VERSION,\r\n            error: Diagnostics.Argument_for_target_option_must_be_es3_or_es5\r\n        },\r\n        {\r\n            name: \"version\",\r\n            shortName: \"v\",\r\n            type: \"boolean\",\r\n            description: Diagnostics.Print_the_compiler_s_version,\r\n        },\r\n        {\r\n            name: \"watch\",\r\n            shortName: \"w\",\r\n            type: \"boolean\",\r\n            description: Diagnostics.Watch_input_files,\r\n        }\r\n    ];\r\n\r\n    var shortOptionNames: Map<string> = {};\r\n    var optionNameMap: Map<CommandLineOption> = {};\r\n\r\n    forEach(optionDeclarations, option => {\r\n        optionNameMap[option.name.toLowerCase()] = option;\r\n\r\n        if (option.shortName) {\r\n            shortOptionNames[option.shortName] = option.name;\r\n        }\r\n    });\r\n\r\n    export function parseCommandLine(commandLine: string[]): ParsedCommandLine {\r\n        // Set default compiler option values\r\n        var options: CompilerOptions = {\r\n            target: ScriptTarget.ES3,\r\n            module: ModuleKind.None\r\n        };\r\n        var filenames: string[] = [];\r\n        var errors: Diagnostic[] = [];\r\n\r\n        parseStrings(commandLine);\r\n        return {\r\n            options: options,\r\n            filenames: filenames,\r\n            errors: errors\r\n        };\r\n\r\n        function parseStrings(args: string[]) {\r\n            var i = 0;\r\n            while (i < args.length) {\r\n                var s = args[i++];\r\n                if (s.charCodeAt(0) === CharacterCodes.at) {\r\n                    parseResponseFile(s.slice(1));\r\n                }\r\n                else if (s.charCodeAt(0) === CharacterCodes.minus) {\r\n                    s = s.slice(s.charCodeAt(1) === CharacterCodes.minus ? 2 : 1).toLowerCase();\r\n\r\n                    // Try to translate short option names to their full equivalents.\r\n                    if (hasProperty(shortOptionNames, s)) {\r\n                        s = shortOptionNames[s];\r\n                    }\r\n\r\n                    if (hasProperty(optionNameMap, s)) {\r\n                        var opt = optionNameMap[s];\r\n\r\n                        // Check to see if no argument was provided (e.g. \"--locale\" is the last command-line argument).\r\n                        if (!args[i] && opt.type !== \"boolean\") {\r\n                            errors.push(createCompilerDiagnostic(Diagnostics.Compiler_option_0_expects_an_argument, opt.name));\r\n                        }\r\n\r\n                        switch (opt.type) {\r\n                            case \"number\":\r\n                                options[opt.name] = parseInt(args[i++]);\r\n                                break;\r\n                            case \"boolean\":\r\n                                options[opt.name] = true;\r\n                                break;\r\n                            case \"string\":\r\n                                options[opt.name] = args[i++] || \"\";\r\n                                break;\r\n                            // If not a primitive, the possible types are specified in what is effectively a map of options.\r\n                            default:\r\n                                var value = (args[i++] || \"\").toLowerCase();\r\n                                if (hasProperty(opt.type, value)) {\r\n                                    options[opt.name] = opt.type[value];\r\n                                }\r\n                                else {\r\n                                    errors.push(createCompilerDiagnostic(opt.error));\r\n                                }\r\n                        }\r\n                    }\r\n                    else {\r\n                        errors.push(createCompilerDiagnostic(Diagnostics.Unknown_compiler_option_0, s));\r\n                    }\r\n                }\r\n                else {\r\n                    filenames.push(s);\r\n                }\r\n            }\r\n        }\r\n\r\n        function parseResponseFile(filename: string) {\r\n            var text = sys.readFile(filename);\r\n\r\n            if (!text) {\r\n                errors.push(createCompilerDiagnostic(Diagnostics.File_0_not_found, filename));\r\n                return;\r\n            }\r\n\r\n            var args: string[] = [];\r\n            var pos = 0;\r\n            while (true) {\r\n                while (pos < text.length && text.charCodeAt(pos) <= CharacterCodes.space) pos++;\r\n                if (pos >= text.length) break;\r\n                var start = pos;\r\n                if (text.charCodeAt(start) === CharacterCodes.doubleQuote) {\r\n                    pos++;\r\n                    while (pos < text.length && text.charCodeAt(pos) !== CharacterCodes.doubleQuote) pos++;\r\n                    if (pos < text.length) {\r\n                        args.push(text.substring(start + 1, pos));\r\n                        pos++;\r\n                    }\r\n                    else {\r\n                        errors.push(createCompilerDiagnostic(Diagnostics.Unterminated_quoted_string_in_response_file_0, filename));\r\n                    }\r\n                }\r\n                else {\r\n                    while (text.charCodeAt(pos) > CharacterCodes.space) pos++;\r\n                    args.push(text.substring(start, pos));\r\n                }\r\n            }\r\n            parseStrings(args);\r\n        }\r\n    }\r\n}\r\n\r\n // file: src/compiler/tsc.ts\r\n/// <reference path=\"core.ts\"/>\r\n/// <reference path=\"sys.ts\"/>\r\n/// <reference path=\"types.ts\"/>\r\n/// <reference path=\"scanner.ts\"/>\r\n/// <reference path=\"parser.ts\"/>\r\n/// <reference path=\"binder.ts\"/>\r\n/// <reference path=\"checker.ts\"/>\r\n/// <reference path=\"emitter.ts\"/>\r\n/// <reference path=\"commandLineParser.ts\"/>\r\n\r\nmodule ts {\r\n    var version = \"1.1.0.0\";\r\n\r\n    /**\r\n     * Checks to see if the locale is in the appropriate format,\r\n     * and if it is, attempts to set the appropriate language.\r\n     */\r\n    function validateLocaleAndSetLanguage(locale: string, errors: Diagnostic[]): boolean {\r\n        var matchResult = /^([a-z]+)([_\\-]([a-z]+))?$/.exec(locale.toLowerCase());\r\n\r\n        if (!matchResult) {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, 'en', 'ja-jp'));\r\n            return false;\r\n        }\r\n\r\n        var language = matchResult[1];\r\n        var territory = matchResult[3];\r\n\r\n        // First try the entire locale, then fall back to just language if that's all we have.\r\n        if (!trySetLanguageAndTerritory(language, territory, errors) &&\r\n            !trySetLanguageAndTerritory(language, undefined, errors)) {\r\n\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Unsupported_locale_0, locale));\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function trySetLanguageAndTerritory(language: string, territory: string, errors: Diagnostic[]): boolean {\r\n        var compilerFilePath = normalizePath(sys.getExecutingFilePath());\r\n        var containingDirectoryPath = getDirectoryPath(compilerFilePath);\r\n\r\n        var filePath = combinePaths(containingDirectoryPath, language);\r\n\r\n        if (territory) {\r\n            filePath = filePath + \"-\" + territory;\r\n        }\r\n\r\n        filePath = sys.resolvePath(combinePaths(filePath, \"diagnosticMessages.generated.json\"));\r\n\r\n        if (!sys.fileExists(filePath)) {\r\n            return false;\r\n        }\r\n\r\n        // TODO: Add codePage support for readFile?\r\n        try {\r\n            var fileContents = sys.readFile(filePath);\r\n        }\r\n        catch (e) {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Unable_to_open_file_0, filePath));\r\n            return false;\r\n        }\r\n        try {\r\n            ts.localizedDiagnosticMessages = JSON.parse(fileContents);\r\n        }\r\n        catch (e) {\r\n            errors.push(createCompilerDiagnostic(Diagnostics.Corrupted_locale_file_0, filePath));\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function countLines(program: Program): number {\r\n        var count = 0;\r\n        forEach(program.getSourceFiles(), file => {\r\n            count += file.getLineAndCharacterFromPosition(file.end).line;\r\n        });\r\n        return count;\r\n    }\r\n\r\n    function getDiagnosticText(message: DiagnosticMessage, ...args: any[]): string {\r\n        var diagnostic: Diagnostic = createCompilerDiagnostic.apply(undefined, arguments);\r\n        return diagnostic.messageText;\r\n    }\r\n\r\n    function reportDiagnostic(diagnostic: Diagnostic) {\r\n        var output = \"\";\r\n        \r\n        if (diagnostic.file) {\r\n            var loc = diagnostic.file.getLineAndCharacterFromPosition(diagnostic.start);\r\n\r\n            output += diagnostic.file.filename + \"(\" + loc.line + \",\" + loc.character + \"): \";\r\n        }\r\n\r\n        var category = DiagnosticCategory[diagnostic.category].toLowerCase();\r\n        output += category + \" TS\" + diagnostic.code + \": \" + diagnostic.messageText + sys.newLine;\r\n\r\n        sys.write(output);\r\n    }\r\n\r\n    function reportDiagnostics(diagnostics: Diagnostic[]) {\r\n        for (var i = 0; i < diagnostics.length; i++) {\r\n            reportDiagnostic(diagnostics[i]);\r\n        }\r\n    }\r\n\r\n    function padLeft(s: string, length: number) {\r\n        while (s.length < length) {\r\n            s = \" \" + s;\r\n        }\r\n        return s;\r\n    }\r\n\r\n    function padRight(s: string, length: number) {\r\n        while (s.length < length) {\r\n            s = s + \" \";\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    function reportStatisticalValue(name: string, value: string) {\r\n        sys.write(padRight(name + \":\", 12) + padLeft(value.toString(), 10) + sys.newLine);\r\n    }\r\n\r\n    function reportCountStatistic(name: string, count: number) {\r\n        reportStatisticalValue(name, \"\" + count);\r\n    }\r\n\r\n    function reportTimeStatistic(name: string, time: number) {\r\n        reportStatisticalValue(name, (time / 1000).toFixed(2) + \"s\");\r\n    }\r\n\r\n    function createCompilerHost(options: CompilerOptions): CompilerHost {\r\n        var currentDirectory: string;\r\n        var existingDirectories: Map<boolean> = {};\r\n\r\n        function getCanonicalFileName(fileName: string): string {\r\n            // if underlying system can distinguish between two files whose names differs only in cases then file name already in canonical form.\r\n            // otherwise use toLowerCase as a canonical form.\r\n            return sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase();\r\n        }\r\n\r\n        function getSourceFile(filename: string, languageVersion: ScriptTarget, onError?: (message: string) => void): SourceFile {\r\n            try {\r\n                var text = sys.readFile(filename, options.charset);\r\n            }\r\n            catch (e) {\r\n                if (onError) {\r\n                    onError(e.message);\r\n                }\r\n                text = \"\";\r\n            }\r\n            return text !== undefined ? createSourceFile(filename, text, languageVersion, /*version:*/ \"0\") : undefined;\r\n        }\r\n\r\n        function writeFile(fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void) {\r\n\r\n            function directoryExists(directoryPath: string): boolean {\r\n                if (hasProperty(existingDirectories, directoryPath)) {\r\n                    return true;\r\n                }\r\n                if (sys.directoryExists(directoryPath)) {\r\n                    existingDirectories[directoryPath] = true;\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n\r\n            function ensureDirectoriesExist(directoryPath: string) {\r\n                if (directoryPath.length > getRootLength(directoryPath) && !directoryExists(directoryPath)) {\r\n                    var parentDirectory = getDirectoryPath(directoryPath);\r\n                    ensureDirectoriesExist(parentDirectory);\r\n                    sys.createDirectory(directoryPath);\r\n                }\r\n            }\r\n\r\n            try {\r\n                ensureDirectoriesExist(getDirectoryPath(normalizePath(fileName)));\r\n                sys.writeFile(fileName, data, writeByteOrderMark);\r\n            }\r\n            catch (e) {\r\n                if (onError) onError(e.message);\r\n            }\r\n        }\r\n\r\n        return {\r\n            getSourceFile: getSourceFile,\r\n            getDefaultLibFilename: () => combinePaths(getDirectoryPath(normalizePath(sys.getExecutingFilePath())), \"lib.d.ts\"),\r\n            writeFile: writeFile,\r\n            getCurrentDirectory: () => currentDirectory || (currentDirectory = sys.getCurrentDirectory()),\r\n            useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,\r\n            getCanonicalFileName: getCanonicalFileName,\r\n            getNewLine: () => sys.newLine\r\n        };\r\n    }\r\n\r\n    export function executeCommandLine(args: string[]): void {\r\n        var commandLine = parseCommandLine(args);\r\n\r\n        if (commandLine.options.locale) {\r\n            validateLocaleAndSetLanguage(commandLine.options.locale, commandLine.errors);\r\n        }\r\n\r\n        // If there are any errors due to command line parsing and/or\r\n        // setting up localization, report them and quit.\r\n        if (commandLine.errors.length > 0) {\r\n            reportDiagnostics(commandLine.errors);\r\n            return sys.exit(1);\r\n        }\r\n\r\n        if (commandLine.options.version) {\r\n            reportDiagnostic(createCompilerDiagnostic(Diagnostics.Version_0, version));\r\n            return sys.exit(0);\r\n        }\r\n\r\n        if (commandLine.options.help || commandLine.filenames.length === 0) {\r\n            printVersion();\r\n            printHelp();\r\n            return sys.exit(0);\r\n        }\r\n\r\n        var defaultCompilerHost = createCompilerHost(commandLine.options);\r\n        \r\n        if (commandLine.options.watch) {\r\n            if (!sys.watchFile) {\r\n                reportDiagnostic(createCompilerDiagnostic(Diagnostics.The_current_host_does_not_support_the_0_option, \"--watch\"));\r\n                return sys.exit(1);\r\n            }\r\n\r\n            watchProgram(commandLine, defaultCompilerHost);\r\n        }\r\n        else {\r\n            var result = compile(commandLine, defaultCompilerHost).errors.length > 0 ? 1 : 0;\r\n            return sys.exit(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compiles the program once, and then watches all given and referenced files for changes.\r\n     * Upon detecting a file change, watchProgram will queue up file modification events for the next\r\n     * 250ms and then perform a recompilation. The reasoning is that in some cases, an editor can\r\n     * save all files at once, and we'd like to just perform a single recompilation.\r\n     */\r\n    function watchProgram(commandLine: ParsedCommandLine, compilerHost: CompilerHost): void {\r\n        var watchers: Map<FileWatcher> = {};\r\n        var updatedFiles: Map<boolean> = {};\r\n\r\n        // Compile the program the first time and watch all given/referenced files.\r\n        var program = compile(commandLine, compilerHost).program;\r\n        reportDiagnostic(createCompilerDiagnostic(Diagnostics.Compilation_complete_Watching_for_file_changes));\r\n        addWatchers(program);\r\n        return;\r\n\r\n        function addWatchers(program: Program) {\r\n            forEach(program.getSourceFiles(), f => {\r\n                var filename = getCanonicalName(f.filename);\r\n                watchers[filename] = sys.watchFile(filename, fileUpdated);\r\n            });\r\n        }\r\n\r\n        function removeWatchers(program: Program) {\r\n            forEach(program.getSourceFiles(), f => {\r\n                var filename = getCanonicalName(f.filename);\r\n                if (hasProperty(watchers, filename)) {\r\n                    watchers[filename].close();\r\n                }\r\n            });\r\n\r\n            watchers = {};\r\n        }\r\n\r\n        // Fired off whenever a file is changed.\r\n        function fileUpdated(filename: string) {\r\n            var firstNotification = isEmpty(updatedFiles);\r\n            updatedFiles[getCanonicalName(filename)] = true;\r\n\r\n            // Only start this off when the first file change comes in,\r\n            // so that we can batch up all further changes.\r\n            if (firstNotification) {\r\n                setTimeout(() => {\r\n                    var changedFiles = updatedFiles;\r\n                    updatedFiles = {};\r\n\r\n                    recompile(changedFiles);\r\n                }, 250);\r\n            }\r\n        }\r\n\r\n        function recompile(changedFiles: Map<boolean>) {\r\n            reportDiagnostic(createCompilerDiagnostic(Diagnostics.File_change_detected_Compiling));\r\n            // Remove all the watchers, as we may not be watching every file\r\n            // specified since the last compilation cycle.\r\n            removeWatchers(program);\r\n\r\n            // Reuse source files from the last compilation so long as they weren't changed.\r\n            var oldSourceFiles = arrayToMap(\r\n                filter(program.getSourceFiles(), file => !hasProperty(changedFiles, getCanonicalName(file.filename))),\r\n                file => getCanonicalName(file.filename));\r\n\r\n            // We create a new compiler host for this compilation cycle.\r\n            // This new host is effectively the same except that 'getSourceFile'\r\n            // will try to reuse the SourceFiles from the last compilation cycle\r\n            // so long as they were not modified.\r\n            var newCompilerHost = clone(compilerHost);\r\n            newCompilerHost.getSourceFile = (fileName, languageVersion, onError) => {\r\n                fileName = getCanonicalName(fileName);\r\n\r\n                var sourceFile = lookUp(oldSourceFiles, fileName);\r\n                if (sourceFile) {\r\n                    return sourceFile;\r\n                }\r\n\r\n                return compilerHost.getSourceFile(fileName, languageVersion, onError);\r\n            };\r\n\r\n            program = compile(commandLine, newCompilerHost).program;\r\n            reportDiagnostic(createCompilerDiagnostic(Diagnostics.Compilation_complete_Watching_for_file_changes));\r\n            addWatchers(program);\r\n        }\r\n\r\n        function getCanonicalName(fileName: string) {\r\n            return compilerHost.getCanonicalFileName(fileName);\r\n        }\r\n    }\r\n\r\n    function compile(commandLine: ParsedCommandLine, compilerHost: CompilerHost) {\r\n        var parseStart = new Date().getTime();\r\n        var program = createProgram(commandLine.filenames, commandLine.options, compilerHost);\r\n\r\n        var bindStart = new Date().getTime();\r\n        var errors = program.getDiagnostics();\r\n        if (errors.length) {\r\n            var checkStart = bindStart;\r\n            var emitStart = bindStart;\r\n            var reportStart = bindStart;\r\n        }\r\n        else {\r\n            var checker = program.getTypeChecker(/*fullTypeCheckMode*/ true);\r\n            var checkStart = new Date().getTime();\r\n            var semanticErrors = checker.getDiagnostics();\r\n            var emitStart = new Date().getTime();\r\n            var emitErrors = checker.emitFiles().errors;\r\n            var reportStart = new Date().getTime();\r\n            errors = concatenate(semanticErrors, emitErrors);\r\n        }\r\n\r\n        reportDiagnostics(errors);\r\n        if (commandLine.options.diagnostics) {\r\n            var memoryUsed = sys.getMemoryUsage ? sys.getMemoryUsage() : -1;\r\n            reportCountStatistic(\"Files\", program.getSourceFiles().length);\r\n            reportCountStatistic(\"Lines\", countLines(program));\r\n            reportCountStatistic(\"Nodes\", checker ? checker.getNodeCount() : 0);\r\n            reportCountStatistic(\"Identifiers\", checker ? checker.getIdentifierCount() : 0);\r\n            reportCountStatistic(\"Symbols\", checker ? checker.getSymbolCount() : 0);\r\n            reportCountStatistic(\"Types\", checker ? checker.getTypeCount() : 0);\r\n            if (memoryUsed >= 0) {\r\n                reportStatisticalValue(\"Memory used\", Math.round(memoryUsed / 1000) + \"K\");\r\n            }\r\n            reportTimeStatistic(\"Parse time\", bindStart - parseStart);\r\n            reportTimeStatistic(\"Bind time\", checkStart - bindStart);\r\n            reportTimeStatistic(\"Check time\", emitStart - checkStart);\r\n            reportTimeStatistic(\"Emit time\", reportStart - emitStart);\r\n            reportTimeStatistic(\"Total time\", reportStart - parseStart);\r\n        }\r\n\r\n        return { program: program, errors: errors };\r\n\r\n    }\r\n\r\n    function printVersion() {\r\n        sys.write(getDiagnosticText(Diagnostics.Version_0, version) + sys.newLine);\r\n    }\r\n\r\n    function printHelp() {\r\n        var output = \"\";\r\n\r\n        // We want to align our \"syntax\" and \"examples\" commands to a certain margin.\r\n        var syntaxLength = getDiagnosticText(Diagnostics.Syntax_Colon_0, \"\").length;\r\n        var examplesLength = getDiagnosticText(Diagnostics.Examples_Colon_0, \"\").length;\r\n        var marginLength = Math.max(syntaxLength, examplesLength);\r\n\r\n        // Build up the syntactic skeleton.\r\n        var syntax = makePadding(marginLength - syntaxLength);\r\n        syntax += \"tsc [\" + getDiagnosticText(Diagnostics.options) + \"] [\" + getDiagnosticText(Diagnostics.file) + \" ...]\";\r\n\r\n        output += getDiagnosticText(Diagnostics.Syntax_Colon_0, syntax);\r\n        output += sys.newLine + sys.newLine;\r\n\r\n        // Build up the list of examples.\r\n        var padding = makePadding(marginLength);\r\n        output += getDiagnosticText(Diagnostics.Examples_Colon_0, makePadding(marginLength - examplesLength) + \"tsc hello.ts\") + sys.newLine;\r\n        output += padding + \"tsc --out foo.js foo.ts\" + sys.newLine;\r\n        output += padding + \"tsc @args.txt\" + sys.newLine;\r\n        output += sys.newLine;\r\n\r\n        output += getDiagnosticText(Diagnostics.Options_Colon) + sys.newLine;\r\n\r\n        // Sort our options by their names, (e.g. \"--noImplicitAny\" comes before \"--watch\")\r\n        var optsList = optionDeclarations.slice();\r\n        optsList.sort((a, b) => compareValues<string>(a.name.toLowerCase(), b.name.toLowerCase()));\r\n\r\n        // We want our descriptions to align at the same column in our output,\r\n        // so we keep track of the longest option usage string.\r\n        var marginLength = 0;\r\n        var usageColumn: string[] = []; // Things like \"-d, --declaration\" go in here.\r\n        var descriptionColumn: string[] = [];\r\n\r\n        for (var i = 0; i < optsList.length; i++) {\r\n            var option = optsList[i];\r\n\r\n            // If an option lacks a description,\r\n            // it is not officially supported.\r\n            if (!option.description) {\r\n                continue;\r\n            }\r\n\r\n            var usageText = \" \";\r\n            if (option.shortName) {\r\n                usageText += \"-\" + option.shortName;\r\n                usageText += getParamName(option);\r\n                usageText += \", \";\r\n            }\r\n\r\n            usageText += \"--\" + option.name;\r\n            usageText += getParamName(option);\r\n\r\n            usageColumn.push(usageText);\r\n            descriptionColumn.push(getDiagnosticText(option.description));\r\n\r\n            // Set the new margin for the description column if necessary.\r\n            marginLength = Math.max(usageText.length, marginLength);\r\n        }\r\n\r\n        // Special case that can't fit in the loop.\r\n        var usageText = \" @<\" + getDiagnosticText(Diagnostics.file) + \">\";\r\n        usageColumn.push(usageText);\r\n        descriptionColumn.push(getDiagnosticText(Diagnostics.Insert_command_line_options_and_files_from_a_file));\r\n        marginLength = Math.max(usageText.length, marginLength);\r\n\r\n        // Print out each row, aligning all the descriptions on the same column.\r\n        for (var i = 0; i < usageColumn.length; i++) {\r\n            var usage = usageColumn[i];\r\n            var description = descriptionColumn[i];\r\n            output += usage + makePadding(marginLength - usage.length + 2) + description + sys.newLine;\r\n        }\r\n\r\n        sys.write(output);\r\n        return;\r\n\r\n        function getParamName(option: CommandLineOption) {\r\n            if (option.paramName !== undefined) {\r\n                return \" \" + getDiagnosticText(option.paramName);\r\n            }\r\n            return \"\";\r\n        }\r\n\r\n        function makePadding(paddingLength: number): string {\r\n            return Array(paddingLength + 1).join(\" \");\r\n        }\r\n    }\r\n}\r\n\r\nts.executeCommandLine(sys.args);\r\n";
var librarySources = "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved. \r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \r\n \r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \r\nMERCHANTABLITY OR NON-INFRINGEMENT. \r\n \r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\n/// <reference no-default-lib=\"true\"/>\r\n\r\n/////////////////////////////\r\n/// ECMAScript APIs\r\n/////////////////////////////\r\n\r\ndeclare var NaN: number;\r\ndeclare var Infinity: number;\r\n\r\n/**\r\n  * Evaluates JavaScript code and executes it. \r\n  * @param x A String value that contains valid JavaScript code.\r\n  */\r\ndeclare function eval(x: string): any;\r\n\r\n/**\r\n  * Converts A string to an integer.\r\n  * @param s A string to convert into a number.\r\n  * @param radix A value between 2 and 36 that specifies the base of the number in numString. \r\n  * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\r\n  * All other strings are considered decimal.\r\n  */\r\ndeclare function parseInt(s: string, radix?: number): number;\r\n\r\n/**\r\n  * Converts a string to a floating-point number. \r\n  * @param string A string that contains a floating-point number. \r\n  */\r\ndeclare function parseFloat(string: string): number;\r\n\r\n/**\r\n  * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number). \r\n  * @param number A numeric value.\r\n  */\r\ndeclare function isNaN(number: number): boolean;\r\n\r\n/** \r\n  * Determines whether a supplied number is finite.\r\n  * @param number Any numeric value.\r\n  */\r\ndeclare function isFinite(number: number): boolean;\r\n\r\n/**\r\n  * Gets the unencoded version of an encoded Uniform Resource Identifier (URI).\r\n  * @param encodedURI A value representing an encoded URI.\r\n  */\r\ndeclare function decodeURI(encodedURI: string): string;\r\n\r\n/**\r\n  * Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).\r\n  * @param encodedURIComponent A value representing an encoded URI component.\r\n  */\r\ndeclare function decodeURIComponent(encodedURIComponent: string): string;\r\n\r\n/** \r\n  * Encodes a text string as a valid Uniform Resource Identifier (URI)\r\n  * @param uri A value representing an encoded URI.\r\n  */\r\ndeclare function encodeURI(uri: string): string;\r\n\r\n/**\r\n  * Encodes a text string as a valid component of a Uniform Resource Identifier (URI).\r\n  * @param uriComponent A value representing an encoded URI component.\r\n  */\r\ndeclare function encodeURIComponent(uriComponent: string): string;\r\n\r\ninterface PropertyDescriptor {\r\n    configurable?: boolean;\r\n    enumerable?: boolean;\r\n    value?: any;\r\n    writable?: boolean;\r\n    get? (): any;\r\n    set? (v: any): void;\r\n}\r\n\r\ninterface PropertyDescriptorMap {\r\n    [s: string]: PropertyDescriptor;\r\n}\r\n\r\ninterface Object {\r\n    /** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */\r\n    constructor: Function;\r\n\r\n    /** Returns a string representation of an object. */\r\n    toString(): string;\r\n\r\n    /** Returns a date converted to a string using the current locale. */\r\n    toLocaleString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Object;\r\n\r\n    /**\r\n      * Determines whether an object has a property with the specified name. \r\n      * @param v A property name.\r\n      */\r\n    hasOwnProperty(v: string): boolean;\r\n\r\n    /**\r\n      * Determines whether an object exists in another object's prototype chain. \r\n      * @param v Another object whose prototype chain is to be checked.\r\n      */\r\n    isPrototypeOf(v: Object): boolean;\r\n\r\n    /** \r\n      * Determines whether a specified property is enumerable.\r\n      * @param v A property name.\r\n      */\r\n    propertyIsEnumerable(v: string): boolean;\r\n}\r\n\r\n/**\r\n  * Provides functionality common to all JavaScript objects.\r\n  */\r\ndeclare var Object: {\r\n    new (value?: any): Object;\r\n    (): any;\r\n    (value: any): any;\r\n\r\n    /** A reference to the prototype for a class of objects. */\r\n    prototype: Object;\r\n\r\n    /** \r\n      * Returns the prototype of an object. \r\n      * @param o The object that references the prototype.\r\n      */\r\n    getPrototypeOf(o: any): any;\r\n\r\n    /**\r\n      * Gets the own property descriptor of the specified object. \r\n      * An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype. \r\n      * @param o Object that contains the property.\r\n      * @param p Name of the property.\r\n    */\r\n    getOwnPropertyDescriptor(o: any, p: string): PropertyDescriptor;\r\n\r\n    /** \r\n      * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly \r\n      * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\r\n      * @param o Object that contains the own properties.\r\n      */\r\n    getOwnPropertyNames(o: any): string[];\r\n\r\n    /** \r\n      * Creates an object that has the specified prototype, and that optionally contains specified properties.\r\n      * @param o Object to use as a prototype. May be null\r\n      * @param properties JavaScript object that contains one or more property descriptors. \r\n      */\r\n    create(o: any, properties?: PropertyDescriptorMap): any;\r\n\r\n    /**\r\n      * Adds a property to an object, or modifies attributes of an existing property. \r\n      * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object.\r\n      * @param p The property name.\r\n      * @param attributes Descriptor for the property. It can be for a data property or an accessor property.\r\n      */\r\n    defineProperty(o: any, p: string, attributes: PropertyDescriptor): any;\r\n\r\n    /**\r\n      * Adds one or more properties to an object, and/or modifies attributes of existing properties. \r\n      * @param o Object on which to add or modify the properties. This can be a native JavaScript object or a DOM object.\r\n      * @param properties JavaScript object that contains one or more descriptor objects. Each descriptor object describes a data property or an accessor property.\r\n      */\r\n    defineProperties(o: any, properties: PropertyDescriptorMap): any;\r\n\r\n    /**\r\n      * Prevents the modification of attributes of existing properties, and prevents the addition of new properties.\r\n      * @param o Object on which to lock the attributes. \r\n      */\r\n    seal(o: any): any;\r\n\r\n    /**\r\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\r\n      * @param o Object on which to lock the attributes.\r\n      */\r\n    freeze(o: any): any;\r\n\r\n    /**\r\n      * Prevents the addition of new properties to an object.\r\n      * @param o Object to make non-extensible. \r\n      */\r\n    preventExtensions(o: any): any;\r\n\r\n    /**\r\n      * Returns true if existing property attributes cannot be modified in an object and new properties cannot be added to the object.\r\n      * @param o Object to test. \r\n      */\r\n    isSealed(o: any): boolean;\r\n\r\n    /**\r\n      * Returns true if existing property attributes and values cannot be modified in an object, and new properties cannot be added to the object.\r\n      * @param o Object to test.  \r\n      */\r\n    isFrozen(o: any): boolean;\r\n\r\n    /**\r\n      * Returns a value that indicates whether new properties can be added to an object.\r\n      * @param o Object to test. \r\n      */\r\n    isExtensible(o: any): boolean;\r\n\r\n    /**\r\n      * Returns the names of the enumerable properties and methods of an object.\r\n      * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\r\n      */\r\n    keys(o: any): string[];\r\n}\r\n\r\n/**\r\n  * Creates a new function.\r\n  */\r\ninterface Function {\r\n    /**\r\n      * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\r\n      * @param thisArg The object to be used as the this object.\r\n      * @param argArray A set of arguments to be passed to the function.\r\n      */\r\n    apply(thisArg: any, argArray?: any): any;\r\n\r\n    /**\r\n      * Calls a method of an object, substituting another object for the current object.\r\n      * @param thisArg The object to be used as the current object.\r\n      * @param argArray A list of arguments to be passed to the method.\r\n      */\r\n    call(thisArg: any, ...argArray: any[]): any;\r\n\r\n    /**\r\n      * For a given function, creates a bound function that has the same body as the original function. \r\n      * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\r\n      * @param thisArg An object to which the this keyword can refer inside the new function.\r\n      * @param argArray A list of arguments to be passed to the new function.\r\n      */\r\n    bind(thisArg: any, ...argArray: any[]): any;\r\n\r\n    prototype: any;\r\n    length: number;\r\n\r\n    // Non-standard extensions\r\n    arguments: any;\r\n    caller: Function;\r\n}\r\n\r\ndeclare var Function: {\r\n    /** \r\n      * Creates a new function.\r\n      * @param args A list of arguments the function accepts.\r\n      */\r\n    new (...args: string[]): Function;\r\n    (...args: string[]): Function;\r\n    prototype: Function;\r\n}\r\n\r\ninterface IArguments {\r\n    [index: number]: any;\r\n    length: number;\r\n    callee: Function;\r\n}\r\n\r\ninterface String {\r\n    /** Returns a string representation of a string. */\r\n    toString(): string;\r\n\r\n    /**\r\n      * Returns the character at the specified index.\r\n      * @param pos The zero-based index of the desired character.\r\n      */\r\n    charAt(pos: number): string;\r\n\r\n    /** \r\n      * Returns the Unicode value of the character at the specified location.\r\n      * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\r\n      */\r\n    charCodeAt(index: number): number;\r\n\r\n    /**\r\n      * Returns a string that contains the concatenation of two or more strings.\r\n      * @param strings The strings to append to the end of the string.  \r\n      */\r\n    concat(...strings: string[]): string;\r\n\r\n    /**\r\n      * Returns the position of the first occurrence of a substring. \r\n      * @param searchString The substring to search for in the string\r\n      * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\r\n      */\r\n    indexOf(searchString: string, position?: number): number;\r\n\r\n    /**\r\n      * Returns the last occurrence of a substring in the string.\r\n      * @param searchString The substring to search for.\r\n      * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\r\n      */\r\n    lastIndexOf(searchString: string, position?: number): number;\r\n\r\n    /**\r\n      * Determines whether two strings are equivalent in the current locale.\r\n      * @param that String to compare to target string\r\n      */\r\n    localeCompare(that: string): number;\r\n\r\n    /** \r\n      * Matches a string with a regular expression, and returns an array containing the results of that search.\r\n      * @param regexp A variable name or string literal containing the regular expression pattern and flags.\r\n      */\r\n    match(regexp: string): RegExpMatchArray;\r\n\r\n    /** \r\n      * Matches a string with a regular expression, and returns an array containing the results of that search.\r\n      * @param regexp A regular expression object that contains the regular expression pattern and applicable flags. \r\n      */\r\n    match(regexp: RegExp): RegExpMatchArray;\r\n\r\n    /**\r\n      * Replaces text in a string, using a regular expression or search string.\r\n      * @param searchValue A String object or string literal that represents the regular expression\r\n      * @param replaceValue A String object or string literal containing the text to replace for every successful match of rgExp in stringObj.\r\n      */\r\n    replace(searchValue: string, replaceValue: string): string;\r\n\r\n    /**\r\n      * Replaces text in a string, using a regular expression or search string.\r\n      * @param searchValue A String object or string literal that represents the regular expression\r\n      * @param replaceValue A function that returns the replacement text.\r\n      */\r\n    replace(searchValue: string, replaceValue: (substring: string, ...args: any[]) => string): string;\r\n\r\n    /**\r\n      * Replaces text in a string, using a regular expression or search string.\r\n      * @param searchValue A Regular Expression object containing the regular expression pattern and applicable flags\r\n      * @param replaceValue A String object or string literal containing the text to replace for every successful match of rgExp in stringObj.\r\n      */\r\n    replace(searchValue: RegExp, replaceValue: string): string;\r\n\r\n    /**\r\n      * Replaces text in a string, using a regular expression or search string.\r\n      * @param searchValue A Regular Expression object containing the regular expression pattern and applicable flags\r\n      * @param replaceValue A function that returns the replacement text.\r\n      */\r\n    replace(searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string;\r\n\r\n    /**\r\n      * Finds the first substring match in a regular expression search.\r\n      * @param regexp The regular expression pattern and applicable flags. \r\n      */\r\n    search(regexp: string): number;\r\n\r\n    /**\r\n      * Finds the first substring match in a regular expression search.\r\n      * @param regexp The regular expression pattern and applicable flags. \r\n      */\r\n    search(regexp: RegExp): number;\r\n\r\n    /**\r\n      * Returns a section of a string.\r\n      * @param start The index to the beginning of the specified portion of stringObj. \r\n      * @param end The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end. \r\n      * If this value is not specified, the substring continues to the end of stringObj.\r\n      */\r\n    slice(start?: number, end?: number): string;\r\n\r\n    /**\r\n      * Split a string into substrings using the specified separator and return them as an array.\r\n      * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned. \r\n      * @param limit A value used to limit the number of elements returned in the array.\r\n      */\r\n    split(separator: string, limit?: number): string[];\r\n\r\n    /**\r\n      * Split a string into substrings using the specified separator and return them as an array.\r\n      * @param separator A Regular Express that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned. \r\n      * @param limit A value used to limit the number of elements returned in the array.\r\n      */\r\n    split(separator: RegExp, limit?: number): string[];\r\n\r\n    /**\r\n      * Returns the substring at the specified location within a String object. \r\n      * @param start The zero-based index number indicating the beginning of the substring.\r\n      * @param end Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\r\n      * If end is omitted, the characters from start through the end of the original string are returned.\r\n      */\r\n    substring(start: number, end?: number): string;\r\n\r\n    /** Converts all the alphabetic characters in a string to lowercase. */\r\n    toLowerCase(): string;\r\n\r\n    /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */\r\n    toLocaleLowerCase(): string;\r\n\r\n    /** Converts all the alphabetic characters in a string to uppercase. */\r\n    toUpperCase(): string;\r\n\r\n    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */\r\n    toLocaleUpperCase(): string;\r\n\r\n    /** Removes the leading and trailing white space and line terminator characters from a string. */\r\n    trim(): string;\r\n\r\n    /** Returns the length of a String object. */\r\n    length: number;\r\n\r\n    // IE extensions\r\n    /**\r\n      * Gets a substring beginning at the specified location and having the specified length.\r\n      * @param from The starting position of the desired substring. The index of the first character in the string is zero.\r\n      * @param length The number of characters to include in the returned substring.\r\n      */\r\n    substr(from: number, length?: number): string;\r\n\r\n    [index: number]: string;\r\n}\r\n\r\n/** \r\n  * Allows manipulation and formatting of text strings and determination and location of substrings within strings. \r\n  */\r\ndeclare var String: {\r\n    new (value?: any): String;\r\n    (value?: any): string;\r\n    prototype: String;\r\n    fromCharCode(...codes: number[]): string;\r\n}\r\n\r\ninterface Boolean {\r\n}\r\ndeclare var Boolean: {\r\n    new (value?: any): Boolean;\r\n    (value?: any): boolean;\r\n    prototype: Boolean;\r\n}\r\n\r\ninterface Number {\r\n    /**\r\n      * Returns a string representation of an object.\r\n      * @param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.\r\n      */\r\n    toString(radix?: number): string;\r\n\r\n    /** \r\n      * Returns a string representing a number in fixed-point notation.\r\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\r\n      */\r\n    toFixed(fractionDigits?: number): string;\r\n\r\n    /**\r\n      * Returns a string containing a number represented in exponential notation.\r\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\r\n      */\r\n    toExponential(fractionDigits?: number): string;\r\n\r\n    /**\r\n      * Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\r\n      * @param precision Number of significant digits. Must be in the range 1 - 21, inclusive.\r\n      */\r\n    toPrecision(precision?: number): string;\r\n}\r\n\r\n/** An object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers. */\r\ndeclare var Number: {\r\n    new (value?: any): Number;\r\n    (value?: any): number;\r\n    prototype: Number;\r\n\r\n    /** The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308. */\r\n    MAX_VALUE: number;\r\n\r\n    /** The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324. */\r\n    MIN_VALUE: number;\r\n\r\n    /** \r\n      * A value that is not a number.\r\n      * In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.\r\n      */\r\n    NaN: number;\r\n\r\n    /** \r\n      * A value that is less than the largest negative number that can be represented in JavaScript.\r\n      * JavaScript displays NEGATIVE_INFINITY values as -infinity. \r\n      */\r\n    NEGATIVE_INFINITY: number;\r\n\r\n    /**\r\n      * A value greater than the largest number that can be represented in JavaScript. \r\n      * JavaScript displays POSITIVE_INFINITY values as infinity. \r\n      */\r\n    POSITIVE_INFINITY: number;\r\n}\r\n\r\ninterface Math {\r\n    /** The mathematical constant e. This is Euler's number, the base of natural logarithms. */\r\n    E: number;\r\n    /** The natural logarithm of 10. */\r\n    LN10: number;\r\n    /** The natural logarithm of 2. */\r\n    LN2: number;\r\n    /** The base-2 logarithm of e. */\r\n    LOG2E: number;\r\n    /** The base-10 logarithm of e. */\r\n    LOG10E: number;\r\n    /** Pi. This is the ratio of the circumference of a circle to its diameter. */\r\n    PI: number;\r\n    /** The square root of 0.5, or, equivalently, one divided by the square root of 2. */\r\n    SQRT1_2: number;\r\n    /** The square root of 2. */\r\n    SQRT2: number;\r\n    /**\r\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative). \r\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\r\n      * @param x A numeric expression for which the absolute value is needed.\r\n      */\r\n    abs(x: number): number;\r\n    /**\r\n      * Returns the arc cosine (or inverse cosine) of a number. \r\n      * @param x A numeric expression.\r\n      */\r\n    acos(x: number): number;\r\n    /** \r\n      * Returns the arcsine of a number. \r\n      * @param x A numeric expression.\r\n      */\r\n    asin(x: number): number;\r\n    /**\r\n      * Returns the arctangent of a number. \r\n      * @param x A numeric expression for which the arctangent is needed.\r\n      */\r\n    atan(x: number): number;\r\n    /**\r\n      * Returns the angle (in radians) from the X axis to a point (y,x).\r\n      * @param y A numeric expression representing the cartesian y-coordinate.\r\n      * @param x A numeric expression representing the cartesian x-coordinate.\r\n      */\r\n    atan2(y: number, x: number): number;\r\n    /**\r\n      * Returns the smallest number greater than or equal to its numeric argument. \r\n      * @param x A numeric expression.\r\n      */\r\n    ceil(x: number): number;\r\n    /**\r\n      * Returns the cosine of a number. \r\n      * @param x A numeric expression that contains an angle measured in radians.\r\n      */\r\n    cos(x: number): number;\r\n    /**\r\n      * Returns e (the base of natural logarithms) raised to a power. \r\n      * @param x A numeric expression representing the power of e.\r\n      */\r\n    exp(x: number): number;\r\n    /**\r\n      * Returns the greatest number less than or equal to its numeric argument. \r\n      * @param x A numeric expression.\r\n      */\r\n    floor(x: number): number;\r\n    /**\r\n      * Returns the natural logarithm (base e) of a number. \r\n      * @param x A numeric expression.\r\n      */\r\n    log(x: number): number;\r\n    /**\r\n      * Returns the larger of a set of supplied numeric expressions. \r\n      * @param values Numeric expressions to be evaluated.\r\n      */\r\n    max(...values: number[]): number;\r\n    /**\r\n      * Returns the smaller of a set of supplied numeric expressions. \r\n      * @param values Numeric expressions to be evaluated.\r\n      */\r\n    min(...values: number[]): number;\r\n    /**\r\n      * Returns the value of a base expression taken to a specified power. \r\n      * @param x The base value of the expression.\r\n      * @param y The exponent value of the expression.\r\n      */\r\n    pow(x: number, y: number): number;\r\n    /** Returns a pseudorandom number between 0 and 1. */\r\n    random(): number;\r\n    /** \r\n      * Returns a supplied numeric expression rounded to the nearest number.\r\n      * @param x The value to be rounded to the nearest number.\r\n      */\r\n    round(x: number): number;\r\n    /**\r\n      * Returns the sine of a number.\r\n      * @param x A numeric expression that contains an angle measured in radians.\r\n      */\r\n    sin(x: number): number;\r\n    /**\r\n      * Returns the square root of a number.\r\n      * @param x A numeric expression.\r\n      */\r\n    sqrt(x: number): number;\r\n    /**\r\n      * Returns the tangent of a number.\r\n      * @param x A numeric expression that contains an angle measured in radians.\r\n      */\r\n    tan(x: number): number;\r\n}\r\n/** An intrinsic object that provides basic mathematics functionality and constants. */\r\ndeclare var Math: Math;\r\n\r\n/** Enables basic storage and retrieval of dates and times. */\r\ninterface Date {\r\n    /** Returns a string representation of a date. The format of the string depends on the locale. */\r\n    toString(): string;\r\n    /** Returns a date as a string value. */\r\n    toDateString(): string;\r\n    /** Returns a time as a string value. */\r\n    toTimeString(): string;\r\n    /** Returns a value as a string value appropriate to the host environment's current locale. */\r\n    toLocaleString(): string;\r\n    /** Returns a date as a string value appropriate to the host environment's current locale. */\r\n    toLocaleDateString(): string;\r\n    /** Returns a time as a string value appropriate to the host environment's current locale. */\r\n    toLocaleTimeString(): string;\r\n    /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */\r\n    valueOf(): number;\r\n    /** Gets the time value in milliseconds. */\r\n    getTime(): number;\r\n    /** Gets the year, using local time. */\r\n    getFullYear(): number;\r\n    /** Gets the year using Universal Coordinated Time (UTC). */\r\n    getUTCFullYear(): number;\r\n    /** Gets the month, using local time. */\r\n    getMonth(): number;\r\n    /** Gets the month of a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCMonth(): number;\r\n    /** Gets the day-of-the-month, using local time. */\r\n    getDate(): number;\r\n    /** Gets the day-of-the-month, using Universal Coordinated Time (UTC). */\r\n    getUTCDate(): number;\r\n    /** Gets the day of the week, using local time. */\r\n    getDay(): number;\r\n    /** Gets the day of the week using Universal Coordinated Time (UTC). */\r\n    getUTCDay(): number;\r\n    /** Gets the hours in a date, using local time. */\r\n    getHours(): number;\r\n    /** Gets the hours value in a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCHours(): number;\r\n    /** Gets the minutes of a Date object, using local time. */\r\n    getMinutes(): number;\r\n    /** Gets the minutes of a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCMinutes(): number;\r\n    /** Gets the seconds of a Date object, using local time. */\r\n    getSeconds(): number;\r\n    /** Gets the seconds of a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCSeconds(): number;\r\n    /** Gets the milliseconds of a Date, using local time. */\r\n    getMilliseconds(): number;\r\n    /** Gets the milliseconds of a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCMilliseconds(): number;\r\n    /** Gets the difference in minutes between the time on the local computer and Universal Coordinated Time (UTC). */\r\n    getTimezoneOffset(): number;\r\n    /** \r\n      * Sets the date and time value in the Date object.\r\n      * @param time A numeric value representing the number of elapsed milliseconds since midnight, January 1, 1970 GMT. \r\n      */\r\n    setTime(time: number): number;\r\n    /**\r\n      * Sets the milliseconds value in the Date object using local time. \r\n      * @param ms A numeric value equal to the millisecond value.\r\n      */\r\n    setMilliseconds(ms: number): number;\r\n    /** \r\n      * Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).\r\n      * @param ms A numeric value equal to the millisecond value. \r\n      */\r\n    setUTCMilliseconds(ms: number): number;\r\n\r\n    /**\r\n      * Sets the seconds value in the Date object using local time. \r\n      * @param sec A numeric value equal to the seconds value.\r\n      * @param ms A numeric value equal to the milliseconds value.\r\n      */\r\n    setSeconds(sec: number, ms?: number): number;\r\n    /**\r\n      * Sets the seconds value in the Date object using Universal Coordinated Time (UTC).\r\n      * @param sec A numeric value equal to the seconds value.\r\n      * @param ms A numeric value equal to the milliseconds value.\r\n      */\r\n    setUTCSeconds(sec: number, ms?: number): number;\r\n    /**\r\n      * Sets the minutes value in the Date object using local time. \r\n      * @param min A numeric value equal to the minutes value. \r\n      * @param sec A numeric value equal to the seconds value. \r\n      * @param ms A numeric value equal to the milliseconds value.\r\n      */\r\n    setMinutes(min: number, sec?: number, ms?: number): number;\r\n    /**\r\n      * Sets the minutes value in the Date object using Universal Coordinated Time (UTC).\r\n      * @param min A numeric value equal to the minutes value. \r\n      * @param sec A numeric value equal to the seconds value. \r\n      * @param ms A numeric value equal to the milliseconds value.\r\n      */\r\n    setUTCMinutes(min: number, sec?: number, ms?: number): number;\r\n    /**\r\n      * Sets the hour value in the Date object using local time.\r\n      * @param hours A numeric value equal to the hours value.\r\n      * @param min A numeric value equal to the minutes value.\r\n      * @param sec A numeric value equal to the seconds value. \r\n      * @param ms A numeric value equal to the milliseconds value.\r\n      */\r\n    setHours(hours: number, min?: number, sec?: number, ms?: number): number;\r\n    /**\r\n      * Sets the hours value in the Date object using Universal Coordinated Time (UTC).\r\n      * @param hours A numeric value equal to the hours value.\r\n      * @param min A numeric value equal to the minutes value.\r\n      * @param sec A numeric value equal to the seconds value. \r\n      * @param ms A numeric value equal to the milliseconds value.\r\n      */\r\n    setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;\r\n    /**\r\n      * Sets the numeric day-of-the-month value of the Date object using local time. \r\n      * @param date A numeric value equal to the day of the month.\r\n      */\r\n    setDate(date: number): number;\r\n    /** \r\n      * Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).\r\n      * @param date A numeric value equal to the day of the month. \r\n      */\r\n    setUTCDate(date: number): number;\r\n    /** \r\n      * Sets the month value in the Date object using local time. \r\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively. \r\n      * @param date A numeric value representing the day of the month. If this value is not supplied, the value from a call to the getDate method is used.\r\n      */\r\n    setMonth(month: number, date?: number): number;\r\n    /**\r\n      * Sets the month value in the Date object using Universal Coordinated Time (UTC).\r\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\r\n      * @param date A numeric value representing the day of the month. If it is not supplied, the value from a call to the getUTCDate method is used.\r\n      */\r\n    setUTCMonth(month: number, date?: number): number;\r\n    /**\r\n      * Sets the year of the Date object using local time.\r\n      * @param year A numeric value for the year.\r\n      * @param month A zero-based numeric value for the month (0 for January, 11 for December). Must be specified if numDate is specified.\r\n      * @param date A numeric value equal for the day of the month.\r\n      */\r\n    setFullYear(year: number, month?: number, date?: number): number;\r\n    /**\r\n      * Sets the year value in the Date object using Universal Coordinated Time (UTC).\r\n      * @param year A numeric value equal to the year.\r\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively. Must be supplied if numDate is supplied.\r\n      * @param date A numeric value equal to the day of the month.\r\n      */\r\n    setUTCFullYear(year: number, month?: number, date?: number): number;\r\n    /** Returns a date converted to a string using Universal Coordinated Time (UTC). */\r\n    toUTCString(): string;\r\n    /** Returns a date as a string value in ISO format. */\r\n    toISOString(): string;\r\n    /** Used by the JSON.stringify method to enable the transformation of an object's data for JavaScript Object Notation (JSON) serialization. */\r\n    toJSON(key?: any): string;\r\n}\r\n\r\ndeclare var Date: {\r\n    new (): Date;\r\n    new (value: number): Date;\r\n    new (value: string): Date;\r\n    new (year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\r\n    (): string;\r\n    prototype: Date;\r\n    /**\r\n      * Parses a string containing a date, and returns the number of milliseconds between that date and midnight, January 1, 1970.\r\n      * @param s A date string\r\n      */\r\n    parse(s: string): number;\r\n    /**\r\n      * Returns the number of milliseconds between midnight, January 1, 1970 Universal Coordinated Time (UTC) (or GMT) and the specified date. \r\n      * @param year The full year designation is required for cross-century date accuracy. If year is between 0 and 99 is used, then year is assumed to be 1900 + year.\r\n      * @param month The month as an number between 0 and 11 (January to December).\r\n      * @param date The date as an number between 1 and 31.\r\n      * @param hours Must be supplied if minutes is supplied. An number from 0 to 23 (midnight to 11pm) that specifies the hour.\r\n      * @param minutes Must be supplied if seconds is supplied. An number from 0 to 59 that specifies the minutes.\r\n      * @param seconds Must be supplied if milliseconds is supplied. An number from 0 to 59 that specifies the seconds.\r\n      * @param ms An number from 0 to 999 that specifies the milliseconds.\r\n      */\r\n    UTC(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): number;\r\n    now(): number;\r\n}\r\n\r\ninterface RegExpMatchArray extends Array<string> {\r\n    index?: number;\r\n    input?: string;\r\n}\r\n\r\ninterface RegExpExecArray extends Array<string> {\r\n    index: number;\r\n    input: string;\r\n}\r\n\r\ninterface RegExp {\r\n    /** \r\n      * Executes a search on a string using a regular expression pattern, and returns an array containing the results of that search.\r\n      * @param string The String object or string literal on which to perform the search.\r\n      */\r\n    exec(string: string): RegExpExecArray;\r\n\r\n    /** \r\n      * Returns a Boolean value that indicates whether or not a pattern exists in a searched string.\r\n      * @param string String on which to perform the search.\r\n      */\r\n    test(string: string): boolean;\r\n\r\n    /** Returns a copy of the text of the regular expression pattern. Read-only. The rgExp argument is a Regular expression object. It can be a variable name or a literal. */\r\n    source: string;\r\n\r\n    /** Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only. */\r\n    global: boolean;\r\n\r\n    /** Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only. */\r\n    ignoreCase: boolean;\r\n\r\n    /** Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only. */\r\n    multiline: boolean;\r\n\r\n    lastIndex: number;\r\n\r\n    // Non-standard extensions\r\n    compile(): RegExp;\r\n}\r\ndeclare var RegExp: {\r\n    new (pattern: string, flags?: string): RegExp;\r\n    (pattern: string, flags?: string): RegExp;\r\n\r\n    // Non-standard extensions\r\n    $1: string;\r\n    $2: string;\r\n    $3: string;\r\n    $4: string;\r\n    $5: string;\r\n    $6: string;\r\n    $7: string;\r\n    $8: string;\r\n    $9: string;\r\n    lastMatch: string;\r\n}\r\n\r\ninterface Error {\r\n    name: string;\r\n    message: string;\r\n}\r\ndeclare var Error: {\r\n    new (message?: string): Error;\r\n    (message?: string): Error;\r\n    prototype: Error;\r\n}\r\n\r\ninterface EvalError extends Error {\r\n}\r\ndeclare var EvalError: {\r\n    new (message?: string): EvalError;\r\n    (message?: string): EvalError;\r\n    prototype: EvalError;\r\n}\r\n\r\ninterface RangeError extends Error {\r\n}\r\ndeclare var RangeError: {\r\n    new (message?: string): RangeError;\r\n    (message?: string): RangeError;\r\n    prototype: RangeError;\r\n}\r\n\r\ninterface ReferenceError extends Error {\r\n}\r\ndeclare var ReferenceError: {\r\n    new (message?: string): ReferenceError;\r\n    (message?: string): ReferenceError;\r\n    prototype: ReferenceError;\r\n}\r\n\r\ninterface SyntaxError extends Error {\r\n}\r\ndeclare var SyntaxError: {\r\n    new (message?: string): SyntaxError;\r\n    (message?: string): SyntaxError;\r\n    prototype: SyntaxError;\r\n}\r\n\r\ninterface TypeError extends Error {\r\n}\r\ndeclare var TypeError: {\r\n    new (message?: string): TypeError;\r\n    (message?: string): TypeError;\r\n    prototype: TypeError;\r\n}\r\n\r\ninterface URIError extends Error {\r\n}\r\ndeclare var URIError: {\r\n    new (message?: string): URIError;\r\n    (message?: string): URIError;\r\n    prototype: URIError;\r\n}\r\n\r\ninterface JSON {\r\n    /**\r\n      * Converts a JavaScript Object Notation (JSON) string into an object.\r\n      * @param text A valid JSON string.\r\n      * @param reviver A function that transforms the results. This function is called for each member of the object. \r\n      * If a member contains nested objects, the nested objects are transformed before the parent object is. \r\n      */\r\n    parse(text: string, reviver?: (key: any, value: any) => any): any;\r\n    /**\r\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n      * @param value A JavaScript value, usually an object or array, to be converted.\r\n      */\r\n    stringify(value: any): string;\r\n    /**\r\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n      * @param value A JavaScript value, usually an object or array, to be converted.\r\n      * @param replacer A function that transforms the results.\r\n      */\r\n    stringify(value: any, replacer: (key: string, value: any) => any): string;\r\n    /**\r\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n      * @param value A JavaScript value, usually an object or array, to be converted.\r\n      * @param replacer Array that transforms the results.\r\n      */\r\n    stringify(value: any, replacer: any[]): string;\r\n    /**\r\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n      * @param value A JavaScript value, usually an object or array, to be converted.\r\n      * @param replacer A function that transforms the results.\r\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n      */\r\n    stringify(value: any, replacer: (key: string, value: any) => any, space: any): string;\r\n    /**\r\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n      * @param value A JavaScript value, usually an object or array, to be converted.\r\n      * @param replacer Array that transforms the results.\r\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n      */\r\n    stringify(value: any, replacer: any[], space: any): string;\r\n}\r\n/**\r\n  * An intrinsic object that provides functions to convert JavaScript values to and from the JavaScript Object Notation (JSON) format.\r\n  */\r\ndeclare var JSON: JSON;\r\n\r\n\r\n/////////////////////////////\r\n/// ECMAScript Array API (specially handled by compiler)\r\n/////////////////////////////\r\n\r\ninterface Array<T> {\r\n    /**\r\n      * Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.\r\n      */\r\n    length: number;\r\n    /**\r\n      * Returns a string representation of an array.\r\n      */\r\n    toString(): string;\r\n    toLocaleString(): string;\r\n    /**\r\n      * Appends new elements to an array, and returns the new length of the array.\r\n      * @param items New elements of the Array.\r\n      */\r\n    push(...items: T[]): number;\r\n    /**\r\n      * Removes the last element from an array and returns it.\r\n      */\r\n    pop(): T;\r\n    /**\r\n      * Combines two or more arrays.\r\n      * @param items Additional items to add to the end of array1.\r\n      */\r\n    concat<U extends T[]>(...items: U[]): T[];\r\n    /**\r\n      * Combines two or more arrays.\r\n      * @param items Additional items to add to the end of array1.\r\n      */\r\n    concat(...items: T[]): T[];\r\n    /**\r\n      * Adds all the elements of an array separated by the specified separator string.\r\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\r\n      */\r\n    join(separator?: string): string;\r\n    /**\r\n      * Reverses the elements in an Array. \r\n      */\r\n    reverse(): T[];\r\n    /**\r\n      * Removes the first element from an array and returns it.\r\n      */\r\n    shift(): T;\r\n    /** \r\n      * Returns a section of an array.\r\n      * @param start The beginning of the specified portion of the array.\r\n      * @param end The end of the specified portion of the array.\r\n      */\r\n    slice(start?: number, end?: number): T[];\r\n\r\n    /**\r\n      * Sorts an array.\r\n      * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\r\n      */\r\n    sort(compareFn?: (a: T, b: T) => number): T[];\r\n\r\n    /**\r\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\r\n      * @param start The zero-based location in the array from which to start removing elements.\r\n      */\r\n    splice(start: number): T[];\r\n\r\n    /**\r\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\r\n      * @param start The zero-based location in the array from which to start removing elements.\r\n      * @param deleteCount The number of elements to remove.\r\n      * @param items Elements to insert into the array in place of the deleted elements.\r\n      */\r\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\r\n\r\n    /**\r\n      * Inserts new elements at the start of an array.\r\n      * @param items  Elements to insert at the start of the Array.\r\n      */\r\n    unshift(...items: T[]): number;\r\n\r\n    /**\r\n      * Returns the index of the first occurrence of a value in an array.\r\n      * @param searchElement The value to locate in the array.\r\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\r\n      */\r\n    indexOf(searchElement: T, fromIndex?: number): number;\r\n\r\n    /**\r\n      * Returns the index of the last occurrence of a specified value in an array.\r\n      * @param searchElement The value to locate in the array.\r\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\r\n      */\r\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\r\n\r\n    /**\r\n      * Determines whether all the members of an array satisfy the specified test.\r\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\r\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n      */\r\n    every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\r\n\r\n    /**\r\n      * Determines whether the specified callback function returns true for any element of an array.\r\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\r\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n      */\r\n    some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\r\n\r\n    /**\r\n      * Performs the specified action for each element in an array.\r\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array. \r\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n      */\r\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\r\n\r\n    /**\r\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\r\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array. \r\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n      */\r\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\r\n\r\n    /**\r\n      * Returns the elements of an array that meet the condition specified in a callback function. \r\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array. \r\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n      */\r\n    filter(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\r\n\r\n    /**\r\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\r\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n      */\r\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\r\n    /**\r\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\r\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n      */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\r\n\r\n    /** \r\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array. \r\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n      */\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\r\n    /** \r\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array. \r\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n      */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\r\n\r\n    [n: number]: T;\r\n}\r\ndeclare var Array: {\r\n    new (arrayLength?: number): any[];\r\n    new <T>(arrayLength: number): T[];\r\n    new <T>(...items: T[]): T[];\r\n    (arrayLength?: number): any[];\r\n    <T>(arrayLength: number): T[];\r\n    <T>(...items: T[]): T[];\r\n    isArray(arg: any): boolean;\r\n    prototype: Array<any>;\r\n}\r\n\r\n/////////////////////////////\r\n/// IE10 ECMAScript Extensions\r\n/////////////////////////////\r\n\r\n/**\r\n  * Represents a raw buffer of binary data, which is used to store data for the \r\n  * different typed arrays. ArrayBuffers cannot be read from or written to directly, \r\n  * but can be passed to a typed array or DataView Object to interpret the raw \r\n  * buffer as needed. \r\n  */\r\ninterface ArrayBuffer {\r\n    /**\r\n      * Read-only. The length of the ArrayBuffer (in bytes).\r\n      */\r\n    byteLength: number;\r\n\r\n    /**\r\n      * Returns a section of an ArrayBuffer.\r\n      */\r\n    slice(begin:number, end?:number): ArrayBuffer;\r\n}\r\n\r\ndeclare var ArrayBuffer: {\r\n    prototype: ArrayBuffer;\r\n    new (byteLength: number): ArrayBuffer;\r\n}\r\n\r\ninterface ArrayBufferView {\r\n    buffer: ArrayBuffer;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n}\r\n\r\n/**\r\n  * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.\r\n  */\r\ninterface Int8Array extends ArrayBufferView {\r\n    /**\r\n      * The size in bytes of each element in the array. \r\n      */\r\n    BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n      * The length of the array.\r\n      */\r\n    length: number;\r\n\r\n    [index: number]: number;\r\n\r\n    /**\r\n      * Gets the element at the specified index.\r\n      * @param index The index at which to get the element of the array.\r\n      */\r\n    get(index: number): number;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param index The index of the location to set.\r\n      * @param value The value to set.\r\n      */\r\n    set(index: number, value: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: Int8Array, offset?: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: number[], offset?: number): void;\r\n\r\n    /**\r\n      * Gets a new Int8Array view of the ArrayBuffer store for this array, referencing the elements at begin, inclusive, up to end, exclusive. \r\n      * @param begin The index of the beginning of the array.\r\n      * @param end The index of the end of the array.\r\n      */\r\n    subarray(begin: number, end?: number): Int8Array;\r\n}\r\ndeclare var Int8Array: {\r\n    prototype: Int8Array;\r\n    new (length: number): Int8Array;\r\n    new (array: Int8Array): Int8Array;\r\n    new (array: number[]): Int8Array;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Int8Array;\r\n    BYTES_PER_ELEMENT: number;\r\n}\r\n\r\n/**\r\n  * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.\r\n  */\r\ninterface Uint8Array extends ArrayBufferView {\r\n    /**\r\n      * The size in bytes of each element in the array. \r\n      */\r\n    BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n      * The length of the array.\r\n      */\r\n    length: number;\r\n    [index: number]: number;\r\n\r\n    /**\r\n      * Gets the element at the specified index.\r\n      * @param index The index at which to get the element of the array.\r\n      */\r\n    get(index: number): number;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param index The index of the location to set.\r\n      * @param value The value to set.\r\n      */\r\n    set(index: number, value: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: Uint8Array, offset?: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: number[], offset?: number): void;\r\n\r\n    /**\r\n      * Gets a new Uint8Array view of the ArrayBuffer Object store for this array, specifying the first and last members of the subarray. \r\n      * @param begin The index of the beginning of the array.\r\n      * @param end The index of the end of the array.\r\n      */\r\n    subarray(begin: number, end?: number): Uint8Array;\r\n}\r\ndeclare var Uint8Array: {\r\n    prototype: Uint8Array;\r\n    new (length: number): Uint8Array;\r\n    new (array: Uint8Array): Uint8Array;\r\n    new (array: number[]): Uint8Array;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Uint8Array;\r\n    BYTES_PER_ELEMENT: number;\r\n}\r\n\r\n/**\r\n  * A typed array of 16-bit integer values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.\r\n  */\r\ninterface Int16Array extends ArrayBufferView {\r\n    /**\r\n      * The size in bytes of each element in the array. \r\n      */\r\n    BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n      * The length of the array.\r\n      */\r\n    length: number;\r\n    [index: number]: number;\r\n\r\n    /**\r\n      * Gets the element at the specified index.\r\n      * @param index The index at which to get the element of the array.\r\n      */\r\n    get(index: number): number;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param index The index of the location to set.\r\n      * @param value The value to set.\r\n      */\r\n    set(index: number, value: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: Int16Array, offset?: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: number[], offset?: number): void;\r\n\r\n    /**\r\n      * Gets a new Int16Array view of the ArrayBuffer Object store for this array, specifying the first and last members of the subarray. \r\n      * @param begin The index of the beginning of the array.\r\n      * @param end The index of the end of the array.\r\n      */\r\n    subarray(begin: number, end?: number): Int16Array;\r\n}\r\ndeclare var Int16Array: {\r\n    prototype: Int16Array;\r\n    new (length: number): Int16Array;\r\n    new (array: Int16Array): Int16Array;\r\n    new (array: number[]): Int16Array;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Int16Array;\r\n    BYTES_PER_ELEMENT: number;\r\n}\r\n\r\n/**\r\n  * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.\r\n  */\r\ninterface Uint16Array extends ArrayBufferView {\r\n    /**\r\n      * The size in bytes of each element in the array. \r\n      */\r\n    BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n      * The length of the array.\r\n      */\r\n    length: number;\r\n    [index: number]: number;\r\n\r\n    /**\r\n      * Gets the element at the specified index.\r\n      * @param index The index at which to get the element of the array.\r\n      */\r\n    get(index: number): number;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param index The index of the location to set.\r\n      * @param value The value to set.\r\n      */\r\n    set(index: number, value: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: Uint16Array, offset?: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: number[], offset?: number): void;\r\n\r\n    /**\r\n      * Gets a new Uint16Array view of the ArrayBuffer Object store for this array, specifying the first and last members of the subarray.\r\n      * @param begin The index of the beginning of the array.\r\n      * @param end The index of the end of the array.\r\n      */\r\n    subarray(begin: number, end?: number): Uint16Array;\r\n}\r\ndeclare var Uint16Array: {\r\n    prototype: Uint16Array;\r\n    new (length: number): Uint16Array;\r\n    new (array: Uint16Array): Uint16Array;\r\n    new (array: number[]): Uint16Array;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Uint16Array;\r\n    BYTES_PER_ELEMENT: number;\r\n}\r\n\r\n/**\r\n  * A typed array of 32-bit integer values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.\r\n  */\r\ninterface Int32Array extends ArrayBufferView {\r\n    /**\r\n      * The size in bytes of each element in the array. \r\n      */\r\n    BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n      * The length of the array.\r\n      */\r\n    length: number;\r\n    [index: number]: number;\r\n\r\n    /**\r\n      * Gets the element at the specified index.\r\n      * @param index The index at which to get the element of the array.\r\n      */\r\n    get(index: number): number;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param index The index of the location to set.\r\n      * @param value The value to set.\r\n      */\r\n    set(index: number, value: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: Int32Array, offset?: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: number[], offset?: number): void;\r\n\r\n    /**\r\n      * Gets a new Int32Array view of the ArrayBuffer Object store for this array, specifying the first and last members of the subarray. \r\n      * @param begin The index of the beginning of the array.\r\n      * @param end The index of the end of the array.\r\n      */\r\n    subarray(begin: number, end?: number): Int32Array;\r\n}\r\ndeclare var Int32Array: {\r\n    prototype: Int32Array;\r\n    new (length: number): Int32Array;\r\n    new (array: Int32Array): Int32Array;\r\n    new (array: number[]): Int32Array;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Int32Array;\r\n    BYTES_PER_ELEMENT: number;\r\n}\r\n\r\n/**\r\n  * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.\r\n  */\r\ninterface Uint32Array extends ArrayBufferView {\r\n    /**\r\n      * The size in bytes of each element in the array. \r\n      */\r\n    BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n      * The length of the array.\r\n      */\r\n    length: number;\r\n    [index: number]: number;\r\n\r\n    /**\r\n      * Gets the element at the specified index.\r\n      * @param index The index at which to get the element of the array.\r\n      */\r\n    get(index: number): number;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param index The index of the location to set.\r\n      * @param value The value to set.\r\n      */\r\n    set(index: number, value: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: Uint32Array, offset?: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: number[], offset?: number): void;\r\n\r\n    /**\r\n      * Gets a new Int8Array view of the ArrayBuffer Object store for this array, specifying the first and last members of the subarray. \r\n      * @param begin The index of the beginning of the array.\r\n      * @param end The index of the end of the array.\r\n      */\r\n    subarray(begin: number, end?: number): Uint32Array;\r\n}\r\ndeclare var Uint32Array: {\r\n    prototype: Uint32Array;\r\n    new (length: number): Uint32Array;\r\n    new (array: Uint32Array): Uint32Array;\r\n    new (array: number[]): Uint32Array;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Uint32Array;\r\n    BYTES_PER_ELEMENT: number;\r\n}\r\n\r\n/**\r\n  * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.\r\n  */\r\ninterface Float32Array extends ArrayBufferView {\r\n    /**\r\n      * The size in bytes of each element in the array. \r\n      */\r\n    BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n      * The length of the array.\r\n      */\r\n    length: number;\r\n    [index: number]: number;\r\n\r\n    /**\r\n      * Gets the element at the specified index.\r\n      * @param index The index at which to get the element of the array.\r\n      */\r\n    get(index: number): number;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param index The index of the location to set.\r\n      * @param value The value to set.\r\n      */\r\n    set(index: number, value: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: Float32Array, offset?: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: number[], offset?: number): void;\r\n\r\n    /**\r\n      * Gets a new Float32Array view of the ArrayBuffer Object store for this array, specifying the first and last members of the subarray. \r\n      * @param begin The index of the beginning of the array.\r\n      * @param end The index of the end of the array.\r\n      */\r\n    subarray(begin: number, end?: number): Float32Array;\r\n}\r\ndeclare var Float32Array: {\r\n    prototype: Float32Array;\r\n    new (length: number): Float32Array;\r\n    new (array: Float32Array): Float32Array;\r\n    new (array: number[]): Float32Array;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Float32Array;\r\n    BYTES_PER_ELEMENT: number;\r\n}\r\n\r\n/**\r\n  * A typed array of 64-bit float values. The contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.\r\n  */\r\ninterface Float64Array extends ArrayBufferView {\r\n    /**\r\n      * The size in bytes of each element in the array. \r\n      */\r\n    BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n      * The length of the array.\r\n      */\r\n    length: number;\r\n    [index: number]: number;\r\n\r\n    /**\r\n      * Gets the element at the specified index.\r\n      * @param index The index at which to get the element of the array.\r\n      */\r\n    get(index: number): number;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param index The index of the location to set.\r\n      * @param value The value to set.\r\n      */\r\n    set(index: number, value: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: Float64Array, offset?: number): void;\r\n\r\n    /**\r\n      * Sets a value or an array of values.\r\n      * @param A typed or untyped array of values to set.\r\n      * @param offset The index in the current array at which the values are to be written.\r\n      */\r\n    set(array: number[], offset?: number): void;\r\n\r\n    /**\r\n      * Gets a new Float64Array view of the ArrayBuffer Object store for this array, specifying the first and last members of the subarray. \r\n      * @param begin The index of the beginning of the array.\r\n      * @param end The index of the end of the array.\r\n      */\r\n    subarray(begin: number, end?: number): Float64Array;\r\n}\r\ndeclare var Float64Array: {\r\n    prototype: Float64Array;\r\n    new (length: number): Float64Array;\r\n    new (array: Float64Array): Float64Array;\r\n    new (array: number[]): Float64Array;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Float64Array;\r\n    BYTES_PER_ELEMENT: number;\r\n}\r\n\r\n/**\r\n  * You can use a DataView object to read and write the different kinds of binary data to any location in the ArrayBuffer. \r\n  */\r\ninterface DataView extends ArrayBufferView {\r\n    /**\r\n      * Gets the Int8 value at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset. \r\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n      */\r\n    getInt8(byteOffset: number): number;\r\n\r\n    /**\r\n      * Gets the Uint8 value at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset. \r\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n      */\r\n    getUint8(byteOffset: number): number;\r\n\r\n    /**\r\n      * Gets the Int16 value at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset. \r\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n      */\r\n    getInt16(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n      * Gets the Uint16 value at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset. \r\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n      */\r\n    getUint16(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n      * Gets the Int32 value at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset. \r\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n      */\r\n    getInt32(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n      * Gets the Uint32 value at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset. \r\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n      */\r\n    getUint32(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n      * Gets the Float32 value at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset. \r\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n      */\r\n    getFloat32(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n      * Gets the Float64 value at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset. \r\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n      */\r\n    getFloat64(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n      * Stores an Int8 value at the specified byte offset from the start of the view. \r\n      * @param byteOffset The place in the buffer at which the value should be set.\r\n      * @param value The value to set.\r\n      */\r\n    setInt8(byteOffset: number, value: number): void;\r\n\r\n    /**\r\n      * Stores an Uint8 value at the specified byte offset from the start of the view. \r\n      * @param byteOffset The place in the buffer at which the value should be set.\r\n      * @param value The value to set.\r\n      */\r\n    setUint8(byteOffset: number, value: number): void;\r\n\r\n    /**\r\n      * Stores an Int16 value at the specified byte offset from the start of the view. \r\n      * @param byteOffset The place in the buffer at which the value should be set.\r\n      * @param value The value to set.\r\n      * @param littleEndian If false or undefined, a big-endian value should be written, otherwise a little-endian value should be written.\r\n      */\r\n    setInt16(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n      * Stores an Uint16 value at the specified byte offset from the start of the view. \r\n      * @param byteOffset The place in the buffer at which the value should be set.\r\n      * @param value The value to set.\r\n      * @param littleEndian If false or undefined, a big-endian value should be written, otherwise a little-endian value should be written.\r\n      */\r\n    setUint16(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n      * Stores an Int32 value at the specified byte offset from the start of the view. \r\n      * @param byteOffset The place in the buffer at which the value should be set.\r\n      * @param value The value to set.\r\n      * @param littleEndian If false or undefined, a big-endian value should be written, otherwise a little-endian value should be written.\r\n      */\r\n    setInt32(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n      * Stores an Uint32 value at the specified byte offset from the start of the view. \r\n      * @param byteOffset The place in the buffer at which the value should be set.\r\n      * @param value The value to set.\r\n      * @param littleEndian If false or undefined, a big-endian value should be written, otherwise a little-endian value should be written.\r\n      */\r\n    setUint32(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n      * Stores an Float32 value at the specified byte offset from the start of the view. \r\n      * @param byteOffset The place in the buffer at which the value should be set.\r\n      * @param value The value to set.\r\n      * @param littleEndian If false or undefined, a big-endian value should be written, otherwise a little-endian value should be written.\r\n      */\r\n    setFloat32(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n      * Stores an Float64 value at the specified byte offset from the start of the view. \r\n      * @param byteOffset The place in the buffer at which the value should be set.\r\n      * @param value The value to set.\r\n      * @param littleEndian If false or undefined, a big-endian value should be written, otherwise a little-endian value should be written.\r\n      */\r\n    setFloat64(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n}\r\ndeclare var DataView: {\r\n    prototype: DataView;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): DataView;\r\n}\r\n\r\n/////////////////////////////\r\n/// IE11 ECMAScript Extensions\r\n/////////////////////////////\r\n\r\ninterface Map<K, V> {\r\n    clear(): void;\r\n    delete(key: K): boolean;\r\n    forEach(callbackfn: (value: V, index: K, map: Map<K, V>) => void, thisArg?: any): void;\r\n    get(key: K): V;\r\n    has(key: K): boolean;\r\n    set(key: K, value: V): Map<K, V>;\r\n    size: number;\r\n}\r\ndeclare var Map: {\r\n    new <K, V>(): Map<K, V>;\r\n}\r\n\r\ninterface WeakMap<K, V> {\r\n    clear(): void;\r\n    delete(key: K): boolean;\r\n    get(key: K): V;\r\n    has(key: K): boolean;\r\n    set(key: K, value: V): WeakMap<K, V>;\r\n}\r\ndeclare var WeakMap: {\r\n    new <K, V>(): WeakMap<K, V>;\r\n}\r\n\r\ninterface Set<T> {\r\n    add(value: T): Set<T>;\r\n    clear(): void;\r\n    delete(value: T): boolean;\r\n    forEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void;\r\n    has(value: T): boolean;\r\n    size: number;\r\n}\r\ndeclare var Set: {\r\n    new <T>(): Set<T>;\r\n}\r\n\r\ndeclare module Intl {\r\n\r\n    interface CollatorOptions {\r\n        usage?: string;\r\n        localeMatcher?: string;\r\n        numeric?: boolean;\r\n        caseFirst?: string;\r\n        sensitivity?: string;\r\n        ignorePunctuation?: boolean;\r\n    }\r\n\r\n    interface ResolvedCollatorOptions {\r\n        locale: string;\r\n        usage: string;\r\n        sensitivity: string;\r\n        ignorePunctuation: boolean;\r\n        collation: string;\r\n        caseFirst: string;\r\n        numeric: boolean;\r\n    }\r\n\r\n    interface Collator {\r\n        compare(x: string, y: string): number;\r\n        resolvedOptions(): ResolvedCollatorOptions;\r\n    }\r\n    var Collator: {\r\n        new (locales?: string[], options?: CollatorOptions): Collator;\r\n        new (locale?: string, options?: CollatorOptions): Collator;\r\n        (locales?: string[], options?: CollatorOptions): Collator;\r\n        (locale?: string, options?: CollatorOptions): Collator;\r\n        supportedLocalesOf(locales: string[], options?: CollatorOptions): string[];\r\n        supportedLocalesOf(locale: string, options?: CollatorOptions): string[];\r\n    }\r\n\r\n    interface NumberFormatOptions {\r\n        localeMatcher?: string;\r\n        style?: string;\r\n        currency?: string;\r\n        currencyDisplay?: string;\r\n        useGrouping?: boolean;\r\n    }\r\n\r\n    interface ResolvedNumberFormatOptions {\r\n        locale: string;\r\n        numberingSystem: string;\r\n        style: string;\r\n        currency?: string;\r\n        currencyDisplay?: string;\r\n        minimumintegerDigits: number;\r\n        minimumFractionDigits: number;\r\n        maximumFractionDigits: number;\r\n        minimumSignificantDigits?: number;\r\n        maximumSignificantDigits?: number;\r\n        useGrouping: boolean;\r\n    }\r\n\r\n    interface NumberFormat {\r\n        format(value: number): string;\r\n        resolvedOptions(): ResolvedNumberFormatOptions;\r\n    }\r\n    var NumberFormat: {\r\n        new (locales?: string[], options?: NumberFormatOptions): Collator;\r\n        new (locale?: string, options?: NumberFormatOptions): Collator;\r\n        (locales?: string[], options?: NumberFormatOptions): Collator;\r\n        (locale?: string, options?: NumberFormatOptions): Collator;\r\n        supportedLocalesOf(locales: string[], options?: NumberFormatOptions): string[];\r\n        supportedLocalesOf(locale: string, options?: NumberFormatOptions): string[];\r\n    }\r\n\r\n    interface DateTimeFormatOptions {\r\n        localeMatcher?: string;\r\n        weekday?: string;\r\n        era?: string;\r\n        year?: string;\r\n        month?: string;\r\n        day?: string;\r\n        hour?: string;\r\n        minute?: string;\r\n        second?: string;\r\n        timeZoneName?: string;\r\n        formatMatcher?: string;\r\n        hour12: boolean;\r\n    }\r\n\r\n    interface ResolvedDateTimeFormatOptions {\r\n        locale: string;\r\n        calendar: string;\r\n        numberingSystem: string;\r\n        timeZone: string;\r\n        hour12?: boolean;\r\n        weekday?: string;\r\n        era?: string;\r\n        year?: string;\r\n        month?: string;\r\n        day?: string;\r\n        hour?: string;\r\n        minute?: string;\r\n        second?: string;\r\n        timeZoneName?: string;\r\n    }\r\n\r\n    interface DateTimeFormat {\r\n        format(date: number): string;\r\n        resolvedOptions(): ResolvedDateTimeFormatOptions;\r\n    }\r\n    var DateTimeFormat: {\r\n        new (locales?: string[], options?: DateTimeFormatOptions): Collator;\r\n        new (locale?: string, options?: DateTimeFormatOptions): Collator;\r\n        (locales?: string[], options?: DateTimeFormatOptions): Collator;\r\n        (locale?: string, options?: DateTimeFormatOptions): Collator;\r\n        supportedLocalesOf(locales: string[], options?: DateTimeFormatOptions): string[];\r\n        supportedLocalesOf(locale: string, options?: DateTimeFormatOptions): string[];\r\n    }\r\n}\r\n\r\ninterface String {\r\n    /**\r\n      * Determines whether two strings are equivalent in the current locale.\r\n      * @param that String to compare to target string\r\n      * @param locales An array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\r\n      * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\r\n      */\r\n    localeCompare(that: string, locales: string[], options?: Intl.CollatorOptions): number;\r\n\r\n    /**\r\n      * Determines whether two strings are equivalent in the current locale.\r\n      * @param that String to compare to target string\r\n      * @param locale Locale tag. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\r\n      * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\r\n      */\r\n    localeCompare(that: string, locale: string, options?: Intl.CollatorOptions): number;\r\n}\r\n\r\ninterface Number {\r\n    /**\r\n      * Converts a number to a string by using the current or specified locale. \r\n      * @param locales An array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\r\n      * @param options An object that contains one or more properties that specify comparison options.\r\n      */\r\n    toLocaleString(locales?: string[], options?: Intl.NumberFormatOptions): string;\r\n\r\n    /**\r\n      * Converts a number to a string by using the current or specified locale. \r\n      * @param locale Locale tag. If you omit this parameter, the default locale of the JavaScript runtime is used.\r\n      * @param options An object that contains one or more properties that specify comparison options.\r\n      */\r\n    toLocaleString(locale?: string, options?: Intl.NumberFormatOptions): string;\r\n}\r\n\r\ninterface Date {\r\n    /**\r\n      * Converts a date to a string by using the current or specified locale.  \r\n      * @param locales An array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\r\n      * @param options An object that contains one or more properties that specify comparison options.\r\n      */\r\n    toLocaleString(locales?: string[], options?: Intl.DateTimeFormatOptions): string;\r\n\r\n    /**\r\n      * Converts a date to a string by using the current or specified locale.  \r\n      * @param locale Locale tag. If you omit this parameter, the default locale of the JavaScript runtime is used.\r\n      * @param options An object that contains one or more properties that specify comparison options.\r\n      */\r\n    toLocaleString(locale?: string, options?: Intl.DateTimeFormatOptions): string;\r\n}\r\n\r\n/////////////////////////////\r\n/// IE DOM APIs\r\n/////////////////////////////\r\n\r\n\r\ninterface PositionOptions {\r\n    enableHighAccuracy?: boolean;\r\n    timeout?: number;\r\n    maximumAge?: number;\r\n}\r\n\r\ninterface ObjectURLOptions {\r\n    oneTimeOnly?: boolean;\r\n}\r\n\r\ninterface StoreExceptionsInformation extends ExceptionInformation {\r\n    siteName?: string;\r\n    explanationString?: string;\r\n    detailURI?: string;\r\n}\r\n\r\ninterface StoreSiteSpecificExceptionsInformation extends StoreExceptionsInformation {\r\n    arrayOfDomainStrings?: string[];\r\n}\r\n\r\ninterface ConfirmSiteSpecificExceptionsInformation extends ExceptionInformation {\r\n    arrayOfDomainStrings?: string[];\r\n}\r\n\r\ninterface AlgorithmParameters {\r\n}\r\n\r\ninterface MutationObserverInit {\r\n    childList?: boolean;\r\n    attributes?: boolean;\r\n    characterData?: boolean;\r\n    subtree?: boolean;\r\n    attributeOldValue?: boolean;\r\n    characterDataOldValue?: boolean;\r\n    attributeFilter?: string[];\r\n}\r\n\r\ninterface PointerEventInit extends MouseEventInit {\r\n    pointerId?: number;\r\n    width?: number;\r\n    height?: number;\r\n    pressure?: number;\r\n    tiltX?: number;\r\n    tiltY?: number;\r\n    pointerType?: string;\r\n    isPrimary?: boolean;\r\n}\r\n\r\ninterface ExceptionInformation {\r\n    domain?: string;\r\n}\r\n\r\ninterface DeviceAccelerationDict {\r\n    x?: number;\r\n    y?: number;\r\n    z?: number;\r\n}\r\n\r\ninterface MsZoomToOptions {\r\n    contentX?: number;\r\n    contentY?: number;\r\n    viewportX?: string;\r\n    viewportY?: string;\r\n    scaleFactor?: number;\r\n    animate?: string;\r\n}\r\n\r\ninterface DeviceRotationRateDict {\r\n    alpha?: number;\r\n    beta?: number;\r\n    gamma?: number;\r\n}\r\n\r\ninterface Algorithm {\r\n    name?: string;\r\n    params?: AlgorithmParameters;\r\n}\r\n\r\ninterface MouseEventInit {\r\n    bubbles?: boolean;\r\n    cancelable?: boolean;\r\n    view?: Window;\r\n    detail?: number;\r\n    screenX?: number;\r\n    screenY?: number;\r\n    clientX?: number;\r\n    clientY?: number;\r\n    ctrlKey?: boolean;\r\n    shiftKey?: boolean;\r\n    altKey?: boolean;\r\n    metaKey?: boolean;\r\n    button?: number;\r\n    buttons?: number;\r\n    relatedTarget?: EventTarget;\r\n}\r\n\r\ninterface WebGLContextAttributes {\r\n    alpha?: boolean;\r\n    depth?: boolean;\r\n    stencil?: boolean;\r\n    antialias?: boolean;\r\n    premultipliedAlpha?: boolean;\r\n    preserveDrawingBuffer?: boolean;\r\n}\r\n\r\ninterface NodeListOf<TNode extends Node> extends NodeList {\r\n    length: number;\r\n    item(index: number): TNode;\r\n    [index: number]: TNode;\r\n}\r\n\r\ninterface HTMLElement extends Element, ElementCSSInlineStyle, MSEventAttachmentTarget, MSNodeExtensions {\r\n    hidden: any;\r\n    readyState: any;\r\n    onmouseleave: (ev: MouseEvent) => any;\r\n    onbeforecut: (ev: DragEvent) => any;\r\n    onkeydown: (ev: KeyboardEvent) => any;\r\n    onmove: (ev: MSEventObj) => any;\r\n    onkeyup: (ev: KeyboardEvent) => any;\r\n    onreset: (ev: Event) => any;\r\n    onhelp: (ev: Event) => any;\r\n    ondragleave: (ev: DragEvent) => any;\r\n    className: string;\r\n    onfocusin: (ev: FocusEvent) => any;\r\n    onseeked: (ev: Event) => any;\r\n    recordNumber: any;\r\n    title: string;\r\n    parentTextEdit: Element;\r\n    outerHTML: string;\r\n    ondurationchange: (ev: Event) => any;\r\n    offsetHeight: number;\r\n    all: HTMLCollection;\r\n    onblur: (ev: FocusEvent) => any;\r\n    dir: string;\r\n    onemptied: (ev: Event) => any;\r\n    onseeking: (ev: Event) => any;\r\n    oncanplay: (ev: Event) => any;\r\n    ondeactivate: (ev: UIEvent) => any;\r\n    ondatasetchanged: (ev: MSEventObj) => any;\r\n    onrowsdelete: (ev: MSEventObj) => any;\r\n    sourceIndex: number;\r\n    onloadstart: (ev: Event) => any;\r\n    onlosecapture: (ev: MSEventObj) => any;\r\n    ondragenter: (ev: DragEvent) => any;\r\n    oncontrolselect: (ev: MSEventObj) => any;\r\n    onsubmit: (ev: Event) => any;\r\n    behaviorUrns: MSBehaviorUrnsCollection;\r\n    scopeName: string;\r\n    onchange: (ev: Event) => any;\r\n    id: string;\r\n    onlayoutcomplete: (ev: MSEventObj) => any;\r\n    uniqueID: string;\r\n    onbeforeactivate: (ev: UIEvent) => any;\r\n    oncanplaythrough: (ev: Event) => any;\r\n    onbeforeupdate: (ev: MSEventObj) => any;\r\n    onfilterchange: (ev: MSEventObj) => any;\r\n    offsetParent: Element;\r\n    ondatasetcomplete: (ev: MSEventObj) => any;\r\n    onsuspend: (ev: Event) => any;\r\n    onmouseenter: (ev: MouseEvent) => any;\r\n    innerText: string;\r\n    onerrorupdate: (ev: MSEventObj) => any;\r\n    onmouseout: (ev: MouseEvent) => any;\r\n    parentElement: HTMLElement;\r\n    onmousewheel: (ev: MouseWheelEvent) => any;\r\n    onvolumechange: (ev: Event) => any;\r\n    oncellchange: (ev: MSEventObj) => any;\r\n    onrowexit: (ev: MSEventObj) => any;\r\n    onrowsinserted: (ev: MSEventObj) => any;\r\n    onpropertychange: (ev: MSEventObj) => any;\r\n    filters: any;\r\n    children: HTMLCollection;\r\n    ondragend: (ev: DragEvent) => any;\r\n    onbeforepaste: (ev: DragEvent) => any;\r\n    ondragover: (ev: DragEvent) => any;\r\n    offsetTop: number;\r\n    onmouseup: (ev: MouseEvent) => any;\r\n    ondragstart: (ev: DragEvent) => any;\r\n    onbeforecopy: (ev: DragEvent) => any;\r\n    ondrag: (ev: DragEvent) => any;\r\n    innerHTML: string;\r\n    onmouseover: (ev: MouseEvent) => any;\r\n    lang: string;\r\n    uniqueNumber: number;\r\n    onpause: (ev: Event) => any;\r\n    tagUrn: string;\r\n    onmousedown: (ev: MouseEvent) => any;\r\n    onclick: (ev: MouseEvent) => any;\r\n    onwaiting: (ev: Event) => any;\r\n    onresizestart: (ev: MSEventObj) => any;\r\n    offsetLeft: number;\r\n    isTextEdit: boolean;\r\n    isDisabled: boolean;\r\n    onpaste: (ev: DragEvent) => any;\r\n    canHaveHTML: boolean;\r\n    onmoveend: (ev: MSEventObj) => any;\r\n    language: string;\r\n    onstalled: (ev: Event) => any;\r\n    onmousemove: (ev: MouseEvent) => any;\r\n    style: MSStyleCSSProperties;\r\n    isContentEditable: boolean;\r\n    onbeforeeditfocus: (ev: MSEventObj) => any;\r\n    onratechange: (ev: Event) => any;\r\n    contentEditable: string;\r\n    tabIndex: number;\r\n    document: Document;\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    ondblclick: (ev: MouseEvent) => any;\r\n    oncontextmenu: (ev: MouseEvent) => any;\r\n    onloadedmetadata: (ev: Event) => any;\r\n    onafterupdate: (ev: MSEventObj) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onplay: (ev: Event) => any;\r\n    onresizeend: (ev: MSEventObj) => any;\r\n    onplaying: (ev: Event) => any;\r\n    isMultiLine: boolean;\r\n    onfocusout: (ev: FocusEvent) => any;\r\n    onabort: (ev: UIEvent) => any;\r\n    ondataavailable: (ev: MSEventObj) => any;\r\n    hideFocus: boolean;\r\n    onreadystatechange: (ev: Event) => any;\r\n    onkeypress: (ev: KeyboardEvent) => any;\r\n    onloadeddata: (ev: Event) => any;\r\n    onbeforedeactivate: (ev: UIEvent) => any;\r\n    outerText: string;\r\n    disabled: boolean;\r\n    onactivate: (ev: UIEvent) => any;\r\n    accessKey: string;\r\n    onmovestart: (ev: MSEventObj) => any;\r\n    onselectstart: (ev: Event) => any;\r\n    onfocus: (ev: FocusEvent) => any;\r\n    ontimeupdate: (ev: Event) => any;\r\n    onresize: (ev: UIEvent) => any;\r\n    oncut: (ev: DragEvent) => any;\r\n    onselect: (ev: UIEvent) => any;\r\n    ondrop: (ev: DragEvent) => any;\r\n    offsetWidth: number;\r\n    oncopy: (ev: DragEvent) => any;\r\n    onended: (ev: Event) => any;\r\n    onscroll: (ev: UIEvent) => any;\r\n    onrowenter: (ev: MSEventObj) => any;\r\n    onload: (ev: Event) => any;\r\n    canHaveChildren: boolean;\r\n    oninput: (ev: Event) => any;\r\n    onmscontentzoom: (ev: MSEventObj) => any;\r\n    oncuechange: (ev: Event) => any;\r\n    spellcheck: boolean;\r\n    classList: DOMTokenList;\r\n    onmsmanipulationstatechanged: (ev: any) => any;\r\n    draggable: boolean;\r\n    dataset: DOMStringMap;\r\n    dragDrop(): boolean;\r\n    scrollIntoView(top?: boolean): void;\r\n    addFilter(filter: any): void;\r\n    setCapture(containerCapture?: boolean): void;\r\n    focus(): void;\r\n    getAdjacentText(where: string): string;\r\n    insertAdjacentText(where: string, text: string): void;\r\n    getElementsByClassName(classNames: string): NodeList;\r\n    setActive(): void;\r\n    removeFilter(filter: any): void;\r\n    blur(): void;\r\n    clearAttributes(): void;\r\n    releaseCapture(): void;\r\n    createControlRange(): ControlRangeCollection;\r\n    removeBehavior(cookie: number): boolean;\r\n    contains(child: HTMLElement): boolean;\r\n    click(): void;\r\n    insertAdjacentElement(position: string, insertedElement: Element): Element;\r\n    mergeAttributes(source: HTMLElement, preserveIdentity?: boolean): void;\r\n    replaceAdjacentText(where: string, newText: string): string;\r\n    applyElement(apply: Element, where?: string): Element;\r\n    addBehavior(bstrUrl: string, factory?: any): number;\r\n    insertAdjacentHTML(where: string, html: string): void;\r\n    msGetInputContext(): MSInputMethodContext;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"move\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"losecapture\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"layoutcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"filterchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforepaste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecopy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"paste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"moveend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizeend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"movestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"copy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var HTMLElement: {\r\n    prototype: HTMLElement;\r\n    new(): HTMLElement;\r\n}\r\n\r\ninterface Document extends Node, NodeSelector, MSEventAttachmentTarget, DocumentEvent, MSResourceMetadata, MSNodeExtensions, MSDocumentExtensions, GlobalEventHandlers {\r\n    /**\r\n      * Gets a reference to the root node of the document. \r\n      */\r\n    documentElement: HTMLElement;\r\n    /**\r\n      * Retrieves the collection of user agents and versions declared in the X-UA-Compatible\r\n      */\r\n    compatible: MSCompatibleInfoCollection;\r\n    /**\r\n      * Fires when the user presses a key.\r\n      * @param ev The keyboard event\r\n      */\r\n    onkeydown: (ev: KeyboardEvent) => any;\r\n    /**\r\n      * Fires when the user releases a key.\r\n      * @param ev The keyboard event\r\n      */\r\n    onkeyup: (ev: KeyboardEvent) => any;\r\n    /**\r\n      * Gets the implementation object of the current document. \r\n      */\r\n    implementation: DOMImplementation;\r\n    /**\r\n      * Fires when the user resets a form. \r\n      * @param ev The event.\r\n      */\r\n    onreset: (ev: Event) => any;\r\n    /**\r\n      * Retrieves a collection of all script objects in the document.\r\n      */\r\n    scripts: HTMLCollection;\r\n    /**\r\n      * Fires when the user presses the F1 key while the browser is the active window. \r\n      * @param ev The event.\r\n      */\r\n    onhelp: (ev: Event) => any;\r\n    /** \r\n      * Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.\r\n      * @param ev The drag event.\r\n      */\r\n    ondragleave: (ev: DragEvent) => any;\r\n    /**\r\n      * Gets or sets the character set used to encode the object.\r\n      */\r\n    charset: string;\r\n    /**\r\n      * Fires for an element just prior to setting focus on that element.\r\n      * @param ev The focus event\r\n      */\r\n    onfocusin: (ev: FocusEvent) => any;\r\n    /** \r\n      * Sets or gets the color of the links that the user has visited.\r\n      */\r\n    vlinkColor: string;\r\n    /**\r\n      * Occurs when the seek operation ends. \r\n      * @param ev The event.\r\n      */\r\n    onseeked: (ev: Event) => any;\r\n    security: string;\r\n    /**\r\n      * Contains the title of the document.\r\n      */\r\n    title: string;\r\n    /**\r\n      * Retrieves a collection of namespace objects.\r\n      */\r\n    namespaces: MSNamespaceInfoCollection;\r\n    /**\r\n      * Gets the default character set from the current regional language settings.\r\n      */\r\n    defaultCharset: string;\r\n    /**\r\n      * Retrieves a collection of all embed objects in the document.\r\n      */\r\n    embeds: HTMLCollection;\r\n    /**\r\n      * Retrieves a collection of styleSheet objects representing the style sheets that correspond to each instance of a link or style object in the document.\r\n      */\r\n    styleSheets: StyleSheetList;\r\n    /**\r\n      * Retrieves a collection of all window objects defined by the given document or defined by the document associated with the given window.\r\n      */\r\n    frames: Window;\r\n    /**\r\n      * Occurs when the duration attribute is updated. \r\n      * @param ev The event.\r\n      */\r\n    ondurationchange: (ev: Event) => any;\r\n    /**\r\n      * Returns a reference to the collection of elements contained by the object.\r\n      */\r\n    all: HTMLCollection;\r\n    /**\r\n      * Retrieves a collection, in source order, of all form objects in the document.\r\n      */\r\n    forms: HTMLCollection;\r\n    /** \r\n      * Fires when the object loses the input focus. \r\n      * @param ev The focus event.\r\n      */\r\n    onblur: (ev: FocusEvent) => any;\r\n    /**\r\n      * Sets or retrieves a value that indicates the reading order of the object. \r\n      */\r\n    dir: string;\r\n    /**\r\n      * Occurs when the media element is reset to its initial state. \r\n      * @param ev The event.\r\n      */\r\n    onemptied: (ev: Event) => any;\r\n    /**\r\n      * Sets or gets a value that indicates whether the document can be edited.\r\n      */\r\n    designMode: string;\r\n    /**\r\n      * Occurs when the current playback position is moved. \r\n      * @param ev The event.\r\n      */\r\n    onseeking: (ev: Event) => any;\r\n    /**\r\n      * Fires when the activeElement is changed from the current object to another object in the parent document.\r\n      * @param ev The UI Event\r\n      */\r\n    ondeactivate: (ev: UIEvent) => any;\r\n    /**\r\n      * Occurs when playback is possible, but would require further buffering. \r\n      * @param ev The event.\r\n      */\r\n    oncanplay: (ev: Event) => any;\r\n    /**\r\n      * Fires when the data set exposed by a data source object changes. \r\n      * @param ev The event.\r\n      */\r\n    ondatasetchanged: (ev: MSEventObj) => any;\r\n    /**\r\n      * Fires when rows are about to be deleted from the recordset.\r\n      * @param ev The event \r\n      */\r\n    onrowsdelete: (ev: MSEventObj) => any;\r\n    Script: MSScriptHost;\r\n    /**\r\n      * Occurs when Internet Explorer begins looking for media data. \r\n      * @param ev The event.\r\n      */\r\n    onloadstart: (ev: Event) => any;\r\n    /**\r\n      * Gets the URL for the document, stripped of any character encoding.\r\n      */\r\n    URLUnencoded: string;\r\n    defaultView: Window;\r\n    /**\r\n      * Fires when the user is about to make a control selection of the object.\r\n      * @param ev The event.\r\n      */\r\n    oncontrolselect: (ev: MSEventObj) => any;\r\n    /** \r\n      * Fires on the target element when the user drags the object to a valid drop target.\r\n      * @param ev The drag event.\r\n      */\r\n    ondragenter: (ev: DragEvent) => any;\r\n    onsubmit: (ev: Event) => any;\r\n    /**\r\n      * Returns the character encoding used to create the webpage that is loaded into the document object.\r\n      */\r\n    inputEncoding: string;\r\n    /**\r\n      * Gets the object that has the focus when the parent document has focus.\r\n      */\r\n    activeElement: Element;\r\n    /**\r\n      * Fires when the contents of the object or selection have changed. \r\n      * @param ev The event.\r\n      */\r\n    onchange: (ev: Event) => any;\r\n    /**\r\n      * Retrieves a collection of all a objects that specify the href property and all area objects in the document.\r\n      */\r\n    links: HTMLCollection;\r\n    /**\r\n      * Retrieves an autogenerated, unique identifier for the object. \r\n      */\r\n    uniqueID: string;\r\n    /**\r\n      * Sets or gets the URL for the current document. \r\n      */\r\n    URL: string;\r\n    /**\r\n      * Fires immediately before the object is set as the active element.\r\n      * @param ev The event.\r\n      */\r\n    onbeforeactivate: (ev: UIEvent) => any;\r\n    head: HTMLHeadElement;\r\n    cookie: string;\r\n    xmlEncoding: string;\r\n    oncanplaythrough: (ev: Event) => any;\r\n    /** \r\n      * Retrieves the document compatibility mode of the document.\r\n      */\r\n    documentMode: number;\r\n    characterSet: string;\r\n    /**\r\n      * Retrieves a collection of all a objects that have a name and/or id property. Objects in this collection are in HTML source order.\r\n      */\r\n    anchors: HTMLCollection;\r\n    onbeforeupdate: (ev: MSEventObj) => any;\r\n    /** \r\n      * Fires to indicate that all data is available from the data source object. \r\n      * @param ev The event.\r\n      */\r\n    ondatasetcomplete: (ev: MSEventObj) => any;\r\n    plugins: HTMLCollection;\r\n    /**\r\n      * Occurs if the load operation has been intentionally halted. \r\n      * @param ev The event.\r\n      */\r\n    onsuspend: (ev: Event) => any;\r\n    /**\r\n      * Gets the root svg element in the document hierarchy.\r\n      */\r\n    rootElement: SVGSVGElement;\r\n    /**\r\n      * Retrieves a value that indicates the current state of the object.\r\n      */\r\n    readyState: string;\r\n    /**\r\n      * Gets the URL of the location that referred the user to the current page.\r\n      */\r\n    referrer: string;\r\n    /**\r\n      * Sets or gets the color of all active links in the document.\r\n      */\r\n    alinkColor: string;\r\n    /**\r\n      * Fires on a databound object when an error occurs while updating the associated data in the data source object. \r\n      * @param ev The event.\r\n      */\r\n    onerrorupdate: (ev: MSEventObj) => any;\r\n    /**\r\n      * Gets a reference to the container object of the window.\r\n      */\r\n    parentWindow: Window;\r\n    /**\r\n      * Fires when the user moves the mouse pointer outside the boundaries of the object. \r\n      * @param ev The mouse event.\r\n      */\r\n    onmouseout: (ev: MouseEvent) => any;\r\n    /**\r\n      * Occurs when a user clicks a button in a Thumbnail Toolbar of a webpage running in Site Mode.\r\n      * @param ev The event.\r\n      */\r\n    onmsthumbnailclick: (ev: MSSiteModeEvent) => any;\r\n    /**\r\n      * Fires when the wheel button is rotated. \r\n      * @param ev The mouse event\r\n      */\r\n    onmousewheel: (ev: MouseWheelEvent) => any;\r\n    /**\r\n      * Occurs when the volume is changed, or playback is muted or unmuted.\r\n      * @param ev The event.\r\n      */\r\n    onvolumechange: (ev: Event) => any;\r\n    /** \r\n      * Fires when data changes in the data provider.\r\n      * @param ev The event.\r\n      */\r\n    oncellchange: (ev: MSEventObj) => any;\r\n    /**\r\n      * Fires just before the data source control changes the current row in the object. \r\n      * @param ev The event.\r\n      */\r\n    onrowexit: (ev: MSEventObj) => any;\r\n    /**\r\n      * Fires just after new rows are inserted in the current recordset.\r\n      * @param ev The event.\r\n      */\r\n    onrowsinserted: (ev: MSEventObj) => any;\r\n    /**\r\n      * Gets or sets the version attribute specified in the declaration of an XML document.\r\n      */\r\n    xmlVersion: string;\r\n    msCapsLockWarningOff: boolean;\r\n    /**\r\n      * Fires when a property changes on the object.\r\n      * @param ev The event.\r\n      */\r\n    onpropertychange: (ev: MSEventObj) => any;\r\n    /**\r\n      * Fires on the source object when the user releases the mouse at the close of a drag operation.\r\n      * @param ev The event.\r\n      */\r\n    ondragend: (ev: DragEvent) => any;\r\n    /**\r\n      * Gets an object representing the document type declaration associated with the current document. \r\n      */\r\n    doctype: DocumentType;\r\n    /**\r\n      * Fires on the target element continuously while the user drags the object over a valid drop target.\r\n      * @param ev The event.\r\n      */\r\n    ondragover: (ev: DragEvent) => any;\r\n    /**\r\n      * Deprecated. Sets or retrieves a value that indicates the background color behind the object. \r\n      */\r\n    bgColor: string;\r\n    /**\r\n      * Fires on the source object when the user starts to drag a text selection or selected object. \r\n      * @param ev The event.\r\n      */\r\n    ondragstart: (ev: DragEvent) => any;\r\n    /**\r\n      * Fires when the user releases a mouse button while the mouse is over the object. \r\n      * @param ev The mouse event.\r\n      */\r\n    onmouseup: (ev: MouseEvent) => any;\r\n    /**\r\n      * Fires on the source object continuously during a drag operation.\r\n      * @param ev The event.\r\n      */\r\n    ondrag: (ev: DragEvent) => any;\r\n    /**\r\n      * Fires when the user moves the mouse pointer into the object.\r\n      * @param ev The mouse event.\r\n      */\r\n    onmouseover: (ev: MouseEvent) => any;\r\n    /**\r\n      * Sets or gets the color of the document links. \r\n      */\r\n    linkColor: string;\r\n    /**\r\n      * Occurs when playback is paused.\r\n      * @param ev The event.\r\n      */\r\n    onpause: (ev: Event) => any;\r\n    /**\r\n      * Fires when the user clicks the object with either mouse button. \r\n      * @param ev The mouse event.\r\n      */\r\n    onmousedown: (ev: MouseEvent) => any;\r\n    /**\r\n      * Fires when the user clicks the left mouse button on the object\r\n      * @param ev The mouse event.\r\n      */\r\n    onclick: (ev: MouseEvent) => any;\r\n    /**\r\n      * Occurs when playback stops because the next frame of a video resource is not available. \r\n      * @param ev The event.\r\n      */\r\n    onwaiting: (ev: Event) => any;\r\n    /**\r\n      * Fires when the user clicks the Stop button or leaves the Web page.\r\n      * @param ev The event.\r\n      */\r\n    onstop: (ev: Event) => any;\r\n    /**\r\n      * Occurs when an item is removed from a Jump List of a webpage running in Site Mode. \r\n      * @param ev The event.\r\n      */\r\n    onmssitemodejumplistitemremoved: (ev: MSSiteModeEvent) => any;\r\n    /**\r\n      * Retrieves a collection of all applet objects in the document.\r\n      */\r\n    applets: HTMLCollection;\r\n    /**\r\n      * Specifies the beginning and end of the document body.\r\n      */\r\n    body: HTMLElement;\r\n    /**\r\n      * Sets or gets the security domain of the document. \r\n      */\r\n    domain: string;\r\n    xmlStandalone: boolean;\r\n    /**\r\n      * Represents the active selection, which is a highlighted block of text or other elements in the document that a user or a script can carry out some action on.\r\n      */\r\n    selection: MSSelection;\r\n    /**\r\n      * Occurs when the download has stopped. \r\n      * @param ev The event.\r\n      */\r\n    onstalled: (ev: Event) => any;\r\n    /**\r\n      * Fires when the user moves the mouse over the object. \r\n      * @param ev The mouse event.\r\n      */\r\n    onmousemove: (ev: MouseEvent) => any;\r\n    /**\r\n      * Fires before an object contained in an editable element enters a UI-activated state or when an editable container object is control selected.\r\n      * @param ev The event.\r\n      */\r\n    onbeforeeditfocus: (ev: MSEventObj) => any;\r\n    /**\r\n      * Occurs when the playback rate is increased or decreased. \r\n      * @param ev The event.\r\n      */\r\n    onratechange: (ev: Event) => any;\r\n    /**\r\n      * Occurs to indicate progress while downloading media data. \r\n      * @param ev The event.\r\n      */\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    /**\r\n      * Fires when the user double-clicks the object.\r\n      * @param ev The mouse event.\r\n      */\r\n    ondblclick: (ev: MouseEvent) => any;\r\n    /**\r\n      * Fires when the user clicks the right mouse button in the client area, opening the context menu. \r\n      * @param ev The mouse event.\r\n      */\r\n    oncontextmenu: (ev: MouseEvent) => any;\r\n    /**\r\n      * Occurs when the duration and dimensions of the media have been determined.\r\n      * @param ev The event.\r\n      */\r\n    onloadedmetadata: (ev: Event) => any;\r\n    media: string;\r\n    /**\r\n      * Fires when an error occurs during object loading.\r\n      * @param ev The event.\r\n      */\r\n    onerror: (ev: ErrorEvent) => any;\r\n    /**\r\n      * Occurs when the play method is requested. \r\n      * @param ev The event.\r\n      */\r\n    onplay: (ev: Event) => any;\r\n    onafterupdate: (ev: MSEventObj) => any;\r\n    /**\r\n      * Occurs when the audio or video has started playing. \r\n      * @param ev The event.\r\n      */\r\n    onplaying: (ev: Event) => any;\r\n    /**\r\n      * Retrieves a collection, in source order, of img objects in the document.\r\n      */\r\n    images: HTMLCollection;\r\n    /**\r\n      * Contains information about the current URL. \r\n      */\r\n    location: Location;\r\n    /**\r\n      * Fires when the user aborts the download.\r\n      * @param ev The event.\r\n      */\r\n    onabort: (ev: UIEvent) => any;\r\n    /**\r\n      * Fires for the current element with focus immediately after moving focus to another element. \r\n      * @param ev The event.\r\n      */\r\n    onfocusout: (ev: FocusEvent) => any;\r\n    /**\r\n      * Fires when the selection state of a document changes.\r\n      * @param ev The event.\r\n      */\r\n    onselectionchange: (ev: Event) => any;\r\n    /**\r\n      * Fires when a local DOM Storage area is written to disk.\r\n      * @param ev The event.\r\n      */\r\n    onstoragecommit: (ev: StorageEvent) => any;\r\n    /**\r\n      * Fires periodically as data arrives from data source objects that asynchronously transmit their data. \r\n      * @param ev The event.\r\n      */\r\n    ondataavailable: (ev: MSEventObj) => any;\r\n    /**\r\n      * Fires when the state of the object has changed.\r\n      * @param ev The event\r\n      */\r\n    onreadystatechange: (ev: Event) => any;\r\n    /**\r\n      * Gets the date that the page was last modified, if the page supplies one. \r\n      */\r\n    lastModified: string;\r\n    /**\r\n      * Fires when the user presses an alphanumeric key.\r\n      * @param ev The event.\r\n      */\r\n    onkeypress: (ev: KeyboardEvent) => any;\r\n    /**\r\n      * Occurs when media data is loaded at the current playback position. \r\n      * @param ev The event.\r\n      */\r\n    onloadeddata: (ev: Event) => any;\r\n    /**\r\n      * Fires immediately before the activeElement is changed from the current object to another object in the parent document.\r\n      * @param ev The event.\r\n      */\r\n    onbeforedeactivate: (ev: UIEvent) => any;\r\n    /**\r\n      * Fires when the object is set as the active element.\r\n      * @param ev The event.\r\n      */\r\n    onactivate: (ev: UIEvent) => any;\r\n    onselectstart: (ev: Event) => any;\r\n    /**\r\n      * Fires when the object receives focus. \r\n      * @param ev The event.\r\n      */\r\n    onfocus: (ev: FocusEvent) => any;\r\n    /**\r\n      * Sets or gets the foreground (text) color of the document.\r\n      */\r\n    fgColor: string;\r\n    /**\r\n      * Occurs to indicate the current playback position.\r\n      * @param ev The event.\r\n      */\r\n    ontimeupdate: (ev: Event) => any;\r\n    /**\r\n      * Fires when the current selection changes.\r\n      * @param ev The event.\r\n      */\r\n    onselect: (ev: UIEvent) => any;\r\n    ondrop: (ev: DragEvent) => any;\r\n    /**\r\n      * Occurs when the end of playback is reached. \r\n      * @param ev The event\r\n      */\r\n    onended: (ev: Event) => any;\r\n    /**\r\n      * Gets a value that indicates whether standards-compliant mode is switched on for the object.\r\n      */\r\n    compatMode: string;\r\n    /**\r\n      * Fires when the user repositions the scroll box in the scroll bar on the object. \r\n      * @param ev The event.\r\n      */\r\n    onscroll: (ev: UIEvent) => any;\r\n    /**\r\n      * Fires to indicate that the current row has changed in the data source and new data values are available on the object. \r\n      * @param ev The event.\r\n      */\r\n    onrowenter: (ev: MSEventObj) => any;\r\n    /**\r\n      * Fires immediately after the browser loads the object. \r\n      * @param ev The event.\r\n      */\r\n    onload: (ev: Event) => any;\r\n    oninput: (ev: Event) => any;\r\n    onmspointerdown: (ev: any) => any;\r\n    msHidden: boolean;\r\n    msVisibilityState: string;\r\n    onmsgesturedoubletap: (ev: any) => any;\r\n    visibilityState: string;\r\n    onmsmanipulationstatechanged: (ev: any) => any;\r\n    onmspointerhover: (ev: any) => any;\r\n    onmscontentzoom: (ev: MSEventObj) => any;\r\n    onmspointermove: (ev: any) => any;\r\n    onmsgesturehold: (ev: any) => any;\r\n    onmsgesturechange: (ev: any) => any;\r\n    onmsgesturestart: (ev: any) => any;\r\n    onmspointercancel: (ev: any) => any;\r\n    onmsgestureend: (ev: any) => any;\r\n    onmsgesturetap: (ev: any) => any;\r\n    onmspointerout: (ev: any) => any;\r\n    onmsinertiastart: (ev: any) => any;\r\n    msCSSOMElementFloatMetrics: boolean;\r\n    onmspointerover: (ev: any) => any;\r\n    hidden: boolean;\r\n    onmspointerup: (ev: any) => any;\r\n    msFullscreenEnabled: boolean;\r\n    onmsfullscreenerror: (ev: any) => any;\r\n    onmspointerenter: (ev: any) => any;\r\n    msFullscreenElement: Element;\r\n    onmsfullscreenchange: (ev: any) => any;\r\n    onmspointerleave: (ev: any) => any;\r\n    /**\r\n      * Returns a reference to the first object with the specified value of the ID or NAME attribute.\r\n      * @param elementId String that specifies the ID value. Case-insensitive.\r\n      */\r\n    getElementById(elementId: string): HTMLElement;\r\n    /**\r\n      * Returns the current value of the document, range, or current selection for the given command.\r\n      * @param commandId String that specifies a command identifier.\r\n      */\r\n    queryCommandValue(commandId: string): string;\r\n    adoptNode(source: Node): Node;\r\n    /**\r\n      * Returns a Boolean value that indicates whether the specified command is in the indeterminate state.\r\n      * @param commandId String that specifies a command identifier.\r\n      */\r\n    queryCommandIndeterm(commandId: string): boolean;\r\n    getElementsByTagNameNS(namespaceURI: string, localName: string): NodeList;\r\n    createProcessingInstruction(target: string, data: string): ProcessingInstruction;\r\n    /**\r\n      * Executes a command on the current document, current selection, or the given range.\r\n      * @param commandId String that specifies the command to execute. This command can be any of the command identifiers that can be executed in script.\r\n      * @param showUI Display the user interface, defaults to false.\r\n      * @param value Value to assign.\r\n      */\r\n    execCommand(commandId: string, showUI?: boolean, value?: any): boolean;\r\n    /**\r\n      * Returns the element for the specified x coordinate and the specified y coordinate. \r\n      * @param x The x-offset\r\n      * @param y The y-offset\r\n      */\r\n    elementFromPoint(x: number, y: number): Element;\r\n    createCDATASection(data: string): CDATASection;\r\n    /**\r\n      * Retrieves the string associated with a command.\r\n      * @param commandId String that contains the identifier of a command. This can be any command identifier given in the list of Command Identifiers. \r\n      */\r\n    queryCommandText(commandId: string): string;\r\n    /**\r\n      * Writes one or more HTML expressions to a document in the specified window. \r\n      * @param content Specifies the text and HTML tags to write.\r\n      */\r\n    write(...content: string[]): void;\r\n    /**\r\n      * Allows updating the print settings for the page.\r\n      */\r\n    updateSettings(): void;\r\n    /**\r\n      * Creates an instance of the element for the specified tag.\r\n      * @param tagName The name of an element.\r\n      */\r\n    createElement(tagName: \"a\"): HTMLAnchorElement;\r\n    createElement(tagName: \"abbr\"): HTMLPhraseElement;\r\n    createElement(tagName: \"acronym\"): HTMLPhraseElement;\r\n    createElement(tagName: \"address\"): HTMLBlockElement;\r\n    createElement(tagName: \"applet\"): HTMLAppletElement;\r\n    createElement(tagName: \"area\"): HTMLAreaElement;\r\n    createElement(tagName: \"article\"): HTMLElement;\r\n    createElement(tagName: \"aside\"): HTMLElement;\r\n    createElement(tagName: \"audio\"): HTMLAudioElement;\r\n    createElement(tagName: \"b\"): HTMLPhraseElement;\r\n    createElement(tagName: \"base\"): HTMLBaseElement;\r\n    createElement(tagName: \"basefont\"): HTMLBaseFontElement;\r\n    createElement(tagName: \"bdo\"): HTMLPhraseElement;\r\n    createElement(tagName: \"bgsound\"): HTMLBGSoundElement;\r\n    createElement(tagName: \"big\"): HTMLPhraseElement;\r\n    createElement(tagName: \"blockquote\"): HTMLBlockElement;\r\n    createElement(tagName: \"body\"): HTMLBodyElement;\r\n    createElement(tagName: \"br\"): HTMLBRElement;\r\n    createElement(tagName: \"button\"): HTMLButtonElement;\r\n    createElement(tagName: \"canvas\"): HTMLCanvasElement;\r\n    createElement(tagName: \"caption\"): HTMLTableCaptionElement;\r\n    createElement(tagName: \"center\"): HTMLBlockElement;\r\n    createElement(tagName: \"cite\"): HTMLPhraseElement;\r\n    createElement(tagName: \"code\"): HTMLPhraseElement;\r\n    createElement(tagName: \"col\"): HTMLTableColElement;\r\n    createElement(tagName: \"colgroup\"): HTMLTableColElement;\r\n    createElement(tagName: \"datalist\"): HTMLDataListElement;\r\n    createElement(tagName: \"dd\"): HTMLDDElement;\r\n    createElement(tagName: \"del\"): HTMLModElement;\r\n    createElement(tagName: \"dfn\"): HTMLPhraseElement;\r\n    createElement(tagName: \"dir\"): HTMLDirectoryElement;\r\n    createElement(tagName: \"div\"): HTMLDivElement;\r\n    createElement(tagName: \"dl\"): HTMLDListElement;\r\n    createElement(tagName: \"dt\"): HTMLDTElement;\r\n    createElement(tagName: \"em\"): HTMLPhraseElement;\r\n    createElement(tagName: \"embed\"): HTMLEmbedElement;\r\n    createElement(tagName: \"fieldset\"): HTMLFieldSetElement;\r\n    createElement(tagName: \"figcaption\"): HTMLElement;\r\n    createElement(tagName: \"figure\"): HTMLElement;\r\n    createElement(tagName: \"font\"): HTMLFontElement;\r\n    createElement(tagName: \"footer\"): HTMLElement;\r\n    createElement(tagName: \"form\"): HTMLFormElement;\r\n    createElement(tagName: \"frame\"): HTMLFrameElement;\r\n    createElement(tagName: \"frameset\"): HTMLFrameSetElement;\r\n    createElement(tagName: \"h1\"): HTMLHeadingElement;\r\n    createElement(tagName: \"h2\"): HTMLHeadingElement;\r\n    createElement(tagName: \"h3\"): HTMLHeadingElement;\r\n    createElement(tagName: \"h4\"): HTMLHeadingElement;\r\n    createElement(tagName: \"h5\"): HTMLHeadingElement;\r\n    createElement(tagName: \"h6\"): HTMLHeadingElement;\r\n    createElement(tagName: \"head\"): HTMLHeadElement;\r\n    createElement(tagName: \"header\"): HTMLElement;\r\n    createElement(tagName: \"hgroup\"): HTMLElement;\r\n    createElement(tagName: \"hr\"): HTMLHRElement;\r\n    createElement(tagName: \"html\"): HTMLHtmlElement;\r\n    createElement(tagName: \"i\"): HTMLPhraseElement;\r\n    createElement(tagName: \"iframe\"): HTMLIFrameElement;\r\n    createElement(tagName: \"img\"): HTMLImageElement;\r\n    createElement(tagName: \"input\"): HTMLInputElement;\r\n    createElement(tagName: \"ins\"): HTMLModElement;\r\n    createElement(tagName: \"isindex\"): HTMLIsIndexElement;\r\n    createElement(tagName: \"kbd\"): HTMLPhraseElement;\r\n    createElement(tagName: \"keygen\"): HTMLBlockElement;\r\n    createElement(tagName: \"label\"): HTMLLabelElement;\r\n    createElement(tagName: \"legend\"): HTMLLegendElement;\r\n    createElement(tagName: \"li\"): HTMLLIElement;\r\n    createElement(tagName: \"link\"): HTMLLinkElement;\r\n    createElement(tagName: \"listing\"): HTMLBlockElement;\r\n    createElement(tagName: \"map\"): HTMLMapElement;\r\n    createElement(tagName: \"mark\"): HTMLElement;\r\n    createElement(tagName: \"marquee\"): HTMLMarqueeElement;\r\n    createElement(tagName: \"menu\"): HTMLMenuElement;\r\n    createElement(tagName: \"meta\"): HTMLMetaElement;\r\n    createElement(tagName: \"nav\"): HTMLElement;\r\n    createElement(tagName: \"nextid\"): HTMLNextIdElement;\r\n    createElement(tagName: \"nobr\"): HTMLPhraseElement;\r\n    createElement(tagName: \"noframes\"): HTMLElement;\r\n    createElement(tagName: \"noscript\"): HTMLElement;\r\n    createElement(tagName: \"object\"): HTMLObjectElement;\r\n    createElement(tagName: \"ol\"): HTMLOListElement;\r\n    createElement(tagName: \"optgroup\"): HTMLOptGroupElement;\r\n    createElement(tagName: \"option\"): HTMLOptionElement;\r\n    createElement(tagName: \"p\"): HTMLParagraphElement;\r\n    createElement(tagName: \"param\"): HTMLParamElement;\r\n    createElement(tagName: \"plaintext\"): HTMLBlockElement;\r\n    createElement(tagName: \"pre\"): HTMLPreElement;\r\n    createElement(tagName: \"progress\"): HTMLProgressElement;\r\n    createElement(tagName: \"q\"): HTMLQuoteElement;\r\n    createElement(tagName: \"rt\"): HTMLPhraseElement;\r\n    createElement(tagName: \"ruby\"): HTMLPhraseElement;\r\n    createElement(tagName: \"s\"): HTMLPhraseElement;\r\n    createElement(tagName: \"samp\"): HTMLPhraseElement;\r\n    createElement(tagName: \"script\"): HTMLScriptElement;\r\n    createElement(tagName: \"section\"): HTMLElement;\r\n    createElement(tagName: \"select\"): HTMLSelectElement;\r\n    createElement(tagName: \"small\"): HTMLPhraseElement;\r\n    createElement(tagName: \"SOURCE\"): HTMLSourceElement;\r\n    createElement(tagName: \"span\"): HTMLSpanElement;\r\n    createElement(tagName: \"strike\"): HTMLPhraseElement;\r\n    createElement(tagName: \"strong\"): HTMLPhraseElement;\r\n    createElement(tagName: \"style\"): HTMLStyleElement;\r\n    createElement(tagName: \"sub\"): HTMLPhraseElement;\r\n    createElement(tagName: \"sup\"): HTMLPhraseElement;\r\n    createElement(tagName: \"table\"): HTMLTableElement;\r\n    createElement(tagName: \"tbody\"): HTMLTableSectionElement;\r\n    createElement(tagName: \"td\"): HTMLTableDataCellElement;\r\n    createElement(tagName: \"textarea\"): HTMLTextAreaElement;\r\n    createElement(tagName: \"tfoot\"): HTMLTableSectionElement;\r\n    createElement(tagName: \"th\"): HTMLTableHeaderCellElement;\r\n    createElement(tagName: \"thead\"): HTMLTableSectionElement;\r\n    createElement(tagName: \"title\"): HTMLTitleElement;\r\n    createElement(tagName: \"tr\"): HTMLTableRowElement;\r\n    createElement(tagName: \"track\"): HTMLTrackElement;\r\n    createElement(tagName: \"tt\"): HTMLPhraseElement;\r\n    createElement(tagName: \"u\"): HTMLPhraseElement;\r\n    createElement(tagName: \"ul\"): HTMLUListElement;\r\n    createElement(tagName: \"var\"): HTMLPhraseElement;\r\n    createElement(tagName: \"video\"): HTMLVideoElement;\r\n    createElement(tagName: \"wbr\"): HTMLElement;\r\n    createElement(tagName: \"x-ms-webview\"): MSHTMLWebViewElement;\r\n    createElement(tagName: \"xmp\"): HTMLBlockElement;\r\n    createElement(tagName: string): HTMLElement;\r\n    /**\r\n      * Removes mouse capture from the object in the current document.\r\n      */\r\n    releaseCapture(): void;\r\n    /**\r\n      * Writes one or more HTML expressions, followed by a carriage return, to a document in the specified window. \r\n      * @param content The text and HTML tags to write.\r\n      */\r\n    writeln(...content: string[]): void;\r\n    createElementNS(namespaceURI: string, qualifiedName: string): Element;\r\n    /**\r\n      * Opens a new window and loads a document specified by a given URL. Also, opens a new window that uses the url parameter and the name parameter to collect the output of the write method and the writeln method.\r\n      * @param url Specifies a MIME type for the document.\r\n      * @param name Specifies the name of the window. This name is used as the value for the TARGET attribute on a form or an anchor element.\r\n      * @param features Contains a list of items separated by commas. Each item consists of an option and a value, separated by an equals sign (for example, \"fullscreen=yes, toolbar=yes\"). The following values are supported.\r\n      * @param replace Specifies whether the existing entry for the document is replaced in the history list.\r\n      */\r\n    open(url?: string, name?: string, features?: string, replace?: boolean): any;\r\n    /**\r\n      * Returns a Boolean value that indicates whether the current command is supported on the current range.\r\n      * @param commandId Specifies a command identifier.\r\n      */\r\n    queryCommandSupported(commandId: string): boolean;\r\n    /**\r\n      * Creates a TreeWalker object that you can use to traverse filtered lists of nodes or elements in a document.\r\n      * @param root The root element or node to start traversing on.\r\n      * @param whatToShow The type of nodes or elements to appear in the node list. For more information, see whatToShow.\r\n      * @param filter A custom NodeFilter function to use.\r\n      * @param entityReferenceExpansion A flag that specifies whether entity reference nodes are expanded.\r\n      */\r\n    createTreeWalker(root: Node, whatToShow: number, filter: NodeFilter, entityReferenceExpansion: boolean): TreeWalker;\r\n    createAttributeNS(namespaceURI: string, qualifiedName: string): Attr;\r\n    /** \r\n      * Returns a Boolean value that indicates whether a specified command can be successfully executed using execCommand, given the current state of the document.\r\n      * @param commandId Specifies a command identifier.\r\n      */\r\n    queryCommandEnabled(commandId: string): boolean;\r\n    /**\r\n      * Causes the element to receive the focus and executes the code specified by the onfocus event.\r\n      */\r\n    focus(): void;\r\n    /**\r\n      * Closes an output stream and forces the sent data to display.\r\n      */\r\n    close(): void;\r\n    getElementsByClassName(classNames: string): NodeList;\r\n    importNode(importedNode: Node, deep: boolean): Node;\r\n    /**\r\n      *  Returns an empty range object that has both of its boundary points positioned at the beginning of the document. \r\n      */\r\n    createRange(): Range;\r\n    /**\r\n      * Fires a specified event on the object.\r\n      * @param eventName Specifies the name of the event to fire.\r\n      * @param eventObj Object that specifies the event object from which to obtain event object properties.\r\n      */\r\n    fireEvent(eventName: string, eventObj?: any): boolean;\r\n    /**\r\n      * Creates a comment object with the specified data.\r\n      * @param data Sets the comment object's data.\r\n      */\r\n    createComment(data: string): Comment;\r\n    /**\r\n      * Retrieves a collection of objects based on the specified element name.\r\n      * @param name Specifies the name of an element.\r\n      */\r\n    getElementsByTagName(name: \"a\"): NodeListOf<HTMLAnchorElement>;\r\n    getElementsByTagName(name: \"abbr\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"acronym\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"address\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"applet\"): NodeListOf<HTMLAppletElement>;\r\n    getElementsByTagName(name: \"area\"): NodeListOf<HTMLAreaElement>;\r\n    getElementsByTagName(name: \"article\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"aside\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"audio\"): NodeListOf<HTMLAudioElement>;\r\n    getElementsByTagName(name: \"b\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"base\"): NodeListOf<HTMLBaseElement>;\r\n    getElementsByTagName(name: \"basefont\"): NodeListOf<HTMLBaseFontElement>;\r\n    getElementsByTagName(name: \"bdo\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"bgsound\"): NodeListOf<HTMLBGSoundElement>;\r\n    getElementsByTagName(name: \"big\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"blockquote\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"body\"): NodeListOf<HTMLBodyElement>;\r\n    getElementsByTagName(name: \"br\"): NodeListOf<HTMLBRElement>;\r\n    getElementsByTagName(name: \"button\"): NodeListOf<HTMLButtonElement>;\r\n    getElementsByTagName(name: \"canvas\"): NodeListOf<HTMLCanvasElement>;\r\n    getElementsByTagName(name: \"caption\"): NodeListOf<HTMLTableCaptionElement>;\r\n    getElementsByTagName(name: \"center\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"cite\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"code\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"col\"): NodeListOf<HTMLTableColElement>;\r\n    getElementsByTagName(name: \"colgroup\"): NodeListOf<HTMLTableColElement>;\r\n    getElementsByTagName(name: \"datalist\"): NodeListOf<HTMLDataListElement>;\r\n    getElementsByTagName(name: \"dd\"): NodeListOf<HTMLDDElement>;\r\n    getElementsByTagName(name: \"del\"): NodeListOf<HTMLModElement>;\r\n    getElementsByTagName(name: \"dfn\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"dir\"): NodeListOf<HTMLDirectoryElement>;\r\n    getElementsByTagName(name: \"div\"): NodeListOf<HTMLDivElement>;\r\n    getElementsByTagName(name: \"dl\"): NodeListOf<HTMLDListElement>;\r\n    getElementsByTagName(name: \"dt\"): NodeListOf<HTMLDTElement>;\r\n    getElementsByTagName(name: \"em\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"embed\"): NodeListOf<HTMLEmbedElement>;\r\n    getElementsByTagName(name: \"fieldset\"): NodeListOf<HTMLFieldSetElement>;\r\n    getElementsByTagName(name: \"figcaption\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"figure\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"font\"): NodeListOf<HTMLFontElement>;\r\n    getElementsByTagName(name: \"footer\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"form\"): NodeListOf<HTMLFormElement>;\r\n    getElementsByTagName(name: \"frame\"): NodeListOf<HTMLFrameElement>;\r\n    getElementsByTagName(name: \"frameset\"): NodeListOf<HTMLFrameSetElement>;\r\n    getElementsByTagName(name: \"h1\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h2\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h3\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h4\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h5\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h6\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"head\"): NodeListOf<HTMLHeadElement>;\r\n    getElementsByTagName(name: \"header\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"hgroup\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"hr\"): NodeListOf<HTMLHRElement>;\r\n    getElementsByTagName(name: \"html\"): NodeListOf<HTMLHtmlElement>;\r\n    getElementsByTagName(name: \"i\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"iframe\"): NodeListOf<HTMLIFrameElement>;\r\n    getElementsByTagName(name: \"img\"): NodeListOf<HTMLImageElement>;\r\n    getElementsByTagName(name: \"input\"): NodeListOf<HTMLInputElement>;\r\n    getElementsByTagName(name: \"ins\"): NodeListOf<HTMLModElement>;\r\n    getElementsByTagName(name: \"isindex\"): NodeListOf<HTMLIsIndexElement>;\r\n    getElementsByTagName(name: \"kbd\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"keygen\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"label\"): NodeListOf<HTMLLabelElement>;\r\n    getElementsByTagName(name: \"legend\"): NodeListOf<HTMLLegendElement>;\r\n    getElementsByTagName(name: \"li\"): NodeListOf<HTMLLIElement>;\r\n    getElementsByTagName(name: \"link\"): NodeListOf<HTMLLinkElement>;\r\n    getElementsByTagName(name: \"listing\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"map\"): NodeListOf<HTMLMapElement>;\r\n    getElementsByTagName(name: \"mark\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"marquee\"): NodeListOf<HTMLMarqueeElement>;\r\n    getElementsByTagName(name: \"menu\"): NodeListOf<HTMLMenuElement>;\r\n    getElementsByTagName(name: \"meta\"): NodeListOf<HTMLMetaElement>;\r\n    getElementsByTagName(name: \"nav\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"nextid\"): NodeListOf<HTMLNextIdElement>;\r\n    getElementsByTagName(name: \"nobr\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"noframes\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"noscript\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"object\"): NodeListOf<HTMLObjectElement>;\r\n    getElementsByTagName(name: \"ol\"): NodeListOf<HTMLOListElement>;\r\n    getElementsByTagName(name: \"optgroup\"): NodeListOf<HTMLOptGroupElement>;\r\n    getElementsByTagName(name: \"option\"): NodeListOf<HTMLOptionElement>;\r\n    getElementsByTagName(name: \"p\"): NodeListOf<HTMLParagraphElement>;\r\n    getElementsByTagName(name: \"param\"): NodeListOf<HTMLParamElement>;\r\n    getElementsByTagName(name: \"plaintext\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"pre\"): NodeListOf<HTMLPreElement>;\r\n    getElementsByTagName(name: \"progress\"): NodeListOf<HTMLProgressElement>;\r\n    getElementsByTagName(name: \"q\"): NodeListOf<HTMLQuoteElement>;\r\n    getElementsByTagName(name: \"rt\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"ruby\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"s\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"samp\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"script\"): NodeListOf<HTMLScriptElement>;\r\n    getElementsByTagName(name: \"section\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"select\"): NodeListOf<HTMLSelectElement>;\r\n    getElementsByTagName(name: \"small\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"SOURCE\"): NodeListOf<HTMLSourceElement>;\r\n    getElementsByTagName(name: \"span\"): NodeListOf<HTMLSpanElement>;\r\n    getElementsByTagName(name: \"strike\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"strong\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"style\"): NodeListOf<HTMLStyleElement>;\r\n    getElementsByTagName(name: \"sub\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"sup\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"table\"): NodeListOf<HTMLTableElement>;\r\n    getElementsByTagName(name: \"tbody\"): NodeListOf<HTMLTableSectionElement>;\r\n    getElementsByTagName(name: \"td\"): NodeListOf<HTMLTableDataCellElement>;\r\n    getElementsByTagName(name: \"textarea\"): NodeListOf<HTMLTextAreaElement>;\r\n    getElementsByTagName(name: \"tfoot\"): NodeListOf<HTMLTableSectionElement>;\r\n    getElementsByTagName(name: \"th\"): NodeListOf<HTMLTableHeaderCellElement>;\r\n    getElementsByTagName(name: \"thead\"): NodeListOf<HTMLTableSectionElement>;\r\n    getElementsByTagName(name: \"title\"): NodeListOf<HTMLTitleElement>;\r\n    getElementsByTagName(name: \"tr\"): NodeListOf<HTMLTableRowElement>;\r\n    getElementsByTagName(name: \"track\"): NodeListOf<HTMLTrackElement>;\r\n    getElementsByTagName(name: \"tt\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"u\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"ul\"): NodeListOf<HTMLUListElement>;\r\n    getElementsByTagName(name: \"var\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"video\"): NodeListOf<HTMLVideoElement>;\r\n    getElementsByTagName(name: \"wbr\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"x-ms-webview\"): NodeListOf<MSHTMLWebViewElement>;\r\n    getElementsByTagName(name: \"xmp\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: string): NodeList;\r\n    /**\r\n      * Creates a new document.\r\n      */\r\n    createDocumentFragment(): DocumentFragment;\r\n    /**\r\n      * Creates a style sheet for the document. \r\n      * @param href Specifies how to add the style sheet to the document. If a file name is specified for the URL, the style information is added as a link object. If the URL contains style information, it is added to the style object.\r\n      * @param index Specifies the index that indicates where the new style sheet is inserted in the styleSheets collection. The default is to insert the new style sheet at the end of the collection.\r\n      */\r\n    createStyleSheet(href?: string, index?: number): CSSStyleSheet;\r\n    /**\r\n      * Gets a collection of objects based on the value of the NAME or ID attribute.\r\n      * @param elementName Gets a collection of objects based on the value of the NAME or ID attribute.\r\n      */\r\n    getElementsByName(elementName: string): NodeList;\r\n    /**\r\n      * Returns a Boolean value that indicates the current state of the command.\r\n      * @param commandId String that specifies a command identifier.\r\n      */\r\n    queryCommandState(commandId: string): boolean;\r\n    /**\r\n      * Gets a value indicating whether the object currently has focus.\r\n      */\r\n    hasFocus(): boolean;\r\n    /**\r\n      * Displays help information for the given command identifier.\r\n      * @param commandId Displays help information for the given command identifier.\r\n      */\r\n    execCommandShowHelp(commandId: string): boolean;\r\n    /**\r\n      * Creates an attribute object with a specified name.\r\n      * @param name String that sets the attribute object's name.\r\n      */\r\n    createAttribute(name: string): Attr;\r\n    /**\r\n      * Creates a text string from the specified value. \r\n      * @param data String that specifies the nodeValue property of the text node.\r\n      */\r\n    createTextNode(data: string): Text;\r\n    /**\r\n      * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document. \r\n      * @param root The root element or node to start traversing on.\r\n      * @param whatToShow The type of nodes or elements to appear in the node list\r\n      * @param filter A custom NodeFilter function to use. For more information, see filter. Use null for no filter.\r\n      * @param entityReferenceExpansion A flag that specifies whether entity reference nodes are expanded.\r\n      */\r\n    createNodeIterator(root: Node, whatToShow: number, filter: NodeFilter, entityReferenceExpansion: boolean): NodeIterator;\r\n    /**\r\n      * Generates an event object to pass event context information when you use the fireEvent method.\r\n      * @param eventObj An object that specifies an existing event object on which to base the new object.\r\n      */\r\n    createEventObject(eventObj?: any): MSEventObj;\r\n    /**\r\n      * Returns an object representing the current selection of the document that is loaded into the object displaying a webpage.\r\n      */\r\n    getSelection(): Selection;\r\n    msElementsFromPoint(x: number, y: number): NodeList;\r\n    msElementsFromRect(left: number, top: number, width: number, height: number): NodeList;\r\n    clear(): void;\r\n    msExitFullscreen(): void;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msthumbnailclick\", listener: (ev: MSSiteModeEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stop\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mssitemodejumplistitemremoved\", listener: (ev: MSSiteModeEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectionchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"storagecommit\", listener: (ev: StorageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msfullscreenerror\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msfullscreenchange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var Document: {\r\n    prototype: Document;\r\n    new(): Document;\r\n}\r\n\r\ninterface Console {\r\n    info(message?: any, ...optionalParams: any[]): void;\r\n    warn(message?: any, ...optionalParams: any[]): void;\r\n    error(message?: any, ...optionalParams: any[]): void;\r\n    log(message?: any, ...optionalParams: any[]): void;\r\n    profile(reportName?: string): void;\r\n    assert(test?: boolean, message?: string, ...optionalParams: any[]): void;\r\n    msIsIndependentlyComposed(element: Element): boolean;\r\n    clear(): void;\r\n    dir(value?: any, ...optionalParams: any[]): void;\r\n    profileEnd(): void;\r\n    count(countTitle?: string): void;\r\n    groupEnd(): void;\r\n    time(timerName?: string): void;\r\n    timeEnd(timerName?: string): void;\r\n    trace(): void;\r\n    group(groupTitle?: string): void;\r\n    dirxml(value: any): void;\r\n    debug(message?: string, ...optionalParams: any[]): void;\r\n    groupCollapsed(groupTitle?: string): void;\r\n    select(element: Element): void;\r\n}\r\ndeclare var Console: {\r\n    prototype: Console;\r\n    new(): Console;\r\n}\r\n\r\ninterface MSEventObj extends Event {\r\n    nextPage: string;\r\n    keyCode: number;\r\n    toElement: Element;\r\n    returnValue: any;\r\n    dataFld: string;\r\n    y: number;\r\n    dataTransfer: DataTransfer;\r\n    propertyName: string;\r\n    url: string;\r\n    offsetX: number;\r\n    recordset: any;\r\n    screenX: number;\r\n    buttonID: number;\r\n    wheelDelta: number;\r\n    reason: number;\r\n    origin: string;\r\n    data: string;\r\n    srcFilter: any;\r\n    boundElements: HTMLCollection;\r\n    cancelBubble: boolean;\r\n    altLeft: boolean;\r\n    behaviorCookie: number;\r\n    bookmarks: BookmarkCollection;\r\n    type: string;\r\n    repeat: boolean;\r\n    srcElement: Element;\r\n    source: Window;\r\n    fromElement: Element;\r\n    offsetY: number;\r\n    x: number;\r\n    behaviorPart: number;\r\n    qualifier: string;\r\n    altKey: boolean;\r\n    ctrlKey: boolean;\r\n    clientY: number;\r\n    shiftKey: boolean;\r\n    shiftLeft: boolean;\r\n    contentOverflow: boolean;\r\n    screenY: number;\r\n    ctrlLeft: boolean;\r\n    button: number;\r\n    srcUrn: string;\r\n    clientX: number;\r\n    actionURL: string;\r\n    getAttribute(strAttributeName: string, lFlags?: number): any;\r\n    setAttribute(strAttributeName: string, AttributeValue: any, lFlags?: number): void;\r\n    removeAttribute(strAttributeName: string, lFlags?: number): boolean;\r\n}\r\ndeclare var MSEventObj: {\r\n    prototype: MSEventObj;\r\n    new(): MSEventObj;\r\n}\r\n\r\ninterface HTMLCanvasElement extends HTMLElement {\r\n    /**\r\n      * Gets or sets the width of a canvas element on a document.\r\n      */\r\n    width: number;\r\n    /**\r\n      * Gets or sets the height of a canvas element on a document.\r\n      */\r\n    height: number;\r\n    /**\r\n      * Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas.\r\n      * @param contextId The identifier (ID) of the type of canvas to create. Internet Explorer 9 and Internet Explorer 10 support only a 2-D context using canvas.getContext(\"2d\"); IE11 Preview also supports 3-D or WebGL context using canvas.getContext(\"experimental-webgl\");\r\n      */\r\n    getContext(contextId: \"2d\"): CanvasRenderingContext2D;\r\n    /**\r\n      * Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas.\r\n      * @param contextId The identifier (ID) of the type of canvas to create. Internet Explorer 9 and Internet Explorer 10 support only a 2-D context using canvas.getContext(\"2d\"); IE11 Preview also supports 3-D or WebGL context using canvas.getContext(\"experimental-webgl\");\r\n      */\r\n    getContext(contextId: \"experimental-webgl\"): WebGLRenderingContext;\r\n    /**\r\n      * Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas.\r\n      * @param contextId The identifier (ID) of the type of canvas to create. Internet Explorer 9 and Internet Explorer 10 support only a 2-D context using canvas.getContext(\"2d\"); IE11 Preview also supports 3-D or WebGL context using canvas.getContext(\"experimental-webgl\");\r\n      */\r\n    getContext(contextId: string, ...args: any[]): any;\r\n    /**\r\n      * Returns the content of the current canvas as an image that you can use as a source for another canvas or an HTML element.\r\n      * @param type The standard MIME type for the image format to return. If you do not specify this parameter, the default value is a PNG format image.\r\n      */\r\n    toDataURL(type?: string, ...args: any[]): string;\r\n    /**\r\n      * Returns a blob object encoded as a Portable Network Graphics (PNG) format from a canvas image or drawing.\r\n      */\r\n    msToBlob(): Blob;\r\n}\r\ndeclare var HTMLCanvasElement: {\r\n    prototype: HTMLCanvasElement;\r\n    new(): HTMLCanvasElement;\r\n}\r\n\r\ninterface Window extends EventTarget, MSEventAttachmentTarget, WindowLocalStorage, MSWindowExtensions, WindowSessionStorage, WindowTimers, WindowBase64, IDBEnvironment, WindowConsole, GlobalEventHandlers {\r\n    ondragend: (ev: DragEvent) => any;\r\n    onkeydown: (ev: KeyboardEvent) => any;\r\n    ondragover: (ev: DragEvent) => any;\r\n    onkeyup: (ev: KeyboardEvent) => any;\r\n    onreset: (ev: Event) => any;\r\n    onmouseup: (ev: MouseEvent) => any;\r\n    ondragstart: (ev: DragEvent) => any;\r\n    ondrag: (ev: DragEvent) => any;\r\n    screenX: number;\r\n    onmouseover: (ev: MouseEvent) => any;\r\n    ondragleave: (ev: DragEvent) => any;\r\n    history: History;\r\n    pageXOffset: number;\r\n    name: string;\r\n    onafterprint: (ev: Event) => any;\r\n    onpause: (ev: Event) => any;\r\n    onbeforeprint: (ev: Event) => any;\r\n    top: Window;\r\n    onmousedown: (ev: MouseEvent) => any;\r\n    onseeked: (ev: Event) => any;\r\n    opener: Window;\r\n    onclick: (ev: MouseEvent) => any;\r\n    innerHeight: number;\r\n    onwaiting: (ev: Event) => any;\r\n    ononline: (ev: Event) => any;\r\n    ondurationchange: (ev: Event) => any;\r\n    frames: Window;\r\n    onblur: (ev: FocusEvent) => any;\r\n    onemptied: (ev: Event) => any;\r\n    onseeking: (ev: Event) => any;\r\n    oncanplay: (ev: Event) => any;\r\n    outerWidth: number;\r\n    onstalled: (ev: Event) => any;\r\n    onmousemove: (ev: MouseEvent) => any;\r\n    innerWidth: number;\r\n    onoffline: (ev: Event) => any;\r\n    length: number;\r\n    screen: Screen;\r\n    onbeforeunload: (ev: BeforeUnloadEvent) => any;\r\n    onratechange: (ev: Event) => any;\r\n    onstorage: (ev: StorageEvent) => any;\r\n    onloadstart: (ev: Event) => any;\r\n    ondragenter: (ev: DragEvent) => any;\r\n    onsubmit: (ev: Event) => any;\r\n    self: Window;\r\n    document: Document;\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    ondblclick: (ev: MouseEvent) => any;\r\n    pageYOffset: number;\r\n    oncontextmenu: (ev: MouseEvent) => any;\r\n    onchange: (ev: Event) => any;\r\n    onloadedmetadata: (ev: Event) => any;\r\n    onplay: (ev: Event) => any;\r\n    onerror: ErrorEventHandler;\r\n    onplaying: (ev: Event) => any;\r\n    parent: Window;\r\n    location: Location;\r\n    oncanplaythrough: (ev: Event) => any;\r\n    onabort: (ev: UIEvent) => any;\r\n    onreadystatechange: (ev: Event) => any;\r\n    outerHeight: number;\r\n    onkeypress: (ev: KeyboardEvent) => any;\r\n    frameElement: Element;\r\n    onloadeddata: (ev: Event) => any;\r\n    onsuspend: (ev: Event) => any;\r\n    window: Window;\r\n    onfocus: (ev: FocusEvent) => any;\r\n    onmessage: (ev: MessageEvent) => any;\r\n    ontimeupdate: (ev: Event) => any;\r\n    onresize: (ev: UIEvent) => any;\r\n    onselect: (ev: UIEvent) => any;\r\n    navigator: Navigator;\r\n    styleMedia: StyleMedia;\r\n    ondrop: (ev: DragEvent) => any;\r\n    onmouseout: (ev: MouseEvent) => any;\r\n    onended: (ev: Event) => any;\r\n    onhashchange: (ev: Event) => any;\r\n    onunload: (ev: Event) => any;\r\n    onscroll: (ev: UIEvent) => any;\r\n    screenY: number;\r\n    onmousewheel: (ev: MouseWheelEvent) => any;\r\n    onload: (ev: Event) => any;\r\n    onvolumechange: (ev: Event) => any;\r\n    oninput: (ev: Event) => any;\r\n    performance: Performance;\r\n    onmspointerdown: (ev: any) => any;\r\n    animationStartTime: number;\r\n    onmsgesturedoubletap: (ev: any) => any;\r\n    onmspointerhover: (ev: any) => any;\r\n    onmsgesturehold: (ev: any) => any;\r\n    onmspointermove: (ev: any) => any;\r\n    onmsgesturechange: (ev: any) => any;\r\n    onmsgesturestart: (ev: any) => any;\r\n    onmspointercancel: (ev: any) => any;\r\n    onmsgestureend: (ev: any) => any;\r\n    onmsgesturetap: (ev: any) => any;\r\n    onmspointerout: (ev: any) => any;\r\n    msAnimationStartTime: number;\r\n    applicationCache: ApplicationCache;\r\n    onmsinertiastart: (ev: any) => any;\r\n    onmspointerover: (ev: any) => any;\r\n    onpopstate: (ev: PopStateEvent) => any;\r\n    onmspointerup: (ev: any) => any;\r\n    onpageshow: (ev: PageTransitionEvent) => any;\r\n    ondevicemotion: (ev: DeviceMotionEvent) => any;\r\n    devicePixelRatio: number;\r\n    msCrypto: Crypto;\r\n    ondeviceorientation: (ev: DeviceOrientationEvent) => any;\r\n    doNotTrack: string;\r\n    onmspointerenter: (ev: any) => any;\r\n    onpagehide: (ev: PageTransitionEvent) => any;\r\n    onmspointerleave: (ev: any) => any;\r\n    alert(message?: any): void;\r\n    scroll(x?: number, y?: number): void;\r\n    focus(): void;\r\n    scrollTo(x?: number, y?: number): void;\r\n    print(): void;\r\n    prompt(message?: string, _default?: string): string;\r\n    toString(): string;\r\n    open(url?: string, target?: string, features?: string, replace?: boolean): Window;\r\n    scrollBy(x?: number, y?: number): void;\r\n    confirm(message?: string): boolean;\r\n    close(): void;\r\n    postMessage(message: any, targetOrigin: string, ports?: any): void;\r\n    showModalDialog(url?: string, argument?: any, options?: any): any;\r\n    blur(): void;\r\n    getSelection(): Selection;\r\n    getComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration;\r\n    msCancelRequestAnimationFrame(handle: number): void;\r\n    matchMedia(mediaQuery: string): MediaQueryList;\r\n    cancelAnimationFrame(handle: number): void;\r\n    msIsStaticHTML(html: string): boolean;\r\n    msMatchMedia(mediaQuery: string): MediaQueryList;\r\n    requestAnimationFrame(callback: FrameRequestCallback): number;\r\n    msRequestAnimationFrame(callback: FrameRequestCallback): number;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterprint\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeprint\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"online\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"offline\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeunload\", listener: (ev: BeforeUnloadEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"storage\", listener: (ev: StorageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"message\", listener: (ev: MessageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"hashchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"unload\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"popstate\", listener: (ev: PopStateEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pageshow\", listener: (ev: PageTransitionEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"devicemotion\", listener: (ev: DeviceMotionEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deviceorientation\", listener: (ev: DeviceOrientationEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pagehide\", listener: (ev: PageTransitionEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var Window: {\r\n    prototype: Window;\r\n    new(): Window;\r\n}\r\n\r\ninterface FormData {\r\n    append(name: any, value: any, blobName?: string): void;\r\n}\r\ndeclare var FormData: {\r\n    prototype: FormData;\r\n    new (form?: HTMLFormElement): FormData;\r\n}\r\n\r\ninterface SourceBuffer extends EventTarget {\r\n    updating: boolean;\r\n    appendWindowStart: number;\r\n    appendWindowEnd: number;\r\n    buffered: TimeRanges;\r\n    timestampOffset: number;\r\n    audioTracks: AudioTrackList;\r\n    appendBuffer(data: ArrayBufferView): void;\r\n    appendBuffer(data: ArrayBuffer): void;\r\n    remove(start: number, end: number): void;\r\n    abort(): void;\r\n    appendStream(stream: MSStream, maxSize?: number): void;\r\n}\r\ndeclare var SourceBuffer: {\r\n    prototype: SourceBuffer;\r\n    new(): SourceBuffer;\r\n}\r\n\r\ninterface NavigatorID {\r\n    appVersion: string;\r\n    appName: string;\r\n    userAgent: string;\r\n    platform: string;\r\n    product: string;\r\n    vendor: string;\r\n}\r\n\r\ninterface HTMLTableElement extends HTMLElement, MSDataBindingTableExtensions, MSDataBindingExtensions, DOML2DeprecatedBackgroundStyle, DOML2DeprecatedBackgroundColorStyle {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: string;\r\n    /**\r\n      * Sets or retrieves the color for one of the two colors used to draw the 3-D border of the object.\r\n      */\r\n    borderColorLight: any;\r\n    /**\r\n      * Sets or retrieves the amount of space between cells in a table.\r\n      */\r\n    cellSpacing: string;\r\n    /**\r\n      * Retrieves the tFoot object of the table.\r\n      */\r\n    tFoot: HTMLTableSectionElement;\r\n    /**\r\n      * Sets or retrieves the way the border frame around the table is displayed.\r\n      */\r\n    frame: string;\r\n    /**\r\n      * Sets or retrieves the border color of the object. \r\n      */\r\n    borderColor: any;\r\n    /**\r\n      * Sets or retrieves the number of horizontal rows contained in the object.\r\n      */\r\n    rows: HTMLCollection;\r\n    /**\r\n      * Sets or retrieves which dividing lines (inner borders) are displayed.\r\n      */\r\n    rules: string;\r\n    /**\r\n      * Sets or retrieves the number of columns in the table.\r\n      */\r\n    cols: number;\r\n    /**\r\n      * Sets or retrieves a description and/or structure of the object.\r\n      */\r\n    summary: string;\r\n    /**\r\n      * Retrieves the caption object of a table.\r\n      */\r\n    caption: HTMLTableCaptionElement;\r\n    /**\r\n      * Retrieves a collection of all tBody objects in the table. Objects in this collection are in source order.\r\n      */\r\n    tBodies: HTMLCollection;\r\n    /**\r\n      * Retrieves the tHead object of the table.\r\n      */\r\n    tHead: HTMLTableSectionElement;\r\n    /**\r\n      * Sets or retrieves a value that indicates the table alignment.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Retrieves a collection of all cells in the table row or in the entire table.\r\n      */\r\n    cells: HTMLCollection;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: any;\r\n    /**\r\n      * Sets or retrieves the amount of space between the border of the cell and the content of the cell.\r\n      */\r\n    cellPadding: string;\r\n    /**\r\n      * Sets or retrieves the width of the border to draw around the object.\r\n      */\r\n    border: string;\r\n    /**\r\n      * Sets or retrieves the color for one of the two colors used to draw the 3-D border of the object.\r\n      */\r\n    borderColorDark: any;\r\n    /**\r\n      * Removes the specified row (tr) from the element and from the rows collection.\r\n      * @param index Number that specifies the zero-based position in the rows collection of the row to remove.\r\n      */\r\n    deleteRow(index?: number): void;\r\n    /**\r\n      * Creates an empty tBody element in the table.\r\n      */\r\n    createTBody(): HTMLElement;\r\n    /**\r\n      * Deletes the caption element and its contents from the table.\r\n      */\r\n    deleteCaption(): void;\r\n    /**\r\n      * Creates a new row (tr) in the table, and adds the row to the rows collection.\r\n      * @param index Number that specifies where to insert the row in the rows collection. The default value is -1, which appends the new row to the end of the rows collection.\r\n      */\r\n    insertRow(index?: number): HTMLElement;\r\n    /**\r\n      * Deletes the tFoot element and its contents from the table.\r\n      */\r\n    deleteTFoot(): void;\r\n    /**\r\n      * Returns the tHead element object if successful, or null otherwise.\r\n      */\r\n    createTHead(): HTMLElement;\r\n    /**\r\n      * Deletes the tHead element and its contents from the table.\r\n      */\r\n    deleteTHead(): void;\r\n    /**\r\n      * Creates an empty caption element in the table.\r\n      */\r\n    createCaption(): HTMLElement;\r\n    /**\r\n      * Moves a table row to a new position.\r\n      * @param indexFrom Number that specifies the index in the rows collection of the table row that is moved.\r\n      * @param indexTo Number that specifies where the row is moved within the rows collection.\r\n      */\r\n    moveRow(indexFrom?: number, indexTo?: number): any;\r\n    /**\r\n      * Creates an empty tFoot element in the table.\r\n      */\r\n    createTFoot(): HTMLElement;\r\n}\r\ndeclare var HTMLTableElement: {\r\n    prototype: HTMLTableElement;\r\n    new(): HTMLTableElement;\r\n}\r\n\r\ninterface TreeWalker {\r\n    whatToShow: number;\r\n    filter: NodeFilter;\r\n    root: Node;\r\n    currentNode: Node;\r\n    expandEntityReferences: boolean;\r\n    previousSibling(): Node;\r\n    lastChild(): Node;\r\n    nextSibling(): Node;\r\n    nextNode(): Node;\r\n    parentNode(): Node;\r\n    firstChild(): Node;\r\n    previousNode(): Node;\r\n}\r\ndeclare var TreeWalker: {\r\n    prototype: TreeWalker;\r\n    new(): TreeWalker;\r\n}\r\n\r\ninterface GetSVGDocument {\r\n    getSVGDocument(): Document;\r\n}\r\n\r\ninterface SVGPathSegCurvetoQuadraticRel extends SVGPathSeg {\r\n    y: number;\r\n    y1: number;\r\n    x: number;\r\n    x1: number;\r\n}\r\ndeclare var SVGPathSegCurvetoQuadraticRel: {\r\n    prototype: SVGPathSegCurvetoQuadraticRel;\r\n    new(): SVGPathSegCurvetoQuadraticRel;\r\n}\r\n\r\ninterface Performance {\r\n    navigation: PerformanceNavigation;\r\n    timing: PerformanceTiming;\r\n    getEntriesByType(entryType: string): any;\r\n    toJSON(): any;\r\n    getMeasures(measureName?: string): any;\r\n    clearMarks(markName?: string): void;\r\n    getMarks(markName?: string): any;\r\n    clearResourceTimings(): void;\r\n    mark(markName: string): void;\r\n    measure(measureName: string, startMarkName?: string, endMarkName?: string): void;\r\n    getEntriesByName(name: string, entryType?: string): any;\r\n    getEntries(): any;\r\n    clearMeasures(measureName?: string): void;\r\n    setResourceTimingBufferSize(maxSize: number): void;\r\n    now(): number;\r\n}\r\ndeclare var Performance: {\r\n    prototype: Performance;\r\n    new(): Performance;\r\n}\r\n\r\ninterface MSDataBindingTableExtensions {\r\n    dataPageSize: number;\r\n    nextPage(): void;\r\n    firstPage(): void;\r\n    refresh(): void;\r\n    previousPage(): void;\r\n    lastPage(): void;\r\n}\r\n\r\ninterface CompositionEvent extends UIEvent {\r\n    data: string;\r\n    locale: string;\r\n    initCompositionEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, dataArg: string, locale: string): void;\r\n}\r\ndeclare var CompositionEvent: {\r\n    prototype: CompositionEvent;\r\n    new(): CompositionEvent;\r\n}\r\n\r\ninterface WindowTimers extends WindowTimersExtension {\r\n    clearTimeout(handle: number): void;\r\n    setTimeout(handler: any, timeout?: any, ...args: any[]): number;\r\n    clearInterval(handle: number): void;\r\n    setInterval(handler: any, timeout?: any, ...args: any[]): number;\r\n}\r\n\r\ninterface SVGMarkerElement extends SVGElement, SVGStylable, SVGLangSpace, SVGFitToViewBox, SVGExternalResourcesRequired {\r\n    orientType: SVGAnimatedEnumeration;\r\n    markerUnits: SVGAnimatedEnumeration;\r\n    markerWidth: SVGAnimatedLength;\r\n    markerHeight: SVGAnimatedLength;\r\n    orientAngle: SVGAnimatedAngle;\r\n    refY: SVGAnimatedLength;\r\n    refX: SVGAnimatedLength;\r\n    setOrientToAngle(angle: SVGAngle): void;\r\n    setOrientToAuto(): void;\r\n    SVG_MARKER_ORIENT_UNKNOWN: number;\r\n    SVG_MARKER_ORIENT_ANGLE: number;\r\n    SVG_MARKERUNITS_UNKNOWN: number;\r\n    SVG_MARKERUNITS_STROKEWIDTH: number;\r\n    SVG_MARKER_ORIENT_AUTO: number;\r\n    SVG_MARKERUNITS_USERSPACEONUSE: number;\r\n}\r\ndeclare var SVGMarkerElement: {\r\n    prototype: SVGMarkerElement;\r\n    new(): SVGMarkerElement;\r\n    SVG_MARKER_ORIENT_UNKNOWN: number;\r\n    SVG_MARKER_ORIENT_ANGLE: number;\r\n    SVG_MARKERUNITS_UNKNOWN: number;\r\n    SVG_MARKERUNITS_STROKEWIDTH: number;\r\n    SVG_MARKER_ORIENT_AUTO: number;\r\n    SVG_MARKERUNITS_USERSPACEONUSE: number;\r\n}\r\n\r\ninterface CSSStyleDeclaration {\r\n    backgroundAttachment: string;\r\n    visibility: string;\r\n    textAlignLast: string;\r\n    borderRightStyle: string;\r\n    counterIncrement: string;\r\n    orphans: string;\r\n    cssText: string;\r\n    borderStyle: string;\r\n    pointerEvents: string;\r\n    borderTopColor: string;\r\n    markerEnd: string;\r\n    textIndent: string;\r\n    listStyleImage: string;\r\n    cursor: string;\r\n    listStylePosition: string;\r\n    wordWrap: string;\r\n    borderTopStyle: string;\r\n    alignmentBaseline: string;\r\n    opacity: string;\r\n    direction: string;\r\n    strokeMiterlimit: string;\r\n    maxWidth: string;\r\n    color: string;\r\n    clip: string;\r\n    borderRightWidth: string;\r\n    verticalAlign: string;\r\n    overflow: string;\r\n    mask: string;\r\n    borderLeftStyle: string;\r\n    emptyCells: string;\r\n    stopOpacity: string;\r\n    paddingRight: string;\r\n    parentRule: CSSRule;\r\n    background: string;\r\n    boxSizing: string;\r\n    textJustify: string;\r\n    height: string;\r\n    paddingTop: string;\r\n    length: number;\r\n    right: string;\r\n    baselineShift: string;\r\n    borderLeft: string;\r\n    widows: string;\r\n    lineHeight: string;\r\n    left: string;\r\n    textUnderlinePosition: string;\r\n    glyphOrientationHorizontal: string;\r\n    display: string;\r\n    textAnchor: string;\r\n    cssFloat: string;\r\n    strokeDasharray: string;\r\n    rubyAlign: string;\r\n    fontSizeAdjust: string;\r\n    borderLeftColor: string;\r\n    backgroundImage: string;\r\n    listStyleType: string;\r\n    strokeWidth: string;\r\n    textOverflow: string;\r\n    fillRule: string;\r\n    borderBottomColor: string;\r\n    zIndex: string;\r\n    position: string;\r\n    listStyle: string;\r\n    msTransformOrigin: string;\r\n    dominantBaseline: string;\r\n    overflowY: string;\r\n    fill: string;\r\n    captionSide: string;\r\n    borderCollapse: string;\r\n    boxShadow: string;\r\n    quotes: string;\r\n    tableLayout: string;\r\n    unicodeBidi: string;\r\n    borderBottomWidth: string;\r\n    backgroundSize: string;\r\n    textDecoration: string;\r\n    strokeDashoffset: string;\r\n    fontSize: string;\r\n    border: string;\r\n    pageBreakBefore: string;\r\n    borderTopRightRadius: string;\r\n    msTransform: string;\r\n    borderBottomLeftRadius: string;\r\n    textTransform: string;\r\n    rubyPosition: string;\r\n    strokeLinejoin: string;\r\n    clipPath: string;\r\n    borderRightColor: string;\r\n    fontFamily: string;\r\n    clear: string;\r\n    content: string;\r\n    backgroundClip: string;\r\n    marginBottom: string;\r\n    counterReset: string;\r\n    outlineWidth: string;\r\n    marginRight: string;\r\n    paddingLeft: string;\r\n    borderBottom: string;\r\n    wordBreak: string;\r\n    marginTop: string;\r\n    top: string;\r\n    fontWeight: string;\r\n    borderRight: string;\r\n    width: string;\r\n    kerning: string;\r\n    pageBreakAfter: string;\r\n    borderBottomStyle: string;\r\n    fontStretch: string;\r\n    padding: string;\r\n    strokeOpacity: string;\r\n    markerStart: string;\r\n    bottom: string;\r\n    borderLeftWidth: string;\r\n    clipRule: string;\r\n    backgroundPosition: string;\r\n    backgroundColor: string;\r\n    pageBreakInside: string;\r\n    backgroundOrigin: string;\r\n    strokeLinecap: string;\r\n    borderTopWidth: string;\r\n    outlineStyle: string;\r\n    borderTop: string;\r\n    outlineColor: string;\r\n    paddingBottom: string;\r\n    marginLeft: string;\r\n    font: string;\r\n    outline: string;\r\n    wordSpacing: string;\r\n    maxHeight: string;\r\n    fillOpacity: string;\r\n    letterSpacing: string;\r\n    borderSpacing: string;\r\n    backgroundRepeat: string;\r\n    borderRadius: string;\r\n    borderWidth: string;\r\n    borderBottomRightRadius: string;\r\n    whiteSpace: string;\r\n    fontStyle: string;\r\n    minWidth: string;\r\n    stopColor: string;\r\n    borderTopLeftRadius: string;\r\n    borderColor: string;\r\n    marker: string;\r\n    glyphOrientationVertical: string;\r\n    markerMid: string;\r\n    fontVariant: string;\r\n    minHeight: string;\r\n    stroke: string;\r\n    rubyOverhang: string;\r\n    overflowX: string;\r\n    textAlign: string;\r\n    margin: string;\r\n    animationFillMode: string;\r\n    floodColor: string;\r\n    animationIterationCount: string;\r\n    textShadow: string;\r\n    backfaceVisibility: string;\r\n    msAnimationIterationCount: string;\r\n    animationDelay: string;\r\n    animationTimingFunction: string;\r\n    columnWidth: any;\r\n    msScrollSnapX: string;\r\n    columnRuleColor: any;\r\n    columnRuleWidth: any;\r\n    transitionDelay: string;\r\n    transition: string;\r\n    msFlowFrom: string;\r\n    msScrollSnapType: string;\r\n    msContentZoomSnapType: string;\r\n    msGridColumns: string;\r\n    msAnimationName: string;\r\n    msGridRowAlign: string;\r\n    msContentZoomChaining: string;\r\n    msGridColumn: any;\r\n    msHyphenateLimitZone: any;\r\n    msScrollRails: string;\r\n    msAnimationDelay: string;\r\n    enableBackground: string;\r\n    msWrapThrough: string;\r\n    columnRuleStyle: string;\r\n    msAnimation: string;\r\n    msFlexFlow: string;\r\n    msScrollSnapY: string;\r\n    msHyphenateLimitLines: any;\r\n    msTouchAction: string;\r\n    msScrollLimit: string;\r\n    animation: string;\r\n    transform: string;\r\n    filter: string;\r\n    colorInterpolationFilters: string;\r\n    transitionTimingFunction: string;\r\n    msBackfaceVisibility: string;\r\n    animationPlayState: string;\r\n    transformOrigin: string;\r\n    msScrollLimitYMin: any;\r\n    msFontFeatureSettings: string;\r\n    msContentZoomLimitMin: any;\r\n    columnGap: any;\r\n    transitionProperty: string;\r\n    msAnimationDuration: string;\r\n    msAnimationFillMode: string;\r\n    msFlexDirection: string;\r\n    msTransitionDuration: string;\r\n    fontFeatureSettings: string;\r\n    breakBefore: string;\r\n    msFlexWrap: string;\r\n    perspective: string;\r\n    msFlowInto: string;\r\n    msTransformStyle: string;\r\n    msScrollTranslation: string;\r\n    msTransitionProperty: string;\r\n    msUserSelect: string;\r\n    msOverflowStyle: string;\r\n    msScrollSnapPointsY: string;\r\n    animationDirection: string;\r\n    animationDuration: string;\r\n    msFlex: string;\r\n    msTransitionTimingFunction: string;\r\n    animationName: string;\r\n    columnRule: string;\r\n    msGridColumnSpan: any;\r\n    msFlexNegative: string;\r\n    columnFill: string;\r\n    msGridRow: any;\r\n    msFlexOrder: string;\r\n    msFlexItemAlign: string;\r\n    msFlexPositive: string;\r\n    msContentZoomLimitMax: any;\r\n    msScrollLimitYMax: any;\r\n    msGridColumnAlign: string;\r\n    perspectiveOrigin: string;\r\n    lightingColor: string;\r\n    columns: string;\r\n    msScrollChaining: string;\r\n    msHyphenateLimitChars: string;\r\n    msTouchSelect: string;\r\n    floodOpacity: string;\r\n    msAnimationDirection: string;\r\n    msAnimationPlayState: string;\r\n    columnSpan: string;\r\n    msContentZooming: string;\r\n    msPerspective: string;\r\n    msFlexPack: string;\r\n    msScrollSnapPointsX: string;\r\n    msContentZoomSnapPoints: string;\r\n    msGridRowSpan: any;\r\n    msContentZoomSnap: string;\r\n    msScrollLimitXMin: any;\r\n    breakInside: string;\r\n    msHighContrastAdjust: string;\r\n    msFlexLinePack: string;\r\n    msGridRows: string;\r\n    transitionDuration: string;\r\n    msHyphens: string;\r\n    breakAfter: string;\r\n    msTransition: string;\r\n    msPerspectiveOrigin: string;\r\n    msContentZoomLimit: string;\r\n    msScrollLimitXMax: any;\r\n    msFlexAlign: string;\r\n    msWrapMargin: any;\r\n    columnCount: any;\r\n    msAnimationTimingFunction: string;\r\n    msTransitionDelay: string;\r\n    transformStyle: string;\r\n    msWrapFlow: string;\r\n    msFlexPreferredSize: string;\r\n    alignItems: string;\r\n    borderImageSource: string;\r\n    flexBasis: string;\r\n    borderImageWidth: string;\r\n    borderImageRepeat: string;\r\n    order: string;\r\n    flex: string;\r\n    alignContent: string;\r\n    msImeAlign: string;\r\n    flexShrink: string;\r\n    flexGrow: string;\r\n    borderImageSlice: string;\r\n    flexWrap: string;\r\n    borderImageOutset: string;\r\n    flexDirection: string;\r\n    touchAction: string;\r\n    flexFlow: string;\r\n    borderImage: string;\r\n    justifyContent: string;\r\n    alignSelf: string;\r\n    msTextCombineHorizontal: string;\r\n    getPropertyPriority(propertyName: string): string;\r\n    getPropertyValue(propertyName: string): string;\r\n    removeProperty(propertyName: string): string;\r\n    item(index: number): string;\r\n    [index: number]: string;\r\n    setProperty(propertyName: string, value: string, priority?: string): void;\r\n}\r\ndeclare var CSSStyleDeclaration: {\r\n    prototype: CSSStyleDeclaration;\r\n    new(): CSSStyleDeclaration;\r\n}\r\n\r\ninterface SVGGElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n}\r\ndeclare var SVGGElement: {\r\n    prototype: SVGGElement;\r\n    new(): SVGGElement;\r\n}\r\n\r\ninterface MSStyleCSSProperties extends MSCSSProperties {\r\n    pixelWidth: number;\r\n    posHeight: number;\r\n    posLeft: number;\r\n    pixelTop: number;\r\n    pixelBottom: number;\r\n    textDecorationNone: boolean;\r\n    pixelLeft: number;\r\n    posTop: number;\r\n    posBottom: number;\r\n    textDecorationOverline: boolean;\r\n    posWidth: number;\r\n    textDecorationLineThrough: boolean;\r\n    pixelHeight: number;\r\n    textDecorationBlink: boolean;\r\n    posRight: number;\r\n    pixelRight: number;\r\n    textDecorationUnderline: boolean;\r\n}\r\ndeclare var MSStyleCSSProperties: {\r\n    prototype: MSStyleCSSProperties;\r\n    new(): MSStyleCSSProperties;\r\n}\r\n\r\ninterface Navigator extends NavigatorID, NavigatorOnLine, NavigatorContentUtils, MSNavigatorExtensions, NavigatorGeolocation, MSNavigatorDoNotTrack, NavigatorStorageUtils, MSFileSaver {\r\n    msMaxTouchPoints: number;\r\n    msPointerEnabled: boolean;\r\n    msManipulationViewsEnabled: boolean;\r\n    pointerEnabled: boolean;\r\n    maxTouchPoints: number;\r\n    msLaunchUri(uri: string, successCallback?: MSLaunchUriCallback, noHandlerCallback?: MSLaunchUriCallback): void;\r\n}\r\ndeclare var Navigator: {\r\n    prototype: Navigator;\r\n    new(): Navigator;\r\n}\r\n\r\ninterface SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg {\r\n    y: number;\r\n    x2: number;\r\n    x: number;\r\n    y2: number;\r\n}\r\ndeclare var SVGPathSegCurvetoCubicSmoothAbs: {\r\n    prototype: SVGPathSegCurvetoCubicSmoothAbs;\r\n    new(): SVGPathSegCurvetoCubicSmoothAbs;\r\n}\r\n\r\ninterface SVGZoomEvent extends UIEvent {\r\n    zoomRectScreen: SVGRect;\r\n    previousScale: number;\r\n    newScale: number;\r\n    previousTranslate: SVGPoint;\r\n    newTranslate: SVGPoint;\r\n}\r\ndeclare var SVGZoomEvent: {\r\n    prototype: SVGZoomEvent;\r\n    new(): SVGZoomEvent;\r\n}\r\n\r\ninterface NodeSelector {\r\n    querySelectorAll(selectors: string): NodeList;\r\n    querySelector(selectors: string): Element;\r\n}\r\n\r\ninterface HTMLTableDataCellElement extends HTMLTableCellElement {\r\n}\r\ndeclare var HTMLTableDataCellElement: {\r\n    prototype: HTMLTableDataCellElement;\r\n    new(): HTMLTableDataCellElement;\r\n}\r\n\r\ninterface HTMLBaseElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the window or frame at which to target content.\r\n      */\r\n    target: string;\r\n    /**\r\n      * Gets or sets the baseline URL on which relative links are based.\r\n      */\r\n    href: string;\r\n}\r\ndeclare var HTMLBaseElement: {\r\n    prototype: HTMLBaseElement;\r\n    new(): HTMLBaseElement;\r\n}\r\n\r\ninterface ClientRect {\r\n    left: number;\r\n    width: number;\r\n    right: number;\r\n    top: number;\r\n    bottom: number;\r\n    height: number;\r\n}\r\ndeclare var ClientRect: {\r\n    prototype: ClientRect;\r\n    new(): ClientRect;\r\n}\r\n\r\ninterface PositionErrorCallback {\r\n    (error: PositionError): void;\r\n}\r\n\r\ninterface DOMImplementation {\r\n    createDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType;\r\n    createDocument(namespaceURI: string, qualifiedName: string, doctype: DocumentType): Document;\r\n    hasFeature(feature: string, version?: string): boolean;\r\n    createHTMLDocument(title: string): Document;\r\n}\r\ndeclare var DOMImplementation: {\r\n    prototype: DOMImplementation;\r\n    new(): DOMImplementation;\r\n}\r\n\r\ninterface SVGUnitTypes {\r\n    SVG_UNIT_TYPE_UNKNOWN: number;\r\n    SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: number;\r\n    SVG_UNIT_TYPE_USERSPACEONUSE: number;\r\n}\r\ndeclare var SVGUnitTypes: SVGUnitTypes;\r\n\r\ninterface Element extends Node, NodeSelector, ElementTraversal, GlobalEventHandlers {\r\n    scrollTop: number;\r\n    clientLeft: number;\r\n    scrollLeft: number;\r\n    tagName: string;\r\n    clientWidth: number;\r\n    scrollWidth: number;\r\n    clientHeight: number;\r\n    clientTop: number;\r\n    scrollHeight: number;\r\n    msRegionOverflow: string;\r\n    onmspointerdown: (ev: any) => any;\r\n    onmsgotpointercapture: (ev: any) => any;\r\n    onmsgesturedoubletap: (ev: any) => any;\r\n    onmspointerhover: (ev: any) => any;\r\n    onmsgesturehold: (ev: any) => any;\r\n    onmspointermove: (ev: any) => any;\r\n    onmsgesturechange: (ev: any) => any;\r\n    onmsgesturestart: (ev: any) => any;\r\n    onmspointercancel: (ev: any) => any;\r\n    onmsgestureend: (ev: any) => any;\r\n    onmsgesturetap: (ev: any) => any;\r\n    onmspointerout: (ev: any) => any;\r\n    onmsinertiastart: (ev: any) => any;\r\n    onmslostpointercapture: (ev: any) => any;\r\n    onmspointerover: (ev: any) => any;\r\n    msContentZoomFactor: number;\r\n    onmspointerup: (ev: any) => any;\r\n    onlostpointercapture: (ev: PointerEvent) => any;\r\n    onmspointerenter: (ev: any) => any;\r\n    ongotpointercapture: (ev: PointerEvent) => any;\r\n    onmspointerleave: (ev: any) => any;\r\n    getAttribute(name?: string): string;\r\n    getElementsByTagNameNS(namespaceURI: string, localName: string): NodeList;\r\n    hasAttributeNS(namespaceURI: string, localName: string): boolean;\r\n    getBoundingClientRect(): ClientRect;\r\n    getAttributeNS(namespaceURI: string, localName: string): string;\r\n    getAttributeNodeNS(namespaceURI: string, localName: string): Attr;\r\n    setAttributeNodeNS(newAttr: Attr): Attr;\r\n    msMatchesSelector(selectors: string): boolean;\r\n    hasAttribute(name: string): boolean;\r\n    removeAttribute(name?: string): void;\r\n    setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;\r\n    getAttributeNode(name: string): Attr;\r\n    fireEvent(eventName: string, eventObj?: any): boolean;\r\n    getElementsByTagName(name: \"a\"): NodeListOf<HTMLAnchorElement>;\r\n    getElementsByTagName(name: \"abbr\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"acronym\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"address\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"applet\"): NodeListOf<HTMLAppletElement>;\r\n    getElementsByTagName(name: \"area\"): NodeListOf<HTMLAreaElement>;\r\n    getElementsByTagName(name: \"article\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"aside\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"audio\"): NodeListOf<HTMLAudioElement>;\r\n    getElementsByTagName(name: \"b\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"base\"): NodeListOf<HTMLBaseElement>;\r\n    getElementsByTagName(name: \"basefont\"): NodeListOf<HTMLBaseFontElement>;\r\n    getElementsByTagName(name: \"bdo\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"bgsound\"): NodeListOf<HTMLBGSoundElement>;\r\n    getElementsByTagName(name: \"big\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"blockquote\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"body\"): NodeListOf<HTMLBodyElement>;\r\n    getElementsByTagName(name: \"br\"): NodeListOf<HTMLBRElement>;\r\n    getElementsByTagName(name: \"button\"): NodeListOf<HTMLButtonElement>;\r\n    getElementsByTagName(name: \"canvas\"): NodeListOf<HTMLCanvasElement>;\r\n    getElementsByTagName(name: \"caption\"): NodeListOf<HTMLTableCaptionElement>;\r\n    getElementsByTagName(name: \"center\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"cite\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"code\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"col\"): NodeListOf<HTMLTableColElement>;\r\n    getElementsByTagName(name: \"colgroup\"): NodeListOf<HTMLTableColElement>;\r\n    getElementsByTagName(name: \"datalist\"): NodeListOf<HTMLDataListElement>;\r\n    getElementsByTagName(name: \"dd\"): NodeListOf<HTMLDDElement>;\r\n    getElementsByTagName(name: \"del\"): NodeListOf<HTMLModElement>;\r\n    getElementsByTagName(name: \"dfn\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"dir\"): NodeListOf<HTMLDirectoryElement>;\r\n    getElementsByTagName(name: \"div\"): NodeListOf<HTMLDivElement>;\r\n    getElementsByTagName(name: \"dl\"): NodeListOf<HTMLDListElement>;\r\n    getElementsByTagName(name: \"dt\"): NodeListOf<HTMLDTElement>;\r\n    getElementsByTagName(name: \"em\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"embed\"): NodeListOf<HTMLEmbedElement>;\r\n    getElementsByTagName(name: \"fieldset\"): NodeListOf<HTMLFieldSetElement>;\r\n    getElementsByTagName(name: \"figcaption\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"figure\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"font\"): NodeListOf<HTMLFontElement>;\r\n    getElementsByTagName(name: \"footer\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"form\"): NodeListOf<HTMLFormElement>;\r\n    getElementsByTagName(name: \"frame\"): NodeListOf<HTMLFrameElement>;\r\n    getElementsByTagName(name: \"frameset\"): NodeListOf<HTMLFrameSetElement>;\r\n    getElementsByTagName(name: \"h1\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h2\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h3\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h4\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h5\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"h6\"): NodeListOf<HTMLHeadingElement>;\r\n    getElementsByTagName(name: \"head\"): NodeListOf<HTMLHeadElement>;\r\n    getElementsByTagName(name: \"header\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"hgroup\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"hr\"): NodeListOf<HTMLHRElement>;\r\n    getElementsByTagName(name: \"html\"): NodeListOf<HTMLHtmlElement>;\r\n    getElementsByTagName(name: \"i\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"iframe\"): NodeListOf<HTMLIFrameElement>;\r\n    getElementsByTagName(name: \"img\"): NodeListOf<HTMLImageElement>;\r\n    getElementsByTagName(name: \"input\"): NodeListOf<HTMLInputElement>;\r\n    getElementsByTagName(name: \"ins\"): NodeListOf<HTMLModElement>;\r\n    getElementsByTagName(name: \"isindex\"): NodeListOf<HTMLIsIndexElement>;\r\n    getElementsByTagName(name: \"kbd\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"keygen\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"label\"): NodeListOf<HTMLLabelElement>;\r\n    getElementsByTagName(name: \"legend\"): NodeListOf<HTMLLegendElement>;\r\n    getElementsByTagName(name: \"li\"): NodeListOf<HTMLLIElement>;\r\n    getElementsByTagName(name: \"link\"): NodeListOf<HTMLLinkElement>;\r\n    getElementsByTagName(name: \"listing\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"map\"): NodeListOf<HTMLMapElement>;\r\n    getElementsByTagName(name: \"mark\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"marquee\"): NodeListOf<HTMLMarqueeElement>;\r\n    getElementsByTagName(name: \"menu\"): NodeListOf<HTMLMenuElement>;\r\n    getElementsByTagName(name: \"meta\"): NodeListOf<HTMLMetaElement>;\r\n    getElementsByTagName(name: \"nav\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"nextid\"): NodeListOf<HTMLNextIdElement>;\r\n    getElementsByTagName(name: \"nobr\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"noframes\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"noscript\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"object\"): NodeListOf<HTMLObjectElement>;\r\n    getElementsByTagName(name: \"ol\"): NodeListOf<HTMLOListElement>;\r\n    getElementsByTagName(name: \"optgroup\"): NodeListOf<HTMLOptGroupElement>;\r\n    getElementsByTagName(name: \"option\"): NodeListOf<HTMLOptionElement>;\r\n    getElementsByTagName(name: \"p\"): NodeListOf<HTMLParagraphElement>;\r\n    getElementsByTagName(name: \"param\"): NodeListOf<HTMLParamElement>;\r\n    getElementsByTagName(name: \"plaintext\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: \"pre\"): NodeListOf<HTMLPreElement>;\r\n    getElementsByTagName(name: \"progress\"): NodeListOf<HTMLProgressElement>;\r\n    getElementsByTagName(name: \"q\"): NodeListOf<HTMLQuoteElement>;\r\n    getElementsByTagName(name: \"rt\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"ruby\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"s\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"samp\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"script\"): NodeListOf<HTMLScriptElement>;\r\n    getElementsByTagName(name: \"section\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"select\"): NodeListOf<HTMLSelectElement>;\r\n    getElementsByTagName(name: \"small\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"SOURCE\"): NodeListOf<HTMLSourceElement>;\r\n    getElementsByTagName(name: \"span\"): NodeListOf<HTMLSpanElement>;\r\n    getElementsByTagName(name: \"strike\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"strong\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"style\"): NodeListOf<HTMLStyleElement>;\r\n    getElementsByTagName(name: \"sub\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"sup\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"table\"): NodeListOf<HTMLTableElement>;\r\n    getElementsByTagName(name: \"tbody\"): NodeListOf<HTMLTableSectionElement>;\r\n    getElementsByTagName(name: \"td\"): NodeListOf<HTMLTableDataCellElement>;\r\n    getElementsByTagName(name: \"textarea\"): NodeListOf<HTMLTextAreaElement>;\r\n    getElementsByTagName(name: \"tfoot\"): NodeListOf<HTMLTableSectionElement>;\r\n    getElementsByTagName(name: \"th\"): NodeListOf<HTMLTableHeaderCellElement>;\r\n    getElementsByTagName(name: \"thead\"): NodeListOf<HTMLTableSectionElement>;\r\n    getElementsByTagName(name: \"title\"): NodeListOf<HTMLTitleElement>;\r\n    getElementsByTagName(name: \"tr\"): NodeListOf<HTMLTableRowElement>;\r\n    getElementsByTagName(name: \"track\"): NodeListOf<HTMLTrackElement>;\r\n    getElementsByTagName(name: \"tt\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"u\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"ul\"): NodeListOf<HTMLUListElement>;\r\n    getElementsByTagName(name: \"var\"): NodeListOf<HTMLPhraseElement>;\r\n    getElementsByTagName(name: \"video\"): NodeListOf<HTMLVideoElement>;\r\n    getElementsByTagName(name: \"wbr\"): NodeListOf<HTMLElement>;\r\n    getElementsByTagName(name: \"x-ms-webview\"): NodeListOf<MSHTMLWebViewElement>;\r\n    getElementsByTagName(name: \"xmp\"): NodeListOf<HTMLBlockElement>;\r\n    getElementsByTagName(name: string): NodeList;\r\n    getClientRects(): ClientRectList;\r\n    setAttributeNode(newAttr: Attr): Attr;\r\n    removeAttributeNode(oldAttr: Attr): Attr;\r\n    setAttribute(name?: string, value?: string): void;\r\n    removeAttributeNS(namespaceURI: string, localName: string): void;\r\n    msGetRegionContent(): MSRangeCollection;\r\n    msReleasePointerCapture(pointerId: number): void;\r\n    msSetPointerCapture(pointerId: number): void;\r\n    msZoomTo(args: MsZoomToOptions): void;\r\n    setPointerCapture(pointerId: number): void;\r\n    msGetUntransformedBounds(): ClientRect;\r\n    releasePointerCapture(pointerId: number): void;\r\n    msRequestFullscreen(): void;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var Element: {\r\n    prototype: Element;\r\n    new(): Element;\r\n}\r\n\r\ninterface HTMLNextIdElement extends HTMLElement {\r\n    n: string;\r\n}\r\ndeclare var HTMLNextIdElement: {\r\n    prototype: HTMLNextIdElement;\r\n    new(): HTMLNextIdElement;\r\n}\r\n\r\ninterface SVGPathSegMovetoRel extends SVGPathSeg {\r\n    y: number;\r\n    x: number;\r\n}\r\ndeclare var SVGPathSegMovetoRel: {\r\n    prototype: SVGPathSegMovetoRel;\r\n    new(): SVGPathSegMovetoRel;\r\n}\r\n\r\ninterface SVGLineElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n    y1: SVGAnimatedLength;\r\n    x2: SVGAnimatedLength;\r\n    x1: SVGAnimatedLength;\r\n    y2: SVGAnimatedLength;\r\n}\r\ndeclare var SVGLineElement: {\r\n    prototype: SVGLineElement;\r\n    new(): SVGLineElement;\r\n}\r\n\r\ninterface HTMLParagraphElement extends HTMLElement, DOML2DeprecatedTextFlowControl {\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text. \r\n      */\r\n    align: string;\r\n}\r\ndeclare var HTMLParagraphElement: {\r\n    prototype: HTMLParagraphElement;\r\n    new(): HTMLParagraphElement;\r\n}\r\n\r\ninterface HTMLAreasCollection extends HTMLCollection {\r\n    /**\r\n      * Removes an element from the collection.\r\n      */\r\n    remove(index?: number): void;\r\n    /**\r\n      * Adds an element to the areas, controlRange, or options collection.\r\n      */\r\n    add(element: HTMLElement, before?: any): void;\r\n}\r\ndeclare var HTMLAreasCollection: {\r\n    prototype: HTMLAreasCollection;\r\n    new(): HTMLAreasCollection;\r\n}\r\n\r\ninterface SVGDescElement extends SVGElement, SVGStylable, SVGLangSpace {\r\n}\r\ndeclare var SVGDescElement: {\r\n    prototype: SVGDescElement;\r\n    new(): SVGDescElement;\r\n}\r\n\r\ninterface Node extends EventTarget {\r\n    nodeType: number;\r\n    previousSibling: Node;\r\n    localName: string;\r\n    namespaceURI: string;\r\n    textContent: string;\r\n    parentNode: Node;\r\n    nextSibling: Node;\r\n    nodeValue: string;\r\n    lastChild: Node;\r\n    childNodes: NodeList;\r\n    nodeName: string;\r\n    ownerDocument: Document;\r\n    attributes: NamedNodeMap;\r\n    firstChild: Node;\r\n    prefix: string;\r\n    removeChild(oldChild: Node): Node;\r\n    appendChild(newChild: Node): Node;\r\n    isSupported(feature: string, version: string): boolean;\r\n    isEqualNode(arg: Node): boolean;\r\n    lookupPrefix(namespaceURI: string): string;\r\n    isDefaultNamespace(namespaceURI: string): boolean;\r\n    compareDocumentPosition(other: Node): number;\r\n    normalize(): void;\r\n    isSameNode(other: Node): boolean;\r\n    hasAttributes(): boolean;\r\n    lookupNamespaceURI(prefix: string): string;\r\n    cloneNode(deep?: boolean): Node;\r\n    hasChildNodes(): boolean;\r\n    replaceChild(newChild: Node, oldChild: Node): Node;\r\n    insertBefore(newChild: Node, refChild?: Node): Node;\r\n    ENTITY_REFERENCE_NODE: number;\r\n    ATTRIBUTE_NODE: number;\r\n    DOCUMENT_FRAGMENT_NODE: number;\r\n    TEXT_NODE: number;\r\n    ELEMENT_NODE: number;\r\n    COMMENT_NODE: number;\r\n    DOCUMENT_POSITION_DISCONNECTED: number;\r\n    DOCUMENT_POSITION_CONTAINED_BY: number;\r\n    DOCUMENT_POSITION_CONTAINS: number;\r\n    DOCUMENT_TYPE_NODE: number;\r\n    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;\r\n    DOCUMENT_NODE: number;\r\n    ENTITY_NODE: number;\r\n    PROCESSING_INSTRUCTION_NODE: number;\r\n    CDATA_SECTION_NODE: number;\r\n    NOTATION_NODE: number;\r\n    DOCUMENT_POSITION_FOLLOWING: number;\r\n    DOCUMENT_POSITION_PRECEDING: number;\r\n}\r\ndeclare var Node: {\r\n    prototype: Node;\r\n    new(): Node;\r\n    ENTITY_REFERENCE_NODE: number;\r\n    ATTRIBUTE_NODE: number;\r\n    DOCUMENT_FRAGMENT_NODE: number;\r\n    TEXT_NODE: number;\r\n    ELEMENT_NODE: number;\r\n    COMMENT_NODE: number;\r\n    DOCUMENT_POSITION_DISCONNECTED: number;\r\n    DOCUMENT_POSITION_CONTAINED_BY: number;\r\n    DOCUMENT_POSITION_CONTAINS: number;\r\n    DOCUMENT_TYPE_NODE: number;\r\n    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;\r\n    DOCUMENT_NODE: number;\r\n    ENTITY_NODE: number;\r\n    PROCESSING_INSTRUCTION_NODE: number;\r\n    CDATA_SECTION_NODE: number;\r\n    NOTATION_NODE: number;\r\n    DOCUMENT_POSITION_FOLLOWING: number;\r\n    DOCUMENT_POSITION_PRECEDING: number;\r\n}\r\n\r\ninterface SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg {\r\n    y: number;\r\n    x: number;\r\n}\r\ndeclare var SVGPathSegCurvetoQuadraticSmoothRel: {\r\n    prototype: SVGPathSegCurvetoQuadraticSmoothRel;\r\n    new(): SVGPathSegCurvetoQuadraticSmoothRel;\r\n}\r\n\r\ninterface DOML2DeprecatedListSpaceReduction {\r\n    compact: boolean;\r\n}\r\n\r\ninterface MSScriptHost {\r\n}\r\ndeclare var MSScriptHost: {\r\n    prototype: MSScriptHost;\r\n    new(): MSScriptHost;\r\n}\r\n\r\ninterface SVGClipPathElement extends SVGElement, SVGUnitTypes, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n    clipPathUnits: SVGAnimatedEnumeration;\r\n}\r\ndeclare var SVGClipPathElement: {\r\n    prototype: SVGClipPathElement;\r\n    new(): SVGClipPathElement;\r\n}\r\n\r\ninterface MouseEvent extends UIEvent {\r\n    toElement: Element;\r\n    layerY: number;\r\n    fromElement: Element;\r\n    which: number;\r\n    pageX: number;\r\n    offsetY: number;\r\n    x: number;\r\n    y: number;\r\n    metaKey: boolean;\r\n    altKey: boolean;\r\n    ctrlKey: boolean;\r\n    offsetX: number;\r\n    screenX: number;\r\n    clientY: number;\r\n    shiftKey: boolean;\r\n    layerX: number;\r\n    screenY: number;\r\n    relatedTarget: EventTarget;\r\n    button: number;\r\n    pageY: number;\r\n    buttons: number;\r\n    clientX: number;\r\n    initMouseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget): void;\r\n    getModifierState(keyArg: string): boolean;\r\n}\r\ndeclare var MouseEvent: {\r\n    prototype: MouseEvent;\r\n    new(): MouseEvent;\r\n}\r\n\r\ninterface RangeException {\r\n    code: number;\r\n    message: string;\r\n    name: string;\r\n    toString(): string;\r\n    INVALID_NODE_TYPE_ERR: number;\r\n    BAD_BOUNDARYPOINTS_ERR: number;\r\n}\r\ndeclare var RangeException: {\r\n    prototype: RangeException;\r\n    new(): RangeException;\r\n    INVALID_NODE_TYPE_ERR: number;\r\n    BAD_BOUNDARYPOINTS_ERR: number;\r\n}\r\n\r\ninterface SVGTextPositioningElement extends SVGTextContentElement {\r\n    y: SVGAnimatedLengthList;\r\n    rotate: SVGAnimatedNumberList;\r\n    dy: SVGAnimatedLengthList;\r\n    x: SVGAnimatedLengthList;\r\n    dx: SVGAnimatedLengthList;\r\n}\r\ndeclare var SVGTextPositioningElement: {\r\n    prototype: SVGTextPositioningElement;\r\n    new(): SVGTextPositioningElement;\r\n}\r\n\r\ninterface HTMLAppletElement extends HTMLElement, DOML2DeprecatedMarginStyle, DOML2DeprecatedBorderStyle, DOML2DeprecatedAlignmentStyle, MSDataBindingExtensions, MSDataBindingRecordSetExtensions {\r\n    width: number;\r\n    /**\r\n      * Sets or retrieves the Internet media type for the code associated with the object.\r\n      */\r\n    codeType: string;\r\n    object: string;\r\n    form: HTMLFormElement;\r\n    code: string;\r\n    /**\r\n      * Sets or retrieves a character string that can be used to implement your own archive functionality for the object.\r\n      */\r\n    archive: string;\r\n    /**\r\n      * Sets or retrieves a text alternative to the graphic.\r\n      */\r\n    alt: string;\r\n    /**\r\n      * Sets or retrieves a message to be displayed while an object is loading.\r\n      */\r\n    standby: string;\r\n    /**\r\n      * Sets or retrieves the class identifier for the object.\r\n      */\r\n    classid: string;\r\n    /**\r\n      * Sets or retrieves the shape of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\r\n      */\r\n    useMap: string;\r\n    /**\r\n      * Sets or retrieves the URL that references the data of the object.\r\n      */\r\n    data: string;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: string;\r\n    /**\r\n      * Gets or sets the optional alternative HTML script to execute if the object fails to load.\r\n      */\r\n    altHtml: string;\r\n    /**\r\n      * Address of a pointer to the document this page or frame contains. If there is no document, then null will be returned.\r\n      */\r\n    contentDocument: Document;\r\n    /**\r\n      * Sets or retrieves the URL of the component.\r\n      */\r\n    codeBase: string;\r\n    /**\r\n      * Sets or retrieves a character string that can be used to implement your own declare functionality for the object.\r\n      */\r\n    declare: boolean;\r\n    /**\r\n      * Returns the content type of the object.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Retrieves a string of the URL where the object tag can be found. This is often the href of the document that the object is in, or the value set by a base element.\r\n      */\r\n    BaseHref: string;\r\n}\r\ndeclare var HTMLAppletElement: {\r\n    prototype: HTMLAppletElement;\r\n    new(): HTMLAppletElement;\r\n}\r\n\r\ninterface TextMetrics {\r\n    width: number;\r\n}\r\ndeclare var TextMetrics: {\r\n    prototype: TextMetrics;\r\n    new(): TextMetrics;\r\n}\r\n\r\ninterface DocumentEvent {\r\n    createEvent(eventInterface: \"AnimationEvent\"): AnimationEvent;\r\n    createEvent(eventInterface: \"CloseEvent\"): CloseEvent;\r\n    createEvent(eventInterface: \"CompositionEvent\"): CompositionEvent;\r\n    createEvent(eventInterface: \"CustomEvent\"): CustomEvent;\r\n    createEvent(eventInterface: \"DeviceMotionEvent\"): DeviceMotionEvent;\r\n    createEvent(eventInterface: \"DeviceOrientationEvent\"): DeviceOrientationEvent;\r\n    createEvent(eventInterface: \"DragEvent\"): DragEvent;\r\n    createEvent(eventInterface: \"ErrorEvent\"): ErrorEvent;\r\n    createEvent(eventInterface: \"Event\"): Event;\r\n    createEvent(eventInterface: \"Events\"): Event;\r\n    createEvent(eventInterface: \"FocusEvent\"): FocusEvent;\r\n    createEvent(eventInterface: \"HTMLEvents\"): Event;\r\n    createEvent(eventInterface: \"IDBVersionChangeEvent\"): IDBVersionChangeEvent;\r\n    createEvent(eventInterface: \"KeyboardEvent\"): KeyboardEvent;\r\n    createEvent(eventInterface: \"LongRunningScriptDetectedEvent\"): LongRunningScriptDetectedEvent;\r\n    createEvent(eventInterface: \"MessageEvent\"): MessageEvent;\r\n    createEvent(eventInterface: \"MouseEvent\"): MouseEvent;\r\n    createEvent(eventInterface: \"MouseEvents\"): MouseEvent;\r\n    createEvent(eventInterface: \"MouseWheelEvent\"): MouseWheelEvent;\r\n    createEvent(eventInterface: \"MSGestureEvent\"): MSGestureEvent;\r\n    createEvent(eventInterface: \"MSPointerEvent\"): MSPointerEvent;\r\n    createEvent(eventInterface: \"MutationEvent\"): MutationEvent;\r\n    createEvent(eventInterface: \"MutationEvents\"): MutationEvent;\r\n    createEvent(eventInterface: \"NavigationCompletedEvent\"): NavigationCompletedEvent;\r\n    createEvent(eventInterface: \"NavigationEvent\"): NavigationEvent;\r\n    createEvent(eventInterface: \"PageTransitionEvent\"): PageTransitionEvent;\r\n    createEvent(eventInterface: \"PointerEvent\"): MSPointerEvent;\r\n    createEvent(eventInterface: \"PopStateEvent\"): PopStateEvent;\r\n    createEvent(eventInterface: \"ProgressEvent\"): ProgressEvent;\r\n    createEvent(eventInterface: \"StorageEvent\"): StorageEvent;\r\n    createEvent(eventInterface: \"SVGZoomEvents\"): SVGZoomEvent;\r\n    createEvent(eventInterface: \"TextEvent\"): TextEvent;\r\n    createEvent(eventInterface: \"TrackEvent\"): TrackEvent;\r\n    createEvent(eventInterface: \"TransitionEvent\"): TransitionEvent;\r\n    createEvent(eventInterface: \"UIEvent\"): UIEvent;\r\n    createEvent(eventInterface: \"UIEvents\"): UIEvent;\r\n    createEvent(eventInterface: \"UnviewableContentIdentifiedEvent\"): UnviewableContentIdentifiedEvent;\r\n    createEvent(eventInterface: \"WebGLContextEvent\"): WebGLContextEvent;\r\n    createEvent(eventInterface: \"WheelEvent\"): WheelEvent;\r\n    createEvent(eventInterface: string): Event;\r\n}\r\n\r\ninterface HTMLOListElement extends HTMLElement, DOML2DeprecatedListSpaceReduction, DOML2DeprecatedListNumberingAndBulletStyle {\r\n    /**\r\n      * The starting number.\r\n      */\r\n    start: number;\r\n}\r\ndeclare var HTMLOListElement: {\r\n    prototype: HTMLOListElement;\r\n    new(): HTMLOListElement;\r\n}\r\n\r\ninterface SVGPathSegLinetoVerticalRel extends SVGPathSeg {\r\n    y: number;\r\n}\r\ndeclare var SVGPathSegLinetoVerticalRel: {\r\n    prototype: SVGPathSegLinetoVerticalRel;\r\n    new(): SVGPathSegLinetoVerticalRel;\r\n}\r\n\r\ninterface SVGAnimatedString {\r\n    animVal: string;\r\n    baseVal: string;\r\n}\r\ndeclare var SVGAnimatedString: {\r\n    prototype: SVGAnimatedString;\r\n    new(): SVGAnimatedString;\r\n}\r\n\r\ninterface CDATASection extends Text {\r\n}\r\ndeclare var CDATASection: {\r\n    prototype: CDATASection;\r\n    new(): CDATASection;\r\n}\r\n\r\ninterface StyleMedia {\r\n    type: string;\r\n    matchMedium(mediaquery: string): boolean;\r\n}\r\ndeclare var StyleMedia: {\r\n    prototype: StyleMedia;\r\n    new(): StyleMedia;\r\n}\r\n\r\ninterface HTMLSelectElement extends HTMLElement, MSHTMLCollectionExtensions, MSDataBindingExtensions {\r\n    options: HTMLSelectElement;\r\n    /**\r\n      * Sets or retrieves the value which is returned to the server when the form control is submitted.\r\n      */\r\n    value: string;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in. \r\n      */\r\n    form: HTMLFormElement;\r\n    /**\r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the number of rows in the list box. \r\n      */\r\n    size: number;\r\n    /**\r\n      * Sets or retrieves the number of objects in a collection.\r\n      */\r\n    length: number;\r\n    /**\r\n      * Sets or retrieves the index of the selected option in a select object.\r\n      */\r\n    selectedIndex: number;\r\n    /**\r\n      * Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list.\r\n      */\r\n    multiple: boolean;\r\n    /**\r\n      * Retrieves the type of select control based on the value of the MULTIPLE attribute.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\r\n      */\r\n    validationMessage: string;\r\n    /**\r\n      * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\r\n      */\r\n    autofocus: boolean;\r\n    /**\r\n      * Returns a  ValidityState object that represents the validity states of an element.\r\n      */\r\n    validity: ValidityState;\r\n    /**\r\n      * When present, marks an element that can't be submitted without a value.\r\n      */\r\n    required: boolean;\r\n    /**\r\n      * Returns whether an element will successfully validate based on forms validation rules and constraints.\r\n      */\r\n    willValidate: boolean;\r\n    /**\r\n      * Removes an element from the collection.\r\n      * @param index Number that specifies the zero-based index of the element to remove from the collection.\r\n      */\r\n    remove(index?: number): void;\r\n    /**\r\n      * Adds an element to the areas, controlRange, or options collection.\r\n      * @param element Variant of type Number that specifies the index position in the collection where the element is placed. If no value is given, the method places the element at the end of the collection.\r\n      * @param before Variant of type Object that specifies an element to insert before, or null to append the object to the collection. \r\n      */\r\n    add(element: HTMLElement, before?: any): void;\r\n    /**\r\n      * Retrieves a select object or an object from an options collection.\r\n      * @param name Variant of type Number or String that specifies the object or collection to retrieve. If this parameter is an integer, it is the zero-based index of the object. If this parameter is a string, all objects with matching name or id properties are retrieved, and a collection is returned if more than one match is made.\r\n      * @param index Variant of type Number that specifies the zero-based index of the object to retrieve when a collection is returned.\r\n      */\r\n    item(name?: any, index?: any): any;\r\n    /**\r\n      * Retrieves a select object or an object from an options collection.\r\n      * @param namedItem A String that specifies the name or id property of the object to retrieve. A collection is returned if more than one match is made.\r\n      */\r\n    namedItem(name: string): any;\r\n    [name: string]: any;\r\n    /**\r\n      * Returns whether a form will validate when it is submitted, without having to submit it.\r\n      */\r\n    checkValidity(): boolean;\r\n    /**\r\n      * Sets a custom error message that is displayed when a form is submitted.\r\n      * @param error Sets a custom error message that is displayed when a form is submitted.\r\n      */\r\n    setCustomValidity(error: string): void;\r\n}\r\ndeclare var HTMLSelectElement: {\r\n    prototype: HTMLSelectElement;\r\n    new(): HTMLSelectElement;\r\n}\r\n\r\ninterface TextRange {\r\n    boundingLeft: number;\r\n    htmlText: string;\r\n    offsetLeft: number;\r\n    boundingWidth: number;\r\n    boundingHeight: number;\r\n    boundingTop: number;\r\n    text: string;\r\n    offsetTop: number;\r\n    moveToPoint(x: number, y: number): void;\r\n    queryCommandValue(cmdID: string): any;\r\n    getBookmark(): string;\r\n    move(unit: string, count?: number): number;\r\n    queryCommandIndeterm(cmdID: string): boolean;\r\n    scrollIntoView(fStart?: boolean): void;\r\n    findText(string: string, count?: number, flags?: number): boolean;\r\n    execCommand(cmdID: string, showUI?: boolean, value?: any): boolean;\r\n    getBoundingClientRect(): ClientRect;\r\n    moveToBookmark(bookmark: string): boolean;\r\n    isEqual(range: TextRange): boolean;\r\n    duplicate(): TextRange;\r\n    collapse(start?: boolean): void;\r\n    queryCommandText(cmdID: string): string;\r\n    select(): void;\r\n    pasteHTML(html: string): void;\r\n    inRange(range: TextRange): boolean;\r\n    moveEnd(unit: string, count?: number): number;\r\n    getClientRects(): ClientRectList;\r\n    moveStart(unit: string, count?: number): number;\r\n    parentElement(): Element;\r\n    queryCommandState(cmdID: string): boolean;\r\n    compareEndPoints(how: string, sourceRange: TextRange): number;\r\n    execCommandShowHelp(cmdID: string): boolean;\r\n    moveToElementText(element: Element): void;\r\n    expand(Unit: string): boolean;\r\n    queryCommandSupported(cmdID: string): boolean;\r\n    setEndPoint(how: string, SourceRange: TextRange): void;\r\n    queryCommandEnabled(cmdID: string): boolean;\r\n}\r\ndeclare var TextRange: {\r\n    prototype: TextRange;\r\n    new(): TextRange;\r\n}\r\n\r\ninterface SVGTests {\r\n    requiredFeatures: SVGStringList;\r\n    requiredExtensions: SVGStringList;\r\n    systemLanguage: SVGStringList;\r\n    hasExtension(extension: string): boolean;\r\n}\r\n\r\ninterface HTMLBlockElement extends HTMLElement, DOML2DeprecatedTextFlowControl {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: number;\r\n    /**\r\n      * Sets or retrieves reference information about the object.\r\n      */\r\n    cite: string;\r\n}\r\ndeclare var HTMLBlockElement: {\r\n    prototype: HTMLBlockElement;\r\n    new(): HTMLBlockElement;\r\n}\r\n\r\ninterface CSSStyleSheet extends StyleSheet {\r\n    owningElement: Element;\r\n    imports: StyleSheetList;\r\n    isAlternate: boolean;\r\n    rules: MSCSSRuleList;\r\n    isPrefAlternate: boolean;\r\n    readOnly: boolean;\r\n    cssText: string;\r\n    ownerRule: CSSRule;\r\n    href: string;\r\n    cssRules: CSSRuleList;\r\n    id: string;\r\n    pages: StyleSheetPageList;\r\n    addImport(bstrURL: string, lIndex?: number): number;\r\n    addPageRule(bstrSelector: string, bstrStyle: string, lIndex?: number): number;\r\n    insertRule(rule: string, index?: number): number;\r\n    removeRule(lIndex: number): void;\r\n    deleteRule(index?: number): void;\r\n    addRule(bstrSelector: string, bstrStyle?: string, lIndex?: number): number;\r\n    removeImport(lIndex: number): void;\r\n}\r\ndeclare var CSSStyleSheet: {\r\n    prototype: CSSStyleSheet;\r\n    new(): CSSStyleSheet;\r\n}\r\n\r\ninterface MSSelection {\r\n    type: string;\r\n    typeDetail: string;\r\n    createRange(): TextRange;\r\n    clear(): void;\r\n    createRangeCollection(): TextRangeCollection;\r\n    empty(): void;\r\n}\r\ndeclare var MSSelection: {\r\n    prototype: MSSelection;\r\n    new(): MSSelection;\r\n}\r\n\r\ninterface HTMLMetaElement extends HTMLElement {\r\n    /**\r\n      * Gets or sets information used to bind the value of a content attribute of a meta element to an HTTP response header.\r\n      */\r\n    httpEquiv: string;\r\n    /**\r\n      * Sets or retrieves the value specified in the content attribute of the meta object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Gets or sets meta-information to associate with httpEquiv or name.\r\n      */\r\n    content: string;\r\n    /**\r\n      * Sets or retrieves the URL property that will be loaded after the specified time has elapsed. \r\n      */\r\n    url: string;\r\n    /**\r\n      * Sets or retrieves a scheme to be used in interpreting the value of a property specified for the object.\r\n      */\r\n    scheme: string;\r\n    /**\r\n      * Sets or retrieves the character set used to encode the object.\r\n      */\r\n    charset: string;\r\n}\r\ndeclare var HTMLMetaElement: {\r\n    prototype: HTMLMetaElement;\r\n    new(): HTMLMetaElement;\r\n}\r\n\r\ninterface SVGPatternElement extends SVGElement, SVGUnitTypes, SVGStylable, SVGLangSpace, SVGTests, SVGFitToViewBox, SVGExternalResourcesRequired, SVGURIReference {\r\n    patternUnits: SVGAnimatedEnumeration;\r\n    y: SVGAnimatedLength;\r\n    width: SVGAnimatedLength;\r\n    x: SVGAnimatedLength;\r\n    patternContentUnits: SVGAnimatedEnumeration;\r\n    patternTransform: SVGAnimatedTransformList;\r\n    height: SVGAnimatedLength;\r\n}\r\ndeclare var SVGPatternElement: {\r\n    prototype: SVGPatternElement;\r\n    new(): SVGPatternElement;\r\n}\r\n\r\ninterface SVGAnimatedAngle {\r\n    animVal: SVGAngle;\r\n    baseVal: SVGAngle;\r\n}\r\ndeclare var SVGAnimatedAngle: {\r\n    prototype: SVGAnimatedAngle;\r\n    new(): SVGAnimatedAngle;\r\n}\r\n\r\ninterface Selection {\r\n    isCollapsed: boolean;\r\n    anchorNode: Node;\r\n    focusNode: Node;\r\n    anchorOffset: number;\r\n    focusOffset: number;\r\n    rangeCount: number;\r\n    addRange(range: Range): void;\r\n    collapseToEnd(): void;\r\n    toString(): string;\r\n    selectAllChildren(parentNode: Node): void;\r\n    getRangeAt(index: number): Range;\r\n    collapse(parentNode: Node, offset: number): void;\r\n    removeAllRanges(): void;\r\n    collapseToStart(): void;\r\n    deleteFromDocument(): void;\r\n    removeRange(range: Range): void;\r\n}\r\ndeclare var Selection: {\r\n    prototype: Selection;\r\n    new(): Selection;\r\n}\r\n\r\ninterface SVGScriptElement extends SVGElement, SVGExternalResourcesRequired, SVGURIReference {\r\n    type: string;\r\n}\r\ndeclare var SVGScriptElement: {\r\n    prototype: SVGScriptElement;\r\n    new(): SVGScriptElement;\r\n}\r\n\r\ninterface HTMLDDElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves whether the browser automatically performs wordwrap.\r\n      */\r\n    noWrap: boolean;\r\n}\r\ndeclare var HTMLDDElement: {\r\n    prototype: HTMLDDElement;\r\n    new(): HTMLDDElement;\r\n}\r\n\r\ninterface MSDataBindingRecordSetReadonlyExtensions {\r\n    recordset: any;\r\n    namedRecordset(dataMember: string, hierarchy?: any): any;\r\n}\r\n\r\ninterface CSSStyleRule extends CSSRule {\r\n    selectorText: string;\r\n    style: MSStyleCSSProperties;\r\n    readOnly: boolean;\r\n}\r\ndeclare var CSSStyleRule: {\r\n    prototype: CSSStyleRule;\r\n    new(): CSSStyleRule;\r\n}\r\n\r\ninterface NodeIterator {\r\n    whatToShow: number;\r\n    filter: NodeFilter;\r\n    root: Node;\r\n    expandEntityReferences: boolean;\r\n    nextNode(): Node;\r\n    detach(): void;\r\n    previousNode(): Node;\r\n}\r\ndeclare var NodeIterator: {\r\n    prototype: NodeIterator;\r\n    new(): NodeIterator;\r\n}\r\n\r\ninterface SVGViewElement extends SVGElement, SVGZoomAndPan, SVGFitToViewBox, SVGExternalResourcesRequired {\r\n    viewTarget: SVGStringList;\r\n}\r\ndeclare var SVGViewElement: {\r\n    prototype: SVGViewElement;\r\n    new(): SVGViewElement;\r\n}\r\n\r\ninterface HTMLLinkElement extends HTMLElement, LinkStyle {\r\n    /**\r\n      * Sets or retrieves the relationship between the object and the destination of the link.\r\n      */\r\n    rel: string;\r\n    /**\r\n      * Sets or retrieves the window or frame at which to target content.\r\n      */\r\n    target: string;\r\n    /**\r\n      * Sets or retrieves a destination URL or an anchor point.\r\n      */\r\n    href: string;\r\n    /**\r\n      * Sets or retrieves the media type.\r\n      */\r\n    media: string;\r\n    /**\r\n      * Sets or retrieves the relationship between the object and the destination of the link.\r\n      */\r\n    rev: string;\r\n    /**\r\n      * Sets or retrieves the MIME type of the object.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Sets or retrieves the character set used to encode the object.\r\n      */\r\n    charset: string;\r\n    /**\r\n      * Sets or retrieves the language code of the object.\r\n      */\r\n    hreflang: string;\r\n}\r\ndeclare var HTMLLinkElement: {\r\n    prototype: HTMLLinkElement;\r\n    new(): HTMLLinkElement;\r\n}\r\n\r\ninterface SVGLocatable {\r\n    farthestViewportElement: SVGElement;\r\n    nearestViewportElement: SVGElement;\r\n    getBBox(): SVGRect;\r\n    getTransformToElement(element: SVGElement): SVGMatrix;\r\n    getCTM(): SVGMatrix;\r\n    getScreenCTM(): SVGMatrix;\r\n}\r\n\r\ninterface HTMLFontElement extends HTMLElement, DOML2DeprecatedColorProperty, DOML2DeprecatedSizeProperty {\r\n    /**\r\n      * Sets or retrieves the current typeface family.\r\n      */\r\n    face: string;\r\n}\r\ndeclare var HTMLFontElement: {\r\n    prototype: HTMLFontElement;\r\n    new(): HTMLFontElement;\r\n}\r\n\r\ninterface SVGTitleElement extends SVGElement, SVGStylable, SVGLangSpace {\r\n}\r\ndeclare var SVGTitleElement: {\r\n    prototype: SVGTitleElement;\r\n    new(): SVGTitleElement;\r\n}\r\n\r\ninterface ControlRangeCollection {\r\n    length: number;\r\n    queryCommandValue(cmdID: string): any;\r\n    remove(index: number): void;\r\n    add(item: Element): void;\r\n    queryCommandIndeterm(cmdID: string): boolean;\r\n    scrollIntoView(varargStart?: any): void;\r\n    item(index: number): Element;\r\n    [index: number]: Element;\r\n    execCommand(cmdID: string, showUI?: boolean, value?: any): boolean;\r\n    addElement(item: Element): void;\r\n    queryCommandState(cmdID: string): boolean;\r\n    queryCommandSupported(cmdID: string): boolean;\r\n    queryCommandEnabled(cmdID: string): boolean;\r\n    queryCommandText(cmdID: string): string;\r\n    select(): void;\r\n}\r\ndeclare var ControlRangeCollection: {\r\n    prototype: ControlRangeCollection;\r\n    new(): ControlRangeCollection;\r\n}\r\n\r\ninterface MSNamespaceInfo extends MSEventAttachmentTarget {\r\n    urn: string;\r\n    onreadystatechange: (ev: Event) => any;\r\n    name: string;\r\n    readyState: string;\r\n    doImport(implementationUrl: string): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var MSNamespaceInfo: {\r\n    prototype: MSNamespaceInfo;\r\n    new(): MSNamespaceInfo;\r\n}\r\n\r\ninterface WindowSessionStorage {\r\n    sessionStorage: Storage;\r\n}\r\n\r\ninterface SVGAnimatedTransformList {\r\n    animVal: SVGTransformList;\r\n    baseVal: SVGTransformList;\r\n}\r\ndeclare var SVGAnimatedTransformList: {\r\n    prototype: SVGAnimatedTransformList;\r\n    new(): SVGAnimatedTransformList;\r\n}\r\n\r\ninterface HTMLTableCaptionElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the alignment of the caption or legend.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Sets or retrieves whether the caption appears at the top or bottom of the table.\r\n      */\r\n    vAlign: string;\r\n}\r\ndeclare var HTMLTableCaptionElement: {\r\n    prototype: HTMLTableCaptionElement;\r\n    new(): HTMLTableCaptionElement;\r\n}\r\n\r\ninterface HTMLOptionElement extends HTMLElement, MSDataBindingExtensions {\r\n    /**\r\n      * Sets or retrieves the ordinal position of an option in a list box.\r\n      */\r\n    index: number;\r\n    /**\r\n      * Sets or retrieves the status of an option.\r\n      */\r\n    defaultSelected: boolean;\r\n    /**\r\n      * Sets or retrieves the value which is returned to the server when the form control is submitted.\r\n      */\r\n    value: string;\r\n    /**\r\n      * Sets or retrieves the text string specified by the option tag.\r\n      */\r\n    text: string;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n    /**\r\n      * Sets or retrieves a value that you can use to implement your own label functionality for the object.\r\n      */\r\n    label: string;\r\n    /**\r\n      * Sets or retrieves whether the option in the list box is the default item.\r\n      */\r\n    selected: boolean;\r\n}\r\ndeclare var HTMLOptionElement: {\r\n    prototype: HTMLOptionElement;\r\n    new(): HTMLOptionElement;\r\n    create(): HTMLOptionElement;\r\n}\r\n\r\ninterface HTMLMapElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Retrieves a collection of the area objects defined for the given map object.\r\n      */\r\n    areas: HTMLAreasCollection;\r\n}\r\ndeclare var HTMLMapElement: {\r\n    prototype: HTMLMapElement;\r\n    new(): HTMLMapElement;\r\n}\r\n\r\ninterface HTMLMenuElement extends HTMLElement, DOML2DeprecatedListSpaceReduction {\r\n    type: string;\r\n}\r\ndeclare var HTMLMenuElement: {\r\n    prototype: HTMLMenuElement;\r\n    new(): HTMLMenuElement;\r\n}\r\n\r\ninterface MouseWheelEvent extends MouseEvent {\r\n    wheelDelta: number;\r\n    initMouseWheelEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, buttonArg: number, relatedTargetArg: EventTarget, modifiersListArg: string, wheelDeltaArg: number): void;\r\n}\r\ndeclare var MouseWheelEvent: {\r\n    prototype: MouseWheelEvent;\r\n    new(): MouseWheelEvent;\r\n}\r\n\r\ninterface SVGFitToViewBox {\r\n    viewBox: SVGAnimatedRect;\r\n    preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\r\n}\r\n\r\ninterface SVGPointList {\r\n    numberOfItems: number;\r\n    replaceItem(newItem: SVGPoint, index: number): SVGPoint;\r\n    getItem(index: number): SVGPoint;\r\n    clear(): void;\r\n    appendItem(newItem: SVGPoint): SVGPoint;\r\n    initialize(newItem: SVGPoint): SVGPoint;\r\n    removeItem(index: number): SVGPoint;\r\n    insertItemBefore(newItem: SVGPoint, index: number): SVGPoint;\r\n}\r\ndeclare var SVGPointList: {\r\n    prototype: SVGPointList;\r\n    new(): SVGPointList;\r\n}\r\n\r\ninterface SVGAnimatedLengthList {\r\n    animVal: SVGLengthList;\r\n    baseVal: SVGLengthList;\r\n}\r\ndeclare var SVGAnimatedLengthList: {\r\n    prototype: SVGAnimatedLengthList;\r\n    new(): SVGAnimatedLengthList;\r\n}\r\n\r\ninterface SVGAnimatedPreserveAspectRatio {\r\n    animVal: SVGPreserveAspectRatio;\r\n    baseVal: SVGPreserveAspectRatio;\r\n}\r\ndeclare var SVGAnimatedPreserveAspectRatio: {\r\n    prototype: SVGAnimatedPreserveAspectRatio;\r\n    new(): SVGAnimatedPreserveAspectRatio;\r\n}\r\n\r\ninterface MSSiteModeEvent extends Event {\r\n    buttonID: number;\r\n    actionURL: string;\r\n}\r\ndeclare var MSSiteModeEvent: {\r\n    prototype: MSSiteModeEvent;\r\n    new(): MSSiteModeEvent;\r\n}\r\n\r\ninterface DOML2DeprecatedTextFlowControl {\r\n    clear: string;\r\n}\r\n\r\ninterface StyleSheetPageList {\r\n    length: number;\r\n    item(index: number): CSSPageRule;\r\n    [index: number]: CSSPageRule;\r\n}\r\ndeclare var StyleSheetPageList: {\r\n    prototype: StyleSheetPageList;\r\n    new(): StyleSheetPageList;\r\n}\r\n\r\ninterface MSCSSProperties extends CSSStyleDeclaration {\r\n    scrollbarShadowColor: string;\r\n    scrollbarHighlightColor: string;\r\n    layoutGridChar: string;\r\n    layoutGridType: string;\r\n    textAutospace: string;\r\n    textKashidaSpace: string;\r\n    writingMode: string;\r\n    scrollbarFaceColor: string;\r\n    backgroundPositionY: string;\r\n    lineBreak: string;\r\n    imeMode: string;\r\n    msBlockProgression: string;\r\n    layoutGridLine: string;\r\n    scrollbarBaseColor: string;\r\n    layoutGrid: string;\r\n    layoutFlow: string;\r\n    textKashida: string;\r\n    filter: string;\r\n    zoom: string;\r\n    scrollbarArrowColor: string;\r\n    behavior: string;\r\n    backgroundPositionX: string;\r\n    accelerator: string;\r\n    layoutGridMode: string;\r\n    textJustifyTrim: string;\r\n    scrollbar3dLightColor: string;\r\n    msInterpolationMode: string;\r\n    scrollbarTrackColor: string;\r\n    scrollbarDarkShadowColor: string;\r\n    styleFloat: string;\r\n    getAttribute(attributeName: string, flags?: number): any;\r\n    setAttribute(attributeName: string, AttributeValue: any, flags?: number): void;\r\n    removeAttribute(attributeName: string, flags?: number): boolean;\r\n}\r\ndeclare var MSCSSProperties: {\r\n    prototype: MSCSSProperties;\r\n    new(): MSCSSProperties;\r\n}\r\n\r\ninterface HTMLCollection extends MSHTMLCollectionExtensions {\r\n    /**\r\n      * Sets or retrieves the number of objects in a collection.\r\n      */\r\n    length: number;\r\n    /**\r\n      * Retrieves an object from various collections.\r\n      */\r\n    item(nameOrIndex?: any, optionalIndex?: any): Element;\r\n    /**\r\n      * Retrieves a select object or an object from an options collection.\r\n      */\r\n    namedItem(name: string): Element;\r\n    // [name: string]: Element;\r\n}\r\ndeclare var HTMLCollection: {\r\n    prototype: HTMLCollection;\r\n    new(): HTMLCollection;\r\n}\r\n\r\ninterface SVGExternalResourcesRequired {\r\n    externalResourcesRequired: SVGAnimatedBoolean;\r\n}\r\n\r\ninterface HTMLImageElement extends HTMLElement, MSImageResourceExtensions, MSDataBindingExtensions, MSResourceMetadata {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: number;\r\n    /**\r\n      * Sets or retrieves the vertical margin for the object.\r\n      */\r\n    vspace: number;\r\n    /**\r\n      * The original height of the image resource before sizing.\r\n      */\r\n    naturalHeight: number;\r\n    /**\r\n      * Sets or retrieves a text alternative to the graphic.\r\n      */\r\n    alt: string;\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text.\r\n      */\r\n    align: string;\r\n    /**\r\n      * The address or URL of the a media resource that is to be considered.\r\n      */\r\n    src: string;\r\n    /**\r\n      * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\r\n      */\r\n    useMap: string;\r\n    /**\r\n      * The original width of the image resource before sizing.\r\n      */\r\n    naturalWidth: number;\r\n    /**\r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: number;\r\n    /**\r\n      * Specifies the properties of a border drawn around an object.\r\n      */\r\n    border: string;\r\n    /**\r\n      * Sets or retrieves the width of the border to draw around the object.\r\n      */\r\n    hspace: number;\r\n    /**\r\n      * Sets or retrieves a Uniform Resource Identifier (URI) to a long description of the object.\r\n      */\r\n    longDesc: string;\r\n    /**\r\n      * Contains the hypertext reference (HREF) of the URL.\r\n      */\r\n    href: string;\r\n    /**\r\n      * Sets or retrieves whether the image is a server-side image map.\r\n      */\r\n    isMap: boolean;\r\n    /**\r\n      * Retrieves whether the object is fully loaded.\r\n      */\r\n    complete: boolean;\r\n    /**\r\n      * Gets or sets the primary DLNA PlayTo device.\r\n      */\r\n    msPlayToPrimary: boolean;\r\n    /**\r\n      * Gets or sets whether the DLNA PlayTo device is available.\r\n      */\r\n    msPlayToDisabled: boolean;\r\n    /**\r\n      * Gets the source associated with the media element for use by the PlayToManager.\r\n      */\r\n    msPlayToSource: any;\r\n    crossOrigin: string;\r\n    msPlayToPreferredSourceUri: string;\r\n}\r\ndeclare var HTMLImageElement: {\r\n    prototype: HTMLImageElement;\r\n    new(): HTMLImageElement;\r\n    create(): HTMLImageElement;\r\n}\r\n\r\ninterface HTMLAreaElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the protocol portion of a URL.\r\n      */\r\n    protocol: string;\r\n    /**\r\n      * Sets or retrieves the substring of the href property that follows the question mark.\r\n      */\r\n    search: string;\r\n    /**\r\n      * Sets or retrieves a text alternative to the graphic.\r\n      */\r\n    alt: string;\r\n    /**\r\n      * Sets or retrieves the coordinates of the object.\r\n      */\r\n    coords: string;\r\n    /**\r\n      * Sets or retrieves the host name part of the location or URL. \r\n      */\r\n    hostname: string;\r\n    /**\r\n      * Sets or retrieves the port number associated with a URL.\r\n      */\r\n    port: string;\r\n    /**\r\n      * Sets or retrieves the file name or path specified by the object.\r\n      */\r\n    pathname: string;\r\n    /**\r\n      * Sets or retrieves the hostname and port number of the location or URL.\r\n      */\r\n    host: string;\r\n    /**\r\n      * Sets or retrieves the subsection of the href property that follows the number sign (#).\r\n      */\r\n    hash: string;\r\n    /**\r\n      * Sets or retrieves the window or frame at which to target content.\r\n      */\r\n    target: string;\r\n    /**\r\n      * Sets or retrieves a destination URL or an anchor point.\r\n      */\r\n    href: string;\r\n    /**\r\n      * Sets or gets whether clicks in this region cause action.\r\n      */\r\n    noHref: boolean;\r\n    /**\r\n      * Sets or retrieves the shape of the object.\r\n      */\r\n    shape: string;\r\n    /** \r\n      * Returns a string representation of an object.\r\n      */\r\n    toString(): string;\r\n}\r\ndeclare var HTMLAreaElement: {\r\n    prototype: HTMLAreaElement;\r\n    new(): HTMLAreaElement;\r\n}\r\n\r\ninterface EventTarget {\r\n    removeEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n    dispatchEvent(evt: Event): boolean;\r\n}\r\n\r\ninterface SVGAngle {\r\n    valueAsString: string;\r\n    valueInSpecifiedUnits: number;\r\n    value: number;\r\n    unitType: number;\r\n    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;\r\n    convertToSpecifiedUnits(unitType: number): void;\r\n    SVG_ANGLETYPE_RAD: number;\r\n    SVG_ANGLETYPE_UNKNOWN: number;\r\n    SVG_ANGLETYPE_UNSPECIFIED: number;\r\n    SVG_ANGLETYPE_DEG: number;\r\n    SVG_ANGLETYPE_GRAD: number;\r\n}\r\ndeclare var SVGAngle: {\r\n    prototype: SVGAngle;\r\n    new(): SVGAngle;\r\n    SVG_ANGLETYPE_RAD: number;\r\n    SVG_ANGLETYPE_UNKNOWN: number;\r\n    SVG_ANGLETYPE_UNSPECIFIED: number;\r\n    SVG_ANGLETYPE_DEG: number;\r\n    SVG_ANGLETYPE_GRAD: number;\r\n}\r\n\r\ninterface HTMLButtonElement extends HTMLElement, MSDataBindingExtensions {\r\n    /** \r\n      * Sets or retrieves the default or selected value of the control.\r\n      */\r\n    value: string;\r\n    status: any;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n    /** \r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Gets the classification and default behavior of the button.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\r\n      */\r\n    validationMessage: string;\r\n    /**\r\n      * Overrides the target attribute on a form element.\r\n      */\r\n    formTarget: string;\r\n    /**\r\n      * Returns whether an element will successfully validate based on forms validation rules and constraints.\r\n      */\r\n    willValidate: boolean;\r\n    /**\r\n      * Overrides the action attribute (where the data on a form is sent) on the parent form element.\r\n      */\r\n    formAction: string;\r\n    /**\r\n      * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\r\n      */\r\n    autofocus: boolean;\r\n    /**\r\n      * Returns a  ValidityState object that represents the validity states of an element.\r\n      */\r\n    validity: ValidityState;\r\n    /**\r\n      * Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a \"save draft\"-type submit option.\r\n      */\r\n    formNoValidate: string;\r\n    /**\r\n      * Used to override the encoding (formEnctype attribute) specified on the form element.\r\n      */\r\n    formEnctype: string;\r\n    /**\r\n      * Overrides the submit method attribute previously specified on a form element.\r\n      */\r\n    formMethod: string;\r\n    /**\r\n      * Creates a TextRange object for the element.\r\n      */\r\n    createTextRange(): TextRange;\r\n    /**\r\n      * Returns whether a form will validate when it is submitted, without having to submit it.\r\n      */\r\n    checkValidity(): boolean;\r\n    /**\r\n      * Sets a custom error message that is displayed when a form is submitted.\r\n      * @param error Sets a custom error message that is displayed when a form is submitted.\r\n      */\r\n    setCustomValidity(error: string): void;\r\n}\r\ndeclare var HTMLButtonElement: {\r\n    prototype: HTMLButtonElement;\r\n    new(): HTMLButtonElement;\r\n}\r\n\r\ninterface HTMLSourceElement extends HTMLElement {\r\n    /**\r\n      * The address or URL of the a media resource that is to be considered.\r\n      */\r\n    src: string;\r\n    /**\r\n      * Gets or sets the intended media type of the media source.\r\n     */\r\n    media: string;\r\n    /**\r\n     * Gets or sets the MIME type of a media resource.\r\n     */\r\n    type: string;\r\n    msKeySystem: string;\r\n}\r\ndeclare var HTMLSourceElement: {\r\n    prototype: HTMLSourceElement;\r\n    new(): HTMLSourceElement;\r\n}\r\n\r\ninterface CanvasGradient {\r\n    addColorStop(offset: number, color: string): void;\r\n}\r\ndeclare var CanvasGradient: {\r\n    prototype: CanvasGradient;\r\n    new(): CanvasGradient;\r\n}\r\n\r\ninterface KeyboardEvent extends UIEvent {\r\n    location: number;\r\n    keyCode: number;\r\n    shiftKey: boolean;\r\n    which: number;\r\n    locale: string;\r\n    key: string;\r\n    altKey: boolean;\r\n    metaKey: boolean;\r\n    char: string;\r\n    ctrlKey: boolean;\r\n    repeat: boolean;\r\n    charCode: number;\r\n    getModifierState(keyArg: string): boolean;\r\n    initKeyboardEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, keyArg: string, locationArg: number, modifiersListArg: string, repeat: boolean, locale: string): void;\r\n    DOM_KEY_LOCATION_RIGHT: number;\r\n    DOM_KEY_LOCATION_STANDARD: number;\r\n    DOM_KEY_LOCATION_LEFT: number;\r\n    DOM_KEY_LOCATION_NUMPAD: number;\r\n    DOM_KEY_LOCATION_JOYSTICK: number;\r\n    DOM_KEY_LOCATION_MOBILE: number;\r\n}\r\ndeclare var KeyboardEvent: {\r\n    prototype: KeyboardEvent;\r\n    new(): KeyboardEvent;\r\n    DOM_KEY_LOCATION_RIGHT: number;\r\n    DOM_KEY_LOCATION_STANDARD: number;\r\n    DOM_KEY_LOCATION_LEFT: number;\r\n    DOM_KEY_LOCATION_NUMPAD: number;\r\n    DOM_KEY_LOCATION_JOYSTICK: number;\r\n    DOM_KEY_LOCATION_MOBILE: number;\r\n}\r\n\r\ninterface MessageEvent extends Event {\r\n    source: Window;\r\n    origin: string;\r\n    data: any;\r\n    ports: any;\r\n    initMessageEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, dataArg: any, originArg: string, lastEventIdArg: string, sourceArg: Window): void;\r\n}\r\ndeclare var MessageEvent: {\r\n    prototype: MessageEvent;\r\n    new(): MessageEvent;\r\n}\r\n\r\ninterface SVGElement extends Element {\r\n    onmouseover: (ev: MouseEvent) => any;\r\n    viewportElement: SVGElement;\r\n    onmousemove: (ev: MouseEvent) => any;\r\n    onmouseout: (ev: MouseEvent) => any;\r\n    ondblclick: (ev: MouseEvent) => any;\r\n    onfocusout: (ev: FocusEvent) => any;\r\n    onfocusin: (ev: FocusEvent) => any;\r\n    xmlbase: string;\r\n    onmousedown: (ev: MouseEvent) => any;\r\n    onload: (ev: Event) => any;\r\n    onmouseup: (ev: MouseEvent) => any;\r\n    onclick: (ev: MouseEvent) => any;\r\n    ownerSVGElement: SVGSVGElement;\r\n    id: string;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var SVGElement: {\r\n    prototype: SVGElement;\r\n    new(): SVGElement;\r\n}\r\n\r\ninterface HTMLScriptElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the status of the script.\r\n      */\r\n    defer: boolean;\r\n    /**\r\n      * Retrieves or sets the text of the object as a string. \r\n      */\r\n    text: string;\r\n    /**\r\n      * Retrieves the URL to an external file that contains the source code or data.\r\n      */\r\n    src: string;\r\n    /** \r\n      * Sets or retrieves the object that is bound to the event script.\r\n      */\r\n    htmlFor: string;\r\n    /**\r\n      * Sets or retrieves the character set used to encode the object.\r\n      */\r\n    charset: string;\r\n    /**\r\n      * Sets or retrieves the MIME type for the associated scripting engine.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Sets or retrieves the event for which the script is written. \r\n      */\r\n    event: string;\r\n    async: boolean;\r\n}\r\ndeclare var HTMLScriptElement: {\r\n    prototype: HTMLScriptElement;\r\n    new(): HTMLScriptElement;\r\n}\r\n\r\ninterface HTMLTableRowElement extends HTMLElement, HTMLTableAlignment, DOML2DeprecatedBackgroundColorStyle {\r\n    /**\r\n      * Retrieves the position of the object in the rows collection for the table.\r\n      */\r\n    rowIndex: number;\r\n    /**\r\n      * Retrieves a collection of all cells in the table row.\r\n      */\r\n    cells: HTMLCollection;\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Sets or retrieves the color for one of the two colors used to draw the 3-D border of the object.\r\n      */\r\n    borderColorLight: any;\r\n    /**\r\n      * Retrieves the position of the object in the collection.\r\n      */\r\n    sectionRowIndex: number;\r\n    /**\r\n      * Sets or retrieves the border color of the object.\r\n      */\r\n    borderColor: any;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: any;\r\n    /**\r\n      * Sets or retrieves the color for one of the two colors used to draw the 3-D border of the object.\r\n      */\r\n    borderColorDark: any;\r\n    /**\r\n      * Removes the specified cell from the table row, as well as from the cells collection.\r\n      * @param index Number that specifies the zero-based position of the cell to remove from the table row. If no value is provided, the last cell in the cells collection is deleted.\r\n      */\r\n    deleteCell(index?: number): void;\r\n    /**\r\n      * Creates a new cell in the table row, and adds the cell to the cells collection.\r\n      * @param index Number that specifies where to insert the cell in the tr. The default value is -1, which appends the new cell to the end of the cells collection.\r\n      */\r\n    insertCell(index?: number): HTMLElement;\r\n}\r\ndeclare var HTMLTableRowElement: {\r\n    prototype: HTMLTableRowElement;\r\n    new(): HTMLTableRowElement;\r\n}\r\n\r\ninterface CanvasRenderingContext2D {\r\n    miterLimit: number;\r\n    font: string;\r\n    globalCompositeOperation: string;\r\n    msFillRule: string;\r\n    lineCap: string;\r\n    msImageSmoothingEnabled: boolean;\r\n    lineDashOffset: number;\r\n    shadowColor: string;\r\n    lineJoin: string;\r\n    shadowOffsetX: number;\r\n    lineWidth: number;\r\n    canvas: HTMLCanvasElement;\r\n    strokeStyle: any;\r\n    globalAlpha: number;\r\n    shadowOffsetY: number;\r\n    fillStyle: any;\r\n    shadowBlur: number;\r\n    textAlign: string;\r\n    textBaseline: string;\r\n    restore(): void;\r\n    setTransform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): void;\r\n    save(): void;\r\n    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\r\n    measureText(text: string): TextMetrics;\r\n    isPointInPath(x: number, y: number, fillRule?: string): boolean;\r\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\r\n    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX?: number, dirtyY?: number, dirtyWidth?: number, dirtyHeight?: number): void;\r\n    rotate(angle: number): void;\r\n    fillText(text: string, x: number, y: number, maxWidth?: number): void;\r\n    translate(x: number, y: number): void;\r\n    scale(x: number, y: number): void;\r\n    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;\r\n    lineTo(x: number, y: number): void;\r\n    getLineDash(): number[];\r\n    fill(fillRule?: string): void;\r\n    createImageData(imageDataOrSw: any, sh?: number): ImageData;\r\n    createPattern(image: HTMLElement, repetition: string): CanvasPattern;\r\n    closePath(): void;\r\n    rect(x: number, y: number, w: number, h: number): void;\r\n    clip(fillRule?: string): void;\r\n    clearRect(x: number, y: number, w: number, h: number): void;\r\n    moveTo(x: number, y: number): void;\r\n    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;\r\n    fillRect(x: number, y: number, w: number, h: number): void;\r\n    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;\r\n    drawImage(image: HTMLElement, offsetX: number, offsetY: number, width?: number, height?: number, canvasOffsetX?: number, canvasOffsetY?: number, canvasImageWidth?: number, canvasImageHeight?: number): void;\r\n    transform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): void;\r\n    stroke(): void;\r\n    strokeRect(x: number, y: number, w: number, h: number): void;\r\n    setLineDash(segments: number[]): void;\r\n    strokeText(text: string, x: number, y: number, maxWidth?: number): void;\r\n    beginPath(): void;\r\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;\r\n    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;\r\n}\r\ndeclare var CanvasRenderingContext2D: {\r\n    prototype: CanvasRenderingContext2D;\r\n    new(): CanvasRenderingContext2D;\r\n}\r\n\r\ninterface MSCSSRuleList {\r\n    length: number;\r\n    item(index?: number): CSSStyleRule;\r\n    [index: number]: CSSStyleRule;\r\n}\r\ndeclare var MSCSSRuleList: {\r\n    prototype: MSCSSRuleList;\r\n    new(): MSCSSRuleList;\r\n}\r\n\r\ninterface SVGPathSegLinetoHorizontalAbs extends SVGPathSeg {\r\n    x: number;\r\n}\r\ndeclare var SVGPathSegLinetoHorizontalAbs: {\r\n    prototype: SVGPathSegLinetoHorizontalAbs;\r\n    new(): SVGPathSegLinetoHorizontalAbs;\r\n}\r\n\r\ninterface SVGPathSegArcAbs extends SVGPathSeg {\r\n    y: number;\r\n    sweepFlag: boolean;\r\n    r2: number;\r\n    x: number;\r\n    angle: number;\r\n    r1: number;\r\n    largeArcFlag: boolean;\r\n}\r\ndeclare var SVGPathSegArcAbs: {\r\n    prototype: SVGPathSegArcAbs;\r\n    new(): SVGPathSegArcAbs;\r\n}\r\n\r\ninterface SVGTransformList {\r\n    numberOfItems: number;\r\n    getItem(index: number): SVGTransform;\r\n    consolidate(): SVGTransform;\r\n    clear(): void;\r\n    appendItem(newItem: SVGTransform): SVGTransform;\r\n    initialize(newItem: SVGTransform): SVGTransform;\r\n    removeItem(index: number): SVGTransform;\r\n    insertItemBefore(newItem: SVGTransform, index: number): SVGTransform;\r\n    replaceItem(newItem: SVGTransform, index: number): SVGTransform;\r\n    createSVGTransformFromMatrix(matrix: SVGMatrix): SVGTransform;\r\n}\r\ndeclare var SVGTransformList: {\r\n    prototype: SVGTransformList;\r\n    new(): SVGTransformList;\r\n}\r\n\r\ninterface HTMLHtmlElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the DTD version that governs the current document.\r\n      */\r\n    version: string;\r\n}\r\ndeclare var HTMLHtmlElement: {\r\n    prototype: HTMLHtmlElement;\r\n    new(): HTMLHtmlElement;\r\n}\r\n\r\ninterface SVGPathSegClosePath extends SVGPathSeg {\r\n}\r\ndeclare var SVGPathSegClosePath: {\r\n    prototype: SVGPathSegClosePath;\r\n    new(): SVGPathSegClosePath;\r\n}\r\n\r\ninterface HTMLFrameElement extends HTMLElement, GetSVGDocument, MSDataBindingExtensions {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: any;\r\n    /**\r\n      * Sets or retrieves whether the frame can be scrolled.\r\n      */\r\n    scrolling: string;\r\n    /**\r\n      * Sets or retrieves the top and bottom margin heights before displaying the text in a frame.\r\n      */\r\n    marginHeight: string;\r\n    /**\r\n      * Sets or retrieves the left and right margin widths before displaying the text in a frame.\r\n      */\r\n    marginWidth: string;\r\n    /**\r\n      * Sets or retrieves the border color of the object.\r\n      */\r\n    borderColor: any;\r\n    /**\r\n      * Sets or retrieves the amount of additional space between the frames.\r\n      */\r\n    frameSpacing: any;\r\n    /**\r\n      * Sets or retrieves whether to display a border for the frame.\r\n      */\r\n    frameBorder: string;\r\n    /**\r\n      * Sets or retrieves whether the user can resize the frame.\r\n      */\r\n    noResize: boolean;\r\n    /**\r\n      * Retrieves the object of the specified.\r\n      */\r\n    contentWindow: Window;\r\n    /**\r\n      * Sets or retrieves a URL to be loaded by the object.\r\n      */\r\n    src: string;\r\n    /**\r\n      * Sets or retrieves the frame name.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: any;\r\n    /**\r\n      * Retrieves the document object of the page or frame.\r\n      */\r\n    contentDocument: Document;\r\n    /**\r\n      * Specifies the properties of a border drawn around an object.\r\n      */\r\n    border: string;\r\n    /**\r\n      * Sets or retrieves a URI to a long description of the object.\r\n      */\r\n    longDesc: string;\r\n    /**\r\n      * Raised when the object has been completely received from the server.\r\n      */\r\n    onload: (ev: Event) => any;\r\n    /**\r\n      * Sets the value indicating whether the source file of a frame or iframe has specific security restrictions applied.\r\n      */\r\n    security: any;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"move\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"losecapture\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"layoutcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"filterchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforepaste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecopy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"paste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"moveend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizeend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"movestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"copy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var HTMLFrameElement: {\r\n    prototype: HTMLFrameElement;\r\n    new(): HTMLFrameElement;\r\n}\r\n\r\ninterface SVGAnimatedLength {\r\n    animVal: SVGLength;\r\n    baseVal: SVGLength;\r\n}\r\ndeclare var SVGAnimatedLength: {\r\n    prototype: SVGAnimatedLength;\r\n    new(): SVGAnimatedLength;\r\n}\r\n\r\ninterface SVGAnimatedPoints {\r\n    points: SVGPointList;\r\n    animatedPoints: SVGPointList;\r\n}\r\n\r\ninterface SVGDefsElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n}\r\ndeclare var SVGDefsElement: {\r\n    prototype: SVGDefsElement;\r\n    new(): SVGDefsElement;\r\n}\r\n\r\ninterface HTMLQuoteElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the date and time of a modification to the object.\r\n      */\r\n    dateTime: string;\r\n    /**\r\n      * Sets or retrieves reference information about the object.\r\n      */\r\n    cite: string;\r\n}\r\ndeclare var HTMLQuoteElement: {\r\n    prototype: HTMLQuoteElement;\r\n    new(): HTMLQuoteElement;\r\n}\r\n\r\ninterface CSSMediaRule extends CSSRule {\r\n    media: MediaList;\r\n    cssRules: CSSRuleList;\r\n    insertRule(rule: string, index?: number): number;\r\n    deleteRule(index?: number): void;\r\n}\r\ndeclare var CSSMediaRule: {\r\n    prototype: CSSMediaRule;\r\n    new(): CSSMediaRule;\r\n}\r\n\r\ninterface WindowModal {\r\n    dialogArguments: any;\r\n    returnValue: any;\r\n}\r\n\r\ninterface XMLHttpRequest extends EventTarget {\r\n    responseBody: any;\r\n    status: number;\r\n    readyState: number;\r\n    responseText: string;\r\n    responseXML: any;\r\n    ontimeout: (ev: Event) => any;\r\n    statusText: string;\r\n    onreadystatechange: (ev: Event) => any;\r\n    timeout: number;\r\n    onload: (ev: Event) => any;\r\n    response: any;\r\n    withCredentials: boolean;\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    onabort: (ev: UIEvent) => any;\r\n    responseType: string;\r\n    onloadend: (ev: ProgressEvent) => any;\r\n    upload: XMLHttpRequestEventTarget;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onloadstart: (ev: Event) => any;\r\n    msCaching: string;\r\n    open(method: string, url: string, async?: boolean, user?: string, password?: string): void;\r\n    send(data?: any): void;\r\n    abort(): void;\r\n    getAllResponseHeaders(): string;\r\n    setRequestHeader(header: string, value: string): void;\r\n    getResponseHeader(header: string): string;\r\n    msCachingEnabled(): boolean;\r\n    overrideMimeType(mime: string): void;\r\n    LOADING: number;\r\n    DONE: number;\r\n    UNSENT: number;\r\n    OPENED: number;\r\n    HEADERS_RECEIVED: number;\r\n    addEventListener(type: \"timeout\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadend\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var XMLHttpRequest: {\r\n    prototype: XMLHttpRequest;\r\n    new(): XMLHttpRequest;\r\n    LOADING: number;\r\n    DONE: number;\r\n    UNSENT: number;\r\n    OPENED: number;\r\n    HEADERS_RECEIVED: number;\r\n    create(): XMLHttpRequest;\r\n}\r\n\r\ninterface HTMLTableHeaderCellElement extends HTMLTableCellElement {\r\n    /**\r\n      * Sets or retrieves the group of cells in a table to which the object's information applies.\r\n      */\r\n    scope: string;\r\n}\r\ndeclare var HTMLTableHeaderCellElement: {\r\n    prototype: HTMLTableHeaderCellElement;\r\n    new(): HTMLTableHeaderCellElement;\r\n}\r\n\r\ninterface HTMLDListElement extends HTMLElement, DOML2DeprecatedListSpaceReduction {\r\n}\r\ndeclare var HTMLDListElement: {\r\n    prototype: HTMLDListElement;\r\n    new(): HTMLDListElement;\r\n}\r\n\r\ninterface MSDataBindingExtensions {\r\n    dataSrc: string;\r\n    dataFormatAs: string;\r\n    dataFld: string;\r\n}\r\n\r\ninterface SVGPathSegLinetoHorizontalRel extends SVGPathSeg {\r\n    x: number;\r\n}\r\ndeclare var SVGPathSegLinetoHorizontalRel: {\r\n    prototype: SVGPathSegLinetoHorizontalRel;\r\n    new(): SVGPathSegLinetoHorizontalRel;\r\n}\r\n\r\ninterface SVGEllipseElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n    ry: SVGAnimatedLength;\r\n    cx: SVGAnimatedLength;\r\n    rx: SVGAnimatedLength;\r\n    cy: SVGAnimatedLength;\r\n}\r\ndeclare var SVGEllipseElement: {\r\n    prototype: SVGEllipseElement;\r\n    new(): SVGEllipseElement;\r\n}\r\n\r\ninterface SVGAElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired, SVGURIReference {\r\n    target: SVGAnimatedString;\r\n}\r\ndeclare var SVGAElement: {\r\n    prototype: SVGAElement;\r\n    new(): SVGAElement;\r\n}\r\n\r\ninterface SVGStylable {\r\n    className: SVGAnimatedString;\r\n    style: CSSStyleDeclaration;\r\n}\r\n\r\ninterface SVGTransformable extends SVGLocatable {\r\n    transform: SVGAnimatedTransformList;\r\n}\r\n\r\ninterface HTMLFrameSetElement extends HTMLElement {\r\n    ononline: (ev: Event) => any;\r\n    /**\r\n      * Sets or retrieves the border color of the object.\r\n      */\r\n    borderColor: any;\r\n    /**\r\n      * Sets or retrieves the frame heights of the object.\r\n      */\r\n    rows: string;\r\n    /**\r\n      * Sets or retrieves the frame widths of the object.\r\n      */\r\n    cols: string;\r\n    /**\r\n      * Fires when the object loses the input focus.\r\n      */\r\n    onblur: (ev: FocusEvent) => any;\r\n    /**\r\n      * Sets or retrieves the amount of additional space between the frames.\r\n      */\r\n    frameSpacing: any;\r\n    /**\r\n      * Fires when the object receives focus.\r\n      */\r\n    onfocus: (ev: FocusEvent) => any;\r\n    onmessage: (ev: MessageEvent) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    /**\r\n      * Sets or retrieves whether to display a border for the frame.\r\n      */\r\n    frameBorder: string;\r\n    onresize: (ev: UIEvent) => any;\r\n    name: string;\r\n    onafterprint: (ev: Event) => any;\r\n    onbeforeprint: (ev: Event) => any;\r\n    onoffline: (ev: Event) => any;\r\n    border: string;\r\n    onunload: (ev: Event) => any;\r\n    onhashchange: (ev: Event) => any;\r\n    onload: (ev: Event) => any;\r\n    onbeforeunload: (ev: BeforeUnloadEvent) => any;\r\n    onstorage: (ev: StorageEvent) => any;\r\n    onpageshow: (ev: PageTransitionEvent) => any;\r\n    onpagehide: (ev: PageTransitionEvent) => any;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"move\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"losecapture\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"layoutcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"filterchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforepaste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecopy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"paste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"moveend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizeend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"movestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"copy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"online\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"message\", listener: (ev: MessageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterprint\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeprint\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"offline\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"unload\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"hashchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeunload\", listener: (ev: BeforeUnloadEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"storage\", listener: (ev: StorageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pageshow\", listener: (ev: PageTransitionEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pagehide\", listener: (ev: PageTransitionEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var HTMLFrameSetElement: {\r\n    prototype: HTMLFrameSetElement;\r\n    new(): HTMLFrameSetElement;\r\n}\r\n\r\ninterface Screen extends EventTarget {\r\n    width: number;\r\n    deviceXDPI: number;\r\n    fontSmoothingEnabled: boolean;\r\n    bufferDepth: number;\r\n    logicalXDPI: number;\r\n    systemXDPI: number;\r\n    availHeight: number;\r\n    height: number;\r\n    logicalYDPI: number;\r\n    systemYDPI: number;\r\n    updateInterval: number;\r\n    colorDepth: number;\r\n    availWidth: number;\r\n    deviceYDPI: number;\r\n    pixelDepth: number;\r\n    msOrientation: string;\r\n    onmsorientationchange: (ev: any) => any;\r\n    msLockOrientation(orientation: string): boolean;\r\n    msLockOrientation(orientations: string[]): boolean;\r\n    msUnlockOrientation(): void;\r\n    addEventListener(type: \"msorientationchange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var Screen: {\r\n    prototype: Screen;\r\n    new(): Screen;\r\n}\r\n\r\ninterface Coordinates {\r\n    altitudeAccuracy: number;\r\n    longitude: number;\r\n    latitude: number;\r\n    speed: number;\r\n    heading: number;\r\n    altitude: number;\r\n    accuracy: number;\r\n}\r\ndeclare var Coordinates: {\r\n    prototype: Coordinates;\r\n    new(): Coordinates;\r\n}\r\n\r\ninterface NavigatorGeolocation {\r\n    geolocation: Geolocation;\r\n}\r\n\r\ninterface NavigatorContentUtils {\r\n}\r\n\r\ninterface EventListener {\r\n    (evt: Event): void;\r\n}\r\n\r\ninterface SVGLangSpace {\r\n    xmllang: string;\r\n    xmlspace: string;\r\n}\r\n\r\ninterface DataTransfer {\r\n    effectAllowed: string;\r\n    dropEffect: string;\r\n    types: DOMStringList;\r\n    files: FileList;\r\n    clearData(format?: string): boolean;\r\n    setData(format: string, data: string): boolean;\r\n    getData(format: string): string;\r\n}\r\ndeclare var DataTransfer: {\r\n    prototype: DataTransfer;\r\n    new(): DataTransfer;\r\n}\r\n\r\ninterface FocusEvent extends UIEvent {\r\n    relatedTarget: EventTarget;\r\n    initFocusEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, relatedTargetArg: EventTarget): void;\r\n}\r\ndeclare var FocusEvent: {\r\n    prototype: FocusEvent;\r\n    new(): FocusEvent;\r\n}\r\n\r\ninterface Range {\r\n    startOffset: number;\r\n    collapsed: boolean;\r\n    endOffset: number;\r\n    startContainer: Node;\r\n    endContainer: Node;\r\n    commonAncestorContainer: Node;\r\n    setStart(refNode: Node, offset: number): void;\r\n    setEndBefore(refNode: Node): void;\r\n    setStartBefore(refNode: Node): void;\r\n    selectNode(refNode: Node): void;\r\n    detach(): void;\r\n    getBoundingClientRect(): ClientRect;\r\n    toString(): string;\r\n    compareBoundaryPoints(how: number, sourceRange: Range): number;\r\n    insertNode(newNode: Node): void;\r\n    collapse(toStart: boolean): void;\r\n    selectNodeContents(refNode: Node): void;\r\n    cloneContents(): DocumentFragment;\r\n    setEnd(refNode: Node, offset: number): void;\r\n    cloneRange(): Range;\r\n    getClientRects(): ClientRectList;\r\n    surroundContents(newParent: Node): void;\r\n    deleteContents(): void;\r\n    setStartAfter(refNode: Node): void;\r\n    extractContents(): DocumentFragment;\r\n    setEndAfter(refNode: Node): void;\r\n    createContextualFragment(fragment: string): DocumentFragment;\r\n    END_TO_END: number;\r\n    START_TO_START: number;\r\n    START_TO_END: number;\r\n    END_TO_START: number;\r\n}\r\ndeclare var Range: {\r\n    prototype: Range;\r\n    new(): Range;\r\n    END_TO_END: number;\r\n    START_TO_START: number;\r\n    START_TO_END: number;\r\n    END_TO_START: number;\r\n}\r\n\r\ninterface SVGPoint {\r\n    y: number;\r\n    x: number;\r\n    matrixTransform(matrix: SVGMatrix): SVGPoint;\r\n}\r\ndeclare var SVGPoint: {\r\n    prototype: SVGPoint;\r\n    new(): SVGPoint;\r\n}\r\n\r\ninterface MSPluginsCollection {\r\n    length: number;\r\n    refresh(reload?: boolean): void;\r\n}\r\ndeclare var MSPluginsCollection: {\r\n    prototype: MSPluginsCollection;\r\n    new(): MSPluginsCollection;\r\n}\r\n\r\ninterface SVGAnimatedNumberList {\r\n    animVal: SVGNumberList;\r\n    baseVal: SVGNumberList;\r\n}\r\ndeclare var SVGAnimatedNumberList: {\r\n    prototype: SVGAnimatedNumberList;\r\n    new(): SVGAnimatedNumberList;\r\n}\r\n\r\ninterface SVGSVGElement extends SVGElement, SVGStylable, SVGZoomAndPan, DocumentEvent, SVGLangSpace, SVGLocatable, SVGTests, SVGFitToViewBox, SVGExternalResourcesRequired {\r\n    width: SVGAnimatedLength;\r\n    x: SVGAnimatedLength;\r\n    contentStyleType: string;\r\n    onzoom: (ev: any) => any;\r\n    y: SVGAnimatedLength;\r\n    viewport: SVGRect;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    pixelUnitToMillimeterY: number;\r\n    onresize: (ev: UIEvent) => any;\r\n    screenPixelToMillimeterY: number;\r\n    height: SVGAnimatedLength;\r\n    onabort: (ev: UIEvent) => any;\r\n    contentScriptType: string;\r\n    pixelUnitToMillimeterX: number;\r\n    currentTranslate: SVGPoint;\r\n    onunload: (ev: Event) => any;\r\n    currentScale: number;\r\n    onscroll: (ev: UIEvent) => any;\r\n    screenPixelToMillimeterX: number;\r\n    setCurrentTime(seconds: number): void;\r\n    createSVGLength(): SVGLength;\r\n    getIntersectionList(rect: SVGRect, referenceElement: SVGElement): NodeList;\r\n    unpauseAnimations(): void;\r\n    createSVGRect(): SVGRect;\r\n    checkIntersection(element: SVGElement, rect: SVGRect): boolean;\r\n    unsuspendRedrawAll(): void;\r\n    pauseAnimations(): void;\r\n    suspendRedraw(maxWaitMilliseconds: number): number;\r\n    deselectAll(): void;\r\n    createSVGAngle(): SVGAngle;\r\n    getEnclosureList(rect: SVGRect, referenceElement: SVGElement): NodeList;\r\n    createSVGTransform(): SVGTransform;\r\n    unsuspendRedraw(suspendHandleID: number): void;\r\n    forceRedraw(): void;\r\n    getCurrentTime(): number;\r\n    checkEnclosure(element: SVGElement, rect: SVGRect): boolean;\r\n    createSVGMatrix(): SVGMatrix;\r\n    createSVGPoint(): SVGPoint;\r\n    createSVGNumber(): SVGNumber;\r\n    createSVGTransformFromMatrix(matrix: SVGMatrix): SVGTransform;\r\n    getComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration;\r\n    getElementById(elementId: string): Element;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"zoom\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"unload\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var SVGSVGElement: {\r\n    prototype: SVGSVGElement;\r\n    new(): SVGSVGElement;\r\n}\r\n\r\ninterface HTMLLabelElement extends HTMLElement, MSDataBindingExtensions {\r\n    /**\r\n      * Sets or retrieves the object to which the given label object is assigned.\r\n      */\r\n    htmlFor: string;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n}\r\ndeclare var HTMLLabelElement: {\r\n    prototype: HTMLLabelElement;\r\n    new(): HTMLLabelElement;\r\n}\r\n\r\ninterface MSResourceMetadata {\r\n    protocol: string;\r\n    fileSize: string;\r\n    fileUpdatedDate: string;\r\n    nameProp: string;\r\n    fileCreatedDate: string;\r\n    fileModifiedDate: string;\r\n    mimeType: string;\r\n}\r\n\r\ninterface HTMLLegendElement extends HTMLElement, MSDataBindingExtensions {\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n}\r\ndeclare var HTMLLegendElement: {\r\n    prototype: HTMLLegendElement;\r\n    new(): HTMLLegendElement;\r\n}\r\n\r\ninterface HTMLDirectoryElement extends HTMLElement, DOML2DeprecatedListSpaceReduction, DOML2DeprecatedListNumberingAndBulletStyle {\r\n}\r\ndeclare var HTMLDirectoryElement: {\r\n    prototype: HTMLDirectoryElement;\r\n    new(): HTMLDirectoryElement;\r\n}\r\n\r\ninterface SVGAnimatedInteger {\r\n    animVal: number;\r\n    baseVal: number;\r\n}\r\ndeclare var SVGAnimatedInteger: {\r\n    prototype: SVGAnimatedInteger;\r\n    new(): SVGAnimatedInteger;\r\n}\r\n\r\ninterface SVGTextElement extends SVGTextPositioningElement, SVGTransformable {\r\n}\r\ndeclare var SVGTextElement: {\r\n    prototype: SVGTextElement;\r\n    new(): SVGTextElement;\r\n}\r\n\r\ninterface SVGTSpanElement extends SVGTextPositioningElement {\r\n}\r\ndeclare var SVGTSpanElement: {\r\n    prototype: SVGTSpanElement;\r\n    new(): SVGTSpanElement;\r\n}\r\n\r\ninterface HTMLLIElement extends HTMLElement, DOML2DeprecatedListNumberingAndBulletStyle {\r\n    /**\r\n      * Sets or retrieves the value of a list item.\r\n      */\r\n    value: number;\r\n}\r\ndeclare var HTMLLIElement: {\r\n    prototype: HTMLLIElement;\r\n    new(): HTMLLIElement;\r\n}\r\n\r\ninterface SVGPathSegLinetoVerticalAbs extends SVGPathSeg {\r\n    y: number;\r\n}\r\ndeclare var SVGPathSegLinetoVerticalAbs: {\r\n    prototype: SVGPathSegLinetoVerticalAbs;\r\n    new(): SVGPathSegLinetoVerticalAbs;\r\n}\r\n\r\ninterface MSStorageExtensions {\r\n    remainingSpace: number;\r\n}\r\n\r\ninterface SVGStyleElement extends SVGElement, SVGLangSpace {\r\n    media: string;\r\n    type: string;\r\n    title: string;\r\n}\r\ndeclare var SVGStyleElement: {\r\n    prototype: SVGStyleElement;\r\n    new(): SVGStyleElement;\r\n}\r\n\r\ninterface MSCurrentStyleCSSProperties extends MSCSSProperties {\r\n    blockDirection: string;\r\n    clipBottom: string;\r\n    clipLeft: string;\r\n    clipRight: string;\r\n    clipTop: string;\r\n    hasLayout: string;\r\n}\r\ndeclare var MSCurrentStyleCSSProperties: {\r\n    prototype: MSCurrentStyleCSSProperties;\r\n    new(): MSCurrentStyleCSSProperties;\r\n}\r\n\r\ninterface MSHTMLCollectionExtensions {\r\n    urns(urn: any): any;\r\n    tags(tagName: any): any;\r\n}\r\n\r\ninterface Storage extends MSStorageExtensions {\r\n    length: number;\r\n    getItem(key: string): any;\r\n    [key: string]: any;\r\n    setItem(key: string, data: string): void;\r\n    clear(): void;\r\n    removeItem(key: string): void;\r\n    key(index: number): string;\r\n    [index: number]: string;\r\n}\r\ndeclare var Storage: {\r\n    prototype: Storage;\r\n    new(): Storage;\r\n}\r\n\r\ninterface HTMLIFrameElement extends HTMLElement, GetSVGDocument, MSDataBindingExtensions {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: string;\r\n    /**\r\n      * Sets or retrieves whether the frame can be scrolled.\r\n      */\r\n    scrolling: string;\r\n    /**\r\n      * Sets or retrieves the top and bottom margin heights before displaying the text in a frame.\r\n      */\r\n    marginHeight: string;\r\n    /**\r\n      * Sets or retrieves the left and right margin widths before displaying the text in a frame.\r\n      */\r\n    marginWidth: string;\r\n    /**\r\n      * Sets or retrieves the amount of additional space between the frames.\r\n      */\r\n    frameSpacing: any;\r\n    /**\r\n      * Sets or retrieves whether to display a border for the frame.\r\n      */\r\n    frameBorder: string;\r\n    /**\r\n      * Sets or retrieves whether the user can resize the frame.\r\n      */\r\n    noResize: boolean;\r\n    /**\r\n      * Sets or retrieves the vertical margin for the object.\r\n      */\r\n    vspace: number;\r\n    /**\r\n      * Retrieves the object of the specified.\r\n      */\r\n    contentWindow: Window;\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Sets or retrieves a URL to be loaded by the object.\r\n      */\r\n    src: string;\r\n    /**\r\n      * Sets or retrieves the frame name.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: string;\r\n    /**\r\n      * Specifies the properties of a border drawn around an object.\r\n      */\r\n    border: string;\r\n    /**\r\n      * Retrieves the document object of the page or frame.\r\n      */\r\n    contentDocument: Document;\r\n    /**\r\n      * Sets or retrieves the horizontal margin for the object.\r\n      */\r\n    hspace: number;\r\n    /**\r\n      * Sets or retrieves a URI to a long description of the object.\r\n      */\r\n    longDesc: string;\r\n    /**\r\n      * Sets the value indicating whether the source file of a frame or iframe has specific security restrictions applied.\r\n      */\r\n    security: any;\r\n    /**\r\n      * Raised when the object has been completely received from the server.\r\n      */\r\n    onload: (ev: Event) => any;\r\n    sandbox: DOMSettableTokenList;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"move\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"losecapture\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"layoutcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"filterchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforepaste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecopy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"paste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"moveend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizeend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"movestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"copy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var HTMLIFrameElement: {\r\n    prototype: HTMLIFrameElement;\r\n    new(): HTMLIFrameElement;\r\n}\r\n\r\ninterface TextRangeCollection {\r\n    length: number;\r\n    item(index: number): TextRange;\r\n    [index: number]: TextRange;\r\n}\r\ndeclare var TextRangeCollection: {\r\n    prototype: TextRangeCollection;\r\n    new(): TextRangeCollection;\r\n}\r\n\r\ninterface HTMLBodyElement extends HTMLElement, DOML2DeprecatedBackgroundStyle, DOML2DeprecatedBackgroundColorStyle {\r\n    scroll: string;\r\n    ononline: (ev: Event) => any;\r\n    onblur: (ev: FocusEvent) => any;\r\n    noWrap: boolean;\r\n    onfocus: (ev: FocusEvent) => any;\r\n    onmessage: (ev: MessageEvent) => any;\r\n    text: any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    bgProperties: string;\r\n    onresize: (ev: UIEvent) => any;\r\n    link: any;\r\n    aLink: any;\r\n    bottomMargin: any;\r\n    topMargin: any;\r\n    onafterprint: (ev: Event) => any;\r\n    vLink: any;\r\n    onbeforeprint: (ev: Event) => any;\r\n    onoffline: (ev: Event) => any;\r\n    onunload: (ev: Event) => any;\r\n    onhashchange: (ev: Event) => any;\r\n    onload: (ev: Event) => any;\r\n    rightMargin: any;\r\n    onbeforeunload: (ev: BeforeUnloadEvent) => any;\r\n    leftMargin: any;\r\n    onstorage: (ev: StorageEvent) => any;\r\n    onpopstate: (ev: PopStateEvent) => any;\r\n    onpageshow: (ev: PageTransitionEvent) => any;\r\n    onpagehide: (ev: PageTransitionEvent) => any;\r\n    createTextRange(): TextRange;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"move\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"losecapture\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"layoutcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"filterchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforepaste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecopy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"paste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"moveend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizeend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"movestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"copy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"online\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"message\", listener: (ev: MessageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterprint\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeprint\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"offline\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"unload\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"hashchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeunload\", listener: (ev: BeforeUnloadEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"storage\", listener: (ev: StorageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"popstate\", listener: (ev: PopStateEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pageshow\", listener: (ev: PageTransitionEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pagehide\", listener: (ev: PageTransitionEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var HTMLBodyElement: {\r\n    prototype: HTMLBodyElement;\r\n    new(): HTMLBodyElement;\r\n}\r\n\r\ninterface DocumentType extends Node {\r\n    name: string;\r\n    notations: NamedNodeMap;\r\n    systemId: string;\r\n    internalSubset: string;\r\n    entities: NamedNodeMap;\r\n    publicId: string;\r\n}\r\ndeclare var DocumentType: {\r\n    prototype: DocumentType;\r\n    new(): DocumentType;\r\n}\r\n\r\ninterface SVGRadialGradientElement extends SVGGradientElement {\r\n    cx: SVGAnimatedLength;\r\n    r: SVGAnimatedLength;\r\n    cy: SVGAnimatedLength;\r\n    fx: SVGAnimatedLength;\r\n    fy: SVGAnimatedLength;\r\n}\r\ndeclare var SVGRadialGradientElement: {\r\n    prototype: SVGRadialGradientElement;\r\n    new(): SVGRadialGradientElement;\r\n}\r\n\r\ninterface MutationEvent extends Event {\r\n    newValue: string;\r\n    attrChange: number;\r\n    attrName: string;\r\n    prevValue: string;\r\n    relatedNode: Node;\r\n    initMutationEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, relatedNodeArg: Node, prevValueArg: string, newValueArg: string, attrNameArg: string, attrChangeArg: number): void;\r\n    MODIFICATION: number;\r\n    REMOVAL: number;\r\n    ADDITION: number;\r\n}\r\ndeclare var MutationEvent: {\r\n    prototype: MutationEvent;\r\n    new(): MutationEvent;\r\n    MODIFICATION: number;\r\n    REMOVAL: number;\r\n    ADDITION: number;\r\n}\r\n\r\ninterface DragEvent extends MouseEvent {\r\n    dataTransfer: DataTransfer;\r\n    initDragEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget, dataTransferArg: DataTransfer): void;\r\n    msConvertURL(file: File, targetType: string, targetURL?: string): void;\r\n}\r\ndeclare var DragEvent: {\r\n    prototype: DragEvent;\r\n    new(): DragEvent;\r\n}\r\n\r\ninterface HTMLTableSectionElement extends HTMLElement, HTMLTableAlignment, DOML2DeprecatedBackgroundColorStyle {\r\n    /**\r\n      * Sets or retrieves a value that indicates the table alignment.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Sets or retrieves the number of horizontal rows contained in the object.\r\n      */\r\n    rows: HTMLCollection;\r\n    /**\r\n      * Removes the specified row (tr) from the element and from the rows collection.\r\n      * @param index Number that specifies the zero-based position in the rows collection of the row to remove.\r\n      */\r\n    deleteRow(index?: number): void;\r\n    /**\r\n      * Moves a table row to a new position.\r\n      * @param indexFrom Number that specifies the index in the rows collection of the table row that is moved.\r\n      * @param indexTo Number that specifies where the row is moved within the rows collection.\r\n      */\r\n    moveRow(indexFrom?: number, indexTo?: number): any;\r\n    /**\r\n      * Creates a new row (tr) in the table, and adds the row to the rows collection.\r\n      * @param index Number that specifies where to insert the row in the rows collection. The default value is -1, which appends the new row to the end of the rows collection.\r\n      */\r\n    insertRow(index?: number): HTMLElement;\r\n}\r\ndeclare var HTMLTableSectionElement: {\r\n    prototype: HTMLTableSectionElement;\r\n    new(): HTMLTableSectionElement;\r\n}\r\n\r\ninterface DOML2DeprecatedListNumberingAndBulletStyle {\r\n    type: string;\r\n}\r\n\r\ninterface HTMLInputElement extends HTMLElement, MSDataBindingExtensions {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: string;\r\n    status: boolean;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in. \r\n      */\r\n    form: HTMLFormElement;\r\n    /**\r\n      * Gets or sets the starting position or offset of a text selection.\r\n      */\r\n    selectionStart: number;\r\n    indeterminate: boolean;\r\n    readOnly: boolean;\r\n    size: number;\r\n    loop: number;\r\n    /**\r\n      * Gets or sets the end position or offset of a text selection.\r\n      */\r\n    selectionEnd: number;\r\n    /**\r\n      * Sets or retrieves the URL of the virtual reality modeling language (VRML) world to be displayed in the window.\r\n      */\r\n    vrml: string;\r\n    /**\r\n      * Sets or retrieves a lower resolution image to display.\r\n      */\r\n    lowsrc: string;\r\n    /**\r\n      * Sets or retrieves the vertical margin for the object.\r\n      */\r\n    vspace: number;\r\n    /**\r\n      * Sets or retrieves a comma-separated list of content types.\r\n      */\r\n    accept: string;\r\n    /**\r\n      * Sets or retrieves a text alternative to the graphic.\r\n      */\r\n    alt: string;\r\n    /**\r\n      * Sets or retrieves the state of the check box or radio button.\r\n      */\r\n    defaultChecked: boolean;\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Returns the value of the data at the cursor's current position.\r\n      */\r\n    value: string;\r\n    /**\r\n      * The address or URL of the a media resource that is to be considered.\r\n      */\r\n    src: string;\r\n    /**\r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\r\n      */\r\n    useMap: string;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: string;\r\n    /**\r\n      * Sets or retrieves the width of the border to draw around the object.\r\n      */\r\n    border: string;\r\n    dynsrc: string;\r\n    /**\r\n      * Sets or retrieves the state of the check box or radio button.\r\n      */\r\n    checked: boolean;\r\n    /**\r\n      * Sets or retrieves the width of the border to draw around the object.\r\n      */\r\n    hspace: number;\r\n    /**\r\n      * Sets or retrieves the maximum number of characters that the user can enter in a text control.\r\n      */\r\n    maxLength: number;\r\n    /**\r\n      * Returns the content type of the object.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Sets or retrieves the initial contents of the object.\r\n      */\r\n    defaultValue: string;\r\n    /**\r\n      * Retrieves whether the object is fully loaded.\r\n      */\r\n    complete: boolean;\r\n    start: string;\r\n    /**\r\n      * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\r\n      */\r\n    validationMessage: string;\r\n    /**\r\n      * Returns a FileList object on a file type input object.\r\n      */\r\n    files: FileList;\r\n    /**\r\n      * Defines the maximum acceptable value for an input element with type=\"number\".When used with the min and step attributes, lets you control the range and increment (such as only even numbers) that the user can enter into an input field.\r\n      */\r\n    max: string;\r\n    /**\r\n      * Overrides the target attribute on a form element.\r\n      */\r\n    formTarget: string;\r\n    /**\r\n      * Returns whether an element will successfully validate based on forms validation rules and constraints.\r\n      */\r\n    willValidate: boolean;\r\n    /**\r\n      * Defines an increment or jump between values that you want to allow the user to enter. When used with the max and min attributes, lets you control the range and increment (for example, allow only even numbers) that the user can enter into an input field.\r\n      */\r\n    step: string;\r\n    /**\r\n      * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\r\n      */\r\n    autofocus: boolean;\r\n    /**\r\n      * When present, marks an element that can't be submitted without a value.\r\n      */\r\n    required: boolean;\r\n    /**\r\n      * Used to override the encoding (formEnctype attribute) specified on the form element.\r\n      */\r\n    formEnctype: string;\r\n    /**\r\n      * Returns the input field value as a number.\r\n      */\r\n    valueAsNumber: number;\r\n    /**\r\n      * Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field.\r\n      */\r\n    placeholder: string;\r\n    /**\r\n      * Overrides the submit method attribute previously specified on a form element.\r\n      */\r\n    formMethod: string;\r\n    /**\r\n      * Specifies the ID of a pre-defined datalist of options for an input element.\r\n      */\r\n    list: HTMLElement;\r\n    /**\r\n      * Specifies whether autocomplete is applied to an editable text field.\r\n      */\r\n    autocomplete: string;\r\n    /**\r\n      * Defines the minimum acceptable value for an input element with type=\"number\". When used with the max and step attributes, lets you control the range and increment (such as even numbers only) that the user can enter into an input field.\r\n      */\r\n    min: string;\r\n    /**\r\n      * Overrides the action attribute (where the data on a form is sent) on the parent form element.\r\n      */\r\n    formAction: string;\r\n    /**\r\n      * Gets or sets a string containing a regular expression that the user's input must match.\r\n      */\r\n    pattern: string;\r\n    /**\r\n      * Returns a  ValidityState object that represents the validity states of an element.\r\n      */\r\n    validity: ValidityState;\r\n    /**\r\n      * Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a \"save draft\"-type submit option.\r\n      */\r\n    formNoValidate: string;\r\n    /**\r\n      * Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list.\r\n      */\r\n    multiple: boolean;\r\n    /**\r\n      * Creates a TextRange object for the element.\r\n      */\r\n    createTextRange(): TextRange;\r\n    /**\r\n      * Sets the start and end positions of a selection in a text field.\r\n      * @param start The offset into the text field for the start of the selection.\r\n      * @param end The offset into the text field for the end of the selection.\r\n      */\r\n    setSelectionRange(start: number, end: number): void;\r\n    /**\r\n      * Makes the selection equal to the current object.\r\n      */\r\n    select(): void;\r\n    /**\r\n      * Returns whether a form will validate when it is submitted, without having to submit it.\r\n      */\r\n    checkValidity(): boolean;\r\n    /**\r\n      * Decrements a range input control's value by the value given by the Step attribute. If the optional parameter is used, it will decrement the input control's step value multiplied by the parameter's value.\r\n      * @param n Value to decrement the value by.\r\n      */\r\n    stepDown(n?: number): void;\r\n    /**\r\n      * Increments a range input control's value by the value given by the Step attribute. If the optional parameter is used, will increment the input control's value by that value.\r\n      * @param n Value to increment the value by.\r\n      */\r\n    stepUp(n?: number): void;\r\n    /**\r\n      * Sets a custom error message that is displayed when a form is submitted.\r\n      * @param error Sets a custom error message that is displayed when a form is submitted.\r\n      */\r\n    setCustomValidity(error: string): void;\r\n}\r\ndeclare var HTMLInputElement: {\r\n    prototype: HTMLInputElement;\r\n    new(): HTMLInputElement;\r\n}\r\n\r\ninterface HTMLAnchorElement extends HTMLElement, MSDataBindingExtensions {\r\n    /**\r\n      * Sets or retrieves the relationship between the object and the destination of the link.\r\n      */\r\n    rel: string;\r\n    /**\r\n      * Contains the protocol of the URL.\r\n      */\r\n    protocol: string;\r\n    /**\r\n      * Sets or retrieves the substring of the href property that follows the question mark.\r\n      */\r\n    search: string;\r\n    /**\r\n      * Sets or retrieves the coordinates of the object.\r\n      */\r\n    coords: string;\r\n    /**\r\n      * Contains the hostname of a URL.\r\n      */\r\n    hostname: string;\r\n    /**\r\n      * Contains the pathname of the URL.\r\n      */\r\n    pathname: string;\r\n    Methods: string;\r\n    /**\r\n      * Sets or retrieves the window or frame at which to target content.\r\n      */\r\n    target: string;\r\n    protocolLong: string;\r\n    /**\r\n      * Sets or retrieves a destination URL or an anchor point.\r\n      */\r\n    href: string;\r\n    /**\r\n      * Sets or retrieves the shape of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the character set used to encode the object.\r\n      */\r\n    charset: string;\r\n    /**\r\n      * Sets or retrieves the language code of the object.\r\n      */\r\n    hreflang: string;\r\n    /**\r\n      * Sets or retrieves the port number associated with a URL.\r\n      */\r\n    port: string;\r\n    /**\r\n      * Contains the hostname and port values of the URL.\r\n      */\r\n    host: string;\r\n    /**\r\n      * Contains the anchor portion of the URL including the hash sign (#).\r\n      */\r\n    hash: string;\r\n    nameProp: string;\r\n    urn: string;\r\n    /**\r\n      * Sets or retrieves the relationship between the object and the destination of the link.\r\n      */\r\n    rev: string;\r\n    /**\r\n      * Sets or retrieves the shape of the object.\r\n      */\r\n    shape: string;\r\n    type: string;\r\n    mimeType: string;\r\n    /**\r\n      * Retrieves or sets the text of the object as a string. \r\n      */\r\n    text: string;\r\n    /** \r\n      * Returns a string representation of an object.\r\n      */\r\n    toString(): string;\r\n}\r\ndeclare var HTMLAnchorElement: {\r\n    prototype: HTMLAnchorElement;\r\n    new(): HTMLAnchorElement;\r\n}\r\n\r\ninterface HTMLParamElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the value of an input parameter for an element.\r\n      */\r\n    value: string;\r\n    /**\r\n      * Sets or retrieves the name of an input parameter for an element.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the content type of the resource designated by the value attribute.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Sets or retrieves the data type of the value attribute.\r\n      */\r\n    valueType: string;\r\n}\r\ndeclare var HTMLParamElement: {\r\n    prototype: HTMLParamElement;\r\n    new(): HTMLParamElement;\r\n}\r\n\r\ninterface SVGImageElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired, SVGURIReference {\r\n    y: SVGAnimatedLength;\r\n    width: SVGAnimatedLength;\r\n    preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\r\n    x: SVGAnimatedLength;\r\n    height: SVGAnimatedLength;\r\n}\r\ndeclare var SVGImageElement: {\r\n    prototype: SVGImageElement;\r\n    new(): SVGImageElement;\r\n}\r\n\r\ninterface SVGAnimatedNumber {\r\n    animVal: number;\r\n    baseVal: number;\r\n}\r\ndeclare var SVGAnimatedNumber: {\r\n    prototype: SVGAnimatedNumber;\r\n    new(): SVGAnimatedNumber;\r\n}\r\n\r\ninterface PerformanceTiming {\r\n    redirectStart: number;\r\n    domainLookupEnd: number;\r\n    responseStart: number;\r\n    domComplete: number;\r\n    domainLookupStart: number;\r\n    loadEventStart: number;\r\n    msFirstPaint: number;\r\n    unloadEventEnd: number;\r\n    fetchStart: number;\r\n    requestStart: number;\r\n    domInteractive: number;\r\n    navigationStart: number;\r\n    connectEnd: number;\r\n    loadEventEnd: number;\r\n    connectStart: number;\r\n    responseEnd: number;\r\n    domLoading: number;\r\n    redirectEnd: number;\r\n    unloadEventStart: number;\r\n    domContentLoadedEventStart: number;\r\n    domContentLoadedEventEnd: number;\r\n    toJSON(): any;\r\n}\r\ndeclare var PerformanceTiming: {\r\n    prototype: PerformanceTiming;\r\n    new(): PerformanceTiming;\r\n}\r\n\r\ninterface HTMLPreElement extends HTMLElement, DOML2DeprecatedTextFlowControl {\r\n    /**\r\n      * Sets or gets a value that you can use to implement your own width functionality for the object.\r\n      */\r\n    width: number;\r\n    /**\r\n      * Indicates a citation by rendering text in italic type.\r\n      */\r\n    cite: string;\r\n}\r\ndeclare var HTMLPreElement: {\r\n    prototype: HTMLPreElement;\r\n    new(): HTMLPreElement;\r\n}\r\n\r\ninterface EventException {\r\n    code: number;\r\n    message: string;\r\n    name: string;\r\n    toString(): string;\r\n    DISPATCH_REQUEST_ERR: number;\r\n    UNSPECIFIED_EVENT_TYPE_ERR: number;\r\n}\r\ndeclare var EventException: {\r\n    prototype: EventException;\r\n    new(): EventException;\r\n    DISPATCH_REQUEST_ERR: number;\r\n    UNSPECIFIED_EVENT_TYPE_ERR: number;\r\n}\r\n\r\ninterface MSNavigatorDoNotTrack {\r\n    msDoNotTrack: string;\r\n    removeSiteSpecificTrackingException(args: ExceptionInformation): void;\r\n    removeWebWideTrackingException(args: ExceptionInformation): void;\r\n    storeWebWideTrackingException(args: StoreExceptionsInformation): void;\r\n    storeSiteSpecificTrackingException(args: StoreSiteSpecificExceptionsInformation): void;\r\n    confirmSiteSpecificTrackingException(args: ConfirmSiteSpecificExceptionsInformation): boolean;\r\n    confirmWebWideTrackingException(args: ExceptionInformation): boolean;\r\n}\r\n\r\ninterface NavigatorOnLine {\r\n    onLine: boolean;\r\n}\r\n\r\ninterface WindowLocalStorage {\r\n    localStorage: Storage;\r\n}\r\n\r\ninterface SVGMetadataElement extends SVGElement {\r\n}\r\ndeclare var SVGMetadataElement: {\r\n    prototype: SVGMetadataElement;\r\n    new(): SVGMetadataElement;\r\n}\r\n\r\ninterface SVGPathSegArcRel extends SVGPathSeg {\r\n    y: number;\r\n    sweepFlag: boolean;\r\n    r2: number;\r\n    x: number;\r\n    angle: number;\r\n    r1: number;\r\n    largeArcFlag: boolean;\r\n}\r\ndeclare var SVGPathSegArcRel: {\r\n    prototype: SVGPathSegArcRel;\r\n    new(): SVGPathSegArcRel;\r\n}\r\n\r\ninterface SVGPathSegMovetoAbs extends SVGPathSeg {\r\n    y: number;\r\n    x: number;\r\n}\r\ndeclare var SVGPathSegMovetoAbs: {\r\n    prototype: SVGPathSegMovetoAbs;\r\n    new(): SVGPathSegMovetoAbs;\r\n}\r\n\r\ninterface SVGStringList {\r\n    numberOfItems: number;\r\n    replaceItem(newItem: string, index: number): string;\r\n    getItem(index: number): string;\r\n    clear(): void;\r\n    appendItem(newItem: string): string;\r\n    initialize(newItem: string): string;\r\n    removeItem(index: number): string;\r\n    insertItemBefore(newItem: string, index: number): string;\r\n}\r\ndeclare var SVGStringList: {\r\n    prototype: SVGStringList;\r\n    new(): SVGStringList;\r\n}\r\n\r\ninterface XDomainRequest {\r\n    timeout: number;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onload: (ev: Event) => any;\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    ontimeout: (ev: Event) => any;\r\n    responseText: string;\r\n    contentType: string;\r\n    open(method: string, url: string): void;\r\n    abort(): void;\r\n    send(data?: any): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeout\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var XDomainRequest: {\r\n    prototype: XDomainRequest;\r\n    new(): XDomainRequest;\r\n    create(): XDomainRequest;\r\n}\r\n\r\ninterface DOML2DeprecatedBackgroundColorStyle {\r\n    bgColor: any;\r\n}\r\n\r\ninterface ElementTraversal {\r\n    childElementCount: number;\r\n    previousElementSibling: Element;\r\n    lastElementChild: Element;\r\n    nextElementSibling: Element;\r\n    firstElementChild: Element;\r\n}\r\n\r\ninterface SVGLength {\r\n    valueAsString: string;\r\n    valueInSpecifiedUnits: number;\r\n    value: number;\r\n    unitType: number;\r\n    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;\r\n    convertToSpecifiedUnits(unitType: number): void;\r\n    SVG_LENGTHTYPE_NUMBER: number;\r\n    SVG_LENGTHTYPE_CM: number;\r\n    SVG_LENGTHTYPE_PC: number;\r\n    SVG_LENGTHTYPE_PERCENTAGE: number;\r\n    SVG_LENGTHTYPE_MM: number;\r\n    SVG_LENGTHTYPE_PT: number;\r\n    SVG_LENGTHTYPE_IN: number;\r\n    SVG_LENGTHTYPE_EMS: number;\r\n    SVG_LENGTHTYPE_PX: number;\r\n    SVG_LENGTHTYPE_UNKNOWN: number;\r\n    SVG_LENGTHTYPE_EXS: number;\r\n}\r\ndeclare var SVGLength: {\r\n    prototype: SVGLength;\r\n    new(): SVGLength;\r\n    SVG_LENGTHTYPE_NUMBER: number;\r\n    SVG_LENGTHTYPE_CM: number;\r\n    SVG_LENGTHTYPE_PC: number;\r\n    SVG_LENGTHTYPE_PERCENTAGE: number;\r\n    SVG_LENGTHTYPE_MM: number;\r\n    SVG_LENGTHTYPE_PT: number;\r\n    SVG_LENGTHTYPE_IN: number;\r\n    SVG_LENGTHTYPE_EMS: number;\r\n    SVG_LENGTHTYPE_PX: number;\r\n    SVG_LENGTHTYPE_UNKNOWN: number;\r\n    SVG_LENGTHTYPE_EXS: number;\r\n}\r\n\r\ninterface SVGPolygonElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGAnimatedPoints, SVGTests, SVGExternalResourcesRequired {\r\n}\r\ndeclare var SVGPolygonElement: {\r\n    prototype: SVGPolygonElement;\r\n    new(): SVGPolygonElement;\r\n}\r\n\r\ninterface HTMLPhraseElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the date and time of a modification to the object.\r\n      */\r\n    dateTime: string;\r\n    /**\r\n      * Sets or retrieves reference information about the object.\r\n      */\r\n    cite: string;\r\n}\r\ndeclare var HTMLPhraseElement: {\r\n    prototype: HTMLPhraseElement;\r\n    new(): HTMLPhraseElement;\r\n}\r\n\r\ninterface NavigatorStorageUtils {\r\n}\r\n\r\ninterface SVGPathSegCurvetoCubicRel extends SVGPathSeg {\r\n    y: number;\r\n    y1: number;\r\n    x2: number;\r\n    x: number;\r\n    x1: number;\r\n    y2: number;\r\n}\r\ndeclare var SVGPathSegCurvetoCubicRel: {\r\n    prototype: SVGPathSegCurvetoCubicRel;\r\n    new(): SVGPathSegCurvetoCubicRel;\r\n}\r\n\r\ninterface SVGTextContentElement extends SVGElement, SVGStylable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n    textLength: SVGAnimatedLength;\r\n    lengthAdjust: SVGAnimatedEnumeration;\r\n    getCharNumAtPosition(point: SVGPoint): number;\r\n    getStartPositionOfChar(charnum: number): SVGPoint;\r\n    getExtentOfChar(charnum: number): SVGRect;\r\n    getComputedTextLength(): number;\r\n    getSubStringLength(charnum: number, nchars: number): number;\r\n    selectSubString(charnum: number, nchars: number): void;\r\n    getNumberOfChars(): number;\r\n    getRotationOfChar(charnum: number): number;\r\n    getEndPositionOfChar(charnum: number): SVGPoint;\r\n    LENGTHADJUST_SPACING: number;\r\n    LENGTHADJUST_SPACINGANDGLYPHS: number;\r\n    LENGTHADJUST_UNKNOWN: number;\r\n}\r\ndeclare var SVGTextContentElement: {\r\n    prototype: SVGTextContentElement;\r\n    new(): SVGTextContentElement;\r\n    LENGTHADJUST_SPACING: number;\r\n    LENGTHADJUST_SPACINGANDGLYPHS: number;\r\n    LENGTHADJUST_UNKNOWN: number;\r\n}\r\n\r\ninterface DOML2DeprecatedColorProperty {\r\n    color: string;\r\n}\r\n\r\ninterface Location {\r\n    hash: string;\r\n    protocol: string;\r\n    search: string;\r\n    href: string;\r\n    hostname: string;\r\n    port: string;\r\n    pathname: string;\r\n    host: string;\r\n    reload(flag?: boolean): void;\r\n    replace(url: string): void;\r\n    assign(url: string): void;\r\n    toString(): string;\r\n}\r\ndeclare var Location: {\r\n    prototype: Location;\r\n    new(): Location;\r\n}\r\n\r\ninterface HTMLTitleElement extends HTMLElement {\r\n    /**\r\n      * Retrieves or sets the text of the object as a string. \r\n      */\r\n    text: string;\r\n}\r\ndeclare var HTMLTitleElement: {\r\n    prototype: HTMLTitleElement;\r\n    new(): HTMLTitleElement;\r\n}\r\n\r\ninterface HTMLStyleElement extends HTMLElement, LinkStyle {\r\n    /**\r\n      * Sets or retrieves the media type.\r\n      */\r\n    media: string;\r\n    /**\r\n      * Retrieves the CSS language in which the style sheet is written.\r\n      */\r\n    type: string;\r\n}\r\ndeclare var HTMLStyleElement: {\r\n    prototype: HTMLStyleElement;\r\n    new(): HTMLStyleElement;\r\n}\r\n\r\ninterface PerformanceEntry {\r\n    name: string;\r\n    startTime: number;\r\n    duration: number;\r\n    entryType: string;\r\n}\r\ndeclare var PerformanceEntry: {\r\n    prototype: PerformanceEntry;\r\n    new(): PerformanceEntry;\r\n}\r\n\r\ninterface SVGTransform {\r\n    type: number;\r\n    angle: number;\r\n    matrix: SVGMatrix;\r\n    setTranslate(tx: number, ty: number): void;\r\n    setScale(sx: number, sy: number): void;\r\n    setMatrix(matrix: SVGMatrix): void;\r\n    setSkewY(angle: number): void;\r\n    setRotate(angle: number, cx: number, cy: number): void;\r\n    setSkewX(angle: number): void;\r\n    SVG_TRANSFORM_SKEWX: number;\r\n    SVG_TRANSFORM_UNKNOWN: number;\r\n    SVG_TRANSFORM_SCALE: number;\r\n    SVG_TRANSFORM_TRANSLATE: number;\r\n    SVG_TRANSFORM_MATRIX: number;\r\n    SVG_TRANSFORM_ROTATE: number;\r\n    SVG_TRANSFORM_SKEWY: number;\r\n}\r\ndeclare var SVGTransform: {\r\n    prototype: SVGTransform;\r\n    new(): SVGTransform;\r\n    SVG_TRANSFORM_SKEWX: number;\r\n    SVG_TRANSFORM_UNKNOWN: number;\r\n    SVG_TRANSFORM_SCALE: number;\r\n    SVG_TRANSFORM_TRANSLATE: number;\r\n    SVG_TRANSFORM_MATRIX: number;\r\n    SVG_TRANSFORM_ROTATE: number;\r\n    SVG_TRANSFORM_SKEWY: number;\r\n}\r\n\r\ninterface UIEvent extends Event {\r\n    detail: number;\r\n    view: Window;\r\n    initUIEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number): void;\r\n}\r\ndeclare var UIEvent: {\r\n    prototype: UIEvent;\r\n    new(): UIEvent;\r\n}\r\n\r\ninterface SVGURIReference {\r\n    href: SVGAnimatedString;\r\n}\r\n\r\ninterface SVGPathSeg {\r\n    pathSegType: number;\r\n    pathSegTypeAsLetter: string;\r\n    PATHSEG_MOVETO_REL: number;\r\n    PATHSEG_LINETO_VERTICAL_REL: number;\r\n    PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: number;\r\n    PATHSEG_CURVETO_QUADRATIC_REL: number;\r\n    PATHSEG_CURVETO_CUBIC_ABS: number;\r\n    PATHSEG_LINETO_HORIZONTAL_ABS: number;\r\n    PATHSEG_CURVETO_QUADRATIC_ABS: number;\r\n    PATHSEG_LINETO_ABS: number;\r\n    PATHSEG_CLOSEPATH: number;\r\n    PATHSEG_LINETO_HORIZONTAL_REL: number;\r\n    PATHSEG_CURVETO_CUBIC_SMOOTH_REL: number;\r\n    PATHSEG_LINETO_REL: number;\r\n    PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: number;\r\n    PATHSEG_ARC_REL: number;\r\n    PATHSEG_CURVETO_CUBIC_REL: number;\r\n    PATHSEG_UNKNOWN: number;\r\n    PATHSEG_LINETO_VERTICAL_ABS: number;\r\n    PATHSEG_ARC_ABS: number;\r\n    PATHSEG_MOVETO_ABS: number;\r\n    PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: number;\r\n}\r\ndeclare var SVGPathSeg: {\r\n    prototype: SVGPathSeg;\r\n    new(): SVGPathSeg;\r\n    PATHSEG_MOVETO_REL: number;\r\n    PATHSEG_LINETO_VERTICAL_REL: number;\r\n    PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: number;\r\n    PATHSEG_CURVETO_QUADRATIC_REL: number;\r\n    PATHSEG_CURVETO_CUBIC_ABS: number;\r\n    PATHSEG_LINETO_HORIZONTAL_ABS: number;\r\n    PATHSEG_CURVETO_QUADRATIC_ABS: number;\r\n    PATHSEG_LINETO_ABS: number;\r\n    PATHSEG_CLOSEPATH: number;\r\n    PATHSEG_LINETO_HORIZONTAL_REL: number;\r\n    PATHSEG_CURVETO_CUBIC_SMOOTH_REL: number;\r\n    PATHSEG_LINETO_REL: number;\r\n    PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: number;\r\n    PATHSEG_ARC_REL: number;\r\n    PATHSEG_CURVETO_CUBIC_REL: number;\r\n    PATHSEG_UNKNOWN: number;\r\n    PATHSEG_LINETO_VERTICAL_ABS: number;\r\n    PATHSEG_ARC_ABS: number;\r\n    PATHSEG_MOVETO_ABS: number;\r\n    PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: number;\r\n}\r\n\r\ninterface WheelEvent extends MouseEvent {\r\n    deltaZ: number;\r\n    deltaX: number;\r\n    deltaMode: number;\r\n    deltaY: number;\r\n    initWheelEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, buttonArg: number, relatedTargetArg: EventTarget, modifiersListArg: string, deltaXArg: number, deltaYArg: number, deltaZArg: number, deltaMode: number): void;\r\n    getCurrentPoint(element: Element): void;\r\n    DOM_DELTA_PIXEL: number;\r\n    DOM_DELTA_LINE: number;\r\n    DOM_DELTA_PAGE: number;\r\n}\r\ndeclare var WheelEvent: {\r\n    prototype: WheelEvent;\r\n    new(): WheelEvent;\r\n    DOM_DELTA_PIXEL: number;\r\n    DOM_DELTA_LINE: number;\r\n    DOM_DELTA_PAGE: number;\r\n}\r\n\r\ninterface MSEventAttachmentTarget {\r\n    attachEvent(event: string, listener: EventListener): boolean;\r\n    detachEvent(event: string, listener: EventListener): void;\r\n}\r\n\r\ninterface SVGNumber {\r\n    value: number;\r\n}\r\ndeclare var SVGNumber: {\r\n    prototype: SVGNumber;\r\n    new(): SVGNumber;\r\n}\r\n\r\ninterface SVGPathElement extends SVGElement, SVGStylable, SVGAnimatedPathData, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n    getPathSegAtLength(distance: number): number;\r\n    getPointAtLength(distance: number): SVGPoint;\r\n    createSVGPathSegCurvetoQuadraticAbs(x: number, y: number, x1: number, y1: number): SVGPathSegCurvetoQuadraticAbs;\r\n    createSVGPathSegLinetoRel(x: number, y: number): SVGPathSegLinetoRel;\r\n    createSVGPathSegCurvetoQuadraticRel(x: number, y: number, x1: number, y1: number): SVGPathSegCurvetoQuadraticRel;\r\n    createSVGPathSegCurvetoCubicAbs(x: number, y: number, x1: number, y1: number, x2: number, y2: number): SVGPathSegCurvetoCubicAbs;\r\n    createSVGPathSegLinetoAbs(x: number, y: number): SVGPathSegLinetoAbs;\r\n    createSVGPathSegClosePath(): SVGPathSegClosePath;\r\n    createSVGPathSegCurvetoCubicRel(x: number, y: number, x1: number, y1: number, x2: number, y2: number): SVGPathSegCurvetoCubicRel;\r\n    createSVGPathSegCurvetoQuadraticSmoothRel(x: number, y: number): SVGPathSegCurvetoQuadraticSmoothRel;\r\n    createSVGPathSegMovetoRel(x: number, y: number): SVGPathSegMovetoRel;\r\n    createSVGPathSegCurvetoCubicSmoothAbs(x: number, y: number, x2: number, y2: number): SVGPathSegCurvetoCubicSmoothAbs;\r\n    createSVGPathSegMovetoAbs(x: number, y: number): SVGPathSegMovetoAbs;\r\n    createSVGPathSegLinetoVerticalRel(y: number): SVGPathSegLinetoVerticalRel;\r\n    createSVGPathSegArcRel(x: number, y: number, r1: number, r2: number, angle: number, largeArcFlag: boolean, sweepFlag: boolean): SVGPathSegArcRel;\r\n    createSVGPathSegCurvetoQuadraticSmoothAbs(x: number, y: number): SVGPathSegCurvetoQuadraticSmoothAbs;\r\n    createSVGPathSegLinetoHorizontalRel(x: number): SVGPathSegLinetoHorizontalRel;\r\n    getTotalLength(): number;\r\n    createSVGPathSegCurvetoCubicSmoothRel(x: number, y: number, x2: number, y2: number): SVGPathSegCurvetoCubicSmoothRel;\r\n    createSVGPathSegLinetoHorizontalAbs(x: number): SVGPathSegLinetoHorizontalAbs;\r\n    createSVGPathSegLinetoVerticalAbs(y: number): SVGPathSegLinetoVerticalAbs;\r\n    createSVGPathSegArcAbs(x: number, y: number, r1: number, r2: number, angle: number, largeArcFlag: boolean, sweepFlag: boolean): SVGPathSegArcAbs;\r\n}\r\ndeclare var SVGPathElement: {\r\n    prototype: SVGPathElement;\r\n    new(): SVGPathElement;\r\n}\r\n\r\ninterface MSCompatibleInfo {\r\n    version: string;\r\n    userAgent: string;\r\n}\r\ndeclare var MSCompatibleInfo: {\r\n    prototype: MSCompatibleInfo;\r\n    new(): MSCompatibleInfo;\r\n}\r\n\r\ninterface Text extends CharacterData, MSNodeExtensions {\r\n    wholeText: string;\r\n    splitText(offset: number): Text;\r\n    replaceWholeText(content: string): Text;\r\n}\r\ndeclare var Text: {\r\n    prototype: Text;\r\n    new(): Text;\r\n}\r\n\r\ninterface SVGAnimatedRect {\r\n    animVal: SVGRect;\r\n    baseVal: SVGRect;\r\n}\r\ndeclare var SVGAnimatedRect: {\r\n    prototype: SVGAnimatedRect;\r\n    new(): SVGAnimatedRect;\r\n}\r\n\r\ninterface CSSNamespaceRule extends CSSRule {\r\n    namespaceURI: string;\r\n    prefix: string;\r\n}\r\ndeclare var CSSNamespaceRule: {\r\n    prototype: CSSNamespaceRule;\r\n    new(): CSSNamespaceRule;\r\n}\r\n\r\ninterface SVGPathSegList {\r\n    numberOfItems: number;\r\n    replaceItem(newItem: SVGPathSeg, index: number): SVGPathSeg;\r\n    getItem(index: number): SVGPathSeg;\r\n    clear(): void;\r\n    appendItem(newItem: SVGPathSeg): SVGPathSeg;\r\n    initialize(newItem: SVGPathSeg): SVGPathSeg;\r\n    removeItem(index: number): SVGPathSeg;\r\n    insertItemBefore(newItem: SVGPathSeg, index: number): SVGPathSeg;\r\n}\r\ndeclare var SVGPathSegList: {\r\n    prototype: SVGPathSegList;\r\n    new(): SVGPathSegList;\r\n}\r\n\r\ninterface HTMLUnknownElement extends HTMLElement, MSDataBindingRecordSetReadonlyExtensions {\r\n}\r\ndeclare var HTMLUnknownElement: {\r\n    prototype: HTMLUnknownElement;\r\n    new(): HTMLUnknownElement;\r\n}\r\n\r\ninterface HTMLAudioElement extends HTMLMediaElement {\r\n}\r\ndeclare var HTMLAudioElement: {\r\n    prototype: HTMLAudioElement;\r\n    new(): HTMLAudioElement;\r\n}\r\n\r\ninterface MSImageResourceExtensions {\r\n    dynsrc: string;\r\n    vrml: string;\r\n    lowsrc: string;\r\n    start: string;\r\n    loop: number;\r\n}\r\n\r\ninterface PositionError {\r\n    code: number;\r\n    message: string;\r\n    toString(): string;\r\n    POSITION_UNAVAILABLE: number;\r\n    PERMISSION_DENIED: number;\r\n    TIMEOUT: number;\r\n}\r\ndeclare var PositionError: {\r\n    prototype: PositionError;\r\n    new(): PositionError;\r\n    POSITION_UNAVAILABLE: number;\r\n    PERMISSION_DENIED: number;\r\n    TIMEOUT: number;\r\n}\r\n\r\ninterface HTMLTableCellElement extends HTMLElement, HTMLTableAlignment, DOML2DeprecatedBackgroundStyle, DOML2DeprecatedBackgroundColorStyle {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: number;\r\n    /**\r\n      * Sets or retrieves a list of header cells that provide information for the object.\r\n      */\r\n    headers: string;\r\n    /**\r\n      * Retrieves the position of the object in the cells collection of a row.\r\n      */\r\n    cellIndex: number;\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Sets or retrieves the color for one of the two colors used to draw the 3-D border of the object.\r\n      */\r\n    borderColorLight: any;\r\n    /**\r\n      * Sets or retrieves the number columns in the table that the object should span.\r\n      */\r\n    colSpan: number;\r\n    /**\r\n      * Sets or retrieves the border color of the object. \r\n      */\r\n    borderColor: any;\r\n    /**\r\n      * Sets or retrieves a comma-delimited list of conceptual categories associated with the object.\r\n      */\r\n    axis: string;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: any;\r\n    /**\r\n      * Sets or retrieves whether the browser automatically performs wordwrap.\r\n      */\r\n    noWrap: boolean;\r\n    /**\r\n      * Sets or retrieves abbreviated text for the object.\r\n      */\r\n    abbr: string;\r\n    /**\r\n      * Sets or retrieves how many rows in a table the cell should span.\r\n      */\r\n    rowSpan: number;\r\n    /**\r\n      * Sets or retrieves the group of cells in a table to which the object's information applies.\r\n      */\r\n    scope: string;\r\n    /**\r\n      * Sets or retrieves the color for one of the two colors used to draw the 3-D border of the object.\r\n      */\r\n    borderColorDark: any;\r\n}\r\ndeclare var HTMLTableCellElement: {\r\n    prototype: HTMLTableCellElement;\r\n    new(): HTMLTableCellElement;\r\n}\r\n\r\ninterface SVGElementInstance extends EventTarget {\r\n    previousSibling: SVGElementInstance;\r\n    parentNode: SVGElementInstance;\r\n    lastChild: SVGElementInstance;\r\n    nextSibling: SVGElementInstance;\r\n    childNodes: SVGElementInstanceList;\r\n    correspondingUseElement: SVGUseElement;\r\n    correspondingElement: SVGElement;\r\n    firstChild: SVGElementInstance;\r\n}\r\ndeclare var SVGElementInstance: {\r\n    prototype: SVGElementInstance;\r\n    new(): SVGElementInstance;\r\n}\r\n\r\ninterface MSNamespaceInfoCollection {\r\n    length: number;\r\n    add(namespace?: string, urn?: string, implementationUrl?: any): any;\r\n    item(index: any): any;\r\n    // [index: any]: any;\r\n}\r\ndeclare var MSNamespaceInfoCollection: {\r\n    prototype: MSNamespaceInfoCollection;\r\n    new(): MSNamespaceInfoCollection;\r\n}\r\n\r\ninterface SVGCircleElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n    cx: SVGAnimatedLength;\r\n    r: SVGAnimatedLength;\r\n    cy: SVGAnimatedLength;\r\n}\r\ndeclare var SVGCircleElement: {\r\n    prototype: SVGCircleElement;\r\n    new(): SVGCircleElement;\r\n}\r\n\r\ninterface StyleSheetList {\r\n    length: number;\r\n    item(index?: number): StyleSheet;\r\n    [index: number]: StyleSheet;\r\n}\r\ndeclare var StyleSheetList: {\r\n    prototype: StyleSheetList;\r\n    new(): StyleSheetList;\r\n}\r\n\r\ninterface CSSImportRule extends CSSRule {\r\n    styleSheet: CSSStyleSheet;\r\n    href: string;\r\n    media: MediaList;\r\n}\r\ndeclare var CSSImportRule: {\r\n    prototype: CSSImportRule;\r\n    new(): CSSImportRule;\r\n}\r\n\r\ninterface CustomEvent extends Event {\r\n    detail: any;\r\n    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: any): void;\r\n}\r\ndeclare var CustomEvent: {\r\n    prototype: CustomEvent;\r\n    new(): CustomEvent;\r\n}\r\n\r\ninterface HTMLBaseFontElement extends HTMLElement, DOML2DeprecatedColorProperty {\r\n    /**\r\n      * Sets or retrieves the current typeface family.\r\n      */\r\n    face: string;\r\n    /**\r\n      * Sets or retrieves the font size of the object.\r\n      */\r\n    size: number;\r\n}\r\ndeclare var HTMLBaseFontElement: {\r\n    prototype: HTMLBaseFontElement;\r\n    new(): HTMLBaseFontElement;\r\n}\r\n\r\ninterface HTMLTextAreaElement extends HTMLElement, MSDataBindingExtensions {\r\n    /**\r\n      * Retrieves or sets the text in the entry field of the textArea element.\r\n      */\r\n    value: string;\r\n    /**\r\n      * Sets or retrieves the value indicating whether the control is selected.\r\n      */\r\n    status: any;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n    /**\r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Gets or sets the starting position or offset of a text selection.\r\n      */\r\n    selectionStart: number;\r\n    /**\r\n      * Sets or retrieves the number of horizontal rows contained in the object.\r\n      */\r\n    rows: number;\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    cols: number;\r\n    /**\r\n      * Sets or retrieves the value indicated whether the content of the object is read-only.\r\n      */\r\n    readOnly: boolean;\r\n    /**\r\n      * Sets or retrieves how to handle wordwrapping in the object.\r\n      */\r\n    wrap: string;\r\n    /**\r\n      * Gets or sets the end position or offset of a text selection.\r\n      */\r\n    selectionEnd: number;\r\n    /**\r\n      * Retrieves the type of control.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Sets or retrieves the initial contents of the object.\r\n      */\r\n    defaultValue: string;\r\n    /**\r\n      * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\r\n      */\r\n    validationMessage: string;\r\n    /**\r\n      * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\r\n      */\r\n    autofocus: boolean;\r\n    /**\r\n      * Returns a  ValidityState object that represents the validity states of an element.\r\n      */\r\n    validity: ValidityState;\r\n    /**\r\n      * When present, marks an element that can't be submitted without a value.\r\n      */\r\n    required: boolean;\r\n    /**\r\n      * Sets or retrieves the maximum number of characters that the user can enter in a text control.\r\n      */\r\n    maxLength: number;\r\n    /**\r\n      * Returns whether an element will successfully validate based on forms validation rules and constraints.\r\n      */\r\n    willValidate: boolean;\r\n    /**\r\n      * Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field.\r\n      */\r\n    placeholder: string;\r\n    /**\r\n      * Creates a TextRange object for the element.\r\n      */\r\n    createTextRange(): TextRange;\r\n    /**\r\n      * Sets the start and end positions of a selection in a text field.\r\n      * @param start The offset into the text field for the start of the selection.\r\n      * @param end The offset into the text field for the end of the selection.\r\n      */\r\n    setSelectionRange(start: number, end: number): void;\r\n    /**\r\n      * Highlights the input area of a form element.\r\n      */\r\n    select(): void;\r\n    /**\r\n      * Returns whether a form will validate when it is submitted, without having to submit it.\r\n      */\r\n    checkValidity(): boolean;\r\n    /**\r\n      * Sets a custom error message that is displayed when a form is submitted.\r\n      * @param error Sets a custom error message that is displayed when a form is submitted.\r\n      */\r\n    setCustomValidity(error: string): void;\r\n}\r\ndeclare var HTMLTextAreaElement: {\r\n    prototype: HTMLTextAreaElement;\r\n    new(): HTMLTextAreaElement;\r\n}\r\n\r\ninterface Geolocation {\r\n    clearWatch(watchId: number): void;\r\n    getCurrentPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback, options?: PositionOptions): void;\r\n    watchPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback, options?: PositionOptions): number;\r\n}\r\ndeclare var Geolocation: {\r\n    prototype: Geolocation;\r\n    new(): Geolocation;\r\n}\r\n\r\ninterface DOML2DeprecatedMarginStyle {\r\n    vspace: number;\r\n    hspace: number;\r\n}\r\n\r\ninterface MSWindowModeless {\r\n    dialogTop: any;\r\n    dialogLeft: any;\r\n    dialogWidth: any;\r\n    dialogHeight: any;\r\n    menuArguments: any;\r\n}\r\n\r\ninterface DOML2DeprecatedAlignmentStyle {\r\n    align: string;\r\n}\r\n\r\ninterface HTMLMarqueeElement extends HTMLElement, MSDataBindingExtensions, DOML2DeprecatedBackgroundColorStyle {\r\n    width: string;\r\n    onbounce: (ev: Event) => any;\r\n    vspace: number;\r\n    trueSpeed: boolean;\r\n    scrollAmount: number;\r\n    scrollDelay: number;\r\n    behavior: string;\r\n    height: string;\r\n    loop: number;\r\n    direction: string;\r\n    hspace: number;\r\n    onstart: (ev: Event) => any;\r\n    onfinish: (ev: Event) => any;\r\n    stop(): void;\r\n    start(): void;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"move\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"losecapture\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"layoutcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"filterchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforepaste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecopy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"paste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"moveend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizeend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"movestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"copy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"bounce\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"start\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"finish\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var HTMLMarqueeElement: {\r\n    prototype: HTMLMarqueeElement;\r\n    new(): HTMLMarqueeElement;\r\n}\r\n\r\ninterface SVGRect {\r\n    y: number;\r\n    width: number;\r\n    x: number;\r\n    height: number;\r\n}\r\ndeclare var SVGRect: {\r\n    prototype: SVGRect;\r\n    new(): SVGRect;\r\n}\r\n\r\ninterface MSNodeExtensions {\r\n    swapNode(otherNode: Node): Node;\r\n    removeNode(deep?: boolean): Node;\r\n    replaceNode(replacement: Node): Node;\r\n}\r\n\r\ninterface History {\r\n    length: number;\r\n    state: any;\r\n    back(distance?: any): void;\r\n    forward(distance?: any): void;\r\n    go(delta?: any): void;\r\n    replaceState(statedata: any, title: string, url?: string): void;\r\n    pushState(statedata: any, title: string, url?: string): void;\r\n}\r\ndeclare var History: {\r\n    prototype: History;\r\n    new(): History;\r\n}\r\n\r\ninterface SVGPathSegCurvetoCubicAbs extends SVGPathSeg {\r\n    y: number;\r\n    y1: number;\r\n    x2: number;\r\n    x: number;\r\n    x1: number;\r\n    y2: number;\r\n}\r\ndeclare var SVGPathSegCurvetoCubicAbs: {\r\n    prototype: SVGPathSegCurvetoCubicAbs;\r\n    new(): SVGPathSegCurvetoCubicAbs;\r\n}\r\n\r\ninterface SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg {\r\n    y: number;\r\n    y1: number;\r\n    x: number;\r\n    x1: number;\r\n}\r\ndeclare var SVGPathSegCurvetoQuadraticAbs: {\r\n    prototype: SVGPathSegCurvetoQuadraticAbs;\r\n    new(): SVGPathSegCurvetoQuadraticAbs;\r\n}\r\n\r\ninterface TimeRanges {\r\n    length: number;\r\n    start(index: number): number;\r\n    end(index: number): number;\r\n}\r\ndeclare var TimeRanges: {\r\n    prototype: TimeRanges;\r\n    new(): TimeRanges;\r\n}\r\n\r\ninterface CSSRule {\r\n    cssText: string;\r\n    parentStyleSheet: CSSStyleSheet;\r\n    parentRule: CSSRule;\r\n    type: number;\r\n    IMPORT_RULE: number;\r\n    MEDIA_RULE: number;\r\n    STYLE_RULE: number;\r\n    NAMESPACE_RULE: number;\r\n    PAGE_RULE: number;\r\n    UNKNOWN_RULE: number;\r\n    FONT_FACE_RULE: number;\r\n    CHARSET_RULE: number;\r\n    KEYFRAMES_RULE: number;\r\n    KEYFRAME_RULE: number;\r\n    VIEWPORT_RULE: number;\r\n}\r\ndeclare var CSSRule: {\r\n    prototype: CSSRule;\r\n    new(): CSSRule;\r\n    IMPORT_RULE: number;\r\n    MEDIA_RULE: number;\r\n    STYLE_RULE: number;\r\n    NAMESPACE_RULE: number;\r\n    PAGE_RULE: number;\r\n    UNKNOWN_RULE: number;\r\n    FONT_FACE_RULE: number;\r\n    CHARSET_RULE: number;\r\n    KEYFRAMES_RULE: number;\r\n    KEYFRAME_RULE: number;\r\n    VIEWPORT_RULE: number;\r\n}\r\n\r\ninterface SVGPathSegLinetoAbs extends SVGPathSeg {\r\n    y: number;\r\n    x: number;\r\n}\r\ndeclare var SVGPathSegLinetoAbs: {\r\n    prototype: SVGPathSegLinetoAbs;\r\n    new(): SVGPathSegLinetoAbs;\r\n}\r\n\r\ninterface HTMLModElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the date and time of a modification to the object.\r\n      */\r\n    dateTime: string;\r\n    /**\r\n      * Sets or retrieves reference information about the object.\r\n      */\r\n    cite: string;\r\n}\r\ndeclare var HTMLModElement: {\r\n    prototype: HTMLModElement;\r\n    new(): HTMLModElement;\r\n}\r\n\r\ninterface SVGMatrix {\r\n    e: number;\r\n    c: number;\r\n    a: number;\r\n    b: number;\r\n    d: number;\r\n    f: number;\r\n    multiply(secondMatrix: SVGMatrix): SVGMatrix;\r\n    flipY(): SVGMatrix;\r\n    skewY(angle: number): SVGMatrix;\r\n    inverse(): SVGMatrix;\r\n    scaleNonUniform(scaleFactorX: number, scaleFactorY: number): SVGMatrix;\r\n    rotate(angle: number): SVGMatrix;\r\n    flipX(): SVGMatrix;\r\n    translate(x: number, y: number): SVGMatrix;\r\n    scale(scaleFactor: number): SVGMatrix;\r\n    rotateFromVector(x: number, y: number): SVGMatrix;\r\n    skewX(angle: number): SVGMatrix;\r\n}\r\ndeclare var SVGMatrix: {\r\n    prototype: SVGMatrix;\r\n    new(): SVGMatrix;\r\n}\r\n\r\ninterface MSPopupWindow {\r\n    document: Document;\r\n    isOpen: boolean;\r\n    show(x: number, y: number, w: number, h: number, element?: any): void;\r\n    hide(): void;\r\n}\r\ndeclare var MSPopupWindow: {\r\n    prototype: MSPopupWindow;\r\n    new(): MSPopupWindow;\r\n}\r\n\r\ninterface BeforeUnloadEvent extends Event {\r\n    returnValue: string;\r\n}\r\ndeclare var BeforeUnloadEvent: {\r\n    prototype: BeforeUnloadEvent;\r\n    new(): BeforeUnloadEvent;\r\n}\r\n\r\ninterface SVGUseElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired, SVGURIReference {\r\n    y: SVGAnimatedLength;\r\n    width: SVGAnimatedLength;\r\n    animatedInstanceRoot: SVGElementInstance;\r\n    instanceRoot: SVGElementInstance;\r\n    x: SVGAnimatedLength;\r\n    height: SVGAnimatedLength;\r\n}\r\ndeclare var SVGUseElement: {\r\n    prototype: SVGUseElement;\r\n    new(): SVGUseElement;\r\n}\r\n\r\ninterface Event {\r\n    timeStamp: number;\r\n    defaultPrevented: boolean;\r\n    isTrusted: boolean;\r\n    currentTarget: EventTarget;\r\n    cancelBubble: boolean;\r\n    target: EventTarget;\r\n    eventPhase: number;\r\n    cancelable: boolean;\r\n    type: string;\r\n    srcElement: Element;\r\n    bubbles: boolean;\r\n    initEvent(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean): void;\r\n    stopPropagation(): void;\r\n    stopImmediatePropagation(): void;\r\n    preventDefault(): void;\r\n    CAPTURING_PHASE: number;\r\n    AT_TARGET: number;\r\n    BUBBLING_PHASE: number;\r\n}\r\ndeclare var Event: {\r\n    prototype: Event;\r\n    new(): Event;\r\n    CAPTURING_PHASE: number;\r\n    AT_TARGET: number;\r\n    BUBBLING_PHASE: number;\r\n}\r\n\r\ninterface ImageData {\r\n    width: number;\r\n    data: number[];\r\n    height: number;\r\n}\r\ndeclare var ImageData: {\r\n    prototype: ImageData;\r\n    new(): ImageData;\r\n}\r\n\r\ninterface HTMLTableColElement extends HTMLElement, HTMLTableAlignment {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: any;\r\n    /**\r\n      * Sets or retrieves the alignment of the object relative to the display or table.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Sets or retrieves the number of columns in the group.\r\n      */\r\n    span: number;\r\n}\r\ndeclare var HTMLTableColElement: {\r\n    prototype: HTMLTableColElement;\r\n    new(): HTMLTableColElement;\r\n}\r\n\r\ninterface SVGException {\r\n    code: number;\r\n    message: string;\r\n    name: string;\r\n    toString(): string;\r\n    SVG_MATRIX_NOT_INVERTABLE: number;\r\n    SVG_WRONG_TYPE_ERR: number;\r\n    SVG_INVALID_VALUE_ERR: number;\r\n}\r\ndeclare var SVGException: {\r\n    prototype: SVGException;\r\n    new(): SVGException;\r\n    SVG_MATRIX_NOT_INVERTABLE: number;\r\n    SVG_WRONG_TYPE_ERR: number;\r\n    SVG_INVALID_VALUE_ERR: number;\r\n}\r\n\r\ninterface SVGLinearGradientElement extends SVGGradientElement {\r\n    y1: SVGAnimatedLength;\r\n    x2: SVGAnimatedLength;\r\n    x1: SVGAnimatedLength;\r\n    y2: SVGAnimatedLength;\r\n}\r\ndeclare var SVGLinearGradientElement: {\r\n    prototype: SVGLinearGradientElement;\r\n    new(): SVGLinearGradientElement;\r\n}\r\n\r\ninterface HTMLTableAlignment {\r\n    /**\r\n      * Sets or retrieves a value that you can use to implement your own ch functionality for the object.\r\n      */\r\n    ch: string;\r\n    /**\r\n      * Sets or retrieves how text and other content are vertically aligned within the object that contains them.\r\n      */\r\n    vAlign: string;\r\n    /**\r\n      * Sets or retrieves a value that you can use to implement your own chOff functionality for the object.\r\n      */\r\n    chOff: string;\r\n}\r\n\r\ninterface SVGAnimatedEnumeration {\r\n    animVal: number;\r\n    baseVal: number;\r\n}\r\ndeclare var SVGAnimatedEnumeration: {\r\n    prototype: SVGAnimatedEnumeration;\r\n    new(): SVGAnimatedEnumeration;\r\n}\r\n\r\ninterface DOML2DeprecatedSizeProperty {\r\n    size: number;\r\n}\r\n\r\ninterface HTMLUListElement extends HTMLElement, DOML2DeprecatedListSpaceReduction, DOML2DeprecatedListNumberingAndBulletStyle {\r\n}\r\ndeclare var HTMLUListElement: {\r\n    prototype: HTMLUListElement;\r\n    new(): HTMLUListElement;\r\n}\r\n\r\ninterface SVGRectElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n    y: SVGAnimatedLength;\r\n    width: SVGAnimatedLength;\r\n    ry: SVGAnimatedLength;\r\n    rx: SVGAnimatedLength;\r\n    x: SVGAnimatedLength;\r\n    height: SVGAnimatedLength;\r\n}\r\ndeclare var SVGRectElement: {\r\n    prototype: SVGRectElement;\r\n    new(): SVGRectElement;\r\n}\r\n\r\ninterface ErrorEventHandler {\r\n    (event: Event, source: string, fileno: number, columnNumber: number): void;\r\n}\r\n\r\ninterface HTMLDivElement extends HTMLElement, MSDataBindingExtensions {\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text. \r\n      */\r\n    align: string;\r\n    /**\r\n      * Sets or retrieves whether the browser automatically performs wordwrap.\r\n      */\r\n    noWrap: boolean;\r\n}\r\ndeclare var HTMLDivElement: {\r\n    prototype: HTMLDivElement;\r\n    new(): HTMLDivElement;\r\n}\r\n\r\ninterface DOML2DeprecatedBorderStyle {\r\n    border: string;\r\n}\r\n\r\ninterface NamedNodeMap {\r\n    length: number;\r\n    removeNamedItemNS(namespaceURI: string, localName: string): Attr;\r\n    item(index: number): Attr;\r\n    [index: number]: Attr;\r\n    removeNamedItem(name: string): Attr;\r\n    getNamedItem(name: string): Attr;\r\n    // [name: string]: Attr;\r\n    setNamedItem(arg: Attr): Attr;\r\n    getNamedItemNS(namespaceURI: string, localName: string): Attr;\r\n    setNamedItemNS(arg: Attr): Attr;\r\n}\r\ndeclare var NamedNodeMap: {\r\n    prototype: NamedNodeMap;\r\n    new(): NamedNodeMap;\r\n}\r\n\r\ninterface MediaList {\r\n    length: number;\r\n    mediaText: string;\r\n    deleteMedium(oldMedium: string): void;\r\n    appendMedium(newMedium: string): void;\r\n    item(index: number): string;\r\n    [index: number]: string;\r\n    toString(): string;\r\n}\r\ndeclare var MediaList: {\r\n    prototype: MediaList;\r\n    new(): MediaList;\r\n}\r\n\r\ninterface SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg {\r\n    y: number;\r\n    x: number;\r\n}\r\ndeclare var SVGPathSegCurvetoQuadraticSmoothAbs: {\r\n    prototype: SVGPathSegCurvetoQuadraticSmoothAbs;\r\n    new(): SVGPathSegCurvetoQuadraticSmoothAbs;\r\n}\r\n\r\ninterface SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg {\r\n    y: number;\r\n    x2: number;\r\n    x: number;\r\n    y2: number;\r\n}\r\ndeclare var SVGPathSegCurvetoCubicSmoothRel: {\r\n    prototype: SVGPathSegCurvetoCubicSmoothRel;\r\n    new(): SVGPathSegCurvetoCubicSmoothRel;\r\n}\r\n\r\ninterface SVGLengthList {\r\n    numberOfItems: number;\r\n    replaceItem(newItem: SVGLength, index: number): SVGLength;\r\n    getItem(index: number): SVGLength;\r\n    clear(): void;\r\n    appendItem(newItem: SVGLength): SVGLength;\r\n    initialize(newItem: SVGLength): SVGLength;\r\n    removeItem(index: number): SVGLength;\r\n    insertItemBefore(newItem: SVGLength, index: number): SVGLength;\r\n}\r\ndeclare var SVGLengthList: {\r\n    prototype: SVGLengthList;\r\n    new(): SVGLengthList;\r\n}\r\n\r\ninterface ProcessingInstruction extends Node {\r\n    target: string;\r\n    data: string;\r\n}\r\ndeclare var ProcessingInstruction: {\r\n    prototype: ProcessingInstruction;\r\n    new(): ProcessingInstruction;\r\n}\r\n\r\ninterface MSWindowExtensions {\r\n    status: string;\r\n    onmouseleave: (ev: MouseEvent) => any;\r\n    screenLeft: number;\r\n    offscreenBuffering: any;\r\n    maxConnectionsPerServer: number;\r\n    onmouseenter: (ev: MouseEvent) => any;\r\n    clipboardData: DataTransfer;\r\n    defaultStatus: string;\r\n    clientInformation: Navigator;\r\n    closed: boolean;\r\n    onhelp: (ev: Event) => any;\r\n    external: External;\r\n    event: MSEventObj;\r\n    onfocusout: (ev: FocusEvent) => any;\r\n    screenTop: number;\r\n    onfocusin: (ev: FocusEvent) => any;\r\n    showModelessDialog(url?: string, argument?: any, options?: any): Window;\r\n    navigate(url: string): void;\r\n    resizeBy(x?: number, y?: number): void;\r\n    item(index: any): any;\r\n    resizeTo(x?: number, y?: number): void;\r\n    createPopup(arguments?: any): MSPopupWindow;\r\n    toStaticHTML(html: string): string;\r\n    execScript(code: string, language?: string): any;\r\n    msWriteProfilerMark(profilerMarkName: string): void;\r\n    moveTo(x?: number, y?: number): void;\r\n    moveBy(x?: number, y?: number): void;\r\n    showHelp(url: string, helpArg?: any, features?: string): void;\r\n    captureEvents(): void;\r\n    releaseEvents(): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\n\r\ninterface MSBehaviorUrnsCollection {\r\n    length: number;\r\n    item(index: number): string;\r\n}\r\ndeclare var MSBehaviorUrnsCollection: {\r\n    prototype: MSBehaviorUrnsCollection;\r\n    new(): MSBehaviorUrnsCollection;\r\n}\r\n\r\ninterface CSSFontFaceRule extends CSSRule {\r\n    style: CSSStyleDeclaration;\r\n}\r\ndeclare var CSSFontFaceRule: {\r\n    prototype: CSSFontFaceRule;\r\n    new(): CSSFontFaceRule;\r\n}\r\n\r\ninterface DOML2DeprecatedBackgroundStyle {\r\n    background: string;\r\n}\r\n\r\ninterface TextEvent extends UIEvent {\r\n    inputMethod: number;\r\n    data: string;\r\n    locale: string;\r\n    initTextEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, dataArg: string, inputMethod: number, locale: string): void;\r\n    DOM_INPUT_METHOD_KEYBOARD: number;\r\n    DOM_INPUT_METHOD_DROP: number;\r\n    DOM_INPUT_METHOD_IME: number;\r\n    DOM_INPUT_METHOD_SCRIPT: number;\r\n    DOM_INPUT_METHOD_VOICE: number;\r\n    DOM_INPUT_METHOD_UNKNOWN: number;\r\n    DOM_INPUT_METHOD_PASTE: number;\r\n    DOM_INPUT_METHOD_HANDWRITING: number;\r\n    DOM_INPUT_METHOD_OPTION: number;\r\n    DOM_INPUT_METHOD_MULTIMODAL: number;\r\n}\r\ndeclare var TextEvent: {\r\n    prototype: TextEvent;\r\n    new(): TextEvent;\r\n    DOM_INPUT_METHOD_KEYBOARD: number;\r\n    DOM_INPUT_METHOD_DROP: number;\r\n    DOM_INPUT_METHOD_IME: number;\r\n    DOM_INPUT_METHOD_SCRIPT: number;\r\n    DOM_INPUT_METHOD_VOICE: number;\r\n    DOM_INPUT_METHOD_UNKNOWN: number;\r\n    DOM_INPUT_METHOD_PASTE: number;\r\n    DOM_INPUT_METHOD_HANDWRITING: number;\r\n    DOM_INPUT_METHOD_OPTION: number;\r\n    DOM_INPUT_METHOD_MULTIMODAL: number;\r\n}\r\n\r\ninterface DocumentFragment extends Node, NodeSelector, MSEventAttachmentTarget, MSNodeExtensions {\r\n}\r\ndeclare var DocumentFragment: {\r\n    prototype: DocumentFragment;\r\n    new(): DocumentFragment;\r\n}\r\n\r\ninterface SVGPolylineElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGAnimatedPoints, SVGTests, SVGExternalResourcesRequired {\r\n}\r\ndeclare var SVGPolylineElement: {\r\n    prototype: SVGPolylineElement;\r\n    new(): SVGPolylineElement;\r\n}\r\n\r\ninterface SVGAnimatedPathData {\r\n    pathSegList: SVGPathSegList;\r\n}\r\n\r\ninterface Position {\r\n    timestamp: Date;\r\n    coords: Coordinates;\r\n}\r\ndeclare var Position: {\r\n    prototype: Position;\r\n    new(): Position;\r\n}\r\n\r\ninterface BookmarkCollection {\r\n    length: number;\r\n    item(index: number): any;\r\n    [index: number]: any;\r\n}\r\ndeclare var BookmarkCollection: {\r\n    prototype: BookmarkCollection;\r\n    new(): BookmarkCollection;\r\n}\r\n\r\ninterface PerformanceMark extends PerformanceEntry {\r\n}\r\ndeclare var PerformanceMark: {\r\n    prototype: PerformanceMark;\r\n    new(): PerformanceMark;\r\n}\r\n\r\ninterface CSSPageRule extends CSSRule {\r\n    pseudoClass: string;\r\n    selectorText: string;\r\n    selector: string;\r\n    style: CSSStyleDeclaration;\r\n}\r\ndeclare var CSSPageRule: {\r\n    prototype: CSSPageRule;\r\n    new(): CSSPageRule;\r\n}\r\n\r\ninterface HTMLBRElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves the side on which floating objects are not to be positioned when any IHTMLBlockElement is inserted into the document.\r\n      */\r\n    clear: string;\r\n}\r\ndeclare var HTMLBRElement: {\r\n    prototype: HTMLBRElement;\r\n    new(): HTMLBRElement;\r\n}\r\n\r\ninterface MSNavigatorExtensions {\r\n    userLanguage: string;\r\n    plugins: MSPluginsCollection;\r\n    cookieEnabled: boolean;\r\n    appCodeName: string;\r\n    cpuClass: string;\r\n    appMinorVersion: string;\r\n    connectionSpeed: number;\r\n    browserLanguage: string;\r\n    mimeTypes: MSMimeTypesCollection;\r\n    systemLanguage: string;\r\n    language: string;\r\n    javaEnabled(): boolean;\r\n    taintEnabled(): boolean;\r\n}\r\n\r\ninterface HTMLSpanElement extends HTMLElement, MSDataBindingExtensions {\r\n}\r\ndeclare var HTMLSpanElement: {\r\n    prototype: HTMLSpanElement;\r\n    new(): HTMLSpanElement;\r\n}\r\n\r\ninterface HTMLHeadElement extends HTMLElement {\r\n    profile: string;\r\n}\r\ndeclare var HTMLHeadElement: {\r\n    prototype: HTMLHeadElement;\r\n    new(): HTMLHeadElement;\r\n}\r\n\r\ninterface HTMLHeadingElement extends HTMLElement, DOML2DeprecatedTextFlowControl {\r\n    /**\r\n      * Sets or retrieves a value that indicates the table alignment.\r\n      */\r\n    align: string;\r\n}\r\ndeclare var HTMLHeadingElement: {\r\n    prototype: HTMLHeadingElement;\r\n    new(): HTMLHeadingElement;\r\n}\r\n\r\ninterface HTMLFormElement extends HTMLElement, MSHTMLCollectionExtensions {\r\n    /**\r\n      * Sets or retrieves the number of objects in a collection.\r\n      */\r\n    length: number;\r\n    /**\r\n      * Sets or retrieves the window or frame at which to target content.\r\n      */\r\n    target: string;\r\n    /**\r\n      * Sets or retrieves a list of character encodings for input data that must be accepted by the server processing the form.\r\n      */\r\n    acceptCharset: string;\r\n    /**\r\n      * Sets or retrieves the encoding type for the form.\r\n      */\r\n    enctype: string;\r\n    /**\r\n      * Retrieves a collection, in source order, of all controls in a given form.\r\n      */\r\n    elements: HTMLCollection;\r\n    /**\r\n      * Sets or retrieves the URL to which the form content is sent for processing.\r\n      */\r\n    action: string;\r\n    /**\r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves how to send the form data to the server.\r\n      */\r\n    method: string;\r\n    /**\r\n      * Sets or retrieves the MIME encoding for the form.\r\n      */\r\n    encoding: string;\r\n    /**\r\n      * Specifies whether autocomplete is applied to an editable text field.\r\n      */\r\n    autocomplete: string;\r\n    /**\r\n      * Designates a form that is not validated when submitted.\r\n      */\r\n    noValidate: boolean;\r\n    /**\r\n      * Fires when the user resets a form.\r\n      */\r\n    reset(): void;\r\n    /**\r\n      * Retrieves a form object or an object from an elements collection.\r\n      * @param name Variant of type Number or String that specifies the object or collection to retrieve. If this parameter is a Number, it is the zero-based index of the object. If this parameter is a string, all objects with matching name or id properties are retrieved, and a collection is returned if more than one match is made.\r\n      * @param index Variant of type Number that specifies the zero-based index of the object to retrieve when a collection is returned.\r\n      */\r\n    item(name?: any, index?: any): any;\r\n    /**\r\n      * Fires when a FORM is about to be submitted.\r\n      */\r\n    submit(): void;\r\n    /**\r\n      * Retrieves a form object or an object from an elements collection.\r\n      */\r\n    namedItem(name: string): any;\r\n    [name: string]: any;\r\n    /**\r\n      * Returns whether a form will validate when it is submitted, without having to submit it.\r\n      */\r\n    checkValidity(): boolean;\r\n}\r\ndeclare var HTMLFormElement: {\r\n    prototype: HTMLFormElement;\r\n    new(): HTMLFormElement;\r\n}\r\n\r\ninterface SVGZoomAndPan {\r\n    zoomAndPan: number;\r\n    SVG_ZOOMANDPAN_MAGNIFY: number;\r\n    SVG_ZOOMANDPAN_UNKNOWN: number;\r\n    SVG_ZOOMANDPAN_DISABLE: number;\r\n}\r\ndeclare var SVGZoomAndPan: SVGZoomAndPan;\r\n\r\ninterface HTMLMediaElement extends HTMLElement {\r\n    /**\r\n      * Gets the earliest possible position, in seconds, that the playback can begin.\r\n      */\r\n    initialTime: number;\r\n    /**\r\n      * Gets TimeRanges for the current media resource that has been played.\r\n      */\r\n    played: TimeRanges;\r\n    /**\r\n      * Gets the address or URL of the current media resource that is selected by IHTMLMediaElement.\r\n      */\r\n    currentSrc: string;\r\n    readyState: any;\r\n    /**\r\n      * The autobuffer element is not supported by Internet Explorer 9. Use the preload element instead.\r\n      */\r\n    autobuffer: boolean;\r\n    /**\r\n      * Gets or sets a flag to specify whether playback should restart after it completes.\r\n      */\r\n    loop: boolean;\r\n    /**\r\n      * Gets information about whether the playback has ended or not.\r\n      */\r\n    ended: boolean;\r\n    /**\r\n      * Gets a collection of buffered time ranges.\r\n      */\r\n    buffered: TimeRanges;\r\n    /**\r\n      * Returns an object representing the current error state of the audio or video element.\r\n      */\r\n    error: MediaError;\r\n    /**\r\n      * Returns a TimeRanges object that represents the ranges of the current media resource that can be seeked.\r\n      */\r\n    seekable: TimeRanges;\r\n    /**\r\n      * Gets or sets a value that indicates whether to start playing the media automatically.\r\n      */\r\n    autoplay: boolean;\r\n    /**\r\n      * Gets or sets a flag that indicates whether the client provides a set of controls for the media (in case the developer does not include controls for the player).\r\n      */\r\n    controls: boolean;\r\n    /**\r\n      * Gets or sets the volume level for audio portions of the media element.\r\n      */\r\n    volume: number;\r\n    /**\r\n      * The address or URL of the a media resource that is to be considered.\r\n      */\r\n    src: string;\r\n    /**\r\n      * Gets or sets the current rate of speed for the media resource to play. This speed is expressed as a multiple of the normal speed of the media resource.\r\n      */\r\n    playbackRate: number;\r\n    /**\r\n      * Returns the duration in seconds of the current media resource. A NaN value is returned if duration is not available, or Infinity if the media resource is streaming.\r\n      */\r\n    duration: number;\r\n    /**\r\n      * Gets or sets a flag that indicates whether the audio (either audio or the audio track on video media) is muted.\r\n      */\r\n    muted: boolean;\r\n    /**\r\n      * Gets or sets the default playback rate when the user is not using fast forward or reverse for a video or audio resource.\r\n      */\r\n    defaultPlaybackRate: number;\r\n    /**\r\n      * Gets a flag that specifies whether playback is paused.\r\n      */\r\n    paused: boolean;\r\n    /**\r\n      * Gets a flag that indicates whether the the client is currently moving to a new playback position in the media resource.\r\n      */\r\n    seeking: boolean;\r\n    /**\r\n      * Gets or sets the current playback position, in seconds.\r\n      */\r\n    currentTime: number;\r\n    /**\r\n      * Gets or sets the current playback position, in seconds.\r\n      */\r\n    preload: string;\r\n    /**\r\n      * Gets the current network activity for the element.\r\n      */\r\n    networkState: number;\r\n    /**\r\n      * Specifies the purpose of the audio or video media, such as background audio or alerts.\r\n      */\r\n    msAudioCategory: string;\r\n    /**\r\n      * Specifies whether or not to enable low-latency playback on the media element.\r\n      */\r\n    msRealTime: boolean;\r\n    /**\r\n      * Gets or sets the primary DLNA PlayTo device.\r\n      */\r\n    msPlayToPrimary: boolean;\r\n    textTracks: TextTrackList;\r\n    /**\r\n      * Gets or sets whether the DLNA PlayTo device is available.\r\n      */\r\n    msPlayToDisabled: boolean;\r\n    /**\r\n      * Returns an AudioTrackList object with the audio tracks for a given video element.\r\n      */\r\n    audioTracks: AudioTrackList;\r\n    /**\r\n      * Gets the source associated with the media element for use by the PlayToManager.\r\n      */\r\n    msPlayToSource: any;\r\n    /**\r\n      * Specifies the output device id that the audio will be sent to.\r\n      */\r\n    msAudioDeviceType: string;\r\n    /**\r\n      * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\r\n      */\r\n    msPlayToPreferredSourceUri: string;\r\n    onmsneedkey: (ev: MSMediaKeyNeededEvent) => any;\r\n    /**\r\n      * Gets the MSMediaKeys object, which is used for decrypting media data, that is associated with this media element.\r\n      */\r\n    msKeys: MSMediaKeys;\r\n    msGraphicsTrustStatus: MSGraphicsTrust;\r\n    /**\r\n      * Pauses the current playback and sets paused to TRUE. This can be used to test whether the media is playing or paused. You can also use the pause or play events to tell whether the media is playing or not.\r\n      */\r\n    pause(): void;\r\n    /**\r\n      * Loads and starts playback of a media resource.\r\n      */\r\n    play(): void;\r\n    /**\r\n      * Fires immediately after the client loads the object.\r\n      */\r\n    load(): void;\r\n    /**\r\n      * Returns a string that specifies whether the client can play a given media resource type.\r\n      */\r\n    canPlayType(type: string): string;\r\n    /**\r\n      * Clears all effects from the media pipeline.\r\n      */\r\n    msClearEffects(): void;\r\n    /**\r\n      * Specifies the media protection manager for a given media pipeline.\r\n      */\r\n    msSetMediaProtectionManager(mediaProtectionManager?: any): void;\r\n    /**\r\n      * Inserts the specified audio effect into media pipeline.\r\n      */\r\n    msInsertAudioEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;\r\n    msSetMediaKeys(mediaKeys: MSMediaKeys): void;\r\n    addTextTrack(kind: string, label?: string, language?: string): TextTrack;\r\n    HAVE_METADATA: number;\r\n    HAVE_CURRENT_DATA: number;\r\n    HAVE_NOTHING: number;\r\n    NETWORK_NO_SOURCE: number;\r\n    HAVE_ENOUGH_DATA: number;\r\n    NETWORK_EMPTY: number;\r\n    NETWORK_LOADING: number;\r\n    NETWORK_IDLE: number;\r\n    HAVE_FUTURE_DATA: number;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"move\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"losecapture\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"layoutcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"filterchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforepaste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecopy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"paste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"moveend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizeend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"movestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"copy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msneedkey\", listener: (ev: MSMediaKeyNeededEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var HTMLMediaElement: {\r\n    prototype: HTMLMediaElement;\r\n    new(): HTMLMediaElement;\r\n    HAVE_METADATA: number;\r\n    HAVE_CURRENT_DATA: number;\r\n    HAVE_NOTHING: number;\r\n    NETWORK_NO_SOURCE: number;\r\n    HAVE_ENOUGH_DATA: number;\r\n    NETWORK_EMPTY: number;\r\n    NETWORK_LOADING: number;\r\n    NETWORK_IDLE: number;\r\n    HAVE_FUTURE_DATA: number;\r\n}\r\n\r\ninterface ElementCSSInlineStyle {\r\n    runtimeStyle: MSStyleCSSProperties;\r\n    currentStyle: MSCurrentStyleCSSProperties;\r\n    doScroll(component?: any): void;\r\n    componentFromPoint(x: number, y: number): string;\r\n}\r\n\r\ninterface DOMParser {\r\n    parseFromString(source: string, mimeType: string): Document;\r\n}\r\ndeclare var DOMParser: {\r\n    prototype: DOMParser;\r\n    new(): DOMParser;\r\n}\r\n\r\ninterface MSMimeTypesCollection {\r\n    length: number;\r\n}\r\ndeclare var MSMimeTypesCollection: {\r\n    prototype: MSMimeTypesCollection;\r\n    new(): MSMimeTypesCollection;\r\n}\r\n\r\ninterface StyleSheet {\r\n    disabled: boolean;\r\n    ownerNode: Node;\r\n    parentStyleSheet: StyleSheet;\r\n    href: string;\r\n    media: MediaList;\r\n    type: string;\r\n    title: string;\r\n}\r\ndeclare var StyleSheet: {\r\n    prototype: StyleSheet;\r\n    new(): StyleSheet;\r\n}\r\n\r\ninterface SVGTextPathElement extends SVGTextContentElement, SVGURIReference {\r\n    startOffset: SVGAnimatedLength;\r\n    method: SVGAnimatedEnumeration;\r\n    spacing: SVGAnimatedEnumeration;\r\n    TEXTPATH_SPACINGTYPE_EXACT: number;\r\n    TEXTPATH_METHODTYPE_STRETCH: number;\r\n    TEXTPATH_SPACINGTYPE_AUTO: number;\r\n    TEXTPATH_SPACINGTYPE_UNKNOWN: number;\r\n    TEXTPATH_METHODTYPE_UNKNOWN: number;\r\n    TEXTPATH_METHODTYPE_ALIGN: number;\r\n}\r\ndeclare var SVGTextPathElement: {\r\n    prototype: SVGTextPathElement;\r\n    new(): SVGTextPathElement;\r\n    TEXTPATH_SPACINGTYPE_EXACT: number;\r\n    TEXTPATH_METHODTYPE_STRETCH: number;\r\n    TEXTPATH_SPACINGTYPE_AUTO: number;\r\n    TEXTPATH_SPACINGTYPE_UNKNOWN: number;\r\n    TEXTPATH_METHODTYPE_UNKNOWN: number;\r\n    TEXTPATH_METHODTYPE_ALIGN: number;\r\n}\r\n\r\ninterface HTMLDTElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves whether the browser automatically performs wordwrap.\r\n      */\r\n    noWrap: boolean;\r\n}\r\ndeclare var HTMLDTElement: {\r\n    prototype: HTMLDTElement;\r\n    new(): HTMLDTElement;\r\n}\r\n\r\ninterface NodeList {\r\n    length: number;\r\n    item(index: number): Node;\r\n    [index: number]: Node;\r\n}\r\ndeclare var NodeList: {\r\n    prototype: NodeList;\r\n    new(): NodeList;\r\n}\r\n\r\ninterface XMLSerializer {\r\n    serializeToString(target: Node): string;\r\n}\r\ndeclare var XMLSerializer: {\r\n    prototype: XMLSerializer;\r\n    new(): XMLSerializer;\r\n}\r\n\r\ninterface PerformanceMeasure extends PerformanceEntry {\r\n}\r\ndeclare var PerformanceMeasure: {\r\n    prototype: PerformanceMeasure;\r\n    new(): PerformanceMeasure;\r\n}\r\n\r\ninterface SVGGradientElement extends SVGElement, SVGUnitTypes, SVGStylable, SVGExternalResourcesRequired, SVGURIReference {\r\n    spreadMethod: SVGAnimatedEnumeration;\r\n    gradientTransform: SVGAnimatedTransformList;\r\n    gradientUnits: SVGAnimatedEnumeration;\r\n    SVG_SPREADMETHOD_REFLECT: number;\r\n    SVG_SPREADMETHOD_PAD: number;\r\n    SVG_SPREADMETHOD_UNKNOWN: number;\r\n    SVG_SPREADMETHOD_REPEAT: number;\r\n}\r\ndeclare var SVGGradientElement: {\r\n    prototype: SVGGradientElement;\r\n    new(): SVGGradientElement;\r\n    SVG_SPREADMETHOD_REFLECT: number;\r\n    SVG_SPREADMETHOD_PAD: number;\r\n    SVG_SPREADMETHOD_UNKNOWN: number;\r\n    SVG_SPREADMETHOD_REPEAT: number;\r\n}\r\n\r\ninterface NodeFilter {\r\n    acceptNode(n: Node): number;\r\n    SHOW_ENTITY_REFERENCE: number;\r\n    SHOW_NOTATION: number;\r\n    SHOW_ENTITY: number;\r\n    SHOW_DOCUMENT: number;\r\n    SHOW_PROCESSING_INSTRUCTION: number;\r\n    FILTER_REJECT: number;\r\n    SHOW_CDATA_SECTION: number;\r\n    FILTER_ACCEPT: number;\r\n    SHOW_ALL: number;\r\n    SHOW_DOCUMENT_TYPE: number;\r\n    SHOW_TEXT: number;\r\n    SHOW_ELEMENT: number;\r\n    SHOW_COMMENT: number;\r\n    FILTER_SKIP: number;\r\n    SHOW_ATTRIBUTE: number;\r\n    SHOW_DOCUMENT_FRAGMENT: number;\r\n}\r\ndeclare var NodeFilter: NodeFilter;\r\n\r\ninterface SVGNumberList {\r\n    numberOfItems: number;\r\n    replaceItem(newItem: SVGNumber, index: number): SVGNumber;\r\n    getItem(index: number): SVGNumber;\r\n    clear(): void;\r\n    appendItem(newItem: SVGNumber): SVGNumber;\r\n    initialize(newItem: SVGNumber): SVGNumber;\r\n    removeItem(index: number): SVGNumber;\r\n    insertItemBefore(newItem: SVGNumber, index: number): SVGNumber;\r\n}\r\ndeclare var SVGNumberList: {\r\n    prototype: SVGNumberList;\r\n    new(): SVGNumberList;\r\n}\r\n\r\ninterface MediaError {\r\n    code: number;\r\n    msExtendedCode: number;\r\n    MEDIA_ERR_ABORTED: number;\r\n    MEDIA_ERR_NETWORK: number;\r\n    MEDIA_ERR_SRC_NOT_SUPPORTED: number;\r\n    MEDIA_ERR_DECODE: number;\r\n    MS_MEDIA_ERR_ENCRYPTED: number;\r\n}\r\ndeclare var MediaError: {\r\n    prototype: MediaError;\r\n    new(): MediaError;\r\n    MEDIA_ERR_ABORTED: number;\r\n    MEDIA_ERR_NETWORK: number;\r\n    MEDIA_ERR_SRC_NOT_SUPPORTED: number;\r\n    MEDIA_ERR_DECODE: number;\r\n    MS_MEDIA_ERR_ENCRYPTED: number;\r\n}\r\n\r\ninterface HTMLFieldSetElement extends HTMLElement {\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n    /**\r\n      * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\r\n      */\r\n    validationMessage: string;\r\n    /**\r\n      * Returns a  ValidityState object that represents the validity states of an element.\r\n      */\r\n    validity: ValidityState;\r\n    /**\r\n      * Returns whether an element will successfully validate based on forms validation rules and constraints.\r\n      */\r\n    willValidate: boolean;\r\n    /**\r\n      * Returns whether a form will validate when it is submitted, without having to submit it.\r\n      */\r\n    checkValidity(): boolean;\r\n    /**\r\n      * Sets a custom error message that is displayed when a form is submitted.\r\n      * @param error Sets a custom error message that is displayed when a form is submitted.\r\n      */\r\n    setCustomValidity(error: string): void;\r\n}\r\ndeclare var HTMLFieldSetElement: {\r\n    prototype: HTMLFieldSetElement;\r\n    new(): HTMLFieldSetElement;\r\n}\r\n\r\ninterface HTMLBGSoundElement extends HTMLElement {\r\n    /**\r\n      * Sets or gets the value indicating how the volume of the background sound is divided between the left speaker and the right speaker.\r\n      */\r\n    balance: any;\r\n    /**\r\n      * Sets or gets the volume setting for the sound. \r\n      */\r\n    volume: any;\r\n    /**\r\n      * Sets or gets the URL of a sound to play.\r\n      */\r\n    src: string;\r\n    /**\r\n      * Sets or retrieves the number of times a sound or video clip will loop when activated.\r\n      */\r\n    loop: number;\r\n}\r\ndeclare var HTMLBGSoundElement: {\r\n    prototype: HTMLBGSoundElement;\r\n    new(): HTMLBGSoundElement;\r\n}\r\n\r\ninterface Comment extends CharacterData {\r\n    text: string;\r\n}\r\ndeclare var Comment: {\r\n    prototype: Comment;\r\n    new(): Comment;\r\n}\r\n\r\ninterface PerformanceResourceTiming extends PerformanceEntry {\r\n    redirectStart: number;\r\n    redirectEnd: number;\r\n    domainLookupEnd: number;\r\n    responseStart: number;\r\n    domainLookupStart: number;\r\n    fetchStart: number;\r\n    requestStart: number;\r\n    connectEnd: number;\r\n    connectStart: number;\r\n    initiatorType: string;\r\n    responseEnd: number;\r\n}\r\ndeclare var PerformanceResourceTiming: {\r\n    prototype: PerformanceResourceTiming;\r\n    new(): PerformanceResourceTiming;\r\n}\r\n\r\ninterface CanvasPattern {\r\n}\r\ndeclare var CanvasPattern: {\r\n    prototype: CanvasPattern;\r\n    new(): CanvasPattern;\r\n}\r\n\r\ninterface HTMLHRElement extends HTMLElement, DOML2DeprecatedColorProperty, DOML2DeprecatedSizeProperty {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: number;\r\n    /**\r\n      * Sets or retrieves how the object is aligned with adjacent text.\r\n      */\r\n    align: string;\r\n    /**\r\n      * Sets or retrieves whether the horizontal rule is drawn with 3-D shading.\r\n      */\r\n    noShade: boolean;\r\n}\r\ndeclare var HTMLHRElement: {\r\n    prototype: HTMLHRElement;\r\n    new(): HTMLHRElement;\r\n}\r\n\r\ninterface HTMLObjectElement extends HTMLElement, GetSVGDocument, DOML2DeprecatedMarginStyle, DOML2DeprecatedBorderStyle, DOML2DeprecatedAlignmentStyle, MSDataBindingExtensions, MSDataBindingRecordSetExtensions {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: string;\r\n    /**\r\n      * Sets or retrieves the Internet media type for the code associated with the object.\r\n      */\r\n    codeType: string;\r\n    /**\r\n      * Retrieves the contained object.\r\n      */\r\n    object: any;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n    /**\r\n      * Sets or retrieves the URL of the file containing the compiled Java class.\r\n      */\r\n    code: string;\r\n    /**\r\n      * Sets or retrieves a character string that can be used to implement your own archive functionality for the object.\r\n      */\r\n    archive: string;\r\n    /**\r\n      * Sets or retrieves a message to be displayed while an object is loading.\r\n      */\r\n    standby: string;\r\n    /**\r\n      * Sets or retrieves a text alternative to the graphic.\r\n      */\r\n    alt: string;\r\n    /**\r\n      * Sets or retrieves the class identifier for the object.\r\n      */\r\n    classid: string;\r\n    /**\r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    /**\r\n      * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\r\n      */\r\n    useMap: string;\r\n    /**\r\n      * Sets or retrieves the URL that references the data of the object.\r\n      */\r\n    data: string;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: string;\r\n    /**\r\n      * Retrieves the document object of the page or frame.\r\n      */\r\n    contentDocument: Document;\r\n    /**\r\n      * Gets or sets the optional alternative HTML script to execute if the object fails to load.\r\n      */\r\n    altHtml: string;\r\n    /**\r\n      * Sets or retrieves the URL of the component.\r\n      */\r\n    codeBase: string;\r\n    declare: boolean;\r\n    /**\r\n      * Sets or retrieves the MIME type of the object.\r\n      */\r\n    type: string;\r\n    /**\r\n      * Retrieves a string of the URL where the object tag can be found. This is often the href of the document that the object is in, or the value set by a base element.\r\n      */\r\n    BaseHref: string;\r\n    /**\r\n      * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as \"this is a required field\". The result is that the user sees validation messages without actually submitting.\r\n      */\r\n    validationMessage: string;\r\n    /**\r\n      * Returns a  ValidityState object that represents the validity states of an element.\r\n      */\r\n    validity: ValidityState;\r\n    /**\r\n      * Returns whether an element will successfully validate based on forms validation rules and constraints.\r\n      */\r\n    willValidate: boolean;\r\n    /**\r\n      * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\r\n      */\r\n    msPlayToPreferredSourceUri: string;\r\n    /**\r\n      * Gets or sets the primary DLNA PlayTo device.\r\n      */\r\n    msPlayToPrimary: boolean;\r\n    /**\r\n      * Gets or sets whether the DLNA PlayTo device is available.\r\n      */\r\n    msPlayToDisabled: boolean;\r\n    readyState: number;\r\n    /**\r\n      * Gets the source associated with the media element for use by the PlayToManager.\r\n      */\r\n    msPlayToSource: any;\r\n    /**\r\n      * Returns whether a form will validate when it is submitted, without having to submit it.\r\n      */\r\n    checkValidity(): boolean;\r\n    /**\r\n      * Sets a custom error message that is displayed when a form is submitted.\r\n      * @param error Sets a custom error message that is displayed when a form is submitted.\r\n      */\r\n    setCustomValidity(error: string): void;\r\n}\r\ndeclare var HTMLObjectElement: {\r\n    prototype: HTMLObjectElement;\r\n    new(): HTMLObjectElement;\r\n}\r\n\r\ninterface HTMLEmbedElement extends HTMLElement, GetSVGDocument {\r\n    /**\r\n      * Sets or retrieves the width of the object.\r\n      */\r\n    width: string;\r\n    /**\r\n      * Retrieves the palette used for the embedded document.\r\n      */\r\n    palette: string;\r\n    /**\r\n      * Sets or retrieves a URL to be loaded by the object.\r\n      */\r\n    src: string;\r\n    /**\r\n      * Sets or retrieves the name of the object.\r\n      */\r\n    name: string;\r\n    hidden: string;\r\n    /**\r\n      * Retrieves the URL of the plug-in used to view an embedded document.\r\n      */\r\n    pluginspage: string;\r\n    /**\r\n      * Sets or retrieves the height of the object.\r\n      */\r\n    height: string;\r\n    /**\r\n      * Sets or retrieves the height and width units of the embed object.\r\n      */\r\n    units: string;\r\n    /**\r\n      * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\r\n      */\r\n    msPlayToPreferredSourceUri: string;\r\n    /**\r\n      * Gets or sets the primary DLNA PlayTo device.\r\n      */\r\n    msPlayToPrimary: boolean;\r\n    /**\r\n      * Gets or sets whether the DLNA PlayTo device is available.\r\n      */\r\n    msPlayToDisabled: boolean;\r\n    readyState: string;\r\n    /**\r\n      * Gets the source associated with the media element for use by the PlayToManager.\r\n      */\r\n    msPlayToSource: any;\r\n}\r\ndeclare var HTMLEmbedElement: {\r\n    prototype: HTMLEmbedElement;\r\n    new(): HTMLEmbedElement;\r\n}\r\n\r\ninterface StorageEvent extends Event {\r\n    oldValue: any;\r\n    newValue: any;\r\n    url: string;\r\n    storageArea: Storage;\r\n    key: string;\r\n    initStorageEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, keyArg: string, oldValueArg: any, newValueArg: any, urlArg: string, storageAreaArg: Storage): void;\r\n}\r\ndeclare var StorageEvent: {\r\n    prototype: StorageEvent;\r\n    new(): StorageEvent;\r\n}\r\n\r\ninterface CharacterData extends Node {\r\n    length: number;\r\n    data: string;\r\n    deleteData(offset: number, count: number): void;\r\n    replaceData(offset: number, count: number, arg: string): void;\r\n    appendData(arg: string): void;\r\n    insertData(offset: number, arg: string): void;\r\n    substringData(offset: number, count: number): string;\r\n}\r\ndeclare var CharacterData: {\r\n    prototype: CharacterData;\r\n    new(): CharacterData;\r\n}\r\n\r\ninterface HTMLOptGroupElement extends HTMLElement, MSDataBindingExtensions {\r\n    /**\r\n      * Sets or retrieves the ordinal position of an option in a list box.\r\n      */\r\n    index: number;\r\n    /**\r\n      * Sets or retrieves the status of an option.\r\n      */\r\n    defaultSelected: boolean;\r\n    /**\r\n      * Sets or retrieves the text string specified by the option tag.\r\n      */\r\n    text: string;\r\n    /**\r\n      * Sets or retrieves the value which is returned to the server when the form control is submitted.\r\n      */\r\n    value: string;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n    /**\r\n      * Sets or retrieves a value that you can use to implement your own label functionality for the object.\r\n      */\r\n    label: string;\r\n    /**\r\n      * Sets or retrieves whether the option in the list box is the default item.\r\n      */\r\n    selected: boolean;\r\n}\r\ndeclare var HTMLOptGroupElement: {\r\n    prototype: HTMLOptGroupElement;\r\n    new(): HTMLOptGroupElement;\r\n}\r\n\r\ninterface HTMLIsIndexElement extends HTMLElement {\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in. \r\n      */\r\n    form: HTMLFormElement;\r\n    /**\r\n      * Sets or retrieves the URL to which the form content is sent for processing.\r\n      */\r\n    action: string;\r\n    prompt: string;\r\n}\r\ndeclare var HTMLIsIndexElement: {\r\n    prototype: HTMLIsIndexElement;\r\n    new(): HTMLIsIndexElement;\r\n}\r\n\r\ninterface SVGPathSegLinetoRel extends SVGPathSeg {\r\n    y: number;\r\n    x: number;\r\n}\r\ndeclare var SVGPathSegLinetoRel: {\r\n    prototype: SVGPathSegLinetoRel;\r\n    new(): SVGPathSegLinetoRel;\r\n}\r\n\r\ninterface DOMException {\r\n    code: number;\r\n    message: string;\r\n    name: string;\r\n    toString(): string;\r\n    HIERARCHY_REQUEST_ERR: number;\r\n    NO_MODIFICATION_ALLOWED_ERR: number;\r\n    INVALID_MODIFICATION_ERR: number;\r\n    NAMESPACE_ERR: number;\r\n    INVALID_CHARACTER_ERR: number;\r\n    TYPE_MISMATCH_ERR: number;\r\n    ABORT_ERR: number;\r\n    INVALID_STATE_ERR: number;\r\n    SECURITY_ERR: number;\r\n    NETWORK_ERR: number;\r\n    WRONG_DOCUMENT_ERR: number;\r\n    QUOTA_EXCEEDED_ERR: number;\r\n    INDEX_SIZE_ERR: number;\r\n    DOMSTRING_SIZE_ERR: number;\r\n    SYNTAX_ERR: number;\r\n    SERIALIZE_ERR: number;\r\n    VALIDATION_ERR: number;\r\n    NOT_FOUND_ERR: number;\r\n    URL_MISMATCH_ERR: number;\r\n    PARSE_ERR: number;\r\n    NO_DATA_ALLOWED_ERR: number;\r\n    NOT_SUPPORTED_ERR: number;\r\n    INVALID_ACCESS_ERR: number;\r\n    INUSE_ATTRIBUTE_ERR: number;\r\n    INVALID_NODE_TYPE_ERR: number;\r\n    DATA_CLONE_ERR: number;\r\n    TIMEOUT_ERR: number;\r\n}\r\ndeclare var DOMException: {\r\n    prototype: DOMException;\r\n    new(): DOMException;\r\n    HIERARCHY_REQUEST_ERR: number;\r\n    NO_MODIFICATION_ALLOWED_ERR: number;\r\n    INVALID_MODIFICATION_ERR: number;\r\n    NAMESPACE_ERR: number;\r\n    INVALID_CHARACTER_ERR: number;\r\n    TYPE_MISMATCH_ERR: number;\r\n    ABORT_ERR: number;\r\n    INVALID_STATE_ERR: number;\r\n    SECURITY_ERR: number;\r\n    NETWORK_ERR: number;\r\n    WRONG_DOCUMENT_ERR: number;\r\n    QUOTA_EXCEEDED_ERR: number;\r\n    INDEX_SIZE_ERR: number;\r\n    DOMSTRING_SIZE_ERR: number;\r\n    SYNTAX_ERR: number;\r\n    SERIALIZE_ERR: number;\r\n    VALIDATION_ERR: number;\r\n    NOT_FOUND_ERR: number;\r\n    URL_MISMATCH_ERR: number;\r\n    PARSE_ERR: number;\r\n    NO_DATA_ALLOWED_ERR: number;\r\n    NOT_SUPPORTED_ERR: number;\r\n    INVALID_ACCESS_ERR: number;\r\n    INUSE_ATTRIBUTE_ERR: number;\r\n    INVALID_NODE_TYPE_ERR: number;\r\n    DATA_CLONE_ERR: number;\r\n    TIMEOUT_ERR: number;\r\n}\r\n\r\ninterface SVGAnimatedBoolean {\r\n    animVal: boolean;\r\n    baseVal: boolean;\r\n}\r\ndeclare var SVGAnimatedBoolean: {\r\n    prototype: SVGAnimatedBoolean;\r\n    new(): SVGAnimatedBoolean;\r\n}\r\n\r\ninterface MSCompatibleInfoCollection {\r\n    length: number;\r\n    item(index: number): MSCompatibleInfo;\r\n}\r\ndeclare var MSCompatibleInfoCollection: {\r\n    prototype: MSCompatibleInfoCollection;\r\n    new(): MSCompatibleInfoCollection;\r\n}\r\n\r\ninterface SVGSwitchElement extends SVGElement, SVGStylable, SVGTransformable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n}\r\ndeclare var SVGSwitchElement: {\r\n    prototype: SVGSwitchElement;\r\n    new(): SVGSwitchElement;\r\n}\r\n\r\ninterface SVGPreserveAspectRatio {\r\n    align: number;\r\n    meetOrSlice: number;\r\n    SVG_PRESERVEASPECTRATIO_NONE: number;\r\n    SVG_PRESERVEASPECTRATIO_XMINYMID: number;\r\n    SVG_PRESERVEASPECTRATIO_XMAXYMIN: number;\r\n    SVG_PRESERVEASPECTRATIO_XMINYMAX: number;\r\n    SVG_PRESERVEASPECTRATIO_XMAXYMAX: number;\r\n    SVG_MEETORSLICE_UNKNOWN: number;\r\n    SVG_PRESERVEASPECTRATIO_XMAXYMID: number;\r\n    SVG_PRESERVEASPECTRATIO_XMIDYMAX: number;\r\n    SVG_PRESERVEASPECTRATIO_XMINYMIN: number;\r\n    SVG_MEETORSLICE_MEET: number;\r\n    SVG_PRESERVEASPECTRATIO_XMIDYMID: number;\r\n    SVG_PRESERVEASPECTRATIO_XMIDYMIN: number;\r\n    SVG_MEETORSLICE_SLICE: number;\r\n    SVG_PRESERVEASPECTRATIO_UNKNOWN: number;\r\n}\r\ndeclare var SVGPreserveAspectRatio: {\r\n    prototype: SVGPreserveAspectRatio;\r\n    new(): SVGPreserveAspectRatio;\r\n    SVG_PRESERVEASPECTRATIO_NONE: number;\r\n    SVG_PRESERVEASPECTRATIO_XMINYMID: number;\r\n    SVG_PRESERVEASPECTRATIO_XMAXYMIN: number;\r\n    SVG_PRESERVEASPECTRATIO_XMINYMAX: number;\r\n    SVG_PRESERVEASPECTRATIO_XMAXYMAX: number;\r\n    SVG_MEETORSLICE_UNKNOWN: number;\r\n    SVG_PRESERVEASPECTRATIO_XMAXYMID: number;\r\n    SVG_PRESERVEASPECTRATIO_XMIDYMAX: number;\r\n    SVG_PRESERVEASPECTRATIO_XMINYMIN: number;\r\n    SVG_MEETORSLICE_MEET: number;\r\n    SVG_PRESERVEASPECTRATIO_XMIDYMID: number;\r\n    SVG_PRESERVEASPECTRATIO_XMIDYMIN: number;\r\n    SVG_MEETORSLICE_SLICE: number;\r\n    SVG_PRESERVEASPECTRATIO_UNKNOWN: number;\r\n}\r\n\r\ninterface Attr extends Node {\r\n    expando: boolean;\r\n    specified: boolean;\r\n    ownerElement: Element;\r\n    value: string;\r\n    name: string;\r\n}\r\ndeclare var Attr: {\r\n    prototype: Attr;\r\n    new(): Attr;\r\n}\r\n\r\ninterface PerformanceNavigation {\r\n    redirectCount: number;\r\n    type: number;\r\n    toJSON(): any;\r\n    TYPE_RELOAD: number;\r\n    TYPE_RESERVED: number;\r\n    TYPE_BACK_FORWARD: number;\r\n    TYPE_NAVIGATE: number;\r\n}\r\ndeclare var PerformanceNavigation: {\r\n    prototype: PerformanceNavigation;\r\n    new(): PerformanceNavigation;\r\n    TYPE_RELOAD: number;\r\n    TYPE_RESERVED: number;\r\n    TYPE_BACK_FORWARD: number;\r\n    TYPE_NAVIGATE: number;\r\n}\r\n\r\ninterface SVGStopElement extends SVGElement, SVGStylable {\r\n    offset: SVGAnimatedNumber;\r\n}\r\ndeclare var SVGStopElement: {\r\n    prototype: SVGStopElement;\r\n    new(): SVGStopElement;\r\n}\r\n\r\ninterface PositionCallback {\r\n    (position: Position): void;\r\n}\r\n\r\ninterface SVGSymbolElement extends SVGElement, SVGStylable, SVGLangSpace, SVGFitToViewBox, SVGExternalResourcesRequired {\r\n}\r\ndeclare var SVGSymbolElement: {\r\n    prototype: SVGSymbolElement;\r\n    new(): SVGSymbolElement;\r\n}\r\n\r\ninterface SVGElementInstanceList {\r\n    length: number;\r\n    item(index: number): SVGElementInstance;\r\n}\r\ndeclare var SVGElementInstanceList: {\r\n    prototype: SVGElementInstanceList;\r\n    new(): SVGElementInstanceList;\r\n}\r\n\r\ninterface CSSRuleList {\r\n    length: number;\r\n    item(index: number): CSSRule;\r\n    [index: number]: CSSRule;\r\n}\r\ndeclare var CSSRuleList: {\r\n    prototype: CSSRuleList;\r\n    new(): CSSRuleList;\r\n}\r\n\r\ninterface MSDataBindingRecordSetExtensions {\r\n    recordset: any;\r\n    namedRecordset(dataMember: string, hierarchy?: any): any;\r\n}\r\n\r\ninterface LinkStyle {\r\n    styleSheet: StyleSheet;\r\n    sheet: StyleSheet;\r\n}\r\n\r\ninterface HTMLVideoElement extends HTMLMediaElement {\r\n    /**\r\n      * Gets or sets the width of the video element.\r\n      */\r\n    width: number;\r\n    /**\r\n      * Gets the intrinsic width of a video in CSS pixels, or zero if the dimensions are not known.\r\n      */\r\n    videoWidth: number;\r\n    /**\r\n      * Gets the intrinsic height of a video in CSS pixels, or zero if the dimensions are not known.\r\n      */\r\n    videoHeight: number;\r\n    /**\r\n      * Gets or sets the height of the video element.\r\n      */\r\n    height: number;\r\n    /**\r\n      * Gets or sets a URL of an image to display, for example, like a movie poster. This can be a still frame from the video, or another image if no video data is available.\r\n      */\r\n    poster: string;\r\n    msIsStereo3D: boolean;\r\n    msStereo3DPackingMode: string;\r\n    onMSVideoOptimalLayoutChanged: (ev: any) => any;\r\n    onMSVideoFrameStepCompleted: (ev: any) => any;\r\n    msStereo3DRenderMode: string;\r\n    msIsLayoutOptimalForPlayback: boolean;\r\n    msHorizontalMirror: boolean;\r\n    onMSVideoFormatChanged: (ev: any) => any;\r\n    msZoom: boolean;\r\n    msInsertVideoEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;\r\n    msSetVideoRectangle(left: number, top: number, right: number, bottom: number): void;\r\n    msFrameStep(forward: boolean): void;\r\n    getVideoPlaybackQuality(): VideoPlaybackQuality;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgotpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mslostpointercapture\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"lostpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"gotpointercapture\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"move\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"deactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetchanged\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsdelete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"losecapture\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"controlselect\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"layoutcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"filterchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"datasetcomplete\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"errorupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cellchange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowexit\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowsinserted\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"propertychange\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforepaste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforecopy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"paste\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"moveend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforeeditfocus\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"afterupdate\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resizeend\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"dataavailable\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"beforedeactivate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"activate\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"movestart\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"selectstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cut\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"copy\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"rowenter\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"mscontentzoom\", listener: (ev: MSEventObj) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msmanipulationstatechanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"msneedkey\", listener: (ev: MSMediaKeyNeededEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"MSVideoOptimalLayoutChanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"MSVideoFrameStepCompleted\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"MSVideoFormatChanged\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var HTMLVideoElement: {\r\n    prototype: HTMLVideoElement;\r\n    new(): HTMLVideoElement;\r\n}\r\n\r\ninterface ClientRectList {\r\n    length: number;\r\n    item(index: number): ClientRect;\r\n    [index: number]: ClientRect;\r\n}\r\ndeclare var ClientRectList: {\r\n    prototype: ClientRectList;\r\n    new(): ClientRectList;\r\n}\r\n\r\ninterface SVGMaskElement extends SVGElement, SVGUnitTypes, SVGStylable, SVGLangSpace, SVGTests, SVGExternalResourcesRequired {\r\n    y: SVGAnimatedLength;\r\n    width: SVGAnimatedLength;\r\n    maskUnits: SVGAnimatedEnumeration;\r\n    maskContentUnits: SVGAnimatedEnumeration;\r\n    x: SVGAnimatedLength;\r\n    height: SVGAnimatedLength;\r\n}\r\ndeclare var SVGMaskElement: {\r\n    prototype: SVGMaskElement;\r\n    new(): SVGMaskElement;\r\n}\r\n\r\ninterface External {\r\n}\r\ndeclare var External: {\r\n    prototype: External;\r\n    new(): External;\r\n}\r\n\r\ninterface MSGestureEvent extends UIEvent {\r\n    offsetY: number;\r\n    translationY: number;\r\n    velocityExpansion: number;\r\n    velocityY: number;\r\n    velocityAngular: number;\r\n    translationX: number;\r\n    velocityX: number;\r\n    hwTimestamp: number;\r\n    offsetX: number;\r\n    screenX: number;\r\n    rotation: number;\r\n    expansion: number;\r\n    clientY: number;\r\n    screenY: number;\r\n    scale: number;\r\n    gestureObject: any;\r\n    clientX: number;\r\n    initGestureEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, offsetXArg: number, offsetYArg: number, translationXArg: number, translationYArg: number, scaleArg: number, expansionArg: number, rotationArg: number, velocityXArg: number, velocityYArg: number, velocityExpansionArg: number, velocityAngularArg: number, hwTimestampArg: number): void;\r\n    MSGESTURE_FLAG_BEGIN: number;\r\n    MSGESTURE_FLAG_END: number;\r\n    MSGESTURE_FLAG_CANCEL: number;\r\n    MSGESTURE_FLAG_INERTIA: number;\r\n    MSGESTURE_FLAG_NONE: number;\r\n}\r\ndeclare var MSGestureEvent: {\r\n    prototype: MSGestureEvent;\r\n    new(): MSGestureEvent;\r\n    MSGESTURE_FLAG_BEGIN: number;\r\n    MSGESTURE_FLAG_END: number;\r\n    MSGESTURE_FLAG_CANCEL: number;\r\n    MSGESTURE_FLAG_INERTIA: number;\r\n    MSGESTURE_FLAG_NONE: number;\r\n}\r\n\r\ninterface ErrorEvent extends Event {\r\n    colno: number;\r\n    filename: string;\r\n    error: any;\r\n    lineno: number;\r\n    message: string;\r\n    initErrorEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, messageArg: string, filenameArg: string, linenoArg: number): void;\r\n}\r\ndeclare var ErrorEvent: {\r\n    prototype: ErrorEvent;\r\n    new(): ErrorEvent;\r\n}\r\n\r\ninterface SVGFilterElement extends SVGElement, SVGUnitTypes, SVGStylable, SVGLangSpace, SVGURIReference, SVGExternalResourcesRequired {\r\n    y: SVGAnimatedLength;\r\n    width: SVGAnimatedLength;\r\n    filterResX: SVGAnimatedInteger;\r\n    filterUnits: SVGAnimatedEnumeration;\r\n    primitiveUnits: SVGAnimatedEnumeration;\r\n    x: SVGAnimatedLength;\r\n    height: SVGAnimatedLength;\r\n    filterResY: SVGAnimatedInteger;\r\n    setFilterRes(filterResX: number, filterResY: number): void;\r\n}\r\ndeclare var SVGFilterElement: {\r\n    prototype: SVGFilterElement;\r\n    new(): SVGFilterElement;\r\n}\r\n\r\ninterface TrackEvent extends Event {\r\n    track: any;\r\n}\r\ndeclare var TrackEvent: {\r\n    prototype: TrackEvent;\r\n    new(): TrackEvent;\r\n}\r\n\r\ninterface SVGFEMergeNodeElement extends SVGElement {\r\n    in1: SVGAnimatedString;\r\n}\r\ndeclare var SVGFEMergeNodeElement: {\r\n    prototype: SVGFEMergeNodeElement;\r\n    new(): SVGFEMergeNodeElement;\r\n}\r\n\r\ninterface SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n}\r\ndeclare var SVGFEFloodElement: {\r\n    prototype: SVGFEFloodElement;\r\n    new(): SVGFEFloodElement;\r\n}\r\n\r\ninterface MSGesture {\r\n    target: Element;\r\n    addPointer(pointerId: number): void;\r\n    stop(): void;\r\n}\r\ndeclare var MSGesture: {\r\n    prototype: MSGesture;\r\n    new(): MSGesture;\r\n}\r\n\r\ninterface TextTrackCue extends EventTarget {\r\n    onenter: (ev: Event) => any;\r\n    track: TextTrack;\r\n    endTime: number;\r\n    text: string;\r\n    pauseOnExit: boolean;\r\n    id: string;\r\n    startTime: number;\r\n    onexit: (ev: Event) => any;\r\n    getCueAsHTML(): DocumentFragment;\r\n    addEventListener(type: \"enter\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"exit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var TextTrackCue: {\r\n    prototype: TextTrackCue;\r\n    new(startTime: number, endTime: number, text: string): TextTrackCue;\r\n}\r\n\r\ninterface MSStreamReader extends MSBaseReader {\r\n    error: DOMError;\r\n    readAsArrayBuffer(stream: MSStream, size?: number): void;\r\n    readAsBlob(stream: MSStream, size?: number): void;\r\n    readAsDataURL(stream: MSStream, size?: number): void;\r\n    readAsText(stream: MSStream, encoding?: string, size?: number): void;\r\n}\r\ndeclare var MSStreamReader: {\r\n    prototype: MSStreamReader;\r\n    new(): MSStreamReader;\r\n}\r\n\r\ninterface DOMTokenList {\r\n    length: number;\r\n    contains(token: string): boolean;\r\n    remove(token: string): void;\r\n    toggle(token: string): boolean;\r\n    add(token: string): void;\r\n    item(index: number): string;\r\n    [index: number]: string;\r\n    toString(): string;\r\n}\r\ndeclare var DOMTokenList: {\r\n    prototype: DOMTokenList;\r\n    new(): DOMTokenList;\r\n}\r\n\r\ninterface SVGFEFuncAElement extends SVGComponentTransferFunctionElement {\r\n}\r\ndeclare var SVGFEFuncAElement: {\r\n    prototype: SVGFEFuncAElement;\r\n    new(): SVGFEFuncAElement;\r\n}\r\n\r\ninterface SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    in1: SVGAnimatedString;\r\n}\r\ndeclare var SVGFETileElement: {\r\n    prototype: SVGFETileElement;\r\n    new(): SVGFETileElement;\r\n}\r\n\r\ninterface SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    in2: SVGAnimatedString;\r\n    mode: SVGAnimatedEnumeration;\r\n    in1: SVGAnimatedString;\r\n    SVG_FEBLEND_MODE_DARKEN: number;\r\n    SVG_FEBLEND_MODE_UNKNOWN: number;\r\n    SVG_FEBLEND_MODE_MULTIPLY: number;\r\n    SVG_FEBLEND_MODE_NORMAL: number;\r\n    SVG_FEBLEND_MODE_SCREEN: number;\r\n    SVG_FEBLEND_MODE_LIGHTEN: number;\r\n}\r\ndeclare var SVGFEBlendElement: {\r\n    prototype: SVGFEBlendElement;\r\n    new(): SVGFEBlendElement;\r\n    SVG_FEBLEND_MODE_DARKEN: number;\r\n    SVG_FEBLEND_MODE_UNKNOWN: number;\r\n    SVG_FEBLEND_MODE_MULTIPLY: number;\r\n    SVG_FEBLEND_MODE_NORMAL: number;\r\n    SVG_FEBLEND_MODE_SCREEN: number;\r\n    SVG_FEBLEND_MODE_LIGHTEN: number;\r\n}\r\n\r\ninterface MessageChannel {\r\n    port2: MessagePort;\r\n    port1: MessagePort;\r\n}\r\ndeclare var MessageChannel: {\r\n    prototype: MessageChannel;\r\n    new(): MessageChannel;\r\n}\r\n\r\ninterface SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n}\r\ndeclare var SVGFEMergeElement: {\r\n    prototype: SVGFEMergeElement;\r\n    new(): SVGFEMergeElement;\r\n}\r\n\r\ninterface TransitionEvent extends Event {\r\n    propertyName: string;\r\n    elapsedTime: number;\r\n    initTransitionEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, propertyNameArg: string, elapsedTimeArg: number): void;\r\n}\r\ndeclare var TransitionEvent: {\r\n    prototype: TransitionEvent;\r\n    new(): TransitionEvent;\r\n}\r\n\r\ninterface MediaQueryList {\r\n    matches: boolean;\r\n    media: string;\r\n    addListener(listener: MediaQueryListListener): void;\r\n    removeListener(listener: MediaQueryListListener): void;\r\n}\r\ndeclare var MediaQueryList: {\r\n    prototype: MediaQueryList;\r\n    new(): MediaQueryList;\r\n}\r\n\r\ninterface DOMError {\r\n    name: string;\r\n    toString(): string;\r\n}\r\ndeclare var DOMError: {\r\n    prototype: DOMError;\r\n    new(): DOMError;\r\n}\r\n\r\ninterface CloseEvent extends Event {\r\n    wasClean: boolean;\r\n    reason: string;\r\n    code: number;\r\n    initCloseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, wasCleanArg: boolean, codeArg: number, reasonArg: string): void;\r\n}\r\ndeclare var CloseEvent: {\r\n    prototype: CloseEvent;\r\n    new(): CloseEvent;\r\n}\r\n\r\ninterface WebSocket extends EventTarget {\r\n    protocol: string;\r\n    readyState: number;\r\n    bufferedAmount: number;\r\n    onopen: (ev: Event) => any;\r\n    extensions: string;\r\n    onmessage: (ev: MessageEvent) => any;\r\n    onclose: (ev: CloseEvent) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    binaryType: string;\r\n    url: string;\r\n    close(code?: number, reason?: string): void;\r\n    send(data: any): void;\r\n    OPEN: number;\r\n    CLOSING: number;\r\n    CONNECTING: number;\r\n    CLOSED: number;\r\n    addEventListener(type: \"open\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"message\", listener: (ev: MessageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"close\", listener: (ev: CloseEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var WebSocket: {\r\n    prototype: WebSocket;\r\n    new(url: string, protocols?: string): WebSocket;\r\n    new(url: string, protocols?: string[]): WebSocket;\r\n    OPEN: number;\r\n    CLOSING: number;\r\n    CONNECTING: number;\r\n    CLOSED: number;\r\n}\r\n\r\ninterface SVGFEPointLightElement extends SVGElement {\r\n    y: SVGAnimatedNumber;\r\n    x: SVGAnimatedNumber;\r\n    z: SVGAnimatedNumber;\r\n}\r\ndeclare var SVGFEPointLightElement: {\r\n    prototype: SVGFEPointLightElement;\r\n    new(): SVGFEPointLightElement;\r\n}\r\n\r\ninterface ProgressEvent extends Event {\r\n    loaded: number;\r\n    lengthComputable: boolean;\r\n    total: number;\r\n    initProgressEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, lengthComputableArg: boolean, loadedArg: number, totalArg: number): void;\r\n}\r\ndeclare var ProgressEvent: {\r\n    prototype: ProgressEvent;\r\n    new(): ProgressEvent;\r\n}\r\n\r\ninterface IDBObjectStore {\r\n    indexNames: DOMStringList;\r\n    name: string;\r\n    transaction: IDBTransaction;\r\n    keyPath: string;\r\n    count(key?: any): IDBRequest;\r\n    add(value: any, key?: any): IDBRequest;\r\n    clear(): IDBRequest;\r\n    createIndex(name: string, keyPath: string, optionalParameters?: any): IDBIndex;\r\n    put(value: any, key?: any): IDBRequest;\r\n    openCursor(range?: any, direction?: string): IDBRequest;\r\n    deleteIndex(indexName: string): void;\r\n    index(name: string): IDBIndex;\r\n    get(key: any): IDBRequest;\r\n    delete(key: any): IDBRequest;\r\n}\r\ndeclare var IDBObjectStore: {\r\n    prototype: IDBObjectStore;\r\n    new(): IDBObjectStore;\r\n}\r\n\r\ninterface SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    stdDeviationX: SVGAnimatedNumber;\r\n    in1: SVGAnimatedString;\r\n    stdDeviationY: SVGAnimatedNumber;\r\n    setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;\r\n}\r\ndeclare var SVGFEGaussianBlurElement: {\r\n    prototype: SVGFEGaussianBlurElement;\r\n    new(): SVGFEGaussianBlurElement;\r\n}\r\n\r\ninterface SVGFilterPrimitiveStandardAttributes extends SVGStylable {\r\n    y: SVGAnimatedLength;\r\n    width: SVGAnimatedLength;\r\n    x: SVGAnimatedLength;\r\n    height: SVGAnimatedLength;\r\n    result: SVGAnimatedString;\r\n}\r\n\r\ninterface IDBVersionChangeEvent extends Event {\r\n    newVersion: number;\r\n    oldVersion: number;\r\n}\r\ndeclare var IDBVersionChangeEvent: {\r\n    prototype: IDBVersionChangeEvent;\r\n    new(): IDBVersionChangeEvent;\r\n}\r\n\r\ninterface IDBIndex {\r\n    unique: boolean;\r\n    name: string;\r\n    keyPath: string;\r\n    objectStore: IDBObjectStore;\r\n    count(key?: any): IDBRequest;\r\n    getKey(key: any): IDBRequest;\r\n    openKeyCursor(range?: IDBKeyRange, direction?: string): IDBRequest;\r\n    get(key: any): IDBRequest;\r\n    openCursor(range?: IDBKeyRange, direction?: string): IDBRequest;\r\n}\r\ndeclare var IDBIndex: {\r\n    prototype: IDBIndex;\r\n    new(): IDBIndex;\r\n}\r\n\r\ninterface FileList {\r\n    length: number;\r\n    item(index: number): File;\r\n    [index: number]: File;\r\n}\r\ndeclare var FileList: {\r\n    prototype: FileList;\r\n    new(): FileList;\r\n}\r\n\r\ninterface IDBCursor {\r\n    source: any;\r\n    direction: string;\r\n    key: any;\r\n    primaryKey: any;\r\n    advance(count: number): void;\r\n    delete(): IDBRequest;\r\n    continue(key?: any): void;\r\n    update(value: any): IDBRequest;\r\n    PREV: string;\r\n    PREV_NO_DUPLICATE: string;\r\n    NEXT: string;\r\n    NEXT_NO_DUPLICATE: string;\r\n}\r\ndeclare var IDBCursor: {\r\n    prototype: IDBCursor;\r\n    new(): IDBCursor;\r\n    PREV: string;\r\n    PREV_NO_DUPLICATE: string;\r\n    NEXT: string;\r\n    NEXT_NO_DUPLICATE: string;\r\n}\r\n\r\ninterface SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    kernelUnitLengthY: SVGAnimatedNumber;\r\n    surfaceScale: SVGAnimatedNumber;\r\n    specularExponent: SVGAnimatedNumber;\r\n    in1: SVGAnimatedString;\r\n    kernelUnitLengthX: SVGAnimatedNumber;\r\n    specularConstant: SVGAnimatedNumber;\r\n}\r\ndeclare var SVGFESpecularLightingElement: {\r\n    prototype: SVGFESpecularLightingElement;\r\n    new(): SVGFESpecularLightingElement;\r\n}\r\n\r\ninterface File extends Blob {\r\n    lastModifiedDate: any;\r\n    name: string;\r\n}\r\ndeclare var File: {\r\n    prototype: File;\r\n    new(): File;\r\n}\r\n\r\ninterface URL {\r\n    revokeObjectURL(url: string): void;\r\n    createObjectURL(object: any, options?: ObjectURLOptions): string;\r\n}\r\ndeclare var URL: URL;\r\n\r\ninterface IDBCursorWithValue extends IDBCursor {\r\n    value: any;\r\n}\r\ndeclare var IDBCursorWithValue: {\r\n    prototype: IDBCursorWithValue;\r\n    new(): IDBCursorWithValue;\r\n}\r\n\r\ninterface XMLHttpRequestEventTarget extends EventTarget {\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onload: (ev: Event) => any;\r\n    ontimeout: (ev: Event) => any;\r\n    onabort: (ev: UIEvent) => any;\r\n    onloadstart: (ev: Event) => any;\r\n    onloadend: (ev: ProgressEvent) => any;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"timeout\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadend\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var XMLHttpRequestEventTarget: {\r\n    prototype: XMLHttpRequestEventTarget;\r\n    new(): XMLHttpRequestEventTarget;\r\n}\r\n\r\ninterface IDBEnvironment {\r\n    msIndexedDB: IDBFactory;\r\n    indexedDB: IDBFactory;\r\n}\r\n\r\ninterface AudioTrackList extends EventTarget {\r\n    length: number;\r\n    onchange: (ev: Event) => any;\r\n    onaddtrack: (ev: TrackEvent) => any;\r\n    onremovetrack: (ev: any /*PluginArray*/) => any;\r\n    getTrackById(id: string): AudioTrack;\r\n    item(index: number): AudioTrack;\r\n    [index: number]: AudioTrack;\r\n    addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"addtrack\", listener: (ev: TrackEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"removetrack\", listener: (ev: any /*PluginArray*/) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var AudioTrackList: {\r\n    prototype: AudioTrackList;\r\n    new(): AudioTrackList;\r\n}\r\n\r\ninterface MSBaseReader extends EventTarget {\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    readyState: number;\r\n    onabort: (ev: UIEvent) => any;\r\n    onloadend: (ev: ProgressEvent) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onload: (ev: Event) => any;\r\n    onloadstart: (ev: Event) => any;\r\n    result: any;\r\n    abort(): void;\r\n    LOADING: number;\r\n    EMPTY: number;\r\n    DONE: number;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadend\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\n\r\ninterface SVGFEMorphologyElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    operator: SVGAnimatedEnumeration;\r\n    radiusX: SVGAnimatedNumber;\r\n    radiusY: SVGAnimatedNumber;\r\n    in1: SVGAnimatedString;\r\n    SVG_MORPHOLOGY_OPERATOR_UNKNOWN: number;\r\n    SVG_MORPHOLOGY_OPERATOR_ERODE: number;\r\n    SVG_MORPHOLOGY_OPERATOR_DILATE: number;\r\n}\r\ndeclare var SVGFEMorphologyElement: {\r\n    prototype: SVGFEMorphologyElement;\r\n    new(): SVGFEMorphologyElement;\r\n    SVG_MORPHOLOGY_OPERATOR_UNKNOWN: number;\r\n    SVG_MORPHOLOGY_OPERATOR_ERODE: number;\r\n    SVG_MORPHOLOGY_OPERATOR_DILATE: number;\r\n}\r\n\r\ninterface SVGFEFuncRElement extends SVGComponentTransferFunctionElement {\r\n}\r\ndeclare var SVGFEFuncRElement: {\r\n    prototype: SVGFEFuncRElement;\r\n    new(): SVGFEFuncRElement;\r\n}\r\n\r\ninterface WindowTimersExtension {\r\n    msSetImmediate(expression: any, ...args: any[]): number;\r\n    clearImmediate(handle: number): void;\r\n    msClearImmediate(handle: number): void;\r\n    setImmediate(expression: any, ...args: any[]): number;\r\n}\r\n\r\ninterface SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    in2: SVGAnimatedString;\r\n    xChannelSelector: SVGAnimatedEnumeration;\r\n    yChannelSelector: SVGAnimatedEnumeration;\r\n    scale: SVGAnimatedNumber;\r\n    in1: SVGAnimatedString;\r\n    SVG_CHANNEL_B: number;\r\n    SVG_CHANNEL_R: number;\r\n    SVG_CHANNEL_G: number;\r\n    SVG_CHANNEL_UNKNOWN: number;\r\n    SVG_CHANNEL_A: number;\r\n}\r\ndeclare var SVGFEDisplacementMapElement: {\r\n    prototype: SVGFEDisplacementMapElement;\r\n    new(): SVGFEDisplacementMapElement;\r\n    SVG_CHANNEL_B: number;\r\n    SVG_CHANNEL_R: number;\r\n    SVG_CHANNEL_G: number;\r\n    SVG_CHANNEL_UNKNOWN: number;\r\n    SVG_CHANNEL_A: number;\r\n}\r\n\r\ninterface AnimationEvent extends Event {\r\n    animationName: string;\r\n    elapsedTime: number;\r\n    initAnimationEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, animationNameArg: string, elapsedTimeArg: number): void;\r\n}\r\ndeclare var AnimationEvent: {\r\n    prototype: AnimationEvent;\r\n    new(): AnimationEvent;\r\n}\r\n\r\ninterface SVGComponentTransferFunctionElement extends SVGElement {\r\n    tableValues: SVGAnimatedNumberList;\r\n    slope: SVGAnimatedNumber;\r\n    type: SVGAnimatedEnumeration;\r\n    exponent: SVGAnimatedNumber;\r\n    amplitude: SVGAnimatedNumber;\r\n    intercept: SVGAnimatedNumber;\r\n    offset: SVGAnimatedNumber;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_TABLE: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: number;\r\n}\r\ndeclare var SVGComponentTransferFunctionElement: {\r\n    prototype: SVGComponentTransferFunctionElement;\r\n    new(): SVGComponentTransferFunctionElement;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_TABLE: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: number;\r\n    SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: number;\r\n}\r\n\r\ninterface MSRangeCollection {\r\n    length: number;\r\n    item(index: number): Range;\r\n    [index: number]: Range;\r\n}\r\ndeclare var MSRangeCollection: {\r\n    prototype: MSRangeCollection;\r\n    new(): MSRangeCollection;\r\n}\r\n\r\ninterface SVGFEDistantLightElement extends SVGElement {\r\n    azimuth: SVGAnimatedNumber;\r\n    elevation: SVGAnimatedNumber;\r\n}\r\ndeclare var SVGFEDistantLightElement: {\r\n    prototype: SVGFEDistantLightElement;\r\n    new(): SVGFEDistantLightElement;\r\n}\r\n\r\ninterface SVGFEFuncBElement extends SVGComponentTransferFunctionElement {\r\n}\r\ndeclare var SVGFEFuncBElement: {\r\n    prototype: SVGFEFuncBElement;\r\n    new(): SVGFEFuncBElement;\r\n}\r\n\r\ninterface IDBKeyRange {\r\n    upper: any;\r\n    upperOpen: boolean;\r\n    lower: any;\r\n    lowerOpen: boolean;\r\n}\r\ndeclare var IDBKeyRange: {\r\n    prototype: IDBKeyRange;\r\n    new(): IDBKeyRange;\r\n    bound(lower: any, upper: any, lowerOpen?: boolean, upperOpen?: boolean): IDBKeyRange;\r\n    only(value: any): IDBKeyRange;\r\n    lowerBound(bound: any, open?: boolean): IDBKeyRange;\r\n    upperBound(bound: any, open?: boolean): IDBKeyRange;\r\n}\r\n\r\ninterface WindowConsole {\r\n    console: Console;\r\n}\r\n\r\ninterface IDBTransaction extends EventTarget {\r\n    oncomplete: (ev: Event) => any;\r\n    db: IDBDatabase;\r\n    mode: string;\r\n    error: DOMError;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onabort: (ev: UIEvent) => any;\r\n    abort(): void;\r\n    objectStore(name: string): IDBObjectStore;\r\n    READ_ONLY: string;\r\n    VERSION_CHANGE: string;\r\n    READ_WRITE: string;\r\n    addEventListener(type: \"complete\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var IDBTransaction: {\r\n    prototype: IDBTransaction;\r\n    new(): IDBTransaction;\r\n    READ_ONLY: string;\r\n    VERSION_CHANGE: string;\r\n    READ_WRITE: string;\r\n}\r\n\r\ninterface AudioTrack {\r\n    kind: string;\r\n    language: string;\r\n    id: string;\r\n    label: string;\r\n    enabled: boolean;\r\n    sourceBuffer: SourceBuffer;\r\n}\r\ndeclare var AudioTrack: {\r\n    prototype: AudioTrack;\r\n    new(): AudioTrack;\r\n}\r\n\r\ninterface SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    orderY: SVGAnimatedInteger;\r\n    kernelUnitLengthY: SVGAnimatedNumber;\r\n    orderX: SVGAnimatedInteger;\r\n    preserveAlpha: SVGAnimatedBoolean;\r\n    kernelMatrix: SVGAnimatedNumberList;\r\n    edgeMode: SVGAnimatedEnumeration;\r\n    kernelUnitLengthX: SVGAnimatedNumber;\r\n    bias: SVGAnimatedNumber;\r\n    targetX: SVGAnimatedInteger;\r\n    targetY: SVGAnimatedInteger;\r\n    divisor: SVGAnimatedNumber;\r\n    in1: SVGAnimatedString;\r\n    SVG_EDGEMODE_WRAP: number;\r\n    SVG_EDGEMODE_DUPLICATE: number;\r\n    SVG_EDGEMODE_UNKNOWN: number;\r\n    SVG_EDGEMODE_NONE: number;\r\n}\r\ndeclare var SVGFEConvolveMatrixElement: {\r\n    prototype: SVGFEConvolveMatrixElement;\r\n    new(): SVGFEConvolveMatrixElement;\r\n    SVG_EDGEMODE_WRAP: number;\r\n    SVG_EDGEMODE_DUPLICATE: number;\r\n    SVG_EDGEMODE_UNKNOWN: number;\r\n    SVG_EDGEMODE_NONE: number;\r\n}\r\n\r\ninterface TextTrackCueList {\r\n    length: number;\r\n    item(index: number): TextTrackCue;\r\n    [index: number]: TextTrackCue;\r\n    getCueById(id: string): TextTrackCue;\r\n}\r\ndeclare var TextTrackCueList: {\r\n    prototype: TextTrackCueList;\r\n    new(): TextTrackCueList;\r\n}\r\n\r\ninterface CSSKeyframesRule extends CSSRule {\r\n    name: string;\r\n    cssRules: CSSRuleList;\r\n    findRule(rule: string): CSSKeyframeRule;\r\n    deleteRule(rule: string): void;\r\n    appendRule(rule: string): void;\r\n}\r\ndeclare var CSSKeyframesRule: {\r\n    prototype: CSSKeyframesRule;\r\n    new(): CSSKeyframesRule;\r\n}\r\n\r\ninterface SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    baseFrequencyX: SVGAnimatedNumber;\r\n    numOctaves: SVGAnimatedInteger;\r\n    type: SVGAnimatedEnumeration;\r\n    baseFrequencyY: SVGAnimatedNumber;\r\n    stitchTiles: SVGAnimatedEnumeration;\r\n    seed: SVGAnimatedNumber;\r\n    SVG_STITCHTYPE_UNKNOWN: number;\r\n    SVG_STITCHTYPE_NOSTITCH: number;\r\n    SVG_TURBULENCE_TYPE_UNKNOWN: number;\r\n    SVG_TURBULENCE_TYPE_TURBULENCE: number;\r\n    SVG_TURBULENCE_TYPE_FRACTALNOISE: number;\r\n    SVG_STITCHTYPE_STITCH: number;\r\n}\r\ndeclare var SVGFETurbulenceElement: {\r\n    prototype: SVGFETurbulenceElement;\r\n    new(): SVGFETurbulenceElement;\r\n    SVG_STITCHTYPE_UNKNOWN: number;\r\n    SVG_STITCHTYPE_NOSTITCH: number;\r\n    SVG_TURBULENCE_TYPE_UNKNOWN: number;\r\n    SVG_TURBULENCE_TYPE_TURBULENCE: number;\r\n    SVG_TURBULENCE_TYPE_FRACTALNOISE: number;\r\n    SVG_STITCHTYPE_STITCH: number;\r\n}\r\n\r\ninterface TextTrackList extends EventTarget {\r\n    length: number;\r\n    onaddtrack: (ev: TrackEvent) => any;\r\n    item(index: number): TextTrack;\r\n    [index: number]: TextTrack;\r\n    addEventListener(type: \"addtrack\", listener: (ev: TrackEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var TextTrackList: {\r\n    prototype: TextTrackList;\r\n    new(): TextTrackList;\r\n}\r\n\r\ninterface SVGFEFuncGElement extends SVGComponentTransferFunctionElement {\r\n}\r\ndeclare var SVGFEFuncGElement: {\r\n    prototype: SVGFEFuncGElement;\r\n    new(): SVGFEFuncGElement;\r\n}\r\n\r\ninterface SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    in1: SVGAnimatedString;\r\n    type: SVGAnimatedEnumeration;\r\n    values: SVGAnimatedNumberList;\r\n    SVG_FECOLORMATRIX_TYPE_SATURATE: number;\r\n    SVG_FECOLORMATRIX_TYPE_UNKNOWN: number;\r\n    SVG_FECOLORMATRIX_TYPE_MATRIX: number;\r\n    SVG_FECOLORMATRIX_TYPE_HUEROTATE: number;\r\n    SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: number;\r\n}\r\ndeclare var SVGFEColorMatrixElement: {\r\n    prototype: SVGFEColorMatrixElement;\r\n    new(): SVGFEColorMatrixElement;\r\n    SVG_FECOLORMATRIX_TYPE_SATURATE: number;\r\n    SVG_FECOLORMATRIX_TYPE_UNKNOWN: number;\r\n    SVG_FECOLORMATRIX_TYPE_MATRIX: number;\r\n    SVG_FECOLORMATRIX_TYPE_HUEROTATE: number;\r\n    SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: number;\r\n}\r\n\r\ninterface SVGFESpotLightElement extends SVGElement {\r\n    pointsAtY: SVGAnimatedNumber;\r\n    y: SVGAnimatedNumber;\r\n    limitingConeAngle: SVGAnimatedNumber;\r\n    specularExponent: SVGAnimatedNumber;\r\n    x: SVGAnimatedNumber;\r\n    pointsAtZ: SVGAnimatedNumber;\r\n    z: SVGAnimatedNumber;\r\n    pointsAtX: SVGAnimatedNumber;\r\n}\r\ndeclare var SVGFESpotLightElement: {\r\n    prototype: SVGFESpotLightElement;\r\n    new(): SVGFESpotLightElement;\r\n}\r\n\r\ninterface WindowBase64 {\r\n    btoa(rawString: string): string;\r\n    atob(encodedString: string): string;\r\n}\r\n\r\ninterface IDBDatabase extends EventTarget {\r\n    version: string;\r\n    name: string;\r\n    objectStoreNames: DOMStringList;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onabort: (ev: UIEvent) => any;\r\n    createObjectStore(name: string, optionalParameters?: any): IDBObjectStore;\r\n    close(): void;\r\n    transaction(storeNames: any, mode?: string): IDBTransaction;\r\n    deleteObjectStore(name: string): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var IDBDatabase: {\r\n    prototype: IDBDatabase;\r\n    new(): IDBDatabase;\r\n}\r\n\r\ninterface DOMStringList {\r\n    length: number;\r\n    contains(str: string): boolean;\r\n    item(index: number): string;\r\n    [index: number]: string;\r\n}\r\ndeclare var DOMStringList: {\r\n    prototype: DOMStringList;\r\n    new(): DOMStringList;\r\n}\r\n\r\ninterface IDBOpenDBRequest extends IDBRequest {\r\n    onupgradeneeded: (ev: IDBVersionChangeEvent) => any;\r\n    onblocked: (ev: Event) => any;\r\n    addEventListener(type: \"success\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"upgradeneeded\", listener: (ev: IDBVersionChangeEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"blocked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var IDBOpenDBRequest: {\r\n    prototype: IDBOpenDBRequest;\r\n    new(): IDBOpenDBRequest;\r\n}\r\n\r\ninterface HTMLProgressElement extends HTMLElement {\r\n    /**\r\n      * Sets or gets the current value of a progress element. The value must be a non-negative number between 0 and the max value.\r\n      */\r\n    value: number;\r\n    /**\r\n      * Defines the maximum, or \"done\" value for a progress element.\r\n      */\r\n    max: number;\r\n    /**\r\n      * Returns the quotient of value/max when the value attribute is set (determinate progress bar), or -1 when the value attribute is missing (indeterminate progress bar).\r\n      */\r\n    position: number;\r\n    /**\r\n      * Retrieves a reference to the form that the object is embedded in.\r\n      */\r\n    form: HTMLFormElement;\r\n}\r\ndeclare var HTMLProgressElement: {\r\n    prototype: HTMLProgressElement;\r\n    new(): HTMLProgressElement;\r\n}\r\n\r\ninterface MSLaunchUriCallback {\r\n    (): void;\r\n}\r\n\r\ninterface SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    dy: SVGAnimatedNumber;\r\n    in1: SVGAnimatedString;\r\n    dx: SVGAnimatedNumber;\r\n}\r\ndeclare var SVGFEOffsetElement: {\r\n    prototype: SVGFEOffsetElement;\r\n    new(): SVGFEOffsetElement;\r\n}\r\n\r\ninterface MSUnsafeFunctionCallback {\r\n    (): any;\r\n}\r\n\r\ninterface TextTrack extends EventTarget {\r\n    language: string;\r\n    mode: any;\r\n    readyState: number;\r\n    activeCues: TextTrackCueList;\r\n    cues: TextTrackCueList;\r\n    oncuechange: (ev: Event) => any;\r\n    kind: string;\r\n    onload: (ev: Event) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    label: string;\r\n    addCue(cue: TextTrackCue): void;\r\n    removeCue(cue: TextTrackCue): void;\r\n    ERROR: number;\r\n    SHOWING: number;\r\n    LOADING: number;\r\n    LOADED: number;\r\n    NONE: number;\r\n    HIDDEN: number;\r\n    DISABLED: number;\r\n    addEventListener(type: \"cuechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var TextTrack: {\r\n    prototype: TextTrack;\r\n    new(): TextTrack;\r\n    ERROR: number;\r\n    SHOWING: number;\r\n    LOADING: number;\r\n    LOADED: number;\r\n    NONE: number;\r\n    HIDDEN: number;\r\n    DISABLED: number;\r\n}\r\n\r\ninterface MediaQueryListListener {\r\n    (mql: MediaQueryList): void;\r\n}\r\n\r\ninterface IDBRequest extends EventTarget {\r\n    source: any;\r\n    onsuccess: (ev: Event) => any;\r\n    error: DOMError;\r\n    transaction: IDBTransaction;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    readyState: string;\r\n    result: any;\r\n    addEventListener(type: \"success\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var IDBRequest: {\r\n    prototype: IDBRequest;\r\n    new(): IDBRequest;\r\n}\r\n\r\ninterface MessagePort extends EventTarget {\r\n    onmessage: (ev: MessageEvent) => any;\r\n    close(): void;\r\n    postMessage(message?: any, ports?: any): void;\r\n    start(): void;\r\n    addEventListener(type: \"message\", listener: (ev: MessageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var MessagePort: {\r\n    prototype: MessagePort;\r\n    new(): MessagePort;\r\n}\r\n\r\ninterface FileReader extends MSBaseReader {\r\n    error: DOMError;\r\n    readAsArrayBuffer(blob: Blob): void;\r\n    readAsDataURL(blob: Blob): void;\r\n    readAsText(blob: Blob, encoding?: string): void;\r\n}\r\ndeclare var FileReader: {\r\n    prototype: FileReader;\r\n    new(): FileReader;\r\n}\r\n\r\ninterface Blob {\r\n    type: string;\r\n    size: number;\r\n    msDetachStream(): any;\r\n    slice(start?: number, end?: number, contentType?: string): Blob;\r\n    msClose(): void;\r\n}\r\ndeclare var Blob: {\r\n    prototype: Blob;\r\n    new(): Blob;\r\n}\r\n\r\ninterface ApplicationCache extends EventTarget {\r\n    status: number;\r\n    ondownloading: (ev: Event) => any;\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    onupdateready: (ev: Event) => any;\r\n    oncached: (ev: Event) => any;\r\n    onobsolete: (ev: Event) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onchecking: (ev: Event) => any;\r\n    onnoupdate: (ev: Event) => any;\r\n    swapCache(): void;\r\n    abort(): void;\r\n    update(): void;\r\n    CHECKING: number;\r\n    UNCACHED: number;\r\n    UPDATEREADY: number;\r\n    DOWNLOADING: number;\r\n    IDLE: number;\r\n    OBSOLETE: number;\r\n    addEventListener(type: \"downloading\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"updateready\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"cached\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"obsolete\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"checking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"noupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var ApplicationCache: {\r\n    prototype: ApplicationCache;\r\n    new(): ApplicationCache;\r\n    CHECKING: number;\r\n    UNCACHED: number;\r\n    UPDATEREADY: number;\r\n    DOWNLOADING: number;\r\n    IDLE: number;\r\n    OBSOLETE: number;\r\n}\r\n\r\ninterface FrameRequestCallback {\r\n    (time: number): void;\r\n}\r\n\r\ninterface PopStateEvent extends Event {\r\n    state: any;\r\n    initPopStateEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, stateArg: any): void;\r\n}\r\ndeclare var PopStateEvent: {\r\n    prototype: PopStateEvent;\r\n    new(): PopStateEvent;\r\n}\r\n\r\ninterface CSSKeyframeRule extends CSSRule {\r\n    keyText: string;\r\n    style: CSSStyleDeclaration;\r\n}\r\ndeclare var CSSKeyframeRule: {\r\n    prototype: CSSKeyframeRule;\r\n    new(): CSSKeyframeRule;\r\n}\r\n\r\ninterface MSFileSaver {\r\n    msSaveBlob(blob: any, defaultName?: string): boolean;\r\n    msSaveOrOpenBlob(blob: any, defaultName?: string): boolean;\r\n}\r\n\r\ninterface MSStream {\r\n    type: string;\r\n    msDetachStream(): any;\r\n    msClose(): void;\r\n}\r\ndeclare var MSStream: {\r\n    prototype: MSStream;\r\n    new(): MSStream;\r\n}\r\n\r\ninterface MSBlobBuilder {\r\n    append(data: any, endings?: string): void;\r\n    getBlob(contentType?: string): Blob;\r\n}\r\ndeclare var MSBlobBuilder: {\r\n    prototype: MSBlobBuilder;\r\n    new(): MSBlobBuilder;\r\n}\r\n\r\ninterface DOMSettableTokenList extends DOMTokenList {\r\n    value: string;\r\n}\r\ndeclare var DOMSettableTokenList: {\r\n    prototype: DOMSettableTokenList;\r\n    new(): DOMSettableTokenList;\r\n}\r\n\r\ninterface IDBFactory {\r\n    open(name: string, version?: number): IDBOpenDBRequest;\r\n    cmp(first: any, second: any): number;\r\n    deleteDatabase(name: string): IDBOpenDBRequest;\r\n}\r\ndeclare var IDBFactory: {\r\n    prototype: IDBFactory;\r\n    new(): IDBFactory;\r\n}\r\n\r\ninterface MSPointerEvent extends MouseEvent {\r\n    width: number;\r\n    rotation: number;\r\n    pressure: number;\r\n    pointerType: any;\r\n    isPrimary: boolean;\r\n    tiltY: number;\r\n    height: number;\r\n    intermediatePoints: any;\r\n    currentPoint: any;\r\n    tiltX: number;\r\n    hwTimestamp: number;\r\n    pointerId: number;\r\n    initPointerEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget, offsetXArg: number, offsetYArg: number, widthArg: number, heightArg: number, pressure: number, rotation: number, tiltX: number, tiltY: number, pointerIdArg: number, pointerType: any, hwTimestampArg: number, isPrimary: boolean): void;\r\n    getCurrentPoint(element: Element): void;\r\n    getIntermediatePoints(element: Element): void;\r\n    MSPOINTER_TYPE_PEN: number;\r\n    MSPOINTER_TYPE_MOUSE: number;\r\n    MSPOINTER_TYPE_TOUCH: number;\r\n}\r\ndeclare var MSPointerEvent: {\r\n    prototype: MSPointerEvent;\r\n    new(): MSPointerEvent;\r\n    MSPOINTER_TYPE_PEN: number;\r\n    MSPOINTER_TYPE_MOUSE: number;\r\n    MSPOINTER_TYPE_TOUCH: number;\r\n}\r\n\r\ninterface MSManipulationEvent extends UIEvent {\r\n    lastState: number;\r\n    currentState: number;\r\n    initMSManipulationEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, lastState: number, currentState: number): void;\r\n    MS_MANIPULATION_STATE_STOPPED: number;\r\n    MS_MANIPULATION_STATE_ACTIVE: number;\r\n    MS_MANIPULATION_STATE_INERTIA: number;\r\n    MS_MANIPULATION_STATE_SELECTING: number;\r\n    MS_MANIPULATION_STATE_COMMITTED: number;\r\n    MS_MANIPULATION_STATE_PRESELECT: number;\r\n    MS_MANIPULATION_STATE_DRAGGING: number;\r\n    MS_MANIPULATION_STATE_CANCELLED: number;\r\n}\r\ndeclare var MSManipulationEvent: {\r\n    prototype: MSManipulationEvent;\r\n    new(): MSManipulationEvent;\r\n    MS_MANIPULATION_STATE_STOPPED: number;\r\n    MS_MANIPULATION_STATE_ACTIVE: number;\r\n    MS_MANIPULATION_STATE_INERTIA: number;\r\n    MS_MANIPULATION_STATE_SELECTING: number;\r\n    MS_MANIPULATION_STATE_COMMITTED: number;\r\n    MS_MANIPULATION_STATE_PRESELECT: number;\r\n    MS_MANIPULATION_STATE_DRAGGING: number;\r\n    MS_MANIPULATION_STATE_CANCELLED: number;\r\n}\r\n\r\ninterface HTMLDataListElement extends HTMLElement {\r\n    options: HTMLCollection;\r\n}\r\ndeclare var HTMLDataListElement: {\r\n    prototype: HTMLDataListElement;\r\n    new(): HTMLDataListElement;\r\n}\r\n\r\ninterface SVGFEImageElement extends SVGElement, SVGLangSpace, SVGFilterPrimitiveStandardAttributes, SVGURIReference, SVGExternalResourcesRequired {\r\n    preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\r\n}\r\ndeclare var SVGFEImageElement: {\r\n    prototype: SVGFEImageElement;\r\n    new(): SVGFEImageElement;\r\n}\r\n\r\ninterface AbstractWorker extends EventTarget {\r\n    onerror: (ev: ErrorEvent) => any;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\n\r\ninterface SVGFECompositeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    operator: SVGAnimatedEnumeration;\r\n    in2: SVGAnimatedString;\r\n    k2: SVGAnimatedNumber;\r\n    k1: SVGAnimatedNumber;\r\n    k3: SVGAnimatedNumber;\r\n    in1: SVGAnimatedString;\r\n    k4: SVGAnimatedNumber;\r\n    SVG_FECOMPOSITE_OPERATOR_OUT: number;\r\n    SVG_FECOMPOSITE_OPERATOR_OVER: number;\r\n    SVG_FECOMPOSITE_OPERATOR_XOR: number;\r\n    SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: number;\r\n    SVG_FECOMPOSITE_OPERATOR_UNKNOWN: number;\r\n    SVG_FECOMPOSITE_OPERATOR_IN: number;\r\n    SVG_FECOMPOSITE_OPERATOR_ATOP: number;\r\n}\r\ndeclare var SVGFECompositeElement: {\r\n    prototype: SVGFECompositeElement;\r\n    new(): SVGFECompositeElement;\r\n    SVG_FECOMPOSITE_OPERATOR_OUT: number;\r\n    SVG_FECOMPOSITE_OPERATOR_OVER: number;\r\n    SVG_FECOMPOSITE_OPERATOR_XOR: number;\r\n    SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: number;\r\n    SVG_FECOMPOSITE_OPERATOR_UNKNOWN: number;\r\n    SVG_FECOMPOSITE_OPERATOR_IN: number;\r\n    SVG_FECOMPOSITE_OPERATOR_ATOP: number;\r\n}\r\n\r\ninterface ValidityState {\r\n    customError: boolean;\r\n    valueMissing: boolean;\r\n    stepMismatch: boolean;\r\n    rangeUnderflow: boolean;\r\n    rangeOverflow: boolean;\r\n    typeMismatch: boolean;\r\n    patternMismatch: boolean;\r\n    tooLong: boolean;\r\n    valid: boolean;\r\n}\r\ndeclare var ValidityState: {\r\n    prototype: ValidityState;\r\n    new(): ValidityState;\r\n}\r\n\r\ninterface HTMLTrackElement extends HTMLElement {\r\n    kind: string;\r\n    src: string;\r\n    srclang: string;\r\n    track: TextTrack;\r\n    label: string;\r\n    default: boolean;\r\n    readyState: number;\r\n    ERROR: number;\r\n    LOADING: number;\r\n    LOADED: number;\r\n    NONE: number;\r\n}\r\ndeclare var HTMLTrackElement: {\r\n    prototype: HTMLTrackElement;\r\n    new(): HTMLTrackElement;\r\n    ERROR: number;\r\n    LOADING: number;\r\n    LOADED: number;\r\n    NONE: number;\r\n}\r\n\r\ninterface MSApp {\r\n    createFileFromStorageFile(storageFile: any): File;\r\n    createBlobFromRandomAccessStream(type: string, seeker: any): Blob;\r\n    createStreamFromInputStream(type: string, inputStream: any): MSStream;\r\n    terminateApp(exceptionObject: any): void;\r\n    createDataPackage(object: any): any;\r\n    execUnsafeLocalFunction(unsafeFunction: MSUnsafeFunctionCallback): any;\r\n    getHtmlPrintDocumentSource(htmlDoc: any): any;\r\n    addPublicLocalApplicationUri(uri: string): void;\r\n    createDataPackageFromSelection(): any;\r\n    getViewOpener(): MSAppView;\r\n    suppressSubdownloadCredentialPrompts(suppress: boolean): void;\r\n    execAsyncAtPriority(asynchronousCallback: MSExecAtPriorityFunctionCallback, priority: string, ...args: any[]): void;\r\n    isTaskScheduledAtPriorityOrHigher(priority: string): boolean;\r\n    execAtPriority(synchronousCallback: MSExecAtPriorityFunctionCallback, priority: string, ...args: any[]): any;\r\n    createNewView(uri: string): MSAppView;\r\n    getCurrentPriority(): string;\r\n    NORMAL: string;\r\n    HIGH: string;\r\n    IDLE: string;\r\n    CURRENT: string;\r\n}\r\ndeclare var MSApp: MSApp;\r\n\r\ninterface SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    in1: SVGAnimatedString;\r\n}\r\ndeclare var SVGFEComponentTransferElement: {\r\n    prototype: SVGFEComponentTransferElement;\r\n    new(): SVGFEComponentTransferElement;\r\n}\r\n\r\ninterface SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\r\n    kernelUnitLengthY: SVGAnimatedNumber;\r\n    surfaceScale: SVGAnimatedNumber;\r\n    in1: SVGAnimatedString;\r\n    kernelUnitLengthX: SVGAnimatedNumber;\r\n    diffuseConstant: SVGAnimatedNumber;\r\n}\r\ndeclare var SVGFEDiffuseLightingElement: {\r\n    prototype: SVGFEDiffuseLightingElement;\r\n    new(): SVGFEDiffuseLightingElement;\r\n}\r\n\r\ninterface MSCSSMatrix {\r\n    m24: number;\r\n    m34: number;\r\n    a: number;\r\n    d: number;\r\n    m32: number;\r\n    m41: number;\r\n    m11: number;\r\n    f: number;\r\n    e: number;\r\n    m23: number;\r\n    m14: number;\r\n    m33: number;\r\n    m22: number;\r\n    m21: number;\r\n    c: number;\r\n    m12: number;\r\n    b: number;\r\n    m42: number;\r\n    m31: number;\r\n    m43: number;\r\n    m13: number;\r\n    m44: number;\r\n    multiply(secondMatrix: MSCSSMatrix): MSCSSMatrix;\r\n    skewY(angle: number): MSCSSMatrix;\r\n    setMatrixValue(value: string): void;\r\n    inverse(): MSCSSMatrix;\r\n    rotateAxisAngle(x: number, y: number, z: number, angle: number): MSCSSMatrix;\r\n    toString(): string;\r\n    rotate(angleX: number, angleY?: number, angleZ?: number): MSCSSMatrix;\r\n    translate(x: number, y: number, z?: number): MSCSSMatrix;\r\n    scale(scaleX: number, scaleY?: number, scaleZ?: number): MSCSSMatrix;\r\n    skewX(angle: number): MSCSSMatrix;\r\n}\r\ndeclare var MSCSSMatrix: {\r\n    prototype: MSCSSMatrix;\r\n    new(text?: string): MSCSSMatrix;\r\n}\r\n\r\ninterface Worker extends AbstractWorker {\r\n    onmessage: (ev: MessageEvent) => any;\r\n    postMessage(message: any, ports?: any): void;\r\n    terminate(): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"message\", listener: (ev: MessageEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var Worker: {\r\n    prototype: Worker;\r\n    new(stringUrl: string): Worker;\r\n}\r\n\r\ninterface MSExecAtPriorityFunctionCallback {\r\n    (...args: any[]): any;\r\n}\r\n\r\ninterface MSGraphicsTrust {\r\n    status: string;\r\n    constrictionActive: boolean;\r\n}\r\ndeclare var MSGraphicsTrust: {\r\n    prototype: MSGraphicsTrust;\r\n    new(): MSGraphicsTrust;\r\n}\r\n\r\ninterface SubtleCrypto {\r\n    unwrapKey(wrappedKey: ArrayBufferView, keyAlgorithm: any, keyEncryptionKey: Key, extractable?: boolean, keyUsages?: string[]): KeyOperation;\r\n    encrypt(algorithm: any, key: Key, buffer?: ArrayBufferView): CryptoOperation;\r\n    importKey(format: string, keyData: ArrayBufferView, algorithm: any, extractable?: boolean, keyUsages?: string[]): KeyOperation;\r\n    wrapKey(key: Key, keyEncryptionKey: Key, keyWrappingAlgorithm: any): KeyOperation;\r\n    verify(algorithm: any, key: Key, signature: ArrayBufferView, buffer?: ArrayBufferView): CryptoOperation;\r\n    deriveKey(algorithm: any, baseKey: Key, derivedKeyType: any, extractable?: boolean, keyUsages?: string[]): KeyOperation;\r\n    digest(algorithm: any, buffer?: ArrayBufferView): CryptoOperation;\r\n    exportKey(format: string, key: Key): KeyOperation;\r\n    generateKey(algorithm: any, extractable?: boolean, keyUsages?: string[]): KeyOperation;\r\n    sign(algorithm: any, key: Key, buffer?: ArrayBufferView): CryptoOperation;\r\n    decrypt(algorithm: any, key: Key, buffer?: ArrayBufferView): CryptoOperation;\r\n}\r\ndeclare var SubtleCrypto: {\r\n    prototype: SubtleCrypto;\r\n    new(): SubtleCrypto;\r\n}\r\n\r\ninterface Crypto extends RandomSource {\r\n    subtle: SubtleCrypto;\r\n}\r\ndeclare var Crypto: {\r\n    prototype: Crypto;\r\n    new(): Crypto;\r\n}\r\n\r\ninterface VideoPlaybackQuality {\r\n    totalFrameDelay: number;\r\n    creationTime: number;\r\n    totalVideoFrames: number;\r\n    droppedVideoFrames: number;\r\n}\r\ndeclare var VideoPlaybackQuality: {\r\n    prototype: VideoPlaybackQuality;\r\n    new(): VideoPlaybackQuality;\r\n}\r\n\r\ninterface GlobalEventHandlers {\r\n    onpointerenter: (ev: PointerEvent) => any;\r\n    onpointerout: (ev: PointerEvent) => any;\r\n    onpointerdown: (ev: PointerEvent) => any;\r\n    onpointerup: (ev: PointerEvent) => any;\r\n    onpointercancel: (ev: PointerEvent) => any;\r\n    onpointerover: (ev: PointerEvent) => any;\r\n    onpointermove: (ev: PointerEvent) => any;\r\n    onpointerleave: (ev: PointerEvent) => any;\r\n    addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\n\r\ninterface Key {\r\n    algorithm: Algorithm;\r\n    type: string;\r\n    extractable: boolean;\r\n    keyUsage: string[];\r\n}\r\ndeclare var Key: {\r\n    prototype: Key;\r\n    new(): Key;\r\n}\r\n\r\ninterface DeviceAcceleration {\r\n    y: number;\r\n    x: number;\r\n    z: number;\r\n}\r\ndeclare var DeviceAcceleration: {\r\n    prototype: DeviceAcceleration;\r\n    new(): DeviceAcceleration;\r\n}\r\n\r\ninterface HTMLAllCollection extends HTMLCollection {\r\n    namedItem(name: string): Element;\r\n    // [name: string]: Element;\r\n}\r\ndeclare var HTMLAllCollection: {\r\n    prototype: HTMLAllCollection;\r\n    new(): HTMLAllCollection;\r\n}\r\n\r\ninterface AesGcmEncryptResult {\r\n    ciphertext: ArrayBuffer;\r\n    tag: ArrayBuffer;\r\n}\r\ndeclare var AesGcmEncryptResult: {\r\n    prototype: AesGcmEncryptResult;\r\n    new(): AesGcmEncryptResult;\r\n}\r\n\r\ninterface NavigationCompletedEvent extends NavigationEvent {\r\n    webErrorStatus: number;\r\n    isSuccess: boolean;\r\n}\r\ndeclare var NavigationCompletedEvent: {\r\n    prototype: NavigationCompletedEvent;\r\n    new(): NavigationCompletedEvent;\r\n}\r\n\r\ninterface MutationRecord {\r\n    oldValue: string;\r\n    previousSibling: Node;\r\n    addedNodes: NodeList;\r\n    attributeName: string;\r\n    removedNodes: NodeList;\r\n    target: Node;\r\n    nextSibling: Node;\r\n    attributeNamespace: string;\r\n    type: string;\r\n}\r\ndeclare var MutationRecord: {\r\n    prototype: MutationRecord;\r\n    new(): MutationRecord;\r\n}\r\n\r\ninterface MimeTypeArray {\r\n    length: number;\r\n    item(index: number): Plugin;\r\n    [index: number]: Plugin;\r\n    namedItem(type: string): Plugin;\r\n    // [type: string]: Plugin;\r\n}\r\ndeclare var MimeTypeArray: {\r\n    prototype: MimeTypeArray;\r\n    new(): MimeTypeArray;\r\n}\r\n\r\ninterface KeyOperation extends EventTarget {\r\n    oncomplete: (ev: Event) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    result: any;\r\n    addEventListener(type: \"complete\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var KeyOperation: {\r\n    prototype: KeyOperation;\r\n    new(): KeyOperation;\r\n}\r\n\r\ninterface DOMStringMap {\r\n}\r\ndeclare var DOMStringMap: {\r\n    prototype: DOMStringMap;\r\n    new(): DOMStringMap;\r\n}\r\n\r\ninterface DeviceOrientationEvent extends Event {\r\n    gamma: number;\r\n    alpha: number;\r\n    absolute: boolean;\r\n    beta: number;\r\n    initDeviceOrientationEvent(type: string, bubbles: boolean, cancelable: boolean, alpha: number, beta: number, gamma: number, absolute: boolean): void;\r\n}\r\ndeclare var DeviceOrientationEvent: {\r\n    prototype: DeviceOrientationEvent;\r\n    new(): DeviceOrientationEvent;\r\n}\r\n\r\ninterface MSMediaKeys {\r\n    keySystem: string;\r\n    createSession(type: string, initData: Uint8Array, cdmData?: Uint8Array): MSMediaKeySession;\r\n}\r\ndeclare var MSMediaKeys: {\r\n    prototype: MSMediaKeys;\r\n    new(keySystem: string): MSMediaKeys;\r\n    isTypeSupported(keySystem: string, type?: string): boolean;\r\n}\r\n\r\ninterface MSMediaKeyMessageEvent extends Event {\r\n    destinationURL: string;\r\n    message: Uint8Array;\r\n}\r\ndeclare var MSMediaKeyMessageEvent: {\r\n    prototype: MSMediaKeyMessageEvent;\r\n    new(): MSMediaKeyMessageEvent;\r\n}\r\n\r\ninterface MSHTMLWebViewElement extends HTMLElement {\r\n    documentTitle: string;\r\n    width: number;\r\n    src: string;\r\n    canGoForward: boolean;\r\n    height: number;\r\n    canGoBack: boolean;\r\n    navigateWithHttpRequestMessage(requestMessage: any): void;\r\n    goBack(): void;\r\n    navigate(uri: string): void;\r\n    stop(): void;\r\n    navigateToString(contents: string): void;\r\n    captureSelectedContentToDataPackageAsync(): MSWebViewAsyncOperation;\r\n    capturePreviewToBlobAsync(): MSWebViewAsyncOperation;\r\n    refresh(): void;\r\n    goForward(): void;\r\n    navigateToLocalStreamUri(source: string, streamResolver: any): void;\r\n    invokeScriptAsync(scriptName: string, ...args: any[]): MSWebViewAsyncOperation;\r\n    buildLocalStreamUri(contentIdentifier: string, relativePath: string): string;\r\n}\r\ndeclare var MSHTMLWebViewElement: {\r\n    prototype: MSHTMLWebViewElement;\r\n    new(): MSHTMLWebViewElement;\r\n}\r\n\r\ninterface NavigationEvent extends Event {\r\n    uri: string;\r\n}\r\ndeclare var NavigationEvent: {\r\n    prototype: NavigationEvent;\r\n    new(): NavigationEvent;\r\n}\r\n\r\ninterface RandomSource {\r\n    getRandomValues(array: ArrayBufferView): ArrayBufferView;\r\n}\r\n\r\ninterface MSInputMethodContext extends EventTarget {\r\n    oncandidatewindowshow: (ev: any) => any;\r\n    target: HTMLElement;\r\n    compositionStartOffset: number;\r\n    oncandidatewindowhide: (ev: any) => any;\r\n    oncandidatewindowupdate: (ev: any) => any;\r\n    compositionEndOffset: number;\r\n    getCompositionAlternatives(): string[];\r\n    getCandidateWindowClientRect(): ClientRect;\r\n    hasComposition(): boolean;\r\n    isCandidateWindowVisible(): boolean;\r\n    addEventListener(type: \"candidatewindowshow\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"candidatewindowhide\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"candidatewindowupdate\", listener: (ev: any) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var MSInputMethodContext: {\r\n    prototype: MSInputMethodContext;\r\n    new(): MSInputMethodContext;\r\n}\r\n\r\ninterface DeviceRotationRate {\r\n    gamma: number;\r\n    alpha: number;\r\n    beta: number;\r\n}\r\ndeclare var DeviceRotationRate: {\r\n    prototype: DeviceRotationRate;\r\n    new(): DeviceRotationRate;\r\n}\r\n\r\ninterface PluginArray {\r\n    length: number;\r\n    refresh(reload?: boolean): void;\r\n    item(index: number): Plugin;\r\n    [index: number]: Plugin;\r\n    namedItem(name: string): Plugin;\r\n    // [name: string]: Plugin;\r\n}\r\ndeclare var PluginArray: {\r\n    prototype: PluginArray;\r\n    new(): PluginArray;\r\n}\r\n\r\ninterface MSMediaKeyError {\r\n    systemCode: number;\r\n    code: number;\r\n    MS_MEDIA_KEYERR_SERVICE: number;\r\n    MS_MEDIA_KEYERR_HARDWARECHANGE: number;\r\n    MS_MEDIA_KEYERR_OUTPUT: number;\r\n    MS_MEDIA_KEYERR_DOMAIN: number;\r\n    MS_MEDIA_KEYERR_UNKNOWN: number;\r\n    MS_MEDIA_KEYERR_CLIENT: number;\r\n}\r\ndeclare var MSMediaKeyError: {\r\n    prototype: MSMediaKeyError;\r\n    new(): MSMediaKeyError;\r\n    MS_MEDIA_KEYERR_SERVICE: number;\r\n    MS_MEDIA_KEYERR_HARDWARECHANGE: number;\r\n    MS_MEDIA_KEYERR_OUTPUT: number;\r\n    MS_MEDIA_KEYERR_DOMAIN: number;\r\n    MS_MEDIA_KEYERR_UNKNOWN: number;\r\n    MS_MEDIA_KEYERR_CLIENT: number;\r\n}\r\n\r\ninterface Plugin {\r\n    length: number;\r\n    filename: string;\r\n    version: string;\r\n    name: string;\r\n    description: string;\r\n    item(index: number): MimeType;\r\n    [index: number]: MimeType;\r\n    namedItem(type: string): MimeType;\r\n    // [type: string]: MimeType;\r\n}\r\ndeclare var Plugin: {\r\n    prototype: Plugin;\r\n    new(): Plugin;\r\n}\r\n\r\ninterface MediaSource extends EventTarget {\r\n    sourceBuffers: SourceBufferList;\r\n    duration: number;\r\n    readyState: string;\r\n    activeSourceBuffers: SourceBufferList;\r\n    addSourceBuffer(type: string): SourceBuffer;\r\n    endOfStream(error?: string): void;\r\n    removeSourceBuffer(sourceBuffer: SourceBuffer): void;\r\n}\r\ndeclare var MediaSource: {\r\n    prototype: MediaSource;\r\n    new(): MediaSource;\r\n    isTypeSupported(type: string): boolean;\r\n}\r\n\r\ninterface SourceBufferList extends EventTarget {\r\n    length: number;\r\n    item(index: number): SourceBuffer;\r\n    [index: number]: SourceBuffer;\r\n}\r\ndeclare var SourceBufferList: {\r\n    prototype: SourceBufferList;\r\n    new(): SourceBufferList;\r\n}\r\n\r\ninterface XMLDocument extends Document {\r\n}\r\ndeclare var XMLDocument: {\r\n    prototype: XMLDocument;\r\n    new(): XMLDocument;\r\n}\r\n\r\ninterface DeviceMotionEvent extends Event {\r\n    rotationRate: DeviceRotationRate;\r\n    acceleration: DeviceAcceleration;\r\n    interval: number;\r\n    accelerationIncludingGravity: DeviceAcceleration;\r\n    initDeviceMotionEvent(type: string, bubbles: boolean, cancelable: boolean, acceleration: DeviceAccelerationDict, accelerationIncludingGravity: DeviceAccelerationDict, rotationRate: DeviceRotationRateDict, interval: number): void;\r\n}\r\ndeclare var DeviceMotionEvent: {\r\n    prototype: DeviceMotionEvent;\r\n    new(): DeviceMotionEvent;\r\n}\r\n\r\ninterface MimeType {\r\n    enabledPlugin: Plugin;\r\n    suffixes: string;\r\n    type: string;\r\n    description: string;\r\n}\r\ndeclare var MimeType: {\r\n    prototype: MimeType;\r\n    new(): MimeType;\r\n}\r\n\r\ninterface PointerEvent extends MouseEvent {\r\n    width: number;\r\n    rotation: number;\r\n    pressure: number;\r\n    pointerType: any;\r\n    isPrimary: boolean;\r\n    tiltY: number;\r\n    height: number;\r\n    intermediatePoints: any;\r\n    currentPoint: any;\r\n    tiltX: number;\r\n    hwTimestamp: number;\r\n    pointerId: number;\r\n    initPointerEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget, offsetXArg: number, offsetYArg: number, widthArg: number, heightArg: number, pressure: number, rotation: number, tiltX: number, tiltY: number, pointerIdArg: number, pointerType: any, hwTimestampArg: number, isPrimary: boolean): void;\r\n    getCurrentPoint(element: Element): void;\r\n    getIntermediatePoints(element: Element): void;\r\n}\r\ndeclare var PointerEvent: {\r\n    prototype: PointerEvent;\r\n    new(): PointerEvent;\r\n}\r\n\r\ninterface MSDocumentExtensions {\r\n    captureEvents(): void;\r\n    releaseEvents(): void;\r\n}\r\n\r\ninterface MutationObserver {\r\n    observe(target: Node, options: MutationObserverInit): void;\r\n    takeRecords(): MutationRecord[];\r\n    disconnect(): void;\r\n}\r\ndeclare var MutationObserver: {\r\n    prototype: MutationObserver;\r\n    new (callback: (arr: MutationRecord[], observer: MutationObserver)=>any): MutationObserver;\r\n}\r\n\r\ninterface MSWebViewAsyncOperation extends EventTarget {\r\n    target: MSHTMLWebViewElement;\r\n    oncomplete: (ev: Event) => any;\r\n    error: DOMError;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    readyState: number;\r\n    type: number;\r\n    result: any;\r\n    start(): void;\r\n    ERROR: number;\r\n    TYPE_CREATE_DATA_PACKAGE_FROM_SELECTION: number;\r\n    TYPE_INVOKE_SCRIPT: number;\r\n    COMPLETED: number;\r\n    TYPE_CAPTURE_PREVIEW_TO_RANDOM_ACCESS_STREAM: number;\r\n    STARTED: number;\r\n    addEventListener(type: \"complete\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var MSWebViewAsyncOperation: {\r\n    prototype: MSWebViewAsyncOperation;\r\n    new(): MSWebViewAsyncOperation;\r\n    ERROR: number;\r\n    TYPE_CREATE_DATA_PACKAGE_FROM_SELECTION: number;\r\n    TYPE_INVOKE_SCRIPT: number;\r\n    COMPLETED: number;\r\n    TYPE_CAPTURE_PREVIEW_TO_RANDOM_ACCESS_STREAM: number;\r\n    STARTED: number;\r\n}\r\n\r\ninterface ScriptNotifyEvent extends Event {\r\n    value: string;\r\n    callingUri: string;\r\n}\r\ndeclare var ScriptNotifyEvent: {\r\n    prototype: ScriptNotifyEvent;\r\n    new(): ScriptNotifyEvent;\r\n}\r\n\r\ninterface PerformanceNavigationTiming extends PerformanceEntry {\r\n    redirectStart: number;\r\n    domainLookupEnd: number;\r\n    responseStart: number;\r\n    domComplete: number;\r\n    domainLookupStart: number;\r\n    loadEventStart: number;\r\n    unloadEventEnd: number;\r\n    fetchStart: number;\r\n    requestStart: number;\r\n    domInteractive: number;\r\n    navigationStart: number;\r\n    connectEnd: number;\r\n    loadEventEnd: number;\r\n    connectStart: number;\r\n    responseEnd: number;\r\n    domLoading: number;\r\n    redirectEnd: number;\r\n    redirectCount: number;\r\n    unloadEventStart: number;\r\n    domContentLoadedEventStart: number;\r\n    domContentLoadedEventEnd: number;\r\n    type: string;\r\n}\r\ndeclare var PerformanceNavigationTiming: {\r\n    prototype: PerformanceNavigationTiming;\r\n    new(): PerformanceNavigationTiming;\r\n}\r\n\r\ninterface MSMediaKeyNeededEvent extends Event {\r\n    initData: Uint8Array;\r\n}\r\ndeclare var MSMediaKeyNeededEvent: {\r\n    prototype: MSMediaKeyNeededEvent;\r\n    new(): MSMediaKeyNeededEvent;\r\n}\r\n\r\ninterface LongRunningScriptDetectedEvent extends Event {\r\n    stopPageScriptExecution: boolean;\r\n    executionTime: number;\r\n}\r\ndeclare var LongRunningScriptDetectedEvent: {\r\n    prototype: LongRunningScriptDetectedEvent;\r\n    new(): LongRunningScriptDetectedEvent;\r\n}\r\n\r\ninterface MSAppView {\r\n    viewId: number;\r\n    close(): void;\r\n    postMessage(message: any, targetOrigin: string, ports?: any): void;\r\n}\r\ndeclare var MSAppView: {\r\n    prototype: MSAppView;\r\n    new(): MSAppView;\r\n}\r\n\r\ninterface PerfWidgetExternal {\r\n    maxCpuSpeed: number;\r\n    independentRenderingEnabled: boolean;\r\n    irDisablingContentString: string;\r\n    irStatusAvailable: boolean;\r\n    performanceCounter: number;\r\n    averagePaintTime: number;\r\n    activeNetworkRequestCount: number;\r\n    paintRequestsPerSecond: number;\r\n    extraInformationEnabled: boolean;\r\n    performanceCounterFrequency: number;\r\n    averageFrameTime: number;\r\n    repositionWindow(x: number, y: number): void;\r\n    getRecentMemoryUsage(last: number): any;\r\n    getMemoryUsage(): number;\r\n    resizeWindow(width: number, height: number): void;\r\n    getProcessCpuUsage(): number;\r\n    removeEventListener(eventType: string, callback: (ev: any) => any): void;\r\n    getRecentCpuUsage(last: number): any;\r\n    addEventListener(eventType: string, callback: (ev: any) => any): void;\r\n    getRecentFrames(last: number): any;\r\n    getRecentPaintRequests(last: number): any;\r\n}\r\ndeclare var PerfWidgetExternal: {\r\n    prototype: PerfWidgetExternal;\r\n    new(): PerfWidgetExternal;\r\n}\r\n\r\ninterface PageTransitionEvent extends Event {\r\n    persisted: boolean;\r\n}\r\ndeclare var PageTransitionEvent: {\r\n    prototype: PageTransitionEvent;\r\n    new(): PageTransitionEvent;\r\n}\r\n\r\ninterface MutationCallback {\r\n    (mutations: MutationRecord[], observer: MutationObserver): void;\r\n}\r\n\r\ninterface HTMLDocument extends Document {\r\n}\r\ndeclare var HTMLDocument: {\r\n    prototype: HTMLDocument;\r\n    new(): HTMLDocument;\r\n}\r\n\r\ninterface KeyPair {\r\n    privateKey: Key;\r\n    publicKey: Key;\r\n}\r\ndeclare var KeyPair: {\r\n    prototype: KeyPair;\r\n    new(): KeyPair;\r\n}\r\n\r\ninterface MSMediaKeySession extends EventTarget {\r\n    sessionId: string;\r\n    error: MSMediaKeyError;\r\n    keySystem: string;\r\n    close(): void;\r\n    update(key: Uint8Array): void;\r\n}\r\ndeclare var MSMediaKeySession: {\r\n    prototype: MSMediaKeySession;\r\n    new(): MSMediaKeySession;\r\n}\r\n\r\ninterface UnviewableContentIdentifiedEvent extends NavigationEvent {\r\n    referrer: string;\r\n}\r\ndeclare var UnviewableContentIdentifiedEvent: {\r\n    prototype: UnviewableContentIdentifiedEvent;\r\n    new(): UnviewableContentIdentifiedEvent;\r\n}\r\n\r\ninterface CryptoOperation extends EventTarget {\r\n    algorithm: Algorithm;\r\n    oncomplete: (ev: Event) => any;\r\n    onerror: (ev: ErrorEvent) => any;\r\n    onprogress: (ev: ProgressEvent) => any;\r\n    onabort: (ev: UIEvent) => any;\r\n    key: Key;\r\n    result: any;\r\n    abort(): void;\r\n    finish(): void;\r\n    process(buffer: ArrayBufferView): void;\r\n    addEventListener(type: \"complete\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"error\", listener: (ev: ErrorEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\n    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n}\r\ndeclare var CryptoOperation: {\r\n    prototype: CryptoOperation;\r\n    new(): CryptoOperation;\r\n}\r\n\r\ninterface WebGLTexture extends WebGLObject {\r\n}\r\ndeclare var WebGLTexture: {\r\n    prototype: WebGLTexture;\r\n    new(): WebGLTexture;\r\n}\r\n\r\ninterface OES_texture_float {\r\n}\r\ndeclare var OES_texture_float: {\r\n    prototype: OES_texture_float;\r\n    new(): OES_texture_float;\r\n}\r\n\r\ninterface WebGLContextEvent extends Event {\r\n    statusMessage: string;\r\n}\r\ndeclare var WebGLContextEvent: {\r\n    prototype: WebGLContextEvent;\r\n    new(): WebGLContextEvent;\r\n}\r\n\r\ninterface WebGLRenderbuffer extends WebGLObject {\r\n}\r\ndeclare var WebGLRenderbuffer: {\r\n    prototype: WebGLRenderbuffer;\r\n    new(): WebGLRenderbuffer;\r\n}\r\n\r\ninterface WebGLUniformLocation {\r\n}\r\ndeclare var WebGLUniformLocation: {\r\n    prototype: WebGLUniformLocation;\r\n    new(): WebGLUniformLocation;\r\n}\r\n\r\ninterface WebGLActiveInfo {\r\n    name: string;\r\n    type: number;\r\n    size: number;\r\n}\r\ndeclare var WebGLActiveInfo: {\r\n    prototype: WebGLActiveInfo;\r\n    new(): WebGLActiveInfo;\r\n}\r\n\r\ninterface WEBGL_compressed_texture_s3tc {\r\n    COMPRESSED_RGBA_S3TC_DXT1_EXT: number;\r\n    COMPRESSED_RGBA_S3TC_DXT5_EXT: number;\r\n    COMPRESSED_RGBA_S3TC_DXT3_EXT: number;\r\n    COMPRESSED_RGB_S3TC_DXT1_EXT: number;\r\n}\r\ndeclare var WEBGL_compressed_texture_s3tc: {\r\n    prototype: WEBGL_compressed_texture_s3tc;\r\n    new(): WEBGL_compressed_texture_s3tc;\r\n    COMPRESSED_RGBA_S3TC_DXT1_EXT: number;\r\n    COMPRESSED_RGBA_S3TC_DXT5_EXT: number;\r\n    COMPRESSED_RGBA_S3TC_DXT3_EXT: number;\r\n    COMPRESSED_RGB_S3TC_DXT1_EXT: number;\r\n}\r\n\r\ninterface WebGLRenderingContext {\r\n    drawingBufferWidth: number;\r\n    drawingBufferHeight: number;\r\n    canvas: HTMLCanvasElement;\r\n    getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation;\r\n    bindTexture(target: number, texture: WebGLTexture): void;\r\n    bufferData(target: number, data: ArrayBufferView, usage: number): void;\r\n    bufferData(target: number, data: ArrayBuffer, usage: number): void;\r\n    bufferData(target: number, size: number, usage: number): void;\r\n    depthMask(flag: boolean): void;\r\n    getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;\r\n    vertexAttrib3fv(indx: number, values: number[]): void;\r\n    vertexAttrib3fv(indx: number, values: Float32Array): void;\r\n    linkProgram(program: WebGLProgram): void;\r\n    getSupportedExtensions(): string[];\r\n    bufferSubData(target: number, offset: number, data: ArrayBuffer): void;\r\n    bufferSubData(target: number, offset: number, data: ArrayBufferView): void;\r\n    vertexAttribPointer(indx: number, size: number, type: number, normalized: boolean, stride: number, offset: number): void;\r\n    polygonOffset(factor: number, units: number): void;\r\n    blendColor(red: number, green: number, blue: number, alpha: number): void;\r\n    createTexture(): WebGLTexture;\r\n    hint(target: number, mode: number): void;\r\n    getVertexAttrib(index: number, pname: number): any;\r\n    enableVertexAttribArray(index: number): void;\r\n    depthRange(zNear: number, zFar: number): void;\r\n    cullFace(mode: number): void;\r\n    createFramebuffer(): WebGLFramebuffer;\r\n    uniformMatrix4fv(location: WebGLUniformLocation, transpose: boolean, value: number[]): void;\r\n    uniformMatrix4fv(location: WebGLUniformLocation, transpose: boolean, value: Float32Array): void;\r\n    framebufferTexture2D(target: number, attachment: number, textarget: number, texture: WebGLTexture, level: number): void;\r\n    deleteFramebuffer(framebuffer: WebGLFramebuffer): void;\r\n    colorMask(red: boolean, green: boolean, blue: boolean, alpha: boolean): void;\r\n    compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, data: ArrayBufferView): void;\r\n    uniformMatrix2fv(location: WebGLUniformLocation, transpose: boolean, value: number[]): void;\r\n    uniformMatrix2fv(location: WebGLUniformLocation, transpose: boolean, value: Float32Array): void;\r\n    getExtension(name: string): any;\r\n    createProgram(): WebGLProgram;\r\n    deleteShader(shader: WebGLShader): void;\r\n    getAttachedShaders(program: WebGLProgram): WebGLShader[];\r\n    enable(cap: number): void;\r\n    blendEquation(mode: number): void;\r\n    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView): void;\r\n    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, image: HTMLImageElement): void;\r\n    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, canvas: HTMLCanvasElement): void;\r\n    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, video: HTMLVideoElement): void;\r\n    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, pixels: ImageData): void;\r\n    createBuffer(): WebGLBuffer;\r\n    deleteTexture(texture: WebGLTexture): void;\r\n    useProgram(program: WebGLProgram): void;\r\n    vertexAttrib2fv(indx: number, values: number[]): void;\r\n    vertexAttrib2fv(indx: number, values: Float32Array): void;\r\n    checkFramebufferStatus(target: number): number;\r\n    frontFace(mode: number): void;\r\n    getBufferParameter(target: number, pname: number): any;\r\n    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView): void;\r\n    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, image: HTMLImageElement): void;\r\n    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, canvas: HTMLCanvasElement): void;\r\n    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, video: HTMLVideoElement): void;\r\n    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, pixels: ImageData): void;\r\n    copyTexImage2D(target: number, level: number, internalformat: number, x: number, y: number, width: number, height: number, border: number): void;\r\n    getVertexAttribOffset(index: number, pname: number): number;\r\n    disableVertexAttribArray(index: number): void;\r\n    blendFunc(sfactor: number, dfactor: number): void;\r\n    drawElements(mode: number, count: number, type: number, offset: number): void;\r\n    isFramebuffer(framebuffer: WebGLFramebuffer): boolean;\r\n    uniform3iv(location: WebGLUniformLocation, v: number[]): void;\r\n    uniform3iv(location: WebGLUniformLocation, v: Int32Array): void;\r\n    lineWidth(width: number): void;\r\n    getShaderInfoLog(shader: WebGLShader): string;\r\n    getTexParameter(target: number, pname: number): any;\r\n    getParameter(pname: number): any;\r\n    getShaderPrecisionFormat(shadertype: number, precisiontype: number): WebGLShaderPrecisionFormat;\r\n    getContextAttributes(): WebGLContextAttributes;\r\n    vertexAttrib1f(indx: number, x: number): void;\r\n    bindFramebuffer(target: number, framebuffer: WebGLFramebuffer): void;\r\n    compressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, data: ArrayBufferView): void;\r\n    isContextLost(): boolean;\r\n    uniform1iv(location: WebGLUniformLocation, v: number[]): void;\r\n    uniform1iv(location: WebGLUniformLocation, v: Int32Array): void;\r\n    getRenderbufferParameter(target: number, pname: number): any;\r\n    uniform2fv(location: WebGLUniformLocation, v: number[]): void;\r\n    uniform2fv(location: WebGLUniformLocation, v: Float32Array): void;\r\n    isTexture(texture: WebGLTexture): boolean;\r\n    getError(): number;\r\n    shaderSource(shader: WebGLShader, source: string): void;\r\n    deleteRenderbuffer(renderbuffer: WebGLRenderbuffer): void;\r\n    stencilMask(mask: number): void;\r\n    bindBuffer(target: number, buffer: WebGLBuffer): void;\r\n    getAttribLocation(program: WebGLProgram, name: string): number;\r\n    uniform3i(location: WebGLUniformLocation, x: number, y: number, z: number): void;\r\n    blendEquationSeparate(modeRGB: number, modeAlpha: number): void;\r\n    clear(mask: number): void;\r\n    blendFuncSeparate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;\r\n    stencilFuncSeparate(face: number, func: number, ref: number, mask: number): void;\r\n    readPixels(x: number, y: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView): void;\r\n    scissor(x: number, y: number, width: number, height: number): void;\r\n    uniform2i(location: WebGLUniformLocation, x: number, y: number): void;\r\n    getActiveAttrib(program: WebGLProgram, index: number): WebGLActiveInfo;\r\n    getShaderSource(shader: WebGLShader): string;\r\n    generateMipmap(target: number): void;\r\n    bindAttribLocation(program: WebGLProgram, index: number, name: string): void;\r\n    uniform1fv(location: WebGLUniformLocation, v: number[]): void;\r\n    uniform1fv(location: WebGLUniformLocation, v: Float32Array): void;\r\n    uniform2iv(location: WebGLUniformLocation, v: number[]): void;\r\n    uniform2iv(location: WebGLUniformLocation, v: Int32Array): void;\r\n    stencilOp(fail: number, zfail: number, zpass: number): void;\r\n    uniform4fv(location: WebGLUniformLocation, v: number[]): void;\r\n    uniform4fv(location: WebGLUniformLocation, v: Float32Array): void;\r\n    vertexAttrib1fv(indx: number, values: number[]): void;\r\n    vertexAttrib1fv(indx: number, values: Float32Array): void;\r\n    flush(): void;\r\n    uniform4f(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;\r\n    deleteProgram(program: WebGLProgram): void;\r\n    isRenderbuffer(renderbuffer: WebGLRenderbuffer): boolean;\r\n    uniform1i(location: WebGLUniformLocation, x: number): void;\r\n    getProgramParameter(program: WebGLProgram, pname: number): any;\r\n    getActiveUniform(program: WebGLProgram, index: number): WebGLActiveInfo;\r\n    stencilFunc(func: number, ref: number, mask: number): void;\r\n    pixelStorei(pname: number, param: number): void;\r\n    disable(cap: number): void;\r\n    vertexAttrib4fv(indx: number, values: number[]): void;\r\n    vertexAttrib4fv(indx: number, values: Float32Array): void;\r\n    createRenderbuffer(): WebGLRenderbuffer;\r\n    isBuffer(buffer: WebGLBuffer): boolean;\r\n    stencilOpSeparate(face: number, fail: number, zfail: number, zpass: number): void;\r\n    getFramebufferAttachmentParameter(target: number, attachment: number, pname: number): any;\r\n    uniform4i(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;\r\n    sampleCoverage(value: number, invert: boolean): void;\r\n    depthFunc(func: number): void;\r\n    texParameterf(target: number, pname: number, param: number): void;\r\n    vertexAttrib3f(indx: number, x: number, y: number, z: number): void;\r\n    drawArrays(mode: number, first: number, count: number): void;\r\n    texParameteri(target: number, pname: number, param: number): void;\r\n    vertexAttrib4f(indx: number, x: number, y: number, z: number, w: number): void;\r\n    getShaderParameter(shader: WebGLShader, pname: number): any;\r\n    clearDepth(depth: number): void;\r\n    activeTexture(texture: number): void;\r\n    viewport(x: number, y: number, width: number, height: number): void;\r\n    detachShader(program: WebGLProgram, shader: WebGLShader): void;\r\n    uniform1f(location: WebGLUniformLocation, x: number): void;\r\n    uniformMatrix3fv(location: WebGLUniformLocation, transpose: boolean, value: number[]): void;\r\n    uniformMatrix3fv(location: WebGLUniformLocation, transpose: boolean, value: Float32Array): void;\r\n    deleteBuffer(buffer: WebGLBuffer): void;\r\n    copyTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;\r\n    uniform3fv(location: WebGLUniformLocation, v: number[]): void;\r\n    uniform3fv(location: WebGLUniformLocation, v: Float32Array): void;\r\n    stencilMaskSeparate(face: number, mask: number): void;\r\n    attachShader(program: WebGLProgram, shader: WebGLShader): void;\r\n    compileShader(shader: WebGLShader): void;\r\n    clearColor(red: number, green: number, blue: number, alpha: number): void;\r\n    isShader(shader: WebGLShader): boolean;\r\n    clearStencil(s: number): void;\r\n    framebufferRenderbuffer(target: number, attachment: number, renderbuffertarget: number, renderbuffer: WebGLRenderbuffer): void;\r\n    finish(): void;\r\n    uniform2f(location: WebGLUniformLocation, x: number, y: number): void;\r\n    renderbufferStorage(target: number, internalformat: number, width: number, height: number): void;\r\n    uniform3f(location: WebGLUniformLocation, x: number, y: number, z: number): void;\r\n    getProgramInfoLog(program: WebGLProgram): string;\r\n    validateProgram(program: WebGLProgram): void;\r\n    isEnabled(cap: number): boolean;\r\n    vertexAttrib2f(indx: number, x: number, y: number): void;\r\n    isProgram(program: WebGLProgram): boolean;\r\n    createShader(type: number): WebGLShader;\r\n    bindRenderbuffer(target: number, renderbuffer: WebGLRenderbuffer): void;\r\n    uniform4iv(location: WebGLUniformLocation, v: number[]): void;\r\n    uniform4iv(location: WebGLUniformLocation, v: Int32Array): void;\r\n    DEPTH_FUNC: number;\r\n    DEPTH_COMPONENT16: number;\r\n    REPLACE: number;\r\n    REPEAT: number;\r\n    VERTEX_ATTRIB_ARRAY_ENABLED: number;\r\n    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;\r\n    STENCIL_BUFFER_BIT: number;\r\n    RENDERER: number;\r\n    STENCIL_BACK_REF: number;\r\n    TEXTURE26: number;\r\n    RGB565: number;\r\n    DITHER: number;\r\n    CONSTANT_COLOR: number;\r\n    GENERATE_MIPMAP_HINT: number;\r\n    POINTS: number;\r\n    DECR: number;\r\n    INT_VEC3: number;\r\n    TEXTURE28: number;\r\n    ONE_MINUS_CONSTANT_ALPHA: number;\r\n    BACK: number;\r\n    RENDERBUFFER_STENCIL_SIZE: number;\r\n    UNPACK_FLIP_Y_WEBGL: number;\r\n    BLEND: number;\r\n    TEXTURE9: number;\r\n    ARRAY_BUFFER_BINDING: number;\r\n    MAX_VIEWPORT_DIMS: number;\r\n    INVALID_FRAMEBUFFER_OPERATION: number;\r\n    TEXTURE: number;\r\n    TEXTURE0: number;\r\n    TEXTURE31: number;\r\n    TEXTURE24: number;\r\n    HIGH_INT: number;\r\n    RENDERBUFFER_BINDING: number;\r\n    BLEND_COLOR: number;\r\n    FASTEST: number;\r\n    STENCIL_WRITEMASK: number;\r\n    ALIASED_POINT_SIZE_RANGE: number;\r\n    TEXTURE12: number;\r\n    DST_ALPHA: number;\r\n    BLEND_EQUATION_RGB: number;\r\n    FRAMEBUFFER_COMPLETE: number;\r\n    NEAREST_MIPMAP_NEAREST: number;\r\n    VERTEX_ATTRIB_ARRAY_SIZE: number;\r\n    TEXTURE3: number;\r\n    DEPTH_WRITEMASK: number;\r\n    CONTEXT_LOST_WEBGL: number;\r\n    INVALID_VALUE: number;\r\n    TEXTURE_MAG_FILTER: number;\r\n    ONE_MINUS_CONSTANT_COLOR: number;\r\n    ONE_MINUS_SRC_ALPHA: number;\r\n    TEXTURE_CUBE_MAP_POSITIVE_Z: number;\r\n    NOTEQUAL: number;\r\n    ALPHA: number;\r\n    DEPTH_STENCIL: number;\r\n    MAX_VERTEX_UNIFORM_VECTORS: number;\r\n    DEPTH_COMPONENT: number;\r\n    RENDERBUFFER_RED_SIZE: number;\r\n    TEXTURE20: number;\r\n    RED_BITS: number;\r\n    RENDERBUFFER_BLUE_SIZE: number;\r\n    SCISSOR_BOX: number;\r\n    VENDOR: number;\r\n    FRONT_AND_BACK: number;\r\n    CONSTANT_ALPHA: number;\r\n    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;\r\n    NEAREST: number;\r\n    CULL_FACE: number;\r\n    ALIASED_LINE_WIDTH_RANGE: number;\r\n    TEXTURE19: number;\r\n    FRONT: number;\r\n    DEPTH_CLEAR_VALUE: number;\r\n    GREEN_BITS: number;\r\n    TEXTURE29: number;\r\n    TEXTURE23: number;\r\n    MAX_RENDERBUFFER_SIZE: number;\r\n    STENCIL_ATTACHMENT: number;\r\n    TEXTURE27: number;\r\n    BOOL_VEC2: number;\r\n    OUT_OF_MEMORY: number;\r\n    MIRRORED_REPEAT: number;\r\n    POLYGON_OFFSET_UNITS: number;\r\n    TEXTURE_MIN_FILTER: number;\r\n    STENCIL_BACK_PASS_DEPTH_PASS: number;\r\n    LINE_LOOP: number;\r\n    FLOAT_MAT3: number;\r\n    TEXTURE14: number;\r\n    LINEAR: number;\r\n    RGB5_A1: number;\r\n    ONE_MINUS_SRC_COLOR: number;\r\n    SAMPLE_COVERAGE_INVERT: number;\r\n    DONT_CARE: number;\r\n    FRAMEBUFFER_BINDING: number;\r\n    RENDERBUFFER_ALPHA_SIZE: number;\r\n    STENCIL_REF: number;\r\n    ZERO: number;\r\n    DECR_WRAP: number;\r\n    SAMPLE_COVERAGE: number;\r\n    STENCIL_BACK_FUNC: number;\r\n    TEXTURE30: number;\r\n    VIEWPORT: number;\r\n    STENCIL_BITS: number;\r\n    FLOAT: number;\r\n    COLOR_WRITEMASK: number;\r\n    SAMPLE_COVERAGE_VALUE: number;\r\n    TEXTURE_CUBE_MAP_NEGATIVE_Y: number;\r\n    STENCIL_BACK_FAIL: number;\r\n    FLOAT_MAT4: number;\r\n    UNSIGNED_SHORT_4_4_4_4: number;\r\n    TEXTURE6: number;\r\n    RENDERBUFFER_WIDTH: number;\r\n    RGBA4: number;\r\n    ALWAYS: number;\r\n    BLEND_EQUATION_ALPHA: number;\r\n    COLOR_BUFFER_BIT: number;\r\n    TEXTURE_CUBE_MAP: number;\r\n    DEPTH_BUFFER_BIT: number;\r\n    STENCIL_CLEAR_VALUE: number;\r\n    BLEND_EQUATION: number;\r\n    RENDERBUFFER_GREEN_SIZE: number;\r\n    NEAREST_MIPMAP_LINEAR: number;\r\n    VERTEX_ATTRIB_ARRAY_TYPE: number;\r\n    INCR_WRAP: number;\r\n    ONE_MINUS_DST_COLOR: number;\r\n    HIGH_FLOAT: number;\r\n    BYTE: number;\r\n    FRONT_FACE: number;\r\n    SAMPLE_ALPHA_TO_COVERAGE: number;\r\n    CCW: number;\r\n    TEXTURE13: number;\r\n    MAX_VERTEX_ATTRIBS: number;\r\n    MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;\r\n    TEXTURE_WRAP_T: number;\r\n    UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;\r\n    FLOAT_VEC2: number;\r\n    LUMINANCE: number;\r\n    GREATER: number;\r\n    INT_VEC2: number;\r\n    VALIDATE_STATUS: number;\r\n    FRAMEBUFFER: number;\r\n    FRAMEBUFFER_UNSUPPORTED: number;\r\n    TEXTURE5: number;\r\n    FUNC_SUBTRACT: number;\r\n    BLEND_DST_ALPHA: number;\r\n    SAMPLER_CUBE: number;\r\n    ONE_MINUS_DST_ALPHA: number;\r\n    LESS: number;\r\n    TEXTURE_CUBE_MAP_POSITIVE_X: number;\r\n    BLUE_BITS: number;\r\n    DEPTH_TEST: number;\r\n    VERTEX_ATTRIB_ARRAY_STRIDE: number;\r\n    DELETE_STATUS: number;\r\n    TEXTURE18: number;\r\n    POLYGON_OFFSET_FACTOR: number;\r\n    UNSIGNED_INT: number;\r\n    TEXTURE_2D: number;\r\n    DST_COLOR: number;\r\n    FLOAT_MAT2: number;\r\n    COMPRESSED_TEXTURE_FORMATS: number;\r\n    MAX_FRAGMENT_UNIFORM_VECTORS: number;\r\n    DEPTH_STENCIL_ATTACHMENT: number;\r\n    LUMINANCE_ALPHA: number;\r\n    CW: number;\r\n    VERTEX_ATTRIB_ARRAY_NORMALIZED: number;\r\n    TEXTURE_CUBE_MAP_NEGATIVE_Z: number;\r\n    LINEAR_MIPMAP_LINEAR: number;\r\n    BUFFER_SIZE: number;\r\n    SAMPLE_BUFFERS: number;\r\n    TEXTURE15: number;\r\n    ACTIVE_TEXTURE: number;\r\n    VERTEX_SHADER: number;\r\n    TEXTURE22: number;\r\n    VERTEX_ATTRIB_ARRAY_POINTER: number;\r\n    INCR: number;\r\n    COMPILE_STATUS: number;\r\n    MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;\r\n    TEXTURE7: number;\r\n    UNSIGNED_SHORT_5_5_5_1: number;\r\n    DEPTH_BITS: number;\r\n    RGBA: number;\r\n    TRIANGLE_STRIP: number;\r\n    COLOR_CLEAR_VALUE: number;\r\n    BROWSER_DEFAULT_WEBGL: number;\r\n    INVALID_ENUM: number;\r\n    SCISSOR_TEST: number;\r\n    LINE_STRIP: number;\r\n    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;\r\n    STENCIL_FUNC: number;\r\n    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;\r\n    RENDERBUFFER_HEIGHT: number;\r\n    TEXTURE8: number;\r\n    TRIANGLES: number;\r\n    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;\r\n    STENCIL_BACK_VALUE_MASK: number;\r\n    TEXTURE25: number;\r\n    RENDERBUFFER: number;\r\n    LEQUAL: number;\r\n    TEXTURE1: number;\r\n    STENCIL_INDEX8: number;\r\n    FUNC_ADD: number;\r\n    STENCIL_FAIL: number;\r\n    BLEND_SRC_ALPHA: number;\r\n    BOOL: number;\r\n    ALPHA_BITS: number;\r\n    LOW_INT: number;\r\n    TEXTURE10: number;\r\n    SRC_COLOR: number;\r\n    MAX_VARYING_VECTORS: number;\r\n    BLEND_DST_RGB: number;\r\n    TEXTURE_BINDING_CUBE_MAP: number;\r\n    STENCIL_INDEX: number;\r\n    TEXTURE_BINDING_2D: number;\r\n    MEDIUM_INT: number;\r\n    SHADER_TYPE: number;\r\n    POLYGON_OFFSET_FILL: number;\r\n    DYNAMIC_DRAW: number;\r\n    TEXTURE4: number;\r\n    STENCIL_BACK_PASS_DEPTH_FAIL: number;\r\n    STREAM_DRAW: number;\r\n    MAX_CUBE_MAP_TEXTURE_SIZE: number;\r\n    TEXTURE17: number;\r\n    TRIANGLE_FAN: number;\r\n    UNPACK_ALIGNMENT: number;\r\n    CURRENT_PROGRAM: number;\r\n    LINES: number;\r\n    INVALID_OPERATION: number;\r\n    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;\r\n    LINEAR_MIPMAP_NEAREST: number;\r\n    CLAMP_TO_EDGE: number;\r\n    RENDERBUFFER_DEPTH_SIZE: number;\r\n    TEXTURE_WRAP_S: number;\r\n    ELEMENT_ARRAY_BUFFER: number;\r\n    UNSIGNED_SHORT_5_6_5: number;\r\n    ACTIVE_UNIFORMS: number;\r\n    FLOAT_VEC3: number;\r\n    NO_ERROR: number;\r\n    ATTACHED_SHADERS: number;\r\n    DEPTH_ATTACHMENT: number;\r\n    TEXTURE11: number;\r\n    STENCIL_TEST: number;\r\n    ONE: number;\r\n    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;\r\n    STATIC_DRAW: number;\r\n    GEQUAL: number;\r\n    BOOL_VEC4: number;\r\n    COLOR_ATTACHMENT0: number;\r\n    PACK_ALIGNMENT: number;\r\n    MAX_TEXTURE_SIZE: number;\r\n    STENCIL_PASS_DEPTH_FAIL: number;\r\n    CULL_FACE_MODE: number;\r\n    TEXTURE16: number;\r\n    STENCIL_BACK_WRITEMASK: number;\r\n    SRC_ALPHA: number;\r\n    UNSIGNED_SHORT: number;\r\n    TEXTURE21: number;\r\n    FUNC_REVERSE_SUBTRACT: number;\r\n    SHADING_LANGUAGE_VERSION: number;\r\n    EQUAL: number;\r\n    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;\r\n    BOOL_VEC3: number;\r\n    SAMPLER_2D: number;\r\n    TEXTURE_CUBE_MAP_NEGATIVE_X: number;\r\n    MAX_TEXTURE_IMAGE_UNITS: number;\r\n    TEXTURE_CUBE_MAP_POSITIVE_Y: number;\r\n    RENDERBUFFER_INTERNAL_FORMAT: number;\r\n    STENCIL_VALUE_MASK: number;\r\n    ELEMENT_ARRAY_BUFFER_BINDING: number;\r\n    ARRAY_BUFFER: number;\r\n    DEPTH_RANGE: number;\r\n    NICEST: number;\r\n    ACTIVE_ATTRIBUTES: number;\r\n    NEVER: number;\r\n    FLOAT_VEC4: number;\r\n    CURRENT_VERTEX_ATTRIB: number;\r\n    STENCIL_PASS_DEPTH_PASS: number;\r\n    INVERT: number;\r\n    LINK_STATUS: number;\r\n    RGB: number;\r\n    INT_VEC4: number;\r\n    TEXTURE2: number;\r\n    UNPACK_COLORSPACE_CONVERSION_WEBGL: number;\r\n    MEDIUM_FLOAT: number;\r\n    SRC_ALPHA_SATURATE: number;\r\n    BUFFER_USAGE: number;\r\n    SHORT: number;\r\n    NONE: number;\r\n    UNSIGNED_BYTE: number;\r\n    INT: number;\r\n    SUBPIXEL_BITS: number;\r\n    KEEP: number;\r\n    SAMPLES: number;\r\n    FRAGMENT_SHADER: number;\r\n    LINE_WIDTH: number;\r\n    BLEND_SRC_RGB: number;\r\n    LOW_FLOAT: number;\r\n    VERSION: number;\r\n}\r\ndeclare var WebGLRenderingContext: {\r\n    prototype: WebGLRenderingContext;\r\n    new(): WebGLRenderingContext;\r\n    DEPTH_FUNC: number;\r\n    DEPTH_COMPONENT16: number;\r\n    REPLACE: number;\r\n    REPEAT: number;\r\n    VERTEX_ATTRIB_ARRAY_ENABLED: number;\r\n    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;\r\n    STENCIL_BUFFER_BIT: number;\r\n    RENDERER: number;\r\n    STENCIL_BACK_REF: number;\r\n    TEXTURE26: number;\r\n    RGB565: number;\r\n    DITHER: number;\r\n    CONSTANT_COLOR: number;\r\n    GENERATE_MIPMAP_HINT: number;\r\n    POINTS: number;\r\n    DECR: number;\r\n    INT_VEC3: number;\r\n    TEXTURE28: number;\r\n    ONE_MINUS_CONSTANT_ALPHA: number;\r\n    BACK: number;\r\n    RENDERBUFFER_STENCIL_SIZE: number;\r\n    UNPACK_FLIP_Y_WEBGL: number;\r\n    BLEND: number;\r\n    TEXTURE9: number;\r\n    ARRAY_BUFFER_BINDING: number;\r\n    MAX_VIEWPORT_DIMS: number;\r\n    INVALID_FRAMEBUFFER_OPERATION: number;\r\n    TEXTURE: number;\r\n    TEXTURE0: number;\r\n    TEXTURE31: number;\r\n    TEXTURE24: number;\r\n    HIGH_INT: number;\r\n    RENDERBUFFER_BINDING: number;\r\n    BLEND_COLOR: number;\r\n    FASTEST: number;\r\n    STENCIL_WRITEMASK: number;\r\n    ALIASED_POINT_SIZE_RANGE: number;\r\n    TEXTURE12: number;\r\n    DST_ALPHA: number;\r\n    BLEND_EQUATION_RGB: number;\r\n    FRAMEBUFFER_COMPLETE: number;\r\n    NEAREST_MIPMAP_NEAREST: number;\r\n    VERTEX_ATTRIB_ARRAY_SIZE: number;\r\n    TEXTURE3: number;\r\n    DEPTH_WRITEMASK: number;\r\n    CONTEXT_LOST_WEBGL: number;\r\n    INVALID_VALUE: number;\r\n    TEXTURE_MAG_FILTER: number;\r\n    ONE_MINUS_CONSTANT_COLOR: number;\r\n    ONE_MINUS_SRC_ALPHA: number;\r\n    TEXTURE_CUBE_MAP_POSITIVE_Z: number;\r\n    NOTEQUAL: number;\r\n    ALPHA: number;\r\n    DEPTH_STENCIL: number;\r\n    MAX_VERTEX_UNIFORM_VECTORS: number;\r\n    DEPTH_COMPONENT: number;\r\n    RENDERBUFFER_RED_SIZE: number;\r\n    TEXTURE20: number;\r\n    RED_BITS: number;\r\n    RENDERBUFFER_BLUE_SIZE: number;\r\n    SCISSOR_BOX: number;\r\n    VENDOR: number;\r\n    FRONT_AND_BACK: number;\r\n    CONSTANT_ALPHA: number;\r\n    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;\r\n    NEAREST: number;\r\n    CULL_FACE: number;\r\n    ALIASED_LINE_WIDTH_RANGE: number;\r\n    TEXTURE19: number;\r\n    FRONT: number;\r\n    DEPTH_CLEAR_VALUE: number;\r\n    GREEN_BITS: number;\r\n    TEXTURE29: number;\r\n    TEXTURE23: number;\r\n    MAX_RENDERBUFFER_SIZE: number;\r\n    STENCIL_ATTACHMENT: number;\r\n    TEXTURE27: number;\r\n    BOOL_VEC2: number;\r\n    OUT_OF_MEMORY: number;\r\n    MIRRORED_REPEAT: number;\r\n    POLYGON_OFFSET_UNITS: number;\r\n    TEXTURE_MIN_FILTER: number;\r\n    STENCIL_BACK_PASS_DEPTH_PASS: number;\r\n    LINE_LOOP: number;\r\n    FLOAT_MAT3: number;\r\n    TEXTURE14: number;\r\n    LINEAR: number;\r\n    RGB5_A1: number;\r\n    ONE_MINUS_SRC_COLOR: number;\r\n    SAMPLE_COVERAGE_INVERT: number;\r\n    DONT_CARE: number;\r\n    FRAMEBUFFER_BINDING: number;\r\n    RENDERBUFFER_ALPHA_SIZE: number;\r\n    STENCIL_REF: number;\r\n    ZERO: number;\r\n    DECR_WRAP: number;\r\n    SAMPLE_COVERAGE: number;\r\n    STENCIL_BACK_FUNC: number;\r\n    TEXTURE30: number;\r\n    VIEWPORT: number;\r\n    STENCIL_BITS: number;\r\n    FLOAT: number;\r\n    COLOR_WRITEMASK: number;\r\n    SAMPLE_COVERAGE_VALUE: number;\r\n    TEXTURE_CUBE_MAP_NEGATIVE_Y: number;\r\n    STENCIL_BACK_FAIL: number;\r\n    FLOAT_MAT4: number;\r\n    UNSIGNED_SHORT_4_4_4_4: number;\r\n    TEXTURE6: number;\r\n    RENDERBUFFER_WIDTH: number;\r\n    RGBA4: number;\r\n    ALWAYS: number;\r\n    BLEND_EQUATION_ALPHA: number;\r\n    COLOR_BUFFER_BIT: number;\r\n    TEXTURE_CUBE_MAP: number;\r\n    DEPTH_BUFFER_BIT: number;\r\n    STENCIL_CLEAR_VALUE: number;\r\n    BLEND_EQUATION: number;\r\n    RENDERBUFFER_GREEN_SIZE: number;\r\n    NEAREST_MIPMAP_LINEAR: number;\r\n    VERTEX_ATTRIB_ARRAY_TYPE: number;\r\n    INCR_WRAP: number;\r\n    ONE_MINUS_DST_COLOR: number;\r\n    HIGH_FLOAT: number;\r\n    BYTE: number;\r\n    FRONT_FACE: number;\r\n    SAMPLE_ALPHA_TO_COVERAGE: number;\r\n    CCW: number;\r\n    TEXTURE13: number;\r\n    MAX_VERTEX_ATTRIBS: number;\r\n    MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;\r\n    TEXTURE_WRAP_T: number;\r\n    UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;\r\n    FLOAT_VEC2: number;\r\n    LUMINANCE: number;\r\n    GREATER: number;\r\n    INT_VEC2: number;\r\n    VALIDATE_STATUS: number;\r\n    FRAMEBUFFER: number;\r\n    FRAMEBUFFER_UNSUPPORTED: number;\r\n    TEXTURE5: number;\r\n    FUNC_SUBTRACT: number;\r\n    BLEND_DST_ALPHA: number;\r\n    SAMPLER_CUBE: number;\r\n    ONE_MINUS_DST_ALPHA: number;\r\n    LESS: number;\r\n    TEXTURE_CUBE_MAP_POSITIVE_X: number;\r\n    BLUE_BITS: number;\r\n    DEPTH_TEST: number;\r\n    VERTEX_ATTRIB_ARRAY_STRIDE: number;\r\n    DELETE_STATUS: number;\r\n    TEXTURE18: number;\r\n    POLYGON_OFFSET_FACTOR: number;\r\n    UNSIGNED_INT: number;\r\n    TEXTURE_2D: number;\r\n    DST_COLOR: number;\r\n    FLOAT_MAT2: number;\r\n    COMPRESSED_TEXTURE_FORMATS: number;\r\n    MAX_FRAGMENT_UNIFORM_VECTORS: number;\r\n    DEPTH_STENCIL_ATTACHMENT: number;\r\n    LUMINANCE_ALPHA: number;\r\n    CW: number;\r\n    VERTEX_ATTRIB_ARRAY_NORMALIZED: number;\r\n    TEXTURE_CUBE_MAP_NEGATIVE_Z: number;\r\n    LINEAR_MIPMAP_LINEAR: number;\r\n    BUFFER_SIZE: number;\r\n    SAMPLE_BUFFERS: number;\r\n    TEXTURE15: number;\r\n    ACTIVE_TEXTURE: number;\r\n    VERTEX_SHADER: number;\r\n    TEXTURE22: number;\r\n    VERTEX_ATTRIB_ARRAY_POINTER: number;\r\n    INCR: number;\r\n    COMPILE_STATUS: number;\r\n    MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;\r\n    TEXTURE7: number;\r\n    UNSIGNED_SHORT_5_5_5_1: number;\r\n    DEPTH_BITS: number;\r\n    RGBA: number;\r\n    TRIANGLE_STRIP: number;\r\n    COLOR_CLEAR_VALUE: number;\r\n    BROWSER_DEFAULT_WEBGL: number;\r\n    INVALID_ENUM: number;\r\n    SCISSOR_TEST: number;\r\n    LINE_STRIP: number;\r\n    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;\r\n    STENCIL_FUNC: number;\r\n    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;\r\n    RENDERBUFFER_HEIGHT: number;\r\n    TEXTURE8: number;\r\n    TRIANGLES: number;\r\n    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;\r\n    STENCIL_BACK_VALUE_MASK: number;\r\n    TEXTURE25: number;\r\n    RENDERBUFFER: number;\r\n    LEQUAL: number;\r\n    TEXTURE1: number;\r\n    STENCIL_INDEX8: number;\r\n    FUNC_ADD: number;\r\n    STENCIL_FAIL: number;\r\n    BLEND_SRC_ALPHA: number;\r\n    BOOL: number;\r\n    ALPHA_BITS: number;\r\n    LOW_INT: number;\r\n    TEXTURE10: number;\r\n    SRC_COLOR: number;\r\n    MAX_VARYING_VECTORS: number;\r\n    BLEND_DST_RGB: number;\r\n    TEXTURE_BINDING_CUBE_MAP: number;\r\n    STENCIL_INDEX: number;\r\n    TEXTURE_BINDING_2D: number;\r\n    MEDIUM_INT: number;\r\n    SHADER_TYPE: number;\r\n    POLYGON_OFFSET_FILL: number;\r\n    DYNAMIC_DRAW: number;\r\n    TEXTURE4: number;\r\n    STENCIL_BACK_PASS_DEPTH_FAIL: number;\r\n    STREAM_DRAW: number;\r\n    MAX_CUBE_MAP_TEXTURE_SIZE: number;\r\n    TEXTURE17: number;\r\n    TRIANGLE_FAN: number;\r\n    UNPACK_ALIGNMENT: number;\r\n    CURRENT_PROGRAM: number;\r\n    LINES: number;\r\n    INVALID_OPERATION: number;\r\n    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;\r\n    LINEAR_MIPMAP_NEAREST: number;\r\n    CLAMP_TO_EDGE: number;\r\n    RENDERBUFFER_DEPTH_SIZE: number;\r\n    TEXTURE_WRAP_S: number;\r\n    ELEMENT_ARRAY_BUFFER: number;\r\n    UNSIGNED_SHORT_5_6_5: number;\r\n    ACTIVE_UNIFORMS: number;\r\n    FLOAT_VEC3: number;\r\n    NO_ERROR: number;\r\n    ATTACHED_SHADERS: number;\r\n    DEPTH_ATTACHMENT: number;\r\n    TEXTURE11: number;\r\n    STENCIL_TEST: number;\r\n    ONE: number;\r\n    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;\r\n    STATIC_DRAW: number;\r\n    GEQUAL: number;\r\n    BOOL_VEC4: number;\r\n    COLOR_ATTACHMENT0: number;\r\n    PACK_ALIGNMENT: number;\r\n    MAX_TEXTURE_SIZE: number;\r\n    STENCIL_PASS_DEPTH_FAIL: number;\r\n    CULL_FACE_MODE: number;\r\n    TEXTURE16: number;\r\n    STENCIL_BACK_WRITEMASK: number;\r\n    SRC_ALPHA: number;\r\n    UNSIGNED_SHORT: number;\r\n    TEXTURE21: number;\r\n    FUNC_REVERSE_SUBTRACT: number;\r\n    SHADING_LANGUAGE_VERSION: number;\r\n    EQUAL: number;\r\n    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;\r\n    BOOL_VEC3: number;\r\n    SAMPLER_2D: number;\r\n    TEXTURE_CUBE_MAP_NEGATIVE_X: number;\r\n    MAX_TEXTURE_IMAGE_UNITS: number;\r\n    TEXTURE_CUBE_MAP_POSITIVE_Y: number;\r\n    RENDERBUFFER_INTERNAL_FORMAT: number;\r\n    STENCIL_VALUE_MASK: number;\r\n    ELEMENT_ARRAY_BUFFER_BINDING: number;\r\n    ARRAY_BUFFER: number;\r\n    DEPTH_RANGE: number;\r\n    NICEST: number;\r\n    ACTIVE_ATTRIBUTES: number;\r\n    NEVER: number;\r\n    FLOAT_VEC4: number;\r\n    CURRENT_VERTEX_ATTRIB: number;\r\n    STENCIL_PASS_DEPTH_PASS: number;\r\n    INVERT: number;\r\n    LINK_STATUS: number;\r\n    RGB: number;\r\n    INT_VEC4: number;\r\n    TEXTURE2: number;\r\n    UNPACK_COLORSPACE_CONVERSION_WEBGL: number;\r\n    MEDIUM_FLOAT: number;\r\n    SRC_ALPHA_SATURATE: number;\r\n    BUFFER_USAGE: number;\r\n    SHORT: number;\r\n    NONE: number;\r\n    UNSIGNED_BYTE: number;\r\n    INT: number;\r\n    SUBPIXEL_BITS: number;\r\n    KEEP: number;\r\n    SAMPLES: number;\r\n    FRAGMENT_SHADER: number;\r\n    LINE_WIDTH: number;\r\n    BLEND_SRC_RGB: number;\r\n    LOW_FLOAT: number;\r\n    VERSION: number;\r\n}\r\n\r\ninterface WebGLProgram extends WebGLObject {\r\n}\r\ndeclare var WebGLProgram: {\r\n    prototype: WebGLProgram;\r\n    new(): WebGLProgram;\r\n}\r\n\r\ninterface OES_standard_derivatives {\r\n    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: number;\r\n}\r\ndeclare var OES_standard_derivatives: {\r\n    prototype: OES_standard_derivatives;\r\n    new(): OES_standard_derivatives;\r\n    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: number;\r\n}\r\n\r\ninterface WebGLFramebuffer extends WebGLObject {\r\n}\r\ndeclare var WebGLFramebuffer: {\r\n    prototype: WebGLFramebuffer;\r\n    new(): WebGLFramebuffer;\r\n}\r\n\r\ninterface WebGLShader extends WebGLObject {\r\n}\r\ndeclare var WebGLShader: {\r\n    prototype: WebGLShader;\r\n    new(): WebGLShader;\r\n}\r\n\r\ninterface OES_texture_float_linear {\r\n}\r\ndeclare var OES_texture_float_linear: {\r\n    prototype: OES_texture_float_linear;\r\n    new(): OES_texture_float_linear;\r\n}\r\n\r\ninterface WebGLObject {\r\n}\r\ndeclare var WebGLObject: {\r\n    prototype: WebGLObject;\r\n    new(): WebGLObject;\r\n}\r\n\r\ninterface WebGLBuffer extends WebGLObject {\r\n}\r\ndeclare var WebGLBuffer: {\r\n    prototype: WebGLBuffer;\r\n    new(): WebGLBuffer;\r\n}\r\n\r\ninterface WebGLShaderPrecisionFormat {\r\n    rangeMin: number;\r\n    rangeMax: number;\r\n    precision: number;\r\n}\r\ndeclare var WebGLShaderPrecisionFormat: {\r\n    prototype: WebGLShaderPrecisionFormat;\r\n    new(): WebGLShaderPrecisionFormat;\r\n}\r\n\r\ninterface EXT_texture_filter_anisotropic {\r\n    TEXTURE_MAX_ANISOTROPY_EXT: number;\r\n    MAX_TEXTURE_MAX_ANISOTROPY_EXT: number;\r\n}\r\ndeclare var EXT_texture_filter_anisotropic: {\r\n    prototype: EXT_texture_filter_anisotropic;\r\n    new(): EXT_texture_filter_anisotropic;\r\n    TEXTURE_MAX_ANISOTROPY_EXT: number;\r\n    MAX_TEXTURE_MAX_ANISOTROPY_EXT: number;\r\n}\r\n\r\ndeclare var Option: { new(text?: string, value?: string, defaultSelected?: boolean, selected?:boolean): HTMLOptionElement; };\r\ndeclare var Image: { new(width?: number, height?: number): HTMLImageElement; };\r\ndeclare var Audio: { new(src?: string): HTMLAudioElement; };\r\n\r\ndeclare var ondragend: (ev: DragEvent) => any;\r\ndeclare var onkeydown: (ev: KeyboardEvent) => any;\r\ndeclare var ondragover: (ev: DragEvent) => any;\r\ndeclare var onkeyup: (ev: KeyboardEvent) => any;\r\ndeclare var onreset: (ev: Event) => any;\r\ndeclare var onmouseup: (ev: MouseEvent) => any;\r\ndeclare var ondragstart: (ev: DragEvent) => any;\r\ndeclare var ondrag: (ev: DragEvent) => any;\r\ndeclare var screenX: number;\r\ndeclare var onmouseover: (ev: MouseEvent) => any;\r\ndeclare var ondragleave: (ev: DragEvent) => any;\r\ndeclare var history: History;\r\ndeclare var pageXOffset: number;\r\ndeclare var name: string;\r\ndeclare var onafterprint: (ev: Event) => any;\r\ndeclare var onpause: (ev: Event) => any;\r\ndeclare var onbeforeprint: (ev: Event) => any;\r\ndeclare var top: Window;\r\ndeclare var onmousedown: (ev: MouseEvent) => any;\r\ndeclare var onseeked: (ev: Event) => any;\r\ndeclare var opener: Window;\r\ndeclare var onclick: (ev: MouseEvent) => any;\r\ndeclare var innerHeight: number;\r\ndeclare var onwaiting: (ev: Event) => any;\r\ndeclare var ononline: (ev: Event) => any;\r\ndeclare var ondurationchange: (ev: Event) => any;\r\ndeclare var frames: Window;\r\ndeclare var onblur: (ev: FocusEvent) => any;\r\ndeclare var onemptied: (ev: Event) => any;\r\ndeclare var onseeking: (ev: Event) => any;\r\ndeclare var oncanplay: (ev: Event) => any;\r\ndeclare var outerWidth: number;\r\ndeclare var onstalled: (ev: Event) => any;\r\ndeclare var onmousemove: (ev: MouseEvent) => any;\r\ndeclare var innerWidth: number;\r\ndeclare var onoffline: (ev: Event) => any;\r\ndeclare var length: number;\r\ndeclare var screen: Screen;\r\ndeclare var onbeforeunload: (ev: BeforeUnloadEvent) => any;\r\ndeclare var onratechange: (ev: Event) => any;\r\ndeclare var onstorage: (ev: StorageEvent) => any;\r\ndeclare var onloadstart: (ev: Event) => any;\r\ndeclare var ondragenter: (ev: DragEvent) => any;\r\ndeclare var onsubmit: (ev: Event) => any;\r\ndeclare var self: Window;\r\ndeclare var document: Document;\r\ndeclare var onprogress: (ev: ProgressEvent) => any;\r\ndeclare var ondblclick: (ev: MouseEvent) => any;\r\ndeclare var pageYOffset: number;\r\ndeclare var oncontextmenu: (ev: MouseEvent) => any;\r\ndeclare var onchange: (ev: Event) => any;\r\ndeclare var onloadedmetadata: (ev: Event) => any;\r\ndeclare var onplay: (ev: Event) => any;\r\ndeclare var onerror: ErrorEventHandler;\r\ndeclare var onplaying: (ev: Event) => any;\r\ndeclare var parent: Window;\r\ndeclare var location: Location;\r\ndeclare var oncanplaythrough: (ev: Event) => any;\r\ndeclare var onabort: (ev: UIEvent) => any;\r\ndeclare var onreadystatechange: (ev: Event) => any;\r\ndeclare var outerHeight: number;\r\ndeclare var onkeypress: (ev: KeyboardEvent) => any;\r\ndeclare var frameElement: Element;\r\ndeclare var onloadeddata: (ev: Event) => any;\r\ndeclare var onsuspend: (ev: Event) => any;\r\ndeclare var window: Window;\r\ndeclare var onfocus: (ev: FocusEvent) => any;\r\ndeclare var onmessage: (ev: MessageEvent) => any;\r\ndeclare var ontimeupdate: (ev: Event) => any;\r\ndeclare var onresize: (ev: UIEvent) => any;\r\ndeclare var onselect: (ev: UIEvent) => any;\r\ndeclare var navigator: Navigator;\r\ndeclare var styleMedia: StyleMedia;\r\ndeclare var ondrop: (ev: DragEvent) => any;\r\ndeclare var onmouseout: (ev: MouseEvent) => any;\r\ndeclare var onended: (ev: Event) => any;\r\ndeclare var onhashchange: (ev: Event) => any;\r\ndeclare var onunload: (ev: Event) => any;\r\ndeclare var onscroll: (ev: UIEvent) => any;\r\ndeclare var screenY: number;\r\ndeclare var onmousewheel: (ev: MouseWheelEvent) => any;\r\ndeclare var onload: (ev: Event) => any;\r\ndeclare var onvolumechange: (ev: Event) => any;\r\ndeclare var oninput: (ev: Event) => any;\r\ndeclare var performance: Performance;\r\ndeclare var onmspointerdown: (ev: any) => any;\r\ndeclare var animationStartTime: number;\r\ndeclare var onmsgesturedoubletap: (ev: any) => any;\r\ndeclare var onmspointerhover: (ev: any) => any;\r\ndeclare var onmsgesturehold: (ev: any) => any;\r\ndeclare var onmspointermove: (ev: any) => any;\r\ndeclare var onmsgesturechange: (ev: any) => any;\r\ndeclare var onmsgesturestart: (ev: any) => any;\r\ndeclare var onmspointercancel: (ev: any) => any;\r\ndeclare var onmsgestureend: (ev: any) => any;\r\ndeclare var onmsgesturetap: (ev: any) => any;\r\ndeclare var onmspointerout: (ev: any) => any;\r\ndeclare var msAnimationStartTime: number;\r\ndeclare var applicationCache: ApplicationCache;\r\ndeclare var onmsinertiastart: (ev: any) => any;\r\ndeclare var onmspointerover: (ev: any) => any;\r\ndeclare var onpopstate: (ev: PopStateEvent) => any;\r\ndeclare var onmspointerup: (ev: any) => any;\r\ndeclare var onpageshow: (ev: PageTransitionEvent) => any;\r\ndeclare var ondevicemotion: (ev: DeviceMotionEvent) => any;\r\ndeclare var devicePixelRatio: number;\r\ndeclare var msCrypto: Crypto;\r\ndeclare var ondeviceorientation: (ev: DeviceOrientationEvent) => any;\r\ndeclare var doNotTrack: string;\r\ndeclare var onmspointerenter: (ev: any) => any;\r\ndeclare var onpagehide: (ev: PageTransitionEvent) => any;\r\ndeclare var onmspointerleave: (ev: any) => any;\r\ndeclare function alert(message?: any): void;\r\ndeclare function scroll(x?: number, y?: number): void;\r\ndeclare function focus(): void;\r\ndeclare function scrollTo(x?: number, y?: number): void;\r\ndeclare function print(): void;\r\ndeclare function prompt(message?: string, _default?: string): string;\r\ndeclare function toString(): string;\r\ndeclare function open(url?: string, target?: string, features?: string, replace?: boolean): Window;\r\ndeclare function scrollBy(x?: number, y?: number): void;\r\ndeclare function confirm(message?: string): boolean;\r\ndeclare function close(): void;\r\ndeclare function postMessage(message: any, targetOrigin: string, ports?: any): void;\r\ndeclare function showModalDialog(url?: string, argument?: any, options?: any): any;\r\ndeclare function blur(): void;\r\ndeclare function getSelection(): Selection;\r\ndeclare function getComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration;\r\ndeclare function msCancelRequestAnimationFrame(handle: number): void;\r\ndeclare function matchMedia(mediaQuery: string): MediaQueryList;\r\ndeclare function cancelAnimationFrame(handle: number): void;\r\ndeclare function msIsStaticHTML(html: string): boolean;\r\ndeclare function msMatchMedia(mediaQuery: string): MediaQueryList;\r\ndeclare function requestAnimationFrame(callback: FrameRequestCallback): number;\r\ndeclare function msRequestAnimationFrame(callback: FrameRequestCallback): number;\r\ndeclare function removeEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\ndeclare function dispatchEvent(evt: Event): boolean;\r\ndeclare function attachEvent(event: string, listener: EventListener): boolean;\r\ndeclare function detachEvent(event: string, listener: EventListener): void;\r\ndeclare var localStorage: Storage;\r\ndeclare var status: string;\r\ndeclare var onmouseleave: (ev: MouseEvent) => any;\r\ndeclare var screenLeft: number;\r\ndeclare var offscreenBuffering: any;\r\ndeclare var maxConnectionsPerServer: number;\r\ndeclare var onmouseenter: (ev: MouseEvent) => any;\r\ndeclare var clipboardData: DataTransfer;\r\ndeclare var defaultStatus: string;\r\ndeclare var clientInformation: Navigator;\r\ndeclare var closed: boolean;\r\ndeclare var onhelp: (ev: Event) => any;\r\ndeclare var external: External;\r\ndeclare var event: MSEventObj;\r\ndeclare var onfocusout: (ev: FocusEvent) => any;\r\ndeclare var screenTop: number;\r\ndeclare var onfocusin: (ev: FocusEvent) => any;\r\ndeclare function showModelessDialog(url?: string, argument?: any, options?: any): Window;\r\ndeclare function navigate(url: string): void;\r\ndeclare function resizeBy(x?: number, y?: number): void;\r\ndeclare function item(index: any): any;\r\ndeclare function resizeTo(x?: number, y?: number): void;\r\ndeclare function createPopup(arguments?: any): MSPopupWindow;\r\ndeclare function toStaticHTML(html: string): string;\r\ndeclare function execScript(code: string, language?: string): any;\r\ndeclare function msWriteProfilerMark(profilerMarkName: string): void;\r\ndeclare function moveTo(x?: number, y?: number): void;\r\ndeclare function moveBy(x?: number, y?: number): void;\r\ndeclare function showHelp(url: string, helpArg?: any, features?: string): void;\r\ndeclare function captureEvents(): void;\r\ndeclare function releaseEvents(): void;\r\ndeclare var sessionStorage: Storage;\r\ndeclare function clearTimeout(handle: number): void;\r\ndeclare function setTimeout(handler: any, timeout?: any, ...args: any[]): number;\r\ndeclare function clearInterval(handle: number): void;\r\ndeclare function setInterval(handler: any, timeout?: any, ...args: any[]): number;\r\ndeclare function msSetImmediate(expression: any, ...args: any[]): number;\r\ndeclare function clearImmediate(handle: number): void;\r\ndeclare function msClearImmediate(handle: number): void;\r\ndeclare function setImmediate(expression: any, ...args: any[]): number;\r\ndeclare function btoa(rawString: string): string;\r\ndeclare function atob(encodedString: string): string;\r\ndeclare var msIndexedDB: IDBFactory;\r\ndeclare var indexedDB: IDBFactory;\r\ndeclare var console: Console;\r\ndeclare var onpointerenter: (ev: PointerEvent) => any;\r\ndeclare var onpointerout: (ev: PointerEvent) => any;\r\ndeclare var onpointerdown: (ev: PointerEvent) => any;\r\ndeclare var onpointerup: (ev: PointerEvent) => any;\r\ndeclare var onpointercancel: (ev: PointerEvent) => any;\r\ndeclare var onpointerover: (ev: PointerEvent) => any;\r\ndeclare var onpointermove: (ev: PointerEvent) => any;\r\ndeclare var onpointerleave: (ev: PointerEvent) => any;\r\ndeclare function addEventListener(type: \"mouseleave\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mouseenter\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"help\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"focusout\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"focusin\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pointerenter\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pointerout\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pointerdown\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pointerup\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pointercancel\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pointerover\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pointermove\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pointerleave\", listener: (ev: PointerEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"dragend\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"keydown\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"dragover\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"keyup\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"reset\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mouseup\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"dragstart\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"drag\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mouseover\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"dragleave\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"afterprint\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pause\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"beforeprint\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mousedown\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"seeked\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"click\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"waiting\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"online\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"durationchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"blur\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"emptied\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"seeking\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"canplay\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"stalled\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mousemove\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"offline\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"beforeunload\", listener: (ev: BeforeUnloadEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"ratechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"storage\", listener: (ev: StorageEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"loadstart\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"dragenter\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"submit\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"progress\", listener: (ev: ProgressEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"dblclick\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"contextmenu\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"change\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"loadedmetadata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"play\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"playing\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"canplaythrough\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"abort\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"readystatechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"keypress\", listener: (ev: KeyboardEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"loadeddata\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"suspend\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"focus\", listener: (ev: FocusEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"message\", listener: (ev: MessageEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"timeupdate\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"resize\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"select\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"drop\", listener: (ev: DragEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mouseout\", listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"ended\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"hashchange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"unload\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"scroll\", listener: (ev: UIEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mousewheel\", listener: (ev: MouseWheelEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"load\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"volumechange\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"input\", listener: (ev: Event) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointerdown\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"msgesturedoubletap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointerhover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"msgesturehold\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointermove\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"msgesturechange\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"msgesturestart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointercancel\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"msgestureend\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"msgesturetap\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointerout\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"msinertiastart\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointerover\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"popstate\", listener: (ev: PopStateEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointerup\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pageshow\", listener: (ev: PageTransitionEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"devicemotion\", listener: (ev: DeviceMotionEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"deviceorientation\", listener: (ev: DeviceOrientationEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointerenter\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"pagehide\", listener: (ev: PageTransitionEvent) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: \"mspointerleave\", listener: (ev: any) => any, useCapture?: boolean): void;\r\ndeclare function addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\r\n\r\n/////////////////////////////\r\n/// WorkerGlobalScope APIs \r\n/////////////////////////////\r\n// These are only available in a Web Worker \r\ndeclare function importScripts(...urls: string[]): void;\r\n\r\n\r\n/////////////////////////////\r\n/// Windows Script Host APIS\r\n/////////////////////////////\r\n\r\ndeclare var ActiveXObject: { new (s: string): any; };\r\n\r\ninterface ITextWriter {\r\n    Write(s: string): void;\r\n    WriteLine(s: string): void;\r\n    Close(): void;\r\n}\r\n\r\ndeclare var WScript: {\r\n    Echo(s: any): void;\r\n    StdErr: ITextWriter;\r\n    StdOut: ITextWriter;\r\n    Arguments: { length: number; Item(n: number): string; };\r\n    ScriptFullName: string;\r\n    Quit(exitCode?: number): number;\r\n}\r\n";

var echo;
if(typeof WScript != 'undefined') {
    echo = WScript.Echo;
}
else if(typeof print != 'undefined') {
    echo = print;
}

var console = {
    'log': function() {
        echo(Array.prototype.join.call(arguments, ', '));
    }
};

var startTime = Date.now();
var ts;
(function (ts) {
    ts.Diagnostics = {
        Unterminated_string_literal: { code: 1002, category: 1 /* Error */, key: "Unterminated string literal." },
        Identifier_expected: { code: 1003, category: 1 /* Error */, key: "Identifier expected." },
        _0_expected: { code: 1005, category: 1 /* Error */, key: "'{0}' expected." },
        Trailing_comma_not_allowed: { code: 1009, category: 1 /* Error */, key: "Trailing comma not allowed." },
        Asterisk_Slash_expected: { code: 1010, category: 1 /* Error */, key: "'*/' expected." },
        Unexpected_token: { code: 1012, category: 1 /* Error */, key: "Unexpected token." },
        Catch_clause_parameter_cannot_have_a_type_annotation: { code: 1013, category: 1 /* Error */, key: "Catch clause parameter cannot have a type annotation." },
        A_rest_parameter_must_be_last_in_a_parameter_list: { code: 1014, category: 1 /* Error */, key: "A rest parameter must be last in a parameter list." },
        Parameter_cannot_have_question_mark_and_initializer: { code: 1015, category: 1 /* Error */, key: "Parameter cannot have question mark and initializer." },
        A_required_parameter_cannot_follow_an_optional_parameter: { code: 1016, category: 1 /* Error */, key: "A required parameter cannot follow an optional parameter." },
        An_index_signature_cannot_have_a_rest_parameter: { code: 1017, category: 1 /* Error */, key: "An index signature cannot have a rest parameter." },
        An_index_signature_parameter_cannot_have_an_accessibility_modifier: { code: 1018, category: 1 /* Error */, key: "An index signature parameter cannot have an accessibility modifier." },
        An_index_signature_parameter_cannot_have_a_question_mark: { code: 1019, category: 1 /* Error */, key: "An index signature parameter cannot have a question mark." },
        An_index_signature_parameter_cannot_have_an_initializer: { code: 1020, category: 1 /* Error */, key: "An index signature parameter cannot have an initializer." },
        An_index_signature_must_have_a_type_annotation: { code: 1021, category: 1 /* Error */, key: "An index signature must have a type annotation." },
        An_index_signature_parameter_must_have_a_type_annotation: { code: 1022, category: 1 /* Error */, key: "An index signature parameter must have a type annotation." },
        An_index_signature_parameter_type_must_be_string_or_number: { code: 1023, category: 1 /* Error */, key: "An index signature parameter type must be 'string' or 'number'." },
        A_class_or_interface_declaration_can_only_have_one_extends_clause: { code: 1024, category: 1 /* Error */, key: "A class or interface declaration can only have one 'extends' clause." },
        An_extends_clause_must_precede_an_implements_clause: { code: 1025, category: 1 /* Error */, key: "An 'extends' clause must precede an 'implements' clause." },
        A_class_can_only_extend_a_single_class: { code: 1026, category: 1 /* Error */, key: "A class can only extend a single class." },
        A_class_declaration_can_only_have_one_implements_clause: { code: 1027, category: 1 /* Error */, key: "A class declaration can only have one 'implements' clause." },
        Accessibility_modifier_already_seen: { code: 1028, category: 1 /* Error */, key: "Accessibility modifier already seen." },
        _0_modifier_must_precede_1_modifier: { code: 1029, category: 1 /* Error */, key: "'{0}' modifier must precede '{1}' modifier." },
        _0_modifier_already_seen: { code: 1030, category: 1 /* Error */, key: "'{0}' modifier already seen." },
        _0_modifier_cannot_appear_on_a_class_element: { code: 1031, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a class element." },
        An_interface_declaration_cannot_have_an_implements_clause: { code: 1032, category: 1 /* Error */, key: "An interface declaration cannot have an 'implements' clause." },
        super_must_be_followed_by_an_argument_list_or_member_access: { code: 1034, category: 1 /* Error */, key: "'super' must be followed by an argument list or member access." },
        Only_ambient_modules_can_use_quoted_names: { code: 1035, category: 1 /* Error */, key: "Only ambient modules can use quoted names." },
        Statements_are_not_allowed_in_ambient_contexts: { code: 1036, category: 1 /* Error */, key: "Statements are not allowed in ambient contexts." },
        A_function_implementation_cannot_be_declared_in_an_ambient_context: { code: 1037, category: 1 /* Error */, key: "A function implementation cannot be declared in an ambient context." },
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: { code: 1038, category: 1 /* Error */, key: "A 'declare' modifier cannot be used in an already ambient context." },
        Initializers_are_not_allowed_in_ambient_contexts: { code: 1039, category: 1 /* Error */, key: "Initializers are not allowed in ambient contexts." },
        _0_modifier_cannot_appear_on_a_module_element: { code: 1044, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a module element." },
        A_declare_modifier_cannot_be_used_with_an_interface_declaration: { code: 1045, category: 1 /* Error */, key: "A 'declare' modifier cannot be used with an interface declaration." },
        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: { code: 1046, category: 1 /* Error */, key: "A 'declare' modifier is required for a top level declaration in a .d.ts file." },
        A_rest_parameter_cannot_be_optional: { code: 1047, category: 1 /* Error */, key: "A rest parameter cannot be optional." },
        A_rest_parameter_cannot_have_an_initializer: { code: 1048, category: 1 /* Error */, key: "A rest parameter cannot have an initializer." },
        A_set_accessor_must_have_exactly_one_parameter: { code: 1049, category: 1 /* Error */, key: "A 'set' accessor must have exactly one parameter." },
        A_set_accessor_cannot_have_an_optional_parameter: { code: 1051, category: 1 /* Error */, key: "A 'set' accessor cannot have an optional parameter." },
        A_set_accessor_parameter_cannot_have_an_initializer: { code: 1052, category: 1 /* Error */, key: "A 'set' accessor parameter cannot have an initializer." },
        A_set_accessor_cannot_have_rest_parameter: { code: 1053, category: 1 /* Error */, key: "A 'set' accessor cannot have rest parameter." },
        A_get_accessor_cannot_have_parameters: { code: 1054, category: 1 /* Error */, key: "A 'get' accessor cannot have parameters." },
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: { code: 1056, category: 1 /* Error */, key: "Accessors are only available when targeting ECMAScript 5 and higher." },
        Enum_member_must_have_initializer: { code: 1061, category: 1 /* Error */, key: "Enum member must have initializer." },
        An_export_assignment_cannot_be_used_in_an_internal_module: { code: 1063, category: 1 /* Error */, key: "An export assignment cannot be used in an internal module." },
        Ambient_enum_elements_can_only_have_integer_literal_initializers: { code: 1066, category: 1 /* Error */, key: "Ambient enum elements can only have integer literal initializers." },
        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: { code: 1068, category: 1 /* Error */, key: "Unexpected token. A constructor, method, accessor, or property was expected." },
        A_declare_modifier_cannot_be_used_with_an_import_declaration: { code: 1079, category: 1 /* Error */, key: "A 'declare' modifier cannot be used with an import declaration." },
        Invalid_reference_directive_syntax: { code: 1084, category: 1 /* Error */, key: "Invalid 'reference' directive syntax." },
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: { code: 1085, category: 1 /* Error */, key: "Octal literals are not available when targeting ECMAScript 5 and higher." },
        An_accessor_cannot_be_declared_in_an_ambient_context: { code: 1086, category: 1 /* Error */, key: "An accessor cannot be declared in an ambient context." },
        _0_modifier_cannot_appear_on_a_constructor_declaration: { code: 1089, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a constructor declaration." },
        _0_modifier_cannot_appear_on_a_parameter: { code: 1090, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a parameter." },
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: { code: 1091, category: 1 /* Error */, key: "Only a single variable declaration is allowed in a 'for...in' statement." },
        Type_parameters_cannot_appear_on_a_constructor_declaration: { code: 1092, category: 1 /* Error */, key: "Type parameters cannot appear on a constructor declaration." },
        Type_annotation_cannot_appear_on_a_constructor_declaration: { code: 1093, category: 1 /* Error */, key: "Type annotation cannot appear on a constructor declaration." },
        An_accessor_cannot_have_type_parameters: { code: 1094, category: 1 /* Error */, key: "An accessor cannot have type parameters." },
        A_set_accessor_cannot_have_a_return_type_annotation: { code: 1095, category: 1 /* Error */, key: "A 'set' accessor cannot have a return type annotation." },
        An_index_signature_must_have_exactly_one_parameter: { code: 1096, category: 1 /* Error */, key: "An index signature must have exactly one parameter." },
        _0_list_cannot_be_empty: { code: 1097, category: 1 /* Error */, key: "'{0}' list cannot be empty." },
        Type_parameter_list_cannot_be_empty: { code: 1098, category: 1 /* Error */, key: "Type parameter list cannot be empty." },
        Type_argument_list_cannot_be_empty: { code: 1099, category: 1 /* Error */, key: "Type argument list cannot be empty." },
        Invalid_use_of_0_in_strict_mode: { code: 1100, category: 1 /* Error */, key: "Invalid use of '{0}' in strict mode." },
        with_statements_are_not_allowed_in_strict_mode: { code: 1101, category: 1 /* Error */, key: "'with' statements are not allowed in strict mode." },
        delete_cannot_be_called_on_an_identifier_in_strict_mode: { code: 1102, category: 1 /* Error */, key: "'delete' cannot be called on an identifier in strict mode." },
        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: { code: 1104, category: 1 /* Error */, key: "A 'continue' statement can only be used within an enclosing iteration statement." },
        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: { code: 1105, category: 1 /* Error */, key: "A 'break' statement can only be used within an enclosing iteration or switch statement." },
        Jump_target_cannot_cross_function_boundary: { code: 1107, category: 1 /* Error */, key: "Jump target cannot cross function boundary." },
        A_return_statement_can_only_be_used_within_a_function_body: { code: 1108, category: 1 /* Error */, key: "A 'return' statement can only be used within a function body." },
        Expression_expected: { code: 1109, category: 1 /* Error */, key: "Expression expected." },
        Type_expected: { code: 1110, category: 1 /* Error */, key: "Type expected." },
        A_constructor_implementation_cannot_be_declared_in_an_ambient_context: { code: 1111, category: 1 /* Error */, key: "A constructor implementation cannot be declared in an ambient context." },
        A_class_member_cannot_be_declared_optional: { code: 1112, category: 1 /* Error */, key: "A class member cannot be declared optional." },
        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: { code: 1113, category: 1 /* Error */, key: "A 'default' clause cannot appear more than once in a 'switch' statement." },
        Duplicate_label_0: { code: 1114, category: 1 /* Error */, key: "Duplicate label '{0}'" },
        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: { code: 1115, category: 1 /* Error */, key: "A 'continue' statement can only jump to a label of an enclosing iteration statement." },
        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: { code: 1116, category: 1 /* Error */, key: "A 'break' statement can only jump to a label of an enclosing statement." },
        An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode: { code: 1117, category: 1 /* Error */, key: "An object literal cannot have multiple properties with the same name in strict mode." },
        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: { code: 1118, category: 1 /* Error */, key: "An object literal cannot have multiple get/set accessors with the same name." },
        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: { code: 1119, category: 1 /* Error */, key: "An object literal cannot have property and accessor with the same name." },
        An_export_assignment_cannot_have_modifiers: { code: 1120, category: 1 /* Error */, key: "An export assignment cannot have modifiers." },
        Octal_literals_are_not_allowed_in_strict_mode: { code: 1121, category: 1 /* Error */, key: "Octal literals are not allowed in strict mode." },
        Variable_declaration_list_cannot_be_empty: { code: 1123, category: 1 /* Error */, key: "Variable declaration list cannot be empty." },
        Digit_expected: { code: 1124, category: 1 /* Error */, key: "Digit expected." },
        Hexadecimal_digit_expected: { code: 1125, category: 1 /* Error */, key: "Hexadecimal digit expected." },
        Unexpected_end_of_text: { code: 1126, category: 1 /* Error */, key: "Unexpected end of text." },
        Invalid_character: { code: 1127, category: 1 /* Error */, key: "Invalid character." },
        Declaration_or_statement_expected: { code: 1128, category: 1 /* Error */, key: "Declaration or statement expected." },
        Statement_expected: { code: 1129, category: 1 /* Error */, key: "Statement expected." },
        case_or_default_expected: { code: 1130, category: 1 /* Error */, key: "'case' or 'default' expected." },
        Property_or_signature_expected: { code: 1131, category: 1 /* Error */, key: "Property or signature expected." },
        Enum_member_expected: { code: 1132, category: 1 /* Error */, key: "Enum member expected." },
        Type_reference_expected: { code: 1133, category: 1 /* Error */, key: "Type reference expected." },
        Variable_declaration_expected: { code: 1134, category: 1 /* Error */, key: "Variable declaration expected." },
        Argument_expression_expected: { code: 1135, category: 1 /* Error */, key: "Argument expression expected." },
        Property_assignment_expected: { code: 1136, category: 1 /* Error */, key: "Property assignment expected." },
        Expression_or_comma_expected: { code: 1137, category: 1 /* Error */, key: "Expression or comma expected." },
        Parameter_declaration_expected: { code: 1138, category: 1 /* Error */, key: "Parameter declaration expected." },
        Type_parameter_declaration_expected: { code: 1139, category: 1 /* Error */, key: "Type parameter declaration expected." },
        Type_argument_expected: { code: 1140, category: 1 /* Error */, key: "Type argument expected." },
        String_literal_expected: { code: 1141, category: 1 /* Error */, key: "String literal expected." },
        Line_break_not_permitted_here: { code: 1142, category: 1 /* Error */, key: "Line break not permitted here." },
        catch_or_finally_expected: { code: 1143, category: 1 /* Error */, key: "'catch' or 'finally' expected." },
        Block_or_expected: { code: 1144, category: 1 /* Error */, key: "Block or ';' expected." },
        Modifiers_not_permitted_on_index_signature_members: { code: 1145, category: 1 /* Error */, key: "Modifiers not permitted on index signature members." },
        Declaration_expected: { code: 1146, category: 1 /* Error */, key: "Declaration expected." },
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: { code: 1147, category: 1 /* Error */, key: "Import declarations in an internal module cannot reference an external module." },
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: { code: 1148, category: 1 /* Error */, key: "Cannot compile external modules unless the '--module' flag is provided." },
        Filename_0_differs_from_already_included_filename_1_only_in_casing: { code: 1149, category: 1 /* Error */, key: "Filename '{0}' differs from already included filename '{1}' only in casing" },
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: { code: 1150, category: 1 /* Error */, key: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead." },
        Duplicate_identifier_0: { code: 2300, category: 1 /* Error */, key: "Duplicate identifier '{0}'." },
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: { code: 2301, category: 1 /* Error */, key: "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor." },
        Static_members_cannot_reference_class_type_parameters: { code: 2302, category: 1 /* Error */, key: "Static members cannot reference class type parameters." },
        Circular_definition_of_import_alias_0: { code: 2303, category: 1 /* Error */, key: "Circular definition of import alias '{0}'." },
        Cannot_find_name_0: { code: 2304, category: 1 /* Error */, key: "Cannot find name '{0}'." },
        Module_0_has_no_exported_member_1: { code: 2305, category: 1 /* Error */, key: "Module '{0}' has no exported member '{1}'." },
        File_0_is_not_an_external_module: { code: 2306, category: 1 /* Error */, key: "File '{0}' is not an external module." },
        Cannot_find_external_module_0: { code: 2307, category: 1 /* Error */, key: "Cannot find external module '{0}'." },
        A_module_cannot_have_more_than_one_export_assignment: { code: 2308, category: 1 /* Error */, key: "A module cannot have more than one export assignment." },
        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: { code: 2309, category: 1 /* Error */, key: "An export assignment cannot be used in a module with other exported elements." },
        Type_0_recursively_references_itself_as_a_base_type: { code: 2310, category: 1 /* Error */, key: "Type '{0}' recursively references itself as a base type." },
        A_class_may_only_extend_another_class: { code: 2311, category: 1 /* Error */, key: "A class may only extend another class." },
        An_interface_may_only_extend_a_class_or_another_interface: { code: 2312, category: 1 /* Error */, key: "An interface may only extend a class or another interface." },
        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: { code: 2313, category: 1 /* Error */, key: "Constraint of a type parameter cannot reference any type parameter from the same type parameter list." },
        Generic_type_0_requires_1_type_argument_s: { code: 2314, category: 1 /* Error */, key: "Generic type '{0}' requires {1} type argument(s)." },
        Type_0_is_not_generic: { code: 2315, category: 1 /* Error */, key: "Type '{0}' is not generic." },
        Global_type_0_must_be_a_class_or_interface_type: { code: 2316, category: 1 /* Error */, key: "Global type '{0}' must be a class or interface type." },
        Global_type_0_must_have_1_type_parameter_s: { code: 2317, category: 1 /* Error */, key: "Global type '{0}' must have {1} type parameter(s)." },
        Cannot_find_global_type_0: { code: 2318, category: 1 /* Error */, key: "Cannot find global type '{0}'." },
        Named_properties_0_of_types_1_and_2_are_not_identical: { code: 2319, category: 1 /* Error */, key: "Named properties '{0}' of types '{1}' and '{2}' are not identical." },
        Interface_0_cannot_simultaneously_extend_types_1_and_2_Colon: { code: 2320, category: 1 /* Error */, key: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':" },
        Excessive_stack_depth_comparing_types_0_and_1: { code: 2321, category: 1 /* Error */, key: "Excessive stack depth comparing types '{0}' and '{1}'." },
        Type_0_is_not_assignable_to_type_1_Colon: { code: 2322, category: 1 /* Error */, key: "Type '{0}' is not assignable to type '{1}':" },
        Type_0_is_not_assignable_to_type_1: { code: 2323, category: 1 /* Error */, key: "Type '{0}' is not assignable to type '{1}'." },
        Property_0_is_missing_in_type_1: { code: 2324, category: 1 /* Error */, key: "Property '{0}' is missing in type '{1}'." },
        Private_property_0_cannot_be_reimplemented: { code: 2325, category: 1 /* Error */, key: "Private property '{0}' cannot be reimplemented." },
        Types_of_property_0_are_incompatible_Colon: { code: 2326, category: 1 /* Error */, key: "Types of property '{0}' are incompatible:" },
        Required_property_0_cannot_be_reimplemented_with_optional_property_in_1: { code: 2327, category: 1 /* Error */, key: "Required property '{0}' cannot be reimplemented with optional property in '{1}'." },
        Types_of_parameters_0_and_1_are_incompatible_Colon: { code: 2328, category: 1 /* Error */, key: "Types of parameters '{0}' and '{1}' are incompatible:" },
        Index_signature_is_missing_in_type_0: { code: 2329, category: 1 /* Error */, key: "Index signature is missing in type '{0}'." },
        Index_signatures_are_incompatible_Colon: { code: 2330, category: 1 /* Error */, key: "Index signatures are incompatible:" },
        this_cannot_be_referenced_in_a_module_body: { code: 2331, category: 1 /* Error */, key: "'this' cannot be referenced in a module body." },
        this_cannot_be_referenced_in_current_location: { code: 2332, category: 1 /* Error */, key: "'this' cannot be referenced in current location." },
        this_cannot_be_referenced_in_constructor_arguments: { code: 2333, category: 1 /* Error */, key: "'this' cannot be referenced in constructor arguments." },
        this_cannot_be_referenced_in_a_static_property_initializer: { code: 2334, category: 1 /* Error */, key: "'this' cannot be referenced in a static property initializer." },
        super_can_only_be_referenced_in_a_derived_class: { code: 2335, category: 1 /* Error */, key: "'super' can only be referenced in a derived class." },
        super_cannot_be_referenced_in_constructor_arguments: { code: 2336, category: 1 /* Error */, key: "'super' cannot be referenced in constructor arguments." },
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: { code: 2337, category: 1 /* Error */, key: "Super calls are not permitted outside constructors or in nested functions inside constructors" },
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: { code: 2338, category: 1 /* Error */, key: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class" },
        Property_0_does_not_exist_on_type_1: { code: 2339, category: 1 /* Error */, key: "Property '{0}' does not exist on type '{1}'." },
        Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: { code: 2340, category: 1 /* Error */, key: "Only public methods of the base class are accessible via the 'super' keyword" },
        Property_0_is_inaccessible: { code: 2341, category: 1 /* Error */, key: "Property '{0}' is inaccessible." },
        An_index_expression_argument_must_be_of_type_string_number_or_any: { code: 2342, category: 1 /* Error */, key: "An index expression argument must be of type 'string', 'number', or 'any'." },
        Type_0_does_not_satisfy_the_constraint_1_Colon: { code: 2343, category: 1 /* Error */, key: "Type '{0}' does not satisfy the constraint '{1}':" },
        Type_0_does_not_satisfy_the_constraint_1: { code: 2344, category: 1 /* Error */, key: "Type '{0}' does not satisfy the constraint '{1}'." },
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: { code: 2345, category: 1 /* Error */, key: "Argument of type '{0}' is not assignable to parameter of type '{1}'." },
        Supplied_parameters_do_not_match_any_signature_of_call_target: { code: 2346, category: 1 /* Error */, key: "Supplied parameters do not match any signature of call target." },
        Untyped_function_calls_may_not_accept_type_arguments: { code: 2347, category: 1 /* Error */, key: "Untyped function calls may not accept type arguments." },
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: { code: 2348, category: 1 /* Error */, key: "Value of type '{0}' is not callable. Did you mean to include 'new'?" },
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: { code: 2349, category: 1 /* Error */, key: "Cannot invoke an expression whose type lacks a call signature." },
        Only_a_void_function_can_be_called_with_the_new_keyword: { code: 2350, category: 1 /* Error */, key: "Only a void function can be called with the 'new' keyword." },
        Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature: { code: 2351, category: 1 /* Error */, key: "Cannot use 'new' with an expression whose type lacks a call or construct signature." },
        Neither_type_0_nor_type_1_is_assignable_to_the_other: { code: 2352, category: 1 /* Error */, key: "Neither type '{0}' nor type '{1}' is assignable to the other." },
        Neither_type_0_nor_type_1_is_assignable_to_the_other_Colon: { code: 2353, category: 1 /* Error */, key: "Neither type '{0}' nor type '{1}' is assignable to the other:" },
        No_best_common_type_exists_among_return_expressions: { code: 2354, category: 1 /* Error */, key: "No best common type exists among return expressions." },
        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2355, category: 1 /* Error */, key: "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement." },
        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: { code: 2356, category: 1 /* Error */, key: "An arithmetic operand must be of type 'any', 'number' or an enum type." },
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: { code: 2357, category: 1 /* Error */, key: "The operand of an increment or decrement operator must be a variable, property or indexer." },
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2358, category: 1 /* Error */, key: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter." },
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: { code: 2359, category: 1 /* Error */, key: "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type." },
        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: { code: 2360, category: 1 /* Error */, key: "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'." },
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2361, category: 1 /* Error */, key: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter" },
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2362, category: 1 /* Error */, key: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type." },
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2363, category: 1 /* Error */, key: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type." },
        Invalid_left_hand_side_of_assignment_expression: { code: 2364, category: 1 /* Error */, key: "Invalid left-hand side of assignment expression." },
        Operator_0_cannot_be_applied_to_types_1_and_2: { code: 2365, category: 1 /* Error */, key: "Operator '{0}' cannot be applied to types '{1}' and '{2}'." },
        No_best_common_type_exists_between_0_1_and_2: { code: 2366, category: 1 /* Error */, key: "No best common type exists between '{0}', '{1}', and '{2}'." },
        No_best_common_type_exists_between_0_and_1: { code: 2367, category: 1 /* Error */, key: "No best common type exists between '{0}' and '{1}'." },
        Type_parameter_name_cannot_be_0: { code: 2368, category: 1 /* Error */, key: "Type parameter name cannot be '{0}'" },
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: { code: 2369, category: 1 /* Error */, key: "A parameter property is only allowed in a constructor implementation." },
        A_rest_parameter_must_be_of_an_array_type: { code: 2370, category: 1 /* Error */, key: "A rest parameter must be of an array type." },
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: { code: 2371, category: 1 /* Error */, key: "A parameter initializer is only allowed in a function or constructor implementation." },
        Parameter_0_cannot_be_referenced_in_its_initializer: { code: 2372, category: 1 /* Error */, key: "Parameter '{0}' cannot be referenced in its initializer." },
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: { code: 2373, category: 1 /* Error */, key: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it." },
        Duplicate_string_index_signature: { code: 2374, category: 1 /* Error */, key: "Duplicate string index signature." },
        Duplicate_number_index_signature: { code: 2375, category: 1 /* Error */, key: "Duplicate number index signature." },
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: { code: 2376, category: 1 /* Error */, key: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties." },
        Constructors_for_derived_classes_must_contain_a_super_call: { code: 2377, category: 1 /* Error */, key: "Constructors for derived classes must contain a 'super' call." },
        A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2378, category: 1 /* Error */, key: "A 'get' accessor must return a value or consist of a single 'throw' statement." },
        Getter_and_setter_accessors_do_not_agree_in_visibility: { code: 2379, category: 1 /* Error */, key: "Getter and setter accessors do not agree in visibility." },
        get_and_set_accessor_must_have_the_same_type: { code: 2380, category: 1 /* Error */, key: "'get' and 'set' accessor must have the same type." },
        A_signature_with_an_implementation_cannot_use_a_string_literal_type: { code: 2381, category: 1 /* Error */, key: "A signature with an implementation cannot use a string literal type." },
        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: { code: 2382, category: 1 /* Error */, key: "Specialized overload signature is not assignable to any non-specialized signature." },
        Overload_signatures_must_all_be_exported_or_not_exported: { code: 2383, category: 1 /* Error */, key: "Overload signatures must all be exported or not exported." },
        Overload_signatures_must_all_be_ambient_or_non_ambient: { code: 2384, category: 1 /* Error */, key: "Overload signatures must all be ambient or non-ambient." },
        Overload_signatures_must_all_be_public_or_private: { code: 2385, category: 1 /* Error */, key: "Overload signatures must all be public or private." },
        Overload_signatures_must_all_be_optional_or_required: { code: 2386, category: 1 /* Error */, key: "Overload signatures must all be optional or required." },
        Function_overload_must_be_static: { code: 2387, category: 1 /* Error */, key: "Function overload must be static." },
        Function_overload_must_not_be_static: { code: 2388, category: 1 /* Error */, key: "Function overload must not be static." },
        Function_implementation_name_must_be_0: { code: 2389, category: 1 /* Error */, key: "Function implementation name must be '{0}'." },
        Constructor_implementation_is_missing: { code: 2390, category: 1 /* Error */, key: "Constructor implementation is missing." },
        Function_implementation_is_missing_or_not_immediately_following_the_declaration: { code: 2391, category: 1 /* Error */, key: "Function implementation is missing or not immediately following the declaration." },
        Multiple_constructor_implementations_are_not_allowed: { code: 2392, category: 1 /* Error */, key: "Multiple constructor implementations are not allowed." },
        Duplicate_function_implementation: { code: 2393, category: 1 /* Error */, key: "Duplicate function implementation." },
        Overload_signature_is_not_compatible_with_function_implementation: { code: 2394, category: 1 /* Error */, key: "Overload signature is not compatible with function implementation." },
        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: { code: 2395, category: 1 /* Error */, key: "Individual declarations in merged declaration {0} must be all exported or all local." },
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: { code: 2396, category: 1 /* Error */, key: "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters." },
        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: { code: 2397, category: 1 /* Error */, key: "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter." },
        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: { code: 2398, category: 1 /* Error */, key: "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter." },
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: { code: 2399, category: 1 /* Error */, key: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference." },
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: { code: 2400, category: 1 /* Error */, key: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference." },
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: { code: 2401, category: 1 /* Error */, key: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference." },
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: { code: 2402, category: 1 /* Error */, key: "Expression resolves to '_super' that compiler uses to capture base class reference." },
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: { code: 2403, category: 1 /* Error */, key: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'." },
        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: { code: 2404, category: 1 /* Error */, key: "The left-hand side of a 'for...in' statement cannot use a type annotation." },
        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: { code: 2405, category: 1 /* Error */, key: "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'." },
        Invalid_left_hand_side_in_for_in_statement: { code: 2406, category: 1 /* Error */, key: "Invalid left-hand side in 'for...in' statement." },
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2407, category: 1 /* Error */, key: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter." },
        Setters_cannot_return_a_value: { code: 2408, category: 1 /* Error */, key: "Setters cannot return a value." },
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: { code: 2409, category: 1 /* Error */, key: "Return type of constructor signature must be assignable to the instance type of the class" },
        All_symbols_within_a_with_block_will_be_resolved_to_any: { code: 2410, category: 1 /* Error */, key: "All symbols within a 'with' block will be resolved to 'any'." },
        Property_0_of_type_1_is_not_assignable_to_string_index_type_2: { code: 2411, category: 1 /* Error */, key: "Property '{0}' of type '{1}' is not assignable to string index type '{2}'." },
        Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2: { code: 2412, category: 1 /* Error */, key: "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'." },
        Numeric_index_type_0_is_not_assignable_to_string_index_type_1: { code: 2413, category: 1 /* Error */, key: "Numeric index type '{0}' is not assignable to string index type '{1}'." },
        Class_name_cannot_be_0: { code: 2414, category: 1 /* Error */, key: "Class name cannot be '{0}'" },
        Class_0_incorrectly_extends_base_class_1: { code: 2415, category: 1 /* Error */, key: "Class '{0}' incorrectly extends base class '{1}'." },
        Class_0_incorrectly_extends_base_class_1_Colon: { code: 2416, category: 1 /* Error */, key: "Class '{0}' incorrectly extends base class '{1}':" },
        Class_static_side_0_incorrectly_extends_base_class_static_side_1: { code: 2417, category: 1 /* Error */, key: "Class static side '{0}' incorrectly extends base class static side '{1}'." },
        Class_static_side_0_incorrectly_extends_base_class_static_side_1_Colon: { code: 2418, category: 1 /* Error */, key: "Class static side '{0}' incorrectly extends base class static side '{1}':" },
        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0: { code: 2419, category: 1 /* Error */, key: "Type name '{0}' in extends clause does not reference constructor function for '{0}'." },
        Class_0_incorrectly_implements_interface_1: { code: 2420, category: 1 /* Error */, key: "Class '{0}' incorrectly implements interface '{1}'." },
        Class_0_incorrectly_implements_interface_1_Colon: { code: 2421, category: 1 /* Error */, key: "Class '{0}' incorrectly implements interface '{1}':" },
        A_class_may_only_implement_another_class_or_interface: { code: 2422, category: 1 /* Error */, key: "A class may only implement another class or interface." },
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: { code: 2423, category: 1 /* Error */, key: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor." },
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: { code: 2424, category: 1 /* Error */, key: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property." },
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2425, category: 1 /* Error */, key: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function." },
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2426, category: 1 /* Error */, key: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function." },
        Interface_name_cannot_be_0: { code: 2427, category: 1 /* Error */, key: "Interface name cannot be '{0}'" },
        All_declarations_of_an_interface_must_have_identical_type_parameters: { code: 2428, category: 1 /* Error */, key: "All declarations of an interface must have identical type parameters." },
        Interface_0_incorrectly_extends_interface_1_Colon: { code: 2429, category: 1 /* Error */, key: "Interface '{0}' incorrectly extends interface '{1}':" },
        Interface_0_incorrectly_extends_interface_1: { code: 2430, category: 1 /* Error */, key: "Interface '{0}' incorrectly extends interface '{1}'." },
        Enum_name_cannot_be_0: { code: 2431, category: 1 /* Error */, key: "Enum name cannot be '{0}'" },
        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: { code: 2432, category: 1 /* Error */, key: "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element." },
        A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: { code: 2433, category: 1 /* Error */, key: "A module declaration cannot be in a different file from a class or function with which it is merged" },
        A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: { code: 2434, category: 1 /* Error */, key: "A module declaration cannot be located prior to a class or function with which it is merged" },
        Ambient_external_modules_cannot_be_nested_in_other_modules: { code: 2435, category: 1 /* Error */, key: "Ambient external modules cannot be nested in other modules." },
        Ambient_external_module_declaration_cannot_specify_relative_module_name: { code: 2436, category: 1 /* Error */, key: "Ambient external module declaration cannot specify relative module name." },
        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: { code: 2437, category: 1 /* Error */, key: "Module '{0}' is hidden by a local declaration with the same name" },
        Import_name_cannot_be_0: { code: 2438, category: 1 /* Error */, key: "Import name cannot be '{0}'" },
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: { code: 2439, category: 1 /* Error */, key: "Import declaration in an ambient external module declaration cannot reference external module through relative external module name." },
        Import_declaration_conflicts_with_local_declaration_of_0: { code: 2440, category: 1 /* Error */, key: "Import declaration conflicts with local declaration of '{0}'" },
        Import_declaration_0_is_using_private_name_1: { code: 4000, category: 1 /* Error */, key: "Import declaration '{0}' is using private name '{1}'." },
        Type_parameter_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4001, category: 1 /* Error */, key: "Type parameter '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: { code: 4002, category: 1 /* Error */, key: "Type parameter '{0}' of exported class has or is using private name '{1}'." },
        Type_parameter_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4003, category: 1 /* Error */, key: "Type parameter '{0}' of exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4004, category: 1 /* Error */, key: "Type parameter '{0}' of exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4005, category: 1 /* Error */, key: "Type parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4006, category: 1 /* Error */, key: "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4007, category: 1 /* Error */, key: "Type parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4008, category: 1 /* Error */, key: "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4009, category: 1 /* Error */, key: "Type parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4010, category: 1 /* Error */, key: "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'." },
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4011, category: 1 /* Error */, key: "Type parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4012, category: 1 /* Error */, key: "Type parameter '{0}' of public method from exported class has or is using private name '{1}'." },
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4013, category: 1 /* Error */, key: "Type parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4014, category: 1 /* Error */, key: "Type parameter '{0}' of method from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4015, category: 1 /* Error */, key: "Type parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4016, category: 1 /* Error */, key: "Type parameter '{0}' of exported function has or is using private name '{1}'." },
        Implements_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2: { code: 4017, category: 1 /* Error */, key: "Implements clause of exported class '{0}' has or is using name '{1}' from private module '{2}'." },
        Extends_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2: { code: 4018, category: 1 /* Error */, key: "Extends clause of exported class '{0}' has or is using name '{1}' from private module '{2}'." },
        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4019, category: 1 /* Error */, key: "Implements clause of exported class '{0}' has or is using private name '{1}'." },
        Extends_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4020, category: 1 /* Error */, key: "Extends clause of exported class '{0}' has or is using private name '{1}'." },
        Extends_clause_of_exported_interface_0_has_or_is_using_name_1_from_private_module_2: { code: 4021, category: 1 /* Error */, key: "Extends clause of exported interface '{0}' has or is using name '{1}' from private module '{2}'." },
        Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: { code: 4022, category: 1 /* Error */, key: "Extends clause of exported interface '{0}' has or is using private name '{1}'." },
        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4023, category: 1 /* Error */, key: "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named." },
        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: { code: 4024, category: 1 /* Error */, key: "Exported variable '{0}' has or is using name '{1}' from private module '{2}'." },
        Exported_variable_0_has_or_is_using_private_name_1: { code: 4025, category: 1 /* Error */, key: "Exported variable '{0}' has or is using private name '{1}'." },
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4026, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4027, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4028, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using private name '{1}'." },
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4029, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4030, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Public_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4031, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using private name '{1}'." },
        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4032, category: 1 /* Error */, key: "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'." },
        Property_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4033, category: 1 /* Error */, key: "Property '{0}' of exported interface has or is using private name '{1}'." },
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4034, category: 1 /* Error */, key: "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4035, category: 1 /* Error */, key: "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'." },
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4036, category: 1 /* Error */, key: "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4037, category: 1 /* Error */, key: "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4038, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4039, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4040, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using private name '{0}'." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4041, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4042, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4043, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using private name '{0}'." },
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4044, category: 1 /* Error */, key: "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4045, category: 1 /* Error */, key: "Return type of constructor signature from exported interface has or is using private name '{0}'." },
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4046, category: 1 /* Error */, key: "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4047, category: 1 /* Error */, key: "Return type of call signature from exported interface has or is using private name '{0}'." },
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4048, category: 1 /* Error */, key: "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4049, category: 1 /* Error */, key: "Return type of index signature from exported interface has or is using private name '{0}'." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4050, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4051, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: { code: 4052, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using private name '{0}'." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4053, category: 1 /* Error */, key: "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4054, category: 1 /* Error */, key: "Return type of public method from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: { code: 4055, category: 1 /* Error */, key: "Return type of public method from exported class has or is using private name '{0}'." },
        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4056, category: 1 /* Error */, key: "Return type of method from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: { code: 4057, category: 1 /* Error */, key: "Return type of method from exported interface has or is using private name '{0}'." },
        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4058, category: 1 /* Error */, key: "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: { code: 4059, category: 1 /* Error */, key: "Return type of exported function has or is using name '{0}' from private module '{1}'." },
        Return_type_of_exported_function_has_or_is_using_private_name_0: { code: 4060, category: 1 /* Error */, key: "Return type of exported function has or is using private name '{0}'." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4061, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4062, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: { code: 4063, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using private name '{1}'." },
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4064, category: 1 /* Error */, key: "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4065, category: 1 /* Error */, key: "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'." },
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4066, category: 1 /* Error */, key: "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4067, category: 1 /* Error */, key: "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4068, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4069, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4070, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using private name '{1}'." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4071, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4072, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4073, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using private name '{1}'." },
        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4074, category: 1 /* Error */, key: "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4075, category: 1 /* Error */, key: "Parameter '{0}' of method from exported interface has or is using private name '{1}'." },
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4076, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4077, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4078, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using private name '{1}'." },
        The_current_host_does_not_support_the_0_option: { code: 5001, category: 1 /* Error */, key: "The current host does not support the '{0}' option." },
        Cannot_find_the_common_subdirectory_path_for_the_input_files: { code: 5009, category: 1 /* Error */, key: "Cannot find the common subdirectory path for the input files." },
        Cannot_read_file_0_Colon_1: { code: 5012, category: 1 /* Error */, key: "Cannot read file '{0}': {1}" },
        Unsupported_file_encoding: { code: 5013, category: 1 /* Error */, key: "Unsupported file encoding." },
        Unknown_compiler_option_0: { code: 5023, category: 1 /* Error */, key: "Unknown compiler option '{0}'." },
        Could_not_write_file_0_Colon_1: { code: 5033, category: 1 /* Error */, key: "Could not write file '{0}': {1}" },
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5038, category: 1 /* Error */, key: "Option mapRoot cannot be specified without specifying sourcemap option." },
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5039, category: 1 /* Error */, key: "Option sourceRoot cannot be specified without specifying sourcemap option." },
        Concatenate_and_emit_output_to_single_file: { code: 6001, category: 2 /* Message */, key: "Concatenate and emit output to single file." },
        Generates_corresponding_d_ts_file: { code: 6002, category: 2 /* Message */, key: "Generates corresponding '.d.ts' file." },
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: { code: 6003, category: 2 /* Message */, key: "Specifies the location where debugger should locate map files instead of generated locations." },
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: { code: 6004, category: 2 /* Message */, key: "Specifies the location where debugger should locate TypeScript files instead of source locations." },
        Watch_input_files: { code: 6005, category: 2 /* Message */, key: "Watch input files." },
        Redirect_output_structure_to_the_directory: { code: 6006, category: 2 /* Message */, key: "Redirect output structure to the directory." },
        Do_not_emit_comments_to_output: { code: 6009, category: 2 /* Message */, key: "Do not emit comments to output." },
        Specify_ECMAScript_target_version_Colon_ES3_default_or_ES5: { code: 6015, category: 2 /* Message */, key: "Specify ECMAScript target version: 'ES3' (default), or 'ES5'" },
        Specify_module_code_generation_Colon_commonjs_or_amd: { code: 6016, category: 2 /* Message */, key: "Specify module code generation: 'commonjs' or 'amd'" },
        Print_this_message: { code: 6017, category: 2 /* Message */, key: "Print this message." },
        Print_the_compiler_s_version: { code: 6019, category: 2 /* Message */, key: "Print the compiler's version." },
        Syntax_Colon_0: { code: 6023, category: 2 /* Message */, key: "Syntax: {0}" },
        options: { code: 6024, category: 2 /* Message */, key: "options" },
        file: { code: 6025, category: 2 /* Message */, key: "file" },
        Examples_Colon_0: { code: 6026, category: 2 /* Message */, key: "Examples: {0}" },
        Options_Colon: { code: 6027, category: 2 /* Message */, key: "Options:" },
        Version_0: { code: 6029, category: 2 /* Message */, key: "Version {0}" },
        Insert_command_line_options_and_files_from_a_file: { code: 6030, category: 2 /* Message */, key: "Insert command line options and files from a file." },
        File_change_detected_Compiling: { code: 6032, category: 2 /* Message */, key: "File change detected. Compiling..." },
        KIND: { code: 6034, category: 2 /* Message */, key: "KIND" },
        FILE: { code: 6035, category: 2 /* Message */, key: "FILE" },
        VERSION: { code: 6036, category: 2 /* Message */, key: "VERSION" },
        LOCATION: { code: 6037, category: 2 /* Message */, key: "LOCATION" },
        DIRECTORY: { code: 6038, category: 2 /* Message */, key: "DIRECTORY" },
        Compilation_complete_Watching_for_file_changes: { code: 6042, category: 2 /* Message */, key: "Compilation complete. Watching for file changes." },
        Generates_corresponding_map_file: { code: 6043, category: 2 /* Message */, key: "Generates corresponding '.map' file." },
        Compiler_option_0_expects_an_argument: { code: 6044, category: 1 /* Error */, key: "Compiler option '{0}' expects an argument." },
        Unterminated_quoted_string_in_response_file_0: { code: 6045, category: 1 /* Error */, key: "Unterminated quoted string in response file '{0}'." },
        Argument_for_module_option_must_be_commonjs_or_amd: { code: 6046, category: 1 /* Error */, key: "Argument for '--module' option must be 'commonjs' or 'amd'." },
        Argument_for_target_option_must_be_es3_or_es5: { code: 6047, category: 1 /* Error */, key: "Argument for '--target' option must be 'es3' or 'es5'." },
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: { code: 6048, category: 1 /* Error */, key: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'." },
        Unsupported_locale_0: { code: 6049, category: 1 /* Error */, key: "Unsupported locale '{0}'." },
        Unable_to_open_file_0: { code: 6050, category: 1 /* Error */, key: "Unable to open file '{0}'." },
        Corrupted_locale_file_0: { code: 6051, category: 1 /* Error */, key: "Corrupted locale file {0}." },
        Warn_on_expressions_and_declarations_with_an_implied_any_type: { code: 6052, category: 2 /* Message */, key: "Warn on expressions and declarations with an implied 'any' type." },
        File_0_not_found: { code: 6053, category: 1 /* Error */, key: "File '{0}' not found." },
        File_0_must_have_extension_ts_or_d_ts: { code: 6054, category: 1 /* Error */, key: "File '{0}' must have extension '.ts' or '.d.ts'." },
        Variable_0_implicitly_has_an_1_type: { code: 7005, category: 1 /* Error */, key: "Variable '{0}' implicitly has an '{1}' type." },
        Parameter_0_implicitly_has_an_1_type: { code: 7006, category: 1 /* Error */, key: "Parameter '{0}' implicitly has an '{1}' type." },
        Member_0_implicitly_has_an_1_type: { code: 7008, category: 1 /* Error */, key: "Member '{0}' implicitly has an '{1}' type." },
        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: { code: 7009, category: 1 /* Error */, key: "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type." },
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: { code: 7010, category: 1 /* Error */, key: "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type." },
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: { code: 7011, category: 1 /* Error */, key: "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type." },
        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7013, category: 1 /* Error */, key: "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type." },
        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation: { code: 7016, category: 1 /* Error */, key: "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation." },
        Index_signature_of_object_type_implicitly_has_an_any_type: { code: 7017, category: 1 /* Error */, key: "Index signature of object type implicitly has an 'any' type." },
        Object_literal_s_property_0_implicitly_has_an_1_type: { code: 7018, category: 1 /* Error */, key: "Object literal's property '{0}' implicitly has an '{1}' type." },
        Rest_parameter_0_implicitly_has_an_any_type: { code: 7019, category: 1 /* Error */, key: "Rest parameter '{0}' implicitly has an 'any[]' type." },
        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7020, category: 1 /* Error */, key: "Call signature, which lacks return-type annotation, implicitly has an 'any' return type." },
        You_cannot_rename_this_element: { code: 8000, category: 1 /* Error */, key: "You cannot rename this element." }
    };
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="diagnosticInformationMap.generated.ts"/>
var ts;
(function (ts) {
    var textToToken = {
        "any": 101 /* AnyKeyword */,
        "boolean": 102 /* BooleanKeyword */,
        "break": 56 /* BreakKeyword */,
        "case": 57 /* CaseKeyword */,
        "catch": 58 /* CatchKeyword */,
        "class": 59 /* ClassKeyword */,
        "continue": 61 /* ContinueKeyword */,
        "const": 60 /* ConstKeyword */,
        "constructor": 103 /* ConstructorKeyword */,
        "debugger": 62 /* DebuggerKeyword */,
        "declare": 104 /* DeclareKeyword */,
        "default": 63 /* DefaultKeyword */,
        "delete": 64 /* DeleteKeyword */,
        "do": 65 /* DoKeyword */,
        "else": 66 /* ElseKeyword */,
        "enum": 67 /* EnumKeyword */,
        "export": 68 /* ExportKeyword */,
        "extends": 69 /* ExtendsKeyword */,
        "false": 70 /* FalseKeyword */,
        "finally": 71 /* FinallyKeyword */,
        "for": 72 /* ForKeyword */,
        "function": 73 /* FunctionKeyword */,
        "get": 105 /* GetKeyword */,
        "if": 74 /* IfKeyword */,
        "implements": 92 /* ImplementsKeyword */,
        "import": 75 /* ImportKeyword */,
        "in": 76 /* InKeyword */,
        "instanceof": 77 /* InstanceOfKeyword */,
        "interface": 93 /* InterfaceKeyword */,
        "let": 94 /* LetKeyword */,
        "module": 106 /* ModuleKeyword */,
        "new": 78 /* NewKeyword */,
        "null": 79 /* NullKeyword */,
        "number": 108 /* NumberKeyword */,
        "package": 95 /* PackageKeyword */,
        "private": 96 /* PrivateKeyword */,
        "protected": 97 /* ProtectedKeyword */,
        "public": 98 /* PublicKeyword */,
        "require": 107 /* RequireKeyword */,
        "return": 80 /* ReturnKeyword */,
        "set": 109 /* SetKeyword */,
        "static": 99 /* StaticKeyword */,
        "string": 110 /* StringKeyword */,
        "super": 81 /* SuperKeyword */,
        "switch": 82 /* SwitchKeyword */,
        "this": 83 /* ThisKeyword */,
        "throw": 84 /* ThrowKeyword */,
        "true": 85 /* TrueKeyword */,
        "try": 86 /* TryKeyword */,
        "typeof": 87 /* TypeOfKeyword */,
        "var": 88 /* VarKeyword */,
        "void": 89 /* VoidKeyword */,
        "while": 90 /* WhileKeyword */,
        "with": 91 /* WithKeyword */,
        "yield": 100 /* YieldKeyword */,
        "{": 5 /* OpenBraceToken */,
        "}": 6 /* CloseBraceToken */,
        "(": 7 /* OpenParenToken */,
        ")": 8 /* CloseParenToken */,
        "[": 9 /* OpenBracketToken */,
        "]": 10 /* CloseBracketToken */,
        ".": 11 /* DotToken */,
        "...": 12 /* DotDotDotToken */,
        ";": 13 /* SemicolonToken */,
        ",": 14 /* CommaToken */,
        "<": 15 /* LessThanToken */,
        ">": 16 /* GreaterThanToken */,
        "<=": 17 /* LessThanEqualsToken */,
        ">=": 18 /* GreaterThanEqualsToken */,
        "==": 19 /* EqualsEqualsToken */,
        "!=": 20 /* ExclamationEqualsToken */,
        "===": 21 /* EqualsEqualsEqualsToken */,
        "!==": 22 /* ExclamationEqualsEqualsToken */,
        "=>": 23 /* EqualsGreaterThanToken */,
        "+": 24 /* PlusToken */,
        "-": 25 /* MinusToken */,
        "*": 26 /* AsteriskToken */,
        "/": 27 /* SlashToken */,
        "%": 28 /* PercentToken */,
        "++": 29 /* PlusPlusToken */,
        "--": 30 /* MinusMinusToken */,
        "<<": 31 /* LessThanLessThanToken */,
        ">>": 32 /* GreaterThanGreaterThanToken */,
        ">>>": 33 /* GreaterThanGreaterThanGreaterThanToken */,
        "&": 34 /* AmpersandToken */,
        "|": 35 /* BarToken */,
        "^": 36 /* CaretToken */,
        "!": 37 /* ExclamationToken */,
        "~": 38 /* TildeToken */,
        "&&": 39 /* AmpersandAmpersandToken */,
        "||": 40 /* BarBarToken */,
        "?": 41 /* QuestionToken */,
        ":": 42 /* ColonToken */,
        "=": 43 /* EqualsToken */,
        "+=": 44 /* PlusEqualsToken */,
        "-=": 45 /* MinusEqualsToken */,
        "*=": 46 /* AsteriskEqualsToken */,
        "/=": 47 /* SlashEqualsToken */,
        "%=": 48 /* PercentEqualsToken */,
        "<<=": 49 /* LessThanLessThanEqualsToken */,
        ">>=": 50 /* GreaterThanGreaterThanEqualsToken */,
        ">>>=": 51 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
        "&=": 52 /* AmpersandEqualsToken */,
        "|=": 53 /* BarEqualsToken */,
        "^=": 54 /* CaretEqualsToken */
    };
    /*
        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
        IdentifierStart ::
            Can contain Unicode 3.0.0  categories:
            Uppercase letter (Lu),
            Lowercase letter (Ll),
            Titlecase letter (Lt),
            Modifier letter (Lm),
            Other letter (Lo), or
            Letter number (Nl).
        IdentifierPart :: =
            Can contain IdentifierStart + Unicode 3.0.0  categories:
            Non-spacing mark (Mn),
            Combining spacing mark (Mc),
            Decimal number (Nd), or
            Connector punctuation (Pc).

        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
    */
    var unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
    var unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
    /*
        As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers
        IdentifierStart ::
            Can contain Unicode 6.2  categories:
            Uppercase letter (Lu),
            Lowercase letter (Ll),
            Titlecase letter (Lt),
            Modifier letter (Lm),
            Other letter (Lo), or
            Letter number (Nl).
        IdentifierPart ::
            Can contain IdentifierStart + Unicode 6.2  categories:
            Non-spacing mark (Mn),
            Combining spacing mark (Mc),
            Decimal number (Nd),
            Connector punctuation (Pc),
            <ZWNJ>, or
            <ZWJ>.

        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
    */
    var unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
    var unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
    function lookupInUnicodeMap(code, map) {
        // Bail out quickly if it couldn't possibly be in the map.
        if (code < map[0]) {
            return false;
        }
        // Perform binary search in one of the unicode range maps
        var lo = 0;
        var hi = map.length;
        var mid;
        while (lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            // mid has to be even to catch a range's beginning
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1]) {
                return true;
            }
            if (code < map[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 2;
            }
        }
        return false;
    }
    function isUnicodeIdentifierStart(code, languageVersion) {
        return languageVersion === 0 /* ES3 */ ? lookupInUnicodeMap(code, unicodeES3IdentifierStart) : lookupInUnicodeMap(code, unicodeES5IdentifierStart);
    }
    function isUnicodeIdentifierPart(code, languageVersion) {
        return languageVersion === 0 /* ES3 */ ? lookupInUnicodeMap(code, unicodeES3IdentifierPart) : lookupInUnicodeMap(code, unicodeES5IdentifierPart);
    }
    function makeReverseMap(source) {
        var result = [];
        for (var name in source) {
            if (source.hasOwnProperty(name)) {
                result[source[name]] = name;
            }
        }
        return result;
    }
    var tokenStrings = makeReverseMap(textToToken);
    function tokenToString(t) {
        return tokenStrings[t];
    }
    ts.tokenToString = tokenToString;
    function getLineStarts(text) {
        var result = new Array();
        var pos = 0;
        var lineStart = 0;
        while (pos < text.length) {
            switch (text.charCodeAt(pos++)) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos) === 10 /* lineFeed */) {
                        pos++;
                    }
                case 10 /* lineFeed */:
                    result.push(lineStart);
                    lineStart = pos;
                    break;
            }
        }
        result.push(lineStart);
        return result;
    }
    ts.getLineStarts = getLineStarts;
    function getPositionFromLineAndCharacter(lineStarts, line, character) {
        ts.Debug.assert(line > 0);
        return lineStarts[line - 1] + character - 1;
    }
    ts.getPositionFromLineAndCharacter = getPositionFromLineAndCharacter;
    function getLineAndCharacterOfPosition(lineStarts, position) {
        var lineNumber = ts.binarySearch(lineStarts, position);
        if (lineNumber < 0) {
            // If the actual position was not found,
            // the binary search returns the negative value of the next line start
            // eg. if line starts at [5, 10, 23, 80] and position requested was 20
            // the search will return -2
            lineNumber = (~lineNumber) - 1;
        }
        return {
            line: lineNumber + 1,
            character: position - lineStarts[lineNumber] + 1
        };
    }
    ts.getLineAndCharacterOfPosition = getLineAndCharacterOfPosition;
    function positionToLineAndCharacter(text, pos) {
        var lineStarts = getLineStarts(text);
        return getLineAndCharacterOfPosition(lineStarts, pos);
    }
    ts.positionToLineAndCharacter = positionToLineAndCharacter;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function isWhiteSpace(ch) {
        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ || ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ || ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
    }
    ts.isWhiteSpace = isWhiteSpace;
    function isLineBreak(ch) {
        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
    }
    ts.isLineBreak = isLineBreak;
    function isDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
    }
    function isOctalDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 55 /* _7 */;
    }
    ts.isOctalDigit = isOctalDigit;
    function skipTrivia(text, pos, stopAfterLineBreak) {
        while (true) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos + 1) === 10 /* lineFeed */)
                        pos++;
                case 10 /* lineFeed */:
                    pos++;
                    if (stopAfterLineBreak)
                        return pos;
                    continue;
                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 32 /* space */:
                    pos++;
                    continue;
                case 47 /* slash */:
                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                        pos += 2;
                        while (pos < text.length) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        continue;
                    }
                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                        pos += 2;
                        while (pos < text.length) {
                            if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                pos += 2;
                                break;
                            }
                            pos++;
                        }
                        continue;
                    }
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && (isWhiteSpace(ch) || isLineBreak(ch))) {
                        pos++;
                        continue;
                    }
                    break;
            }
            return pos;
        }
    }
    ts.skipTrivia = skipTrivia;
    // Extract comments from the given source text starting at the given position. If trailing is false, whitespace is skipped until
    // the first line break and comments between that location and the next token are returned. If trailing is true, comments occurring
    // between the given position and the next line break are returned. The return value is an array containing a TextRange for each
    // comment. Single-line comment ranges include the the beginning '//' characters but not the ending line break. Multi-line comment
    // ranges include the beginning '/* and ending '*/' characters. The return value is undefined if no comments were found.
    function getCommentRanges(text, pos, trailing) {
        var result;
        var collecting = trailing || pos === 0;
        while (true) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos + 1) === 10 /* lineFeed */)
                        pos++;
                case 10 /* lineFeed */:
                    pos++;
                    if (trailing) {
                        return result;
                    }
                    collecting = true;
                    if (result && result.length) {
                        result[result.length - 1].hasTrailingNewLine = true;
                    }
                    continue;
                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 32 /* space */:
                    pos++;
                    continue;
                case 47 /* slash */:
                    var nextChar = text.charCodeAt(pos + 1);
                    var hasTrailingNewLine = false;
                    if (nextChar === 47 /* slash */ || nextChar === 42 /* asterisk */) {
                        var startPos = pos;
                        pos += 2;
                        if (nextChar === 47 /* slash */) {
                            while (pos < text.length) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    hasTrailingNewLine = true;
                                    break;
                                }
                                pos++;
                            }
                        }
                        else {
                            while (pos < text.length) {
                                if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                    pos += 2;
                                    break;
                                }
                                pos++;
                            }
                        }
                        if (collecting) {
                            if (!result)
                                result = [];
                            result.push({ pos: startPos, end: pos, hasTrailingNewLine: hasTrailingNewLine });
                        }
                        continue;
                    }
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && (isWhiteSpace(ch) || isLineBreak(ch))) {
                        if (result && result.length && isLineBreak(ch)) {
                            result[result.length - 1].hasTrailingNewLine = true;
                        }
                        pos++;
                        continue;
                    }
                    break;
            }
            return result;
        }
    }
    function getLeadingComments(text, pos) {
        return getCommentRanges(text, pos, false);
    }
    ts.getLeadingComments = getLeadingComments;
    function getTrailingComments(text, pos) {
        return getCommentRanges(text, pos, true);
    }
    ts.getTrailingComments = getTrailingComments;
    function createScanner(languageVersion, text, onError, onComment) {
        var pos; // Current position (end position of text of current token)
        var len; // Length of text
        var startPos; // Start position of whitespace before current token
        var tokenPos; // Start position of text of current token
        var token;
        var tokenValue;
        var precedingLineBreak;
        function error(message) {
            if (onError) {
                onError(message);
            }
        }
        function isIdentifierStart(ch) {
            return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);
        }
        function isIdentifierPart(ch) {
            return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);
        }
        function scanNumber() {
            var start = pos;
            while (isDigit(text.charCodeAt(pos)))
                pos++;
            if (text.charCodeAt(pos) === 46 /* dot */) {
                pos++;
                while (isDigit(text.charCodeAt(pos)))
                    pos++;
            }
            var end = pos;
            if (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */) {
                pos++;
                if (text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */)
                    pos++;
                if (isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (isDigit(text.charCodeAt(pos)))
                        pos++;
                    end = pos;
                }
                else {
                    error(ts.Diagnostics.Digit_expected);
                }
            }
            return +(text.substring(start, end));
        }
        function scanOctalDigits() {
            var start = pos;
            while (isOctalDigit(text.charCodeAt(pos))) {
                pos++;
            }
            return +(text.substring(start, pos));
        }
        function scanHexDigits(count, exact) {
            var digits = 0;
            var value = 0;
            while (digits < count || !exact) {
                var ch = text.charCodeAt(pos);
                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                    value = value * 16 + ch - 48 /* _0 */;
                }
                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                    value = value * 16 + ch - 65 /* A */ + 10;
                }
                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                    value = value * 16 + ch - 97 /* a */ + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function scanString() {
            var quote = text.charCodeAt(pos++);
            var result = "";
            var start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    error(ts.Diagnostics.Unexpected_end_of_text);
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === quote) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 /* backslash */) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        error(ts.Diagnostics.Unexpected_end_of_text);
                        break;
                    }
                    ch = text.charCodeAt(pos++);
                    switch (ch) {
                        case 48 /* _0 */:
                            result += "\0";
                            break;
                        case 98 /* b */:
                            result += "\b";
                            break;
                        case 116 /* t */:
                            result += "\t";
                            break;
                        case 110 /* n */:
                            result += "\n";
                            break;
                        case 118 /* v */:
                            result += "\v";
                            break;
                        case 102 /* f */:
                            result += "\f";
                            break;
                        case 114 /* r */:
                            result += "\r";
                            break;
                        case 39 /* singleQuote */:
                            result += "\'";
                            break;
                        case 34 /* doubleQuote */:
                            result += "\"";
                            break;
                        case 120 /* x */:
                        case 117 /* u */:
                            var ch = scanHexDigits(ch === 120 /* x */ ? 2 : 4, true);
                            if (ch >= 0) {
                                result += String.fromCharCode(ch);
                            }
                            else {
                                error(ts.Diagnostics.Hexadecimal_digit_expected);
                            }
                            break;
                        case 13 /* carriageReturn */:
                            if (pos < len && text.charCodeAt(pos) === 10 /* lineFeed */)
                                pos++;
                            break;
                        case 10 /* lineFeed */:
                        case 8232 /* lineSeparator */:
                        case 8233 /* paragraphSeparator */:
                            break;
                        default:
                            result += String.fromCharCode(ch);
                    }
                    start = pos;
                    continue;
                }
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    error(ts.Diagnostics.Unterminated_string_literal);
                    break;
                }
                pos++;
            }
            return result;
        }
        // Current character is known to be a backslash. Check for Unicode escape of the form '\uXXXX'
        // and return code point value if valid Unicode escape is found. Otherwise return -1.
        function peekUnicodeEscape() {
            if (pos + 5 < len && text.charCodeAt(pos + 1) === 117 /* u */) {
                var start = pos;
                pos += 2;
                var value = scanHexDigits(4, true);
                pos = start;
                return value;
            }
            return -1;
        }
        function scanIdentifierParts() {
            var result = "";
            var start = pos;
            while (pos < len) {
                var ch = text.charCodeAt(pos);
                if (isIdentifierPart(ch)) {
                    pos++;
                }
                else if (ch === 92 /* backslash */) {
                    ch = peekUnicodeEscape();
                    if (!(ch >= 0 && isIdentifierPart(ch))) {
                        break;
                    }
                    result += text.substring(start, pos);
                    result += String.fromCharCode(ch);
                    // Valid Unicode escape is always six characters
                    pos += 6;
                    start = pos;
                }
                else {
                    break;
                }
            }
            result += text.substring(start, pos);
            return result;
        }
        function getIdentifierToken() {
            // Reserved words are between 2 and 11 characters long and start with a lowercase letter
            var len = tokenValue.length;
            if (len >= 2 && len <= 11) {
                var ch = tokenValue.charCodeAt(0);
                if (ch >= 97 /* a */ && ch <= 122 /* z */ && hasOwnProperty.call(textToToken, tokenValue)) {
                    return token = textToToken[tokenValue];
                }
            }
            return token = 55 /* Identifier */;
        }
        function scan() {
            startPos = pos;
            precedingLineBreak = false;
            while (true) {
                tokenPos = pos;
                if (pos >= len) {
                    return token = 1 /* EndOfFileToken */;
                }
                var ch = text.charCodeAt(pos);
                switch (ch) {
                    case 10 /* lineFeed */:
                    case 13 /* carriageReturn */:
                        precedingLineBreak = true;
                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 32 /* space */:
                        pos++;
                        continue;
                    case 33 /* exclamation */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 22 /* ExclamationEqualsEqualsToken */;
                            }
                            return pos += 2, token = 20 /* ExclamationEqualsToken */;
                        }
                        return pos++, token = 37 /* ExclamationToken */;
                    case 34 /* doubleQuote */:
                    case 39 /* singleQuote */:
                        tokenValue = scanString();
                        return token = 3 /* StringLiteral */;
                    case 37 /* percent */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 48 /* PercentEqualsToken */;
                        }
                        return pos++, token = 28 /* PercentToken */;
                    case 38 /* ampersand */:
                        if (text.charCodeAt(pos + 1) === 38 /* ampersand */) {
                            return pos += 2, token = 39 /* AmpersandAmpersandToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 52 /* AmpersandEqualsToken */;
                        }
                        return pos++, token = 34 /* AmpersandToken */;
                    case 40 /* openParen */:
                        return pos++, token = 7 /* OpenParenToken */;
                    case 41 /* closeParen */:
                        return pos++, token = 8 /* CloseParenToken */;
                    case 42 /* asterisk */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 46 /* AsteriskEqualsToken */;
                        }
                        return pos++, token = 26 /* AsteriskToken */;
                    case 43 /* plus */:
                        if (text.charCodeAt(pos + 1) === 43 /* plus */) {
                            return pos += 2, token = 29 /* PlusPlusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 44 /* PlusEqualsToken */;
                        }
                        return pos++, token = 24 /* PlusToken */;
                    case 44 /* comma */:
                        return pos++, token = 14 /* CommaToken */;
                    case 45 /* minus */:
                        if (text.charCodeAt(pos + 1) === 45 /* minus */) {
                            return pos += 2, token = 30 /* MinusMinusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 45 /* MinusEqualsToken */;
                        }
                        return pos++, token = 25 /* MinusToken */;
                    case 46 /* dot */:
                        if (isDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanNumber();
                            return token = 2 /* NumericLiteral */;
                        }
                        if (text.charCodeAt(pos + 1) === 46 /* dot */ && text.charCodeAt(pos + 2) === 46 /* dot */) {
                            return pos += 3, token = 12 /* DotDotDotToken */;
                        }
                        return pos++, token = 11 /* DotToken */;
                    case 47 /* slash */:
                        // Single-line comment
                        if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            while (pos < len) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    break;
                                }
                                pos++;
                            }
                            if (onComment) {
                                onComment(tokenPos, pos);
                            }
                            continue;
                        }
                        // Multi-line comment
                        if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                            pos += 2;
                            var commentClosed = false;
                            while (pos < len) {
                                var ch = text.charCodeAt(pos);
                                if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                    pos += 2;
                                    commentClosed = true;
                                    break;
                                }
                                if (isLineBreak(ch)) {
                                    precedingLineBreak = true;
                                }
                                pos++;
                            }
                            if (!commentClosed) {
                                error(ts.Diagnostics.Asterisk_Slash_expected);
                            }
                            if (onComment) {
                                onComment(tokenPos, pos);
                            }
                            continue;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 47 /* SlashEqualsToken */;
                        }
                        return pos++, token = 27 /* SlashToken */;
                    case 48 /* _0 */:
                        if (pos + 2 < len && (text.charCodeAt(pos + 1) === 88 /* X */ || text.charCodeAt(pos + 1) === 120 /* x */)) {
                            pos += 2;
                            var value = scanHexDigits(1, false);
                            if (value < 0) {
                                error(ts.Diagnostics.Hexadecimal_digit_expected);
                                value = 0;
                            }
                            tokenValue = "" + value;
                            return 2 /* NumericLiteral */;
                        }
                        // Try to parse as an octal
                        if (pos + 1 < len && isOctalDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanOctalDigits();
                            return 2 /* NumericLiteral */;
                        }
                    case 49 /* _1 */:
                    case 50 /* _2 */:
                    case 51 /* _3 */:
                    case 52 /* _4 */:
                    case 53 /* _5 */:
                    case 54 /* _6 */:
                    case 55 /* _7 */:
                    case 56 /* _8 */:
                    case 57 /* _9 */:
                        tokenValue = "" + scanNumber();
                        return token = 2 /* NumericLiteral */;
                    case 58 /* colon */:
                        return pos++, token = 42 /* ColonToken */;
                    case 59 /* semicolon */:
                        return pos++, token = 13 /* SemicolonToken */;
                    case 60 /* lessThan */:
                        if (text.charCodeAt(pos + 1) === 60 /* lessThan */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 49 /* LessThanLessThanEqualsToken */;
                            }
                            return pos += 2, token = 31 /* LessThanLessThanToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 17 /* LessThanEqualsToken */;
                        }
                        return pos++, token = 15 /* LessThanToken */;
                    case 61 /* equals */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 21 /* EqualsEqualsEqualsToken */;
                            }
                            return pos += 2, token = 19 /* EqualsEqualsToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
                            return pos += 2, token = 23 /* EqualsGreaterThanToken */;
                        }
                        return pos++, token = 43 /* EqualsToken */;
                    case 62 /* greaterThan */:
                        return pos++, token = 16 /* GreaterThanToken */;
                    case 63 /* question */:
                        return pos++, token = 41 /* QuestionToken */;
                    case 91 /* openBracket */:
                        return pos++, token = 9 /* OpenBracketToken */;
                    case 93 /* closeBracket */:
                        return pos++, token = 10 /* CloseBracketToken */;
                    case 94 /* caret */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 54 /* CaretEqualsToken */;
                        }
                        return pos++, token = 36 /* CaretToken */;
                    case 123 /* openBrace */:
                        return pos++, token = 5 /* OpenBraceToken */;
                    case 124 /* bar */:
                        if (text.charCodeAt(pos + 1) === 124 /* bar */) {
                            return pos += 2, token = 40 /* BarBarToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 53 /* BarEqualsToken */;
                        }
                        return pos++, token = 35 /* BarToken */;
                    case 125 /* closeBrace */:
                        return pos++, token = 6 /* CloseBraceToken */;
                    case 126 /* tilde */:
                        return pos++, token = 38 /* TildeToken */;
                    case 92 /* backslash */:
                        var ch = peekUnicodeEscape();
                        if (ch >= 0 && isIdentifierStart(ch)) {
                            pos += 6;
                            tokenValue = String.fromCharCode(ch) + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        error(ts.Diagnostics.Invalid_character);
                        return pos++, token = 0 /* Unknown */;
                    default:
                        if (isIdentifierStart(ch)) {
                            pos++;
                            while (pos < len && isIdentifierPart(ch = text.charCodeAt(pos)))
                                pos++;
                            tokenValue = text.substring(tokenPos, pos);
                            if (ch === 92 /* backslash */) {
                                tokenValue += scanIdentifierParts();
                            }
                            return token = getIdentifierToken();
                        }
                        else if (isWhiteSpace(ch)) {
                            pos++;
                            continue;
                        }
                        else if (isLineBreak(ch)) {
                            precedingLineBreak = true;
                            pos++;
                            continue;
                        }
                        error(ts.Diagnostics.Invalid_character);
                        return pos++, token = 0 /* Unknown */;
                }
            }
        }
        function reScanGreaterToken() {
            if (token === 16 /* GreaterThanToken */) {
                if (text.charCodeAt(pos) === 62 /* greaterThan */) {
                    if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
                        if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                            return pos += 3, token = 51 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                        }
                        return pos += 2, token = 33 /* GreaterThanGreaterThanGreaterThanToken */;
                    }
                    if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                        return pos += 2, token = 50 /* GreaterThanGreaterThanEqualsToken */;
                    }
                    return pos++, token = 32 /* GreaterThanGreaterThanToken */;
                }
                if (text.charCodeAt(pos) === 61 /* equals */) {
                    return pos++, token = 18 /* GreaterThanEqualsToken */;
                }
            }
            return token;
        }
        function reScanSlashToken() {
            if (token === 27 /* SlashToken */ || token === 47 /* SlashEqualsToken */) {
                var p = tokenPos + 1;
                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    // If we've hit EOF without closing off the regex,
                    // simply return the token we originally parsed.
                    if (p >= len) {
                        return token;
                    }
                    var ch = text.charCodeAt(p);
                    // Line breaks are not permissible in the middle of a RegExp.
                    if (isLineBreak(ch)) {
                        return token;
                    }
                    if (inEscape) {
                        // Parsing an escape character;
                        // reset the flag and just advance to the next char.
                        inEscape = false;
                    }
                    else if (ch === 47 /* slash */ && !inCharacterClass) {
                        break;
                    }
                    else if (ch === 91 /* openBracket */) {
                        inCharacterClass = true;
                    }
                    else if (ch === 92 /* backslash */) {
                        inEscape = true;
                    }
                    else if (ch === 93 /* closeBracket */) {
                        inCharacterClass = false;
                    }
                    p++;
                }
                p++;
                while (isIdentifierPart(text.charCodeAt(p))) {
                    p++;
                }
                pos = p;
                tokenValue = text.substring(tokenPos, pos);
                token = 4 /* RegularExpressionLiteral */;
            }
            return token;
        }
        function tryScan(callback) {
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var savePrecedingLineBreak = precedingLineBreak;
            var result = callback();
            if (!result) {
                pos = savePos;
                startPos = saveStartPos;
                tokenPos = saveTokenPos;
                token = saveToken;
                tokenValue = saveTokenValue;
                precedingLineBreak = savePrecedingLineBreak;
            }
            return result;
        }
        function setText(newText) {
            text = newText || "";
            len = text.length;
            setTextPos(0);
        }
        function setTextPos(textPos) {
            pos = textPos;
            startPos = textPos;
            tokenPos = textPos;
            token = 0 /* Unknown */;
            precedingLineBreak = false;
        }
        setText(text);
        return {
            getStartPos: function () { return startPos; },
            getTextPos: function () { return pos; },
            getToken: function () { return token; },
            getTokenPos: function () { return tokenPos; },
            getTokenText: function () { return text.substring(tokenPos, pos); },
            getTokenValue: function () { return tokenValue; },
            hasPrecedingLineBreak: function () { return precedingLineBreak; },
            isIdentifier: function () { return token === 55 /* Identifier */ || token > ts.SyntaxKind.LastReservedWord; },
            isReservedWord: function () { return token >= ts.SyntaxKind.FirstReservedWord && token <= ts.SyntaxKind.LastReservedWord; },
            reScanGreaterToken: reScanGreaterToken,
            reScanSlashToken: reScanSlashToken,
            scan: scan,
            setText: setText,
            setTextPos: setTextPos,
            tryScan: tryScan
        };
    }
    ts.createScanner = createScanner;
})(ts || (ts = {}));
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
var ts;
(function (ts) {
    // token > SyntaxKind.Identifer => token is a keyword
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 1] = "EndOfFileToken";
        // Literals
        SyntaxKind[SyntaxKind["NumericLiteral"] = 2] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 3] = "StringLiteral";
        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 4] = "RegularExpressionLiteral";
        // Punctuation
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 5] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 6] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 7] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 8] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 9] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 10] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 11] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 12] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 13] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 14] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 15] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 16] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 17] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 18] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 19] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 20] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 21] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 22] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 23] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 24] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 25] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 26] = "AsteriskToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 27] = "SlashToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 28] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 29] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 30] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 31] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 32] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 33] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 34] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 35] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 36] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 37] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 38] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 39] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 40] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 41] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 42] = "ColonToken";
        // Assignments
        SyntaxKind[SyntaxKind["EqualsToken"] = 43] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 44] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 45] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 46] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 47] = "SlashEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 48] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 49] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 50] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 51] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 52] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 53] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 54] = "CaretEqualsToken";
        // Identifiers
        SyntaxKind[SyntaxKind["Identifier"] = 55] = "Identifier";
        // Reserved words
        SyntaxKind[SyntaxKind["BreakKeyword"] = 56] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 57] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 58] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ClassKeyword"] = 59] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 60] = "ConstKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 61] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 62] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 63] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 64] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 65] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 66] = "ElseKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 67] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 68] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 69] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 70] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 71] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 72] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 73] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 74] = "IfKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 75] = "ImportKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 76] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 77] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 78] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 79] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 80] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 81] = "SuperKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 82] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 83] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 84] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 85] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 86] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 87] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 88] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 89] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 90] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 91] = "WithKeyword";
        // Strict mode reserved words
        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 92] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 93] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 94] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 95] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 96] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 97] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 98] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 99] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 100] = "YieldKeyword";
        // TypeScript keywords
        SyntaxKind[SyntaxKind["AnyKeyword"] = 101] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 102] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 103] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 104] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 105] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 106] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 107] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 108] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 109] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 110] = "StringKeyword";
        // Parse tree nodes
        SyntaxKind[SyntaxKind["Missing"] = 111] = "Missing";
        // Names
        SyntaxKind[SyntaxKind["QualifiedName"] = 112] = "QualifiedName";
        // Signature elements
        SyntaxKind[SyntaxKind["TypeParameter"] = 113] = "TypeParameter";
        SyntaxKind[SyntaxKind["Parameter"] = 114] = "Parameter";
        // TypeMember
        SyntaxKind[SyntaxKind["Property"] = 115] = "Property";
        SyntaxKind[SyntaxKind["Method"] = 116] = "Method";
        SyntaxKind[SyntaxKind["Constructor"] = 117] = "Constructor";
        SyntaxKind[SyntaxKind["GetAccessor"] = 118] = "GetAccessor";
        SyntaxKind[SyntaxKind["SetAccessor"] = 119] = "SetAccessor";
        SyntaxKind[SyntaxKind["CallSignature"] = 120] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 121] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 122] = "IndexSignature";
        // Type
        SyntaxKind[SyntaxKind["TypeReference"] = 123] = "TypeReference";
        SyntaxKind[SyntaxKind["TypeQuery"] = 124] = "TypeQuery";
        SyntaxKind[SyntaxKind["TypeLiteral"] = 125] = "TypeLiteral";
        SyntaxKind[SyntaxKind["ArrayType"] = 126] = "ArrayType";
        // Expression
        SyntaxKind[SyntaxKind["ArrayLiteral"] = 127] = "ArrayLiteral";
        SyntaxKind[SyntaxKind["ObjectLiteral"] = 128] = "ObjectLiteral";
        SyntaxKind[SyntaxKind["PropertyAssignment"] = 129] = "PropertyAssignment";
        SyntaxKind[SyntaxKind["PropertyAccess"] = 130] = "PropertyAccess";
        SyntaxKind[SyntaxKind["IndexedAccess"] = 131] = "IndexedAccess";
        SyntaxKind[SyntaxKind["CallExpression"] = 132] = "CallExpression";
        SyntaxKind[SyntaxKind["NewExpression"] = 133] = "NewExpression";
        SyntaxKind[SyntaxKind["TypeAssertion"] = 134] = "TypeAssertion";
        SyntaxKind[SyntaxKind["ParenExpression"] = 135] = "ParenExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 136] = "FunctionExpression";
        SyntaxKind[SyntaxKind["ArrowFunction"] = 137] = "ArrowFunction";
        SyntaxKind[SyntaxKind["PrefixOperator"] = 138] = "PrefixOperator";
        SyntaxKind[SyntaxKind["PostfixOperator"] = 139] = "PostfixOperator";
        SyntaxKind[SyntaxKind["BinaryExpression"] = 140] = "BinaryExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 141] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 142] = "OmittedExpression";
        // Element
        SyntaxKind[SyntaxKind["Block"] = 143] = "Block";
        SyntaxKind[SyntaxKind["VariableStatement"] = 144] = "VariableStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 145] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 146] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["IfStatement"] = 147] = "IfStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 148] = "DoStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 149] = "WhileStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 150] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 151] = "ForInStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 152] = "ContinueStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 153] = "BreakStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 154] = "ReturnStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 155] = "WithStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 156] = "SwitchStatement";
        SyntaxKind[SyntaxKind["CaseClause"] = 157] = "CaseClause";
        SyntaxKind[SyntaxKind["DefaultClause"] = 158] = "DefaultClause";
        SyntaxKind[SyntaxKind["LabelledStatement"] = 159] = "LabelledStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 160] = "ThrowStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 161] = "TryStatement";
        SyntaxKind[SyntaxKind["TryBlock"] = 162] = "TryBlock";
        SyntaxKind[SyntaxKind["CatchBlock"] = 163] = "CatchBlock";
        SyntaxKind[SyntaxKind["FinallyBlock"] = 164] = "FinallyBlock";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 165] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["VariableDeclaration"] = 166] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 167] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["FunctionBlock"] = 168] = "FunctionBlock";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 169] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 170] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 171] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 172] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ModuleBlock"] = 173] = "ModuleBlock";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 174] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 175] = "ExportAssignment";
        // Enum
        SyntaxKind[SyntaxKind["EnumMember"] = 176] = "EnumMember";
        // Top-level nodes
        SyntaxKind[SyntaxKind["SourceFile"] = 177] = "SourceFile";
        SyntaxKind[SyntaxKind["Program"] = 178] = "Program";
        // Synthesized list
        SyntaxKind[SyntaxKind["SyntaxList"] = 179] = "SyntaxList";
        // Enum value count
        SyntaxKind[SyntaxKind["Count"] = 180] = "Count";
        // Markers
        SyntaxKind[SyntaxKind["FirstAssignment"] = SyntaxKind.EqualsToken] = "FirstAssignment";
        SyntaxKind[SyntaxKind["LastAssignment"] = SyntaxKind.CaretEqualsToken] = "LastAssignment";
        SyntaxKind[SyntaxKind["FirstReservedWord"] = SyntaxKind.BreakKeyword] = "FirstReservedWord";
        SyntaxKind[SyntaxKind["LastReservedWord"] = SyntaxKind.WithKeyword] = "LastReservedWord";
        SyntaxKind[SyntaxKind["FirstKeyword"] = SyntaxKind.BreakKeyword] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = SyntaxKind.StringKeyword] = "LastKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedWord"] = SyntaxKind.ImplementsKeyword] = "FirstFutureReservedWord";
        SyntaxKind[SyntaxKind["LastFutureReservedWord"] = SyntaxKind.YieldKeyword] = "LastFutureReservedWord";
        SyntaxKind[SyntaxKind["FirstTypeNode"] = SyntaxKind.TypeReference] = "FirstTypeNode";
        SyntaxKind[SyntaxKind["LastTypeNode"] = SyntaxKind.ArrayType] = "LastTypeNode";
        SyntaxKind[SyntaxKind["FirstPunctuation"] = SyntaxKind.OpenBraceToken] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = SyntaxKind.CaretEqualsToken] = "LastPunctuation";
    })(ts.SyntaxKind || (ts.SyntaxKind = {}));
    var SyntaxKind = ts.SyntaxKind;
    (function (NodeFlags) {
        NodeFlags[NodeFlags["Export"] = 0x00000001] = "Export";
        NodeFlags[NodeFlags["Ambient"] = 0x00000002] = "Ambient";
        NodeFlags[NodeFlags["QuestionMark"] = 0x00000004] = "QuestionMark";
        NodeFlags[NodeFlags["Rest"] = 0x00000008] = "Rest";
        NodeFlags[NodeFlags["Public"] = 0x00000010] = "Public";
        NodeFlags[NodeFlags["Private"] = 0x00000020] = "Private";
        NodeFlags[NodeFlags["Static"] = 0x00000040] = "Static";
        NodeFlags[NodeFlags["MultiLine"] = 0x00000080] = "MultiLine";
        NodeFlags[NodeFlags["Synthetic"] = 0x00000100] = "Synthetic";
        NodeFlags[NodeFlags["DeclarationFile"] = 0x00000200] = "DeclarationFile";
        NodeFlags[NodeFlags["Modifier"] = NodeFlags.Export | NodeFlags.Ambient | NodeFlags.Public | NodeFlags.Private | NodeFlags.Static] = "Modifier";
    })(ts.NodeFlags || (ts.NodeFlags = {}));
    var NodeFlags = ts.NodeFlags;
    (function (TypeFormatFlags) {
        TypeFormatFlags[TypeFormatFlags["None"] = 0x00000000] = "None";
        /** writes Array<T> instead T[]  */
        TypeFormatFlags[TypeFormatFlags["WriteArrayAsGenericType"] = 0x00000001] = "WriteArrayAsGenericType";
        TypeFormatFlags[TypeFormatFlags["UseTypeOfFunction"] = 0x00000002] = "UseTypeOfFunction";
    })(ts.TypeFormatFlags || (ts.TypeFormatFlags = {}));
    var TypeFormatFlags = ts.TypeFormatFlags;
    (function (SymbolAccessibility) {
        SymbolAccessibility[SymbolAccessibility["Accessible"] = 0] = "Accessible";
        SymbolAccessibility[SymbolAccessibility["NotAccessible"] = 1] = "NotAccessible";
        SymbolAccessibility[SymbolAccessibility["CannotBeNamed"] = 2] = "CannotBeNamed";
    })(ts.SymbolAccessibility || (ts.SymbolAccessibility = {}));
    var SymbolAccessibility = ts.SymbolAccessibility;
    (function (SymbolFlags) {
        SymbolFlags[SymbolFlags["Variable"] = 0x00000001] = "Variable";
        SymbolFlags[SymbolFlags["Property"] = 0x00000002] = "Property";
        SymbolFlags[SymbolFlags["EnumMember"] = 0x00000004] = "EnumMember";
        SymbolFlags[SymbolFlags["Function"] = 0x00000008] = "Function";
        SymbolFlags[SymbolFlags["Class"] = 0x00000010] = "Class";
        SymbolFlags[SymbolFlags["Interface"] = 0x00000020] = "Interface";
        SymbolFlags[SymbolFlags["Enum"] = 0x00000040] = "Enum";
        SymbolFlags[SymbolFlags["ValueModule"] = 0x00000080] = "ValueModule";
        SymbolFlags[SymbolFlags["NamespaceModule"] = 0x00000100] = "NamespaceModule";
        SymbolFlags[SymbolFlags["TypeLiteral"] = 0x00000200] = "TypeLiteral";
        SymbolFlags[SymbolFlags["ObjectLiteral"] = 0x00000400] = "ObjectLiteral";
        SymbolFlags[SymbolFlags["Method"] = 0x00000800] = "Method";
        SymbolFlags[SymbolFlags["Constructor"] = 0x00001000] = "Constructor";
        SymbolFlags[SymbolFlags["GetAccessor"] = 0x00002000] = "GetAccessor";
        SymbolFlags[SymbolFlags["SetAccessor"] = 0x00004000] = "SetAccessor";
        SymbolFlags[SymbolFlags["CallSignature"] = 0x00008000] = "CallSignature";
        SymbolFlags[SymbolFlags["ConstructSignature"] = 0x00010000] = "ConstructSignature";
        SymbolFlags[SymbolFlags["IndexSignature"] = 0x00020000] = "IndexSignature";
        SymbolFlags[SymbolFlags["TypeParameter"] = 0x00040000] = "TypeParameter";
        // Export markers (see comment in declareModuleMember in binder)
        SymbolFlags[SymbolFlags["ExportValue"] = 0x00080000] = "ExportValue";
        SymbolFlags[SymbolFlags["ExportType"] = 0x00100000] = "ExportType";
        SymbolFlags[SymbolFlags["ExportNamespace"] = 0x00200000] = "ExportNamespace";
        SymbolFlags[SymbolFlags["Import"] = 0x00400000] = "Import";
        SymbolFlags[SymbolFlags["Instantiated"] = 0x00800000] = "Instantiated";
        SymbolFlags[SymbolFlags["Merged"] = 0x01000000] = "Merged";
        SymbolFlags[SymbolFlags["Transient"] = 0x02000000] = "Transient";
        SymbolFlags[SymbolFlags["Prototype"] = 0x04000000] = "Prototype";
        SymbolFlags[SymbolFlags["Value"] = SymbolFlags.Variable | SymbolFlags.Property | SymbolFlags.EnumMember | SymbolFlags.Function | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule | SymbolFlags.Method | SymbolFlags.GetAccessor | SymbolFlags.SetAccessor] = "Value";
        SymbolFlags[SymbolFlags["Type"] = SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.Enum | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral | SymbolFlags.TypeParameter] = "Type";
        SymbolFlags[SymbolFlags["Namespace"] = SymbolFlags.ValueModule | SymbolFlags.NamespaceModule] = "Namespace";
        SymbolFlags[SymbolFlags["Module"] = SymbolFlags.ValueModule | SymbolFlags.NamespaceModule] = "Module";
        SymbolFlags[SymbolFlags["Accessor"] = SymbolFlags.GetAccessor | SymbolFlags.SetAccessor] = "Accessor";
        SymbolFlags[SymbolFlags["Signature"] = SymbolFlags.CallSignature | SymbolFlags.ConstructSignature | SymbolFlags.IndexSignature] = "Signature";
        SymbolFlags[SymbolFlags["ParameterExcludes"] = SymbolFlags.Value] = "ParameterExcludes";
        SymbolFlags[SymbolFlags["VariableExcludes"] = SymbolFlags.Value & ~SymbolFlags.Variable] = "VariableExcludes";
        SymbolFlags[SymbolFlags["PropertyExcludes"] = SymbolFlags.Value] = "PropertyExcludes";
        SymbolFlags[SymbolFlags["EnumMemberExcludes"] = SymbolFlags.Value] = "EnumMemberExcludes";
        SymbolFlags[SymbolFlags["FunctionExcludes"] = SymbolFlags.Value & ~(SymbolFlags.Function | SymbolFlags.ValueModule)] = "FunctionExcludes";
        SymbolFlags[SymbolFlags["ClassExcludes"] = (SymbolFlags.Value | SymbolFlags.Type) & ~SymbolFlags.ValueModule] = "ClassExcludes";
        SymbolFlags[SymbolFlags["InterfaceExcludes"] = SymbolFlags.Type & ~SymbolFlags.Interface] = "InterfaceExcludes";
        SymbolFlags[SymbolFlags["EnumExcludes"] = (SymbolFlags.Value | SymbolFlags.Type) & ~(SymbolFlags.Enum | SymbolFlags.ValueModule)] = "EnumExcludes";
        SymbolFlags[SymbolFlags["ValueModuleExcludes"] = SymbolFlags.Value & ~(SymbolFlags.Function | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)] = "ValueModuleExcludes";
        SymbolFlags[SymbolFlags["NamespaceModuleExcludes"] = 0] = "NamespaceModuleExcludes";
        SymbolFlags[SymbolFlags["MethodExcludes"] = SymbolFlags.Value & ~SymbolFlags.Method] = "MethodExcludes";
        SymbolFlags[SymbolFlags["GetAccessorExcludes"] = SymbolFlags.Value & ~SymbolFlags.SetAccessor] = "GetAccessorExcludes";
        SymbolFlags[SymbolFlags["SetAccessorExcludes"] = SymbolFlags.Value & ~SymbolFlags.GetAccessor] = "SetAccessorExcludes";
        SymbolFlags[SymbolFlags["TypeParameterExcludes"] = SymbolFlags.Type & ~SymbolFlags.TypeParameter] = "TypeParameterExcludes";
        // Imports collide with all other imports with the same name.
        SymbolFlags[SymbolFlags["ImportExcludes"] = SymbolFlags.Import] = "ImportExcludes";
        SymbolFlags[SymbolFlags["ModuleMember"] = SymbolFlags.Variable | SymbolFlags.Function | SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.Enum | SymbolFlags.Module | SymbolFlags.Import] = "ModuleMember";
        SymbolFlags[SymbolFlags["ExportHasLocal"] = SymbolFlags.Function | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule] = "ExportHasLocal";
        SymbolFlags[SymbolFlags["HasLocals"] = SymbolFlags.Function | SymbolFlags.Module | SymbolFlags.Method | SymbolFlags.Constructor | SymbolFlags.Accessor | SymbolFlags.Signature] = "HasLocals";
        SymbolFlags[SymbolFlags["HasExports"] = SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.Module] = "HasExports";
        SymbolFlags[SymbolFlags["HasMembers"] = SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral] = "HasMembers";
        SymbolFlags[SymbolFlags["IsContainer"] = SymbolFlags.HasLocals | SymbolFlags.HasExports | SymbolFlags.HasMembers] = "IsContainer";
        SymbolFlags[SymbolFlags["PropertyOrAccessor"] = SymbolFlags.Property | SymbolFlags.Accessor] = "PropertyOrAccessor";
        SymbolFlags[SymbolFlags["Export"] = SymbolFlags.ExportNamespace | SymbolFlags.ExportType | SymbolFlags.ExportValue] = "Export";
    })(ts.SymbolFlags || (ts.SymbolFlags = {}));
    var SymbolFlags = ts.SymbolFlags;
    (function (NodeCheckFlags) {
        NodeCheckFlags[NodeCheckFlags["TypeChecked"] = 0x00000001] = "TypeChecked";
        NodeCheckFlags[NodeCheckFlags["LexicalThis"] = 0x00000002] = "LexicalThis";
        NodeCheckFlags[NodeCheckFlags["CaptureThis"] = 0x00000004] = "CaptureThis";
        NodeCheckFlags[NodeCheckFlags["EmitExtends"] = 0x00000008] = "EmitExtends";
        NodeCheckFlags[NodeCheckFlags["SuperInstance"] = 0x00000010] = "SuperInstance";
        NodeCheckFlags[NodeCheckFlags["SuperStatic"] = 0x00000020] = "SuperStatic";
        NodeCheckFlags[NodeCheckFlags["ContextChecked"] = 0x00000040] = "ContextChecked";
    })(ts.NodeCheckFlags || (ts.NodeCheckFlags = {}));
    var NodeCheckFlags = ts.NodeCheckFlags;
    (function (TypeFlags) {
        TypeFlags[TypeFlags["Any"] = 0x00000001] = "Any";
        TypeFlags[TypeFlags["String"] = 0x00000002] = "String";
        TypeFlags[TypeFlags["Number"] = 0x00000004] = "Number";
        TypeFlags[TypeFlags["Boolean"] = 0x00000008] = "Boolean";
        TypeFlags[TypeFlags["Void"] = 0x00000010] = "Void";
        TypeFlags[TypeFlags["Undefined"] = 0x00000020] = "Undefined";
        TypeFlags[TypeFlags["Null"] = 0x00000040] = "Null";
        TypeFlags[TypeFlags["Enum"] = 0x00000080] = "Enum";
        TypeFlags[TypeFlags["StringLiteral"] = 0x00000100] = "StringLiteral";
        TypeFlags[TypeFlags["TypeParameter"] = 0x00000200] = "TypeParameter";
        TypeFlags[TypeFlags["Class"] = 0x00000400] = "Class";
        TypeFlags[TypeFlags["Interface"] = 0x00000800] = "Interface";
        TypeFlags[TypeFlags["Reference"] = 0x00001000] = "Reference";
        TypeFlags[TypeFlags["Anonymous"] = 0x00002000] = "Anonymous";
        TypeFlags[TypeFlags["FromSignature"] = 0x00004000] = "FromSignature";
        TypeFlags[TypeFlags["Intrinsic"] = TypeFlags.Any | TypeFlags.String | TypeFlags.Number | TypeFlags.Boolean | TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null] = "Intrinsic";
        TypeFlags[TypeFlags["StringLike"] = TypeFlags.String | TypeFlags.StringLiteral] = "StringLike";
        TypeFlags[TypeFlags["NumberLike"] = TypeFlags.Number | TypeFlags.Enum] = "NumberLike";
        TypeFlags[TypeFlags["ObjectType"] = TypeFlags.Class | TypeFlags.Interface | TypeFlags.Reference | TypeFlags.Anonymous] = "ObjectType";
    })(ts.TypeFlags || (ts.TypeFlags = {}));
    var TypeFlags = ts.TypeFlags;
    (function (SignatureKind) {
        SignatureKind[SignatureKind["Call"] = 0] = "Call";
        SignatureKind[SignatureKind["Construct"] = 1] = "Construct";
    })(ts.SignatureKind || (ts.SignatureKind = {}));
    var SignatureKind = ts.SignatureKind;
    (function (IndexKind) {
        IndexKind[IndexKind["String"] = 0] = "String";
        IndexKind[IndexKind["Number"] = 1] = "Number";
    })(ts.IndexKind || (ts.IndexKind = {}));
    var IndexKind = ts.IndexKind;
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
    })(ts.DiagnosticCategory || (ts.DiagnosticCategory = {}));
    var DiagnosticCategory = ts.DiagnosticCategory;
    (function (ModuleKind) {
        ModuleKind[ModuleKind["None"] = 0] = "None";
        ModuleKind[ModuleKind["CommonJS"] = 1] = "CommonJS";
        ModuleKind[ModuleKind["AMD"] = 2] = "AMD";
    })(ts.ModuleKind || (ts.ModuleKind = {}));
    var ModuleKind = ts.ModuleKind;
    (function (ScriptTarget) {
        ScriptTarget[ScriptTarget["ES3"] = 0] = "ES3";
        ScriptTarget[ScriptTarget["ES5"] = 1] = "ES5";
    })(ts.ScriptTarget || (ts.ScriptTarget = {}));
    var ScriptTarget = ts.ScriptTarget;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 0x7F] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 0x0A] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 0x0D] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 0x2028] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 0x2029] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 0x0085] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 0x0020] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 0x00A0] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 0x2000] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 0x2001] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 0x2002] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 0x2003] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 0x2004] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 0x2005] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 0x2006] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 0x2007] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 0x2008] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 0x2009] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 0x200A] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 0x200B] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 0x202F] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 0x3000] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 0x205F] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 0x1680] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 0x5F] = "_";
        CharacterCodes[CharacterCodes["$"] = 0x24] = "$";
        CharacterCodes[CharacterCodes["_0"] = 0x30] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 0x31] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 0x32] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 0x33] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 0x34] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 0x35] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 0x36] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 0x37] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 0x38] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 0x39] = "_9";
        CharacterCodes[CharacterCodes["a"] = 0x61] = "a";
        CharacterCodes[CharacterCodes["b"] = 0x62] = "b";
        CharacterCodes[CharacterCodes["c"] = 0x63] = "c";
        CharacterCodes[CharacterCodes["d"] = 0x64] = "d";
        CharacterCodes[CharacterCodes["e"] = 0x65] = "e";
        CharacterCodes[CharacterCodes["f"] = 0x66] = "f";
        CharacterCodes[CharacterCodes["g"] = 0x67] = "g";
        CharacterCodes[CharacterCodes["h"] = 0x68] = "h";
        CharacterCodes[CharacterCodes["i"] = 0x69] = "i";
        CharacterCodes[CharacterCodes["j"] = 0x6A] = "j";
        CharacterCodes[CharacterCodes["k"] = 0x6B] = "k";
        CharacterCodes[CharacterCodes["l"] = 0x6C] = "l";
        CharacterCodes[CharacterCodes["m"] = 0x6D] = "m";
        CharacterCodes[CharacterCodes["n"] = 0x6E] = "n";
        CharacterCodes[CharacterCodes["o"] = 0x6F] = "o";
        CharacterCodes[CharacterCodes["p"] = 0x70] = "p";
        CharacterCodes[CharacterCodes["q"] = 0x71] = "q";
        CharacterCodes[CharacterCodes["r"] = 0x72] = "r";
        CharacterCodes[CharacterCodes["s"] = 0x73] = "s";
        CharacterCodes[CharacterCodes["t"] = 0x74] = "t";
        CharacterCodes[CharacterCodes["u"] = 0x75] = "u";
        CharacterCodes[CharacterCodes["v"] = 0x76] = "v";
        CharacterCodes[CharacterCodes["w"] = 0x77] = "w";
        CharacterCodes[CharacterCodes["x"] = 0x78] = "x";
        CharacterCodes[CharacterCodes["y"] = 0x79] = "y";
        CharacterCodes[CharacterCodes["z"] = 0x7A] = "z";
        CharacterCodes[CharacterCodes["A"] = 0x41] = "A";
        CharacterCodes[CharacterCodes["B"] = 0x42] = "B";
        CharacterCodes[CharacterCodes["C"] = 0x43] = "C";
        CharacterCodes[CharacterCodes["D"] = 0x44] = "D";
        CharacterCodes[CharacterCodes["E"] = 0x45] = "E";
        CharacterCodes[CharacterCodes["F"] = 0x46] = "F";
        CharacterCodes[CharacterCodes["G"] = 0x47] = "G";
        CharacterCodes[CharacterCodes["H"] = 0x48] = "H";
        CharacterCodes[CharacterCodes["I"] = 0x49] = "I";
        CharacterCodes[CharacterCodes["J"] = 0x4A] = "J";
        CharacterCodes[CharacterCodes["K"] = 0x4B] = "K";
        CharacterCodes[CharacterCodes["L"] = 0x4C] = "L";
        CharacterCodes[CharacterCodes["M"] = 0x4D] = "M";
        CharacterCodes[CharacterCodes["N"] = 0x4E] = "N";
        CharacterCodes[CharacterCodes["O"] = 0x4F] = "O";
        CharacterCodes[CharacterCodes["P"] = 0x50] = "P";
        CharacterCodes[CharacterCodes["Q"] = 0x51] = "Q";
        CharacterCodes[CharacterCodes["R"] = 0x52] = "R";
        CharacterCodes[CharacterCodes["S"] = 0x53] = "S";
        CharacterCodes[CharacterCodes["T"] = 0x54] = "T";
        CharacterCodes[CharacterCodes["U"] = 0x55] = "U";
        CharacterCodes[CharacterCodes["V"] = 0x56] = "V";
        CharacterCodes[CharacterCodes["W"] = 0x57] = "W";
        CharacterCodes[CharacterCodes["X"] = 0x58] = "X";
        CharacterCodes[CharacterCodes["Y"] = 0x59] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 0x5a] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 0x26] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 0x2A] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 0x40] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 0x5C] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 0x7C] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 0x5E] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 0x7D] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 0x5D] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 0x29] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 0x3A] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 0x2C] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 0x2E] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 0x22] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 0x3D] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 0x21] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 0x3E] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 0x3C] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 0x2D] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 0x7B] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 0x5B] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 0x28] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 0x25] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 0x2B] = "plus";
        CharacterCodes[CharacterCodes["question"] = 0x3F] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 0x3B] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 0x27] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 0x2F] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 0x7E] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 0x08] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 0x0C] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 0xFEFF] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 0x09] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 0x0B] = "verticalTab";
    })(ts.CharacterCodes || (ts.CharacterCodes = {}));
    var CharacterCodes = ts.CharacterCodes;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
var ts;
(function (ts) {
    function forEach(array, callback) {
        var result;
        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (result = callback(array[i]))
                    break;
            }
        }
        return result;
    }
    ts.forEach = forEach;
    function contains(array, value) {
        if (array) {
            var len = array.length;
            for (var i = 0; i < len; i++) {
                if (array[i] === value) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.contains = contains;
    function indexOf(array, value) {
        if (array) {
            var len = array.length;
            for (var i = 0; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
        }
        return -1;
    }
    ts.indexOf = indexOf;
    function filter(array, f) {
        var result;
        if (array) {
            result = [];
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (f(item)) {
                    result.push(item);
                }
            }
        }
        return result;
    }
    ts.filter = filter;
    function map(array, f) {
        var result;
        if (array) {
            result = [];
            var len = array.length;
            for (var i = 0; i < len; i++) {
                result.push(f(array[i]));
            }
        }
        return result;
    }
    ts.map = map;
    function concatenate(array1, array2) {
        if (!array2 || !array2.length)
            return array1;
        if (!array1 || !array1.length)
            return array2;
        return array1.concat(array2);
    }
    ts.concatenate = concatenate;
    function sum(array, prop) {
        var result = 0;
        for (var i = 0; i < array.length; i++) {
            result += array[i][prop];
        }
        return result;
    }
    ts.sum = sum;
    function binarySearch(array, value) {
        var low = 0;
        var high = array.length - 1;
        while (low <= high) {
            var middle = low + ((high - low) >> 1);
            var midValue = array[middle];
            if (midValue === value) {
                return middle;
            }
            else if (midValue > value) {
                high = middle - 1;
            }
            else {
                low = middle + 1;
            }
        }
        return ~low;
    }
    ts.binarySearch = binarySearch;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasProperty(map, key) {
        return hasOwnProperty.call(map, key);
    }
    ts.hasProperty = hasProperty;
    function getProperty(map, key) {
        return hasOwnProperty.call(map, key) ? map[key] : undefined;
    }
    ts.getProperty = getProperty;
    function isEmpty(map) {
        for (var id in map) {
            if (hasProperty(map, id)) {
                return false;
            }
        }
        return true;
    }
    ts.isEmpty = isEmpty;
    function clone(object) {
        var result = {};
        for (var id in object) {
            result[id] = object[id];
        }
        return result;
    }
    ts.clone = clone;
    function forEachValue(map, callback) {
        var result;
        for (var id in map) {
            if (result = callback(map[id]))
                break;
        }
        return result;
    }
    ts.forEachValue = forEachValue;
    function forEachKey(map, callback) {
        var result;
        for (var id in map) {
            if (result = callback(id))
                break;
        }
        return result;
    }
    ts.forEachKey = forEachKey;
    function lookUp(map, key) {
        return hasProperty(map, key) ? map[key] : undefined;
    }
    ts.lookUp = lookUp;
    function mapToArray(map) {
        var result = [];
        for (var id in map) {
            result.push(map[id]);
        }
        return result;
    }
    ts.mapToArray = mapToArray;
    /**
     * Creates a map from the elements of an array.
     *
     * @param array the array of input elements.
     * @param makeKey a function that produces a key for a given element.
     *
     * This function makes no effort to avoid collisions; if any two elements produce
     * the same key with the given 'makeKey' function, then the element with the higher
     * index in the array will be the one associated with the produced key.
     */
    function arrayToMap(array, makeKey) {
        var result = {};
        forEach(array, function (value) {
            result[makeKey(value)] = value;
        });
        return result;
    }
    ts.arrayToMap = arrayToMap;
    function formatStringFromArgs(text, args, baseIndex) {
        baseIndex = baseIndex || 0;
        return text.replace(/{(\d+)}/g, function (match, index) { return args[+index + baseIndex]; });
    }
    ts.localizedDiagnosticMessages = undefined;
    function getLocaleSpecificMessage(message) {
        if (ts.localizedDiagnosticMessages) {
            message = ts.localizedDiagnosticMessages[message];
        }
        return message;
    }
    ts.getLocaleSpecificMessage = getLocaleSpecificMessage;
    function createFileDiagnostic(file, start, length, message) {
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: file,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code
        };
    }
    ts.createFileDiagnostic = createFileDiagnostic;
    function createCompilerDiagnostic(message) {
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 1) {
            text = formatStringFromArgs(text, arguments, 1);
        }
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            messageText: text,
            category: message.category,
            code: message.code
        };
    }
    ts.createCompilerDiagnostic = createCompilerDiagnostic;
    function chainDiagnosticMessages(details, message) {
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return {
            messageText: text,
            category: message.category,
            code: message.code,
            next: details
        };
    }
    ts.chainDiagnosticMessages = chainDiagnosticMessages;
    function flattenDiagnosticChain(file, start, length, diagnosticChain, newLine) {
        var code = diagnosticChain.code;
        var category = diagnosticChain.category;
        var messageText = "";
        var indent = 0;
        while (diagnosticChain) {
            if (indent) {
                messageText += newLine;
                for (var i = 0; i < indent; i++) {
                    messageText += "  ";
                }
            }
            messageText += diagnosticChain.messageText;
            indent++;
            diagnosticChain = diagnosticChain.next;
        }
        return {
            file: file,
            start: start,
            length: length,
            code: code,
            category: category,
            messageText: messageText
        };
    }
    ts.flattenDiagnosticChain = flattenDiagnosticChain;
    function compareValues(a, b) {
        if (a === b)
            return 0;
        if (a === undefined)
            return -1;
        if (b === undefined)
            return 1;
        return a < b ? -1 : 1;
    }
    ts.compareValues = compareValues;
    function getDiagnosticFilename(diagnostic) {
        return diagnostic.file ? diagnostic.file.filename : undefined;
    }
    function compareDiagnostics(d1, d2) {
        return compareValues(getDiagnosticFilename(d1), getDiagnosticFilename(d2)) || compareValues(d1.start, d2.start) || compareValues(d1.length, d2.length) || compareValues(d1.code, d2.code) || compareValues(d1.messageText, d2.messageText) || 0;
    }
    ts.compareDiagnostics = compareDiagnostics;
    function deduplicateSortedDiagnostics(diagnostics) {
        if (diagnostics.length < 2) {
            return diagnostics;
        }
        var newDiagnostics = [diagnostics[0]];
        var previousDiagnostic = diagnostics[0];
        for (var i = 1; i < diagnostics.length; i++) {
            var currentDiagnostic = diagnostics[i];
            var isDupe = compareDiagnostics(currentDiagnostic, previousDiagnostic) === 0;
            if (!isDupe) {
                newDiagnostics.push(currentDiagnostic);
                previousDiagnostic = currentDiagnostic;
            }
        }
        return newDiagnostics;
    }
    ts.deduplicateSortedDiagnostics = deduplicateSortedDiagnostics;
    function normalizeSlashes(path) {
        return path.replace(/\\/g, "/");
    }
    ts.normalizeSlashes = normalizeSlashes;
    // Returns length of path root (i.e. length of "/", "x:/", "//server/share/")
    function getRootLength(path) {
        if (path.charCodeAt(0) === 47 /* slash */) {
            if (path.charCodeAt(1) !== 47 /* slash */)
                return 1;
            var p1 = path.indexOf("/", 2);
            if (p1 < 0)
                return 2;
            var p2 = path.indexOf("/", p1 + 1);
            if (p2 < 0)
                return p1 + 1;
            return p2 + 1;
        }
        if (path.charCodeAt(1) === 58 /* colon */) {
            if (path.charCodeAt(2) === 47 /* slash */)
                return 3;
            return 2;
        }
        return 0;
    }
    ts.getRootLength = getRootLength;
    ts.directorySeparator = "/";
    function getNormalizedParts(normalizedSlashedPath, rootLength) {
        var parts = normalizedSlashedPath.substr(rootLength).split(ts.directorySeparator);
        var normalized = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part !== ".") {
                if (part === ".." && normalized.length > 0 && normalized[normalized.length - 1] !== "..") {
                    normalized.pop();
                }
                else {
                    normalized.push(part);
                }
            }
        }
        return normalized;
    }
    function normalizePath(path) {
        var path = normalizeSlashes(path);
        var rootLength = getRootLength(path);
        var normalized = getNormalizedParts(path, rootLength);
        return path.substr(0, rootLength) + normalized.join(ts.directorySeparator);
    }
    ts.normalizePath = normalizePath;
    function getDirectoryPath(path) {
        return path.substr(0, Math.max(getRootLength(path), path.lastIndexOf(ts.directorySeparator)));
    }
    ts.getDirectoryPath = getDirectoryPath;
    function isUrl(path) {
        return path && !isRootedDiskPath(path) && path.indexOf("://") !== -1;
    }
    ts.isUrl = isUrl;
    function isRootedDiskPath(path) {
        return getRootLength(path) !== 0;
    }
    ts.isRootedDiskPath = isRootedDiskPath;
    function normalizedPathComponents(path, rootLength) {
        var normalizedParts = getNormalizedParts(path, rootLength);
        return [path.substr(0, rootLength)].concat(normalizedParts);
    }
    function getNormalizedPathComponents(path, currentDirectory) {
        var path = normalizeSlashes(path);
        var rootLength = getRootLength(path);
        if (rootLength == 0) {
            // If the path is not rooted it is relative to current directory
            path = combinePaths(normalizeSlashes(currentDirectory), path);
            rootLength = getRootLength(path);
        }
        return normalizedPathComponents(path, rootLength);
    }
    ts.getNormalizedPathComponents = getNormalizedPathComponents;
    function getNormalizedPathFromPathCompoments(pathComponents) {
        if (pathComponents && pathComponents.length) {
            return pathComponents[0] + pathComponents.slice(1).join(ts.directorySeparator);
        }
    }
    ts.getNormalizedPathFromPathCompoments = getNormalizedPathFromPathCompoments;
    function getNormalizedPathComponentsOfUrl(url) {
        // Get root length of http://www.website.com/folder1/foler2/
        // In this example the root is:  http://www.website.com/
        // normalized path components should be ["http://www.website.com/", "folder1", "folder2"]
        var urlLength = url.length;
        // Initial root length is http:// part
        var rootLength = url.indexOf("://") + "://".length;
        while (rootLength < urlLength) {
            // Consume all immediate slashes in the protocol
            // eg.initial rootlength is just file:// but it needs to consume another "/" in file:///
            if (url.charCodeAt(rootLength) === 47 /* slash */) {
                rootLength++;
            }
            else {
                break;
            }
        }
        // there are no parts after http:// just return current string as the pathComponent
        if (rootLength === urlLength) {
            return [url];
        }
        // Find the index of "/" after website.com so the root can be http://www.website.com/ (from existing http://)
        var indexOfNextSlash = url.indexOf(ts.directorySeparator, rootLength);
        if (indexOfNextSlash !== -1) {
            // Found the "/" after the website.com so the root is length of http://www.website.com/
            // and get components afetr the root normally like any other folder components
            rootLength = indexOfNextSlash + 1;
            return normalizedPathComponents(url, rootLength);
        }
        else {
            // Can't find the host assume the rest of the string as component
            // but make sure we append "/"  to it as root is not joined using "/"
            // eg. if url passed in was http://website.com we want to use root as [http://website.com/]
            // so that other path manipulations will be correct and it can be merged with relative paths correctly
            return [url + ts.directorySeparator];
        }
    }
    function getNormalizedPathOrUrlComponents(pathOrUrl, currentDirectory) {
        if (isUrl(pathOrUrl)) {
            return getNormalizedPathComponentsOfUrl(pathOrUrl);
        }
        else {
            return getNormalizedPathComponents(pathOrUrl, currentDirectory);
        }
    }
    function getRelativePathToDirectoryOrUrl(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, isAbsolutePathAnUrl) {
        var pathComponents = getNormalizedPathOrUrlComponents(relativeOrAbsolutePath, currentDirectory);
        var directoryComponents = getNormalizedPathOrUrlComponents(directoryPathOrUrl, currentDirectory);
        if (directoryComponents.length > 1 && directoryComponents[directoryComponents.length - 1] === "") {
            // If the directory path given was of type test/cases/ then we really need components of directry to be only till its name
            // that is  ["test", "cases", ""] needs to be actually ["test", "cases"]
            directoryComponents.length--;
        }
        for (var joinStartIndex = 0; joinStartIndex < pathComponents.length && joinStartIndex < directoryComponents.length; joinStartIndex++) {
            if (directoryComponents[joinStartIndex] !== pathComponents[joinStartIndex]) {
                break;
            }
        }
        // Get the relative path
        if (joinStartIndex) {
            var relativePath = "";
            var relativePathComponents = pathComponents.slice(joinStartIndex, pathComponents.length);
            for (; joinStartIndex < directoryComponents.length; joinStartIndex++) {
                if (directoryComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + ".." + ts.directorySeparator;
                }
            }
            return relativePath + relativePathComponents.join(ts.directorySeparator);
        }
        // Cant find the relative path, get the absolute path
        var absolutePath = getNormalizedPathFromPathCompoments(pathComponents);
        if (isAbsolutePathAnUrl && isRootedDiskPath(absolutePath)) {
            absolutePath = "file:///" + absolutePath;
        }
        return absolutePath;
    }
    ts.getRelativePathToDirectoryOrUrl = getRelativePathToDirectoryOrUrl;
    function getBaseFilename(path) {
        var i = path.lastIndexOf(ts.directorySeparator);
        return i < 0 ? path : path.substring(i + 1);
    }
    ts.getBaseFilename = getBaseFilename;
    function combinePaths(path1, path2) {
        if (!(path1 && path1.length))
            return path2;
        if (!(path2 && path2.length))
            return path1;
        if (path2.charAt(0) === ts.directorySeparator)
            return path2;
        if (path1.charAt(path1.length - 1) === ts.directorySeparator)
            return path1 + path2;
        return path1 + ts.directorySeparator + path2;
    }
    ts.combinePaths = combinePaths;
    function fileExtensionIs(path, extension) {
        var pathLen = path.length;
        var extLen = extension.length;
        return pathLen > extLen && path.substr(pathLen - extLen, extLen) === extension;
    }
    ts.fileExtensionIs = fileExtensionIs;
    function Symbol(flags, name) {
        this.flags = flags;
        this.name = name;
        this.declarations = undefined;
    }
    function Type(checker, flags) {
        this.flags = flags;
    }
    function Signature(checker) {
    }
    ts.objectAllocator = {
        getNodeConstructor: function (kind) {
            function Node() {
            }
            Node.prototype = {
                kind: kind,
                pos: 0,
                end: 0,
                flags: 0,
                parent: undefined
            };
            return Node;
        },
        getSymbolConstructor: function () { return Symbol; },
        getTypeConstructor: function () { return Type; },
        getSignatureConstructor: function () { return Signature; }
    };
    (function (AssertionLevel) {
        AssertionLevel[AssertionLevel["None"] = 0] = "None";
        AssertionLevel[AssertionLevel["Normal"] = 1] = "Normal";
        AssertionLevel[AssertionLevel["Aggressive"] = 2] = "Aggressive";
        AssertionLevel[AssertionLevel["VeryAggressive"] = 3] = "VeryAggressive";
    })(ts.AssertionLevel || (ts.AssertionLevel = {}));
    var AssertionLevel = ts.AssertionLevel;
    (function (Debug) {
        var currentAssertionLevel = 0 /* None */;
        function shouldAssert(level) {
            return currentAssertionLevel >= level;
        }
        Debug.shouldAssert = shouldAssert;
        function assert(expression, message, verboseDebugInfo) {
            if (!expression) {
                var verboseDebugString = "";
                if (verboseDebugInfo) {
                    verboseDebugString = "\r\nVerbose Debug Information: " + verboseDebugInfo();
                }
                throw new Error("Debug Failure. False expression: " + (message || "") + verboseDebugString);
            }
        }
        Debug.assert = assert;
        function fail(message) {
            Debug.assert(false, message);
        }
        Debug.fail = fail;
    })(ts.Debug || (ts.Debug = {}));
    var Debug = ts.Debug;
})(ts || (ts = {}));
/// <reference path="diagnosticInformationMap.generated.ts"/>
var sys = (function () {
    function getWScriptSystem() {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var fileStream = new ActiveXObject("ADODB.Stream");
        fileStream.Type = 2;
        var binaryStream = new ActiveXObject("ADODB.Stream");
        binaryStream.Type = 1;
        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }
        function readFile(fileName, encoding) {
            if (!fso.FileExists(fileName)) {
                return undefined;
            }
            fileStream.Open();
            try {
                if (encoding) {
                    fileStream.Charset = encoding;
                    fileStream.LoadFromFile(fileName);
                }
                else {
                    // Load file and read the first two bytes into a string with no interpretation
                    fileStream.Charset = "x-ansi";
                    fileStream.LoadFromFile(fileName);
                    var bom = fileStream.ReadText(2) || "";
                    // Position must be at 0 before encoding can be changed
                    fileStream.Position = 0;
                    // [0xFF,0xFE] and [0xFE,0xFF] mean utf-16 (little or big endian), otherwise default to utf-8
                    fileStream.Charset = bom.length >= 2 && (bom.charCodeAt(0) === 0xFF && bom.charCodeAt(1) === 0xFE || bom.charCodeAt(0) === 0xFE && bom.charCodeAt(1) === 0xFF) ? "unicode" : "utf-8";
                }
                // ReadText method always strips byte order mark from resulting string
                return fileStream.ReadText();
            }
            catch (e) {
                throw e.number === -2147024809 ? new Error(ts.Diagnostics.Unsupported_file_encoding.key) : e;
            }
            finally {
                fileStream.Close();
            }
        }
        function writeFile(fileName, data, writeByteOrderMark) {
            fileStream.Open();
            binaryStream.Open();
            try {
                // Write characters in UTF-8 encoding
                fileStream.Charset = "utf-8";
                fileStream.WriteText(data);
                // If we don't want the BOM, then skip it by setting the starting location to 3 (size of BOM).
                // If not, start from position 0, as the BOM will be added automatically when charset==utf8.
                if (writeByteOrderMark) {
                    fileStream.Position = 0;
                }
                else {
                    fileStream.Position = 3;
                }
                fileStream.CopyTo(binaryStream);
                binaryStream.SaveToFile(fileName, 2);
            }
            finally {
                binaryStream.Close();
                fileStream.Close();
            }
        }
        return {
            args: args,
            newLine: "\r\n",
            useCaseSensitiveFileNames: false,
            write: function (s) {
                WScript.StdOut.Write(s);
            },
            readFile: readFile,
            writeFile: writeFile,
            resolvePath: function (path) {
                return fso.GetAbsolutePathName(path);
            },
            fileExists: function (path) {
                return fso.FileExists(path);
            },
            directoryExists: function (path) {
                return fso.FolderExists(path);
            },
            createDirectory: function (directoryName) {
                if (!this.directoryExists(directoryName)) {
                    fso.CreateFolder(directoryName);
                }
            },
            getExecutingFilePath: function () {
                return WScript.ScriptFullName;
            },
            getCurrentDirectory: function () {
                return new ActiveXObject("WScript.Shell").CurrentDirectory;
            },
            exit: function (exitCode) {
                try {
                    WScript.Quit(exitCode);
                }
                catch (e) {
                }
            }
        };
    }
    function getNodeSystem() {
        var _fs = require("fs");
        var _path = require("path");
        var _os = require('os');
        var platform = _os.platform();
        // win32\win64 are case insensitive platforms, MacOS (darwin) by default is also case insensitive
        var useCaseSensitiveFileNames = platform !== "win32" && platform !== "win64" && platform !== "darwin";
        function readFile(fileName, encoding) {
            if (!_fs.existsSync(fileName)) {
                return undefined;
            }
            var buffer = _fs.readFileSync(fileName);
            var len = buffer.length;
            if (len >= 2 && buffer[0] === 0xFE && buffer[1] === 0xFF) {
                // Big endian UTF-16 byte order mark detected. Since big endian is not supported by node.js,
                // flip all byte pairs and treat as little endian.
                len &= ~1;
                for (var i = 0; i < len; i += 2) {
                    var temp = buffer[i];
                    buffer[i] = buffer[i + 1];
                    buffer[i + 1] = temp;
                }
                return buffer.toString("utf16le", 2);
            }
            if (len >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {
                // Little endian UTF-16 byte order mark detected
                return buffer.toString("utf16le", 2);
            }
            if (len >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
                // UTF-8 byte order mark detected
                return buffer.toString("utf8", 3);
            }
            // Default is UTF-8 with no byte order mark
            return buffer.toString("utf8");
        }
        function writeFile(fileName, data, writeByteOrderMark) {
            // If a BOM is required, emit one
            if (writeByteOrderMark) {
                data = '\uFEFF' + data;
            }
            _fs.writeFileSync(fileName, data, "utf8");
        }
        return {
            args: process.argv.slice(2),
            newLine: _os.EOL,
            useCaseSensitiveFileNames: useCaseSensitiveFileNames,
            write: function (s) {
                // 1 is a standard descriptor for stdout
                _fs.writeSync(1, s);
            },
            readFile: readFile,
            writeFile: writeFile,
            watchFile: function (fileName, callback) {
                // watchFile polls a file every 250ms, picking up file notifications.
                _fs.watchFile(fileName, { persistent: true, interval: 250 }, fileChanged);
                return {
                    close: function () {
                        _fs.unwatchFile(fileName, fileChanged);
                    }
                };
                function fileChanged(curr, prev) {
                    if (+curr.mtime <= +prev.mtime) {
                        return;
                    }
                    callback(fileName);
                }
                ;
            },
            resolvePath: function (path) {
                return _path.resolve(path);
            },
            fileExists: function (path) {
                return _fs.existsSync(path);
            },
            directoryExists: function (path) {
                return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
            },
            createDirectory: function (directoryName) {
                if (!this.directoryExists(directoryName)) {
                    _fs.mkdirSync(directoryName);
                }
            },
            getExecutingFilePath: function () {
                return process.mainModule.filename;
            },
            getCurrentDirectory: function () {
                return process.cwd();
            },
            getMemoryUsage: function () {
                if (global.gc) {
                    global.gc();
                }
                return process.memoryUsage().heapUsed;
            },
            exit: function (exitCode) {
                process.exit(exitCode);
            }
        };
    }
    if (typeof WScript !== "undefined" && typeof ActiveXObject === "function") {
        return getWScriptSystem();
    }
    else if (typeof module !== "undefined" && module.exports) {
        return getNodeSystem();
    }
    else {
        return undefined; // Unsupported host
    }
})();
/// <reference path="sys.ts"/>
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
var ts;
(function (ts) {
    var nodeConstructors = new Array(180 /* Count */);
    function getNodeConstructor(kind) {
        return nodeConstructors[kind] || (nodeConstructors[kind] = ts.objectAllocator.getNodeConstructor(kind));
    }
    ts.getNodeConstructor = getNodeConstructor;
    function createRootNode(kind, pos, end, flags) {
        var node = new (getNodeConstructor(kind))();
        node.pos = pos;
        node.end = end;
        node.flags = flags;
        return node;
    }
    var moduleExtensions = [".d.ts", ".ts", ".js"];
    function getModuleNameFromFilename(filename) {
        for (var i = 0; i < moduleExtensions.length; i++) {
            var ext = moduleExtensions[i];
            var len = filename.length - ext.length;
            if (len > 0 && filename.substr(len) === ext)
                return filename.substr(0, len);
        }
        return filename;
    }
    ts.getModuleNameFromFilename = getModuleNameFromFilename;
    function getSourceFileOfNode(node) {
        while (node && node.kind !== 177 /* SourceFile */)
            node = node.parent;
        return node;
    }
    ts.getSourceFileOfNode = getSourceFileOfNode;
    // This is a useful function for debugging purposes.
    function nodePosToString(node) {
        var file = getSourceFileOfNode(node);
        var loc = file.getLineAndCharacterFromPosition(node.pos);
        return file.filename + "(" + loc.line + "," + loc.character + ")";
    }
    ts.nodePosToString = nodePosToString;
    function getStartPosOfNode(node) {
        return node.pos;
    }
    ts.getStartPosOfNode = getStartPosOfNode;
    function getTokenPosOfNode(node) {
        return ts.skipTrivia(getSourceFileOfNode(node).text, node.pos);
    }
    ts.getTokenPosOfNode = getTokenPosOfNode;
    function getSourceTextOfNodeFromSourceText(sourceText, node) {
        return sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);
    }
    ts.getSourceTextOfNodeFromSourceText = getSourceTextOfNodeFromSourceText;
    function getSourceTextOfNode(node) {
        var text = getSourceFileOfNode(node).text;
        return text.substring(ts.skipTrivia(text, node.pos), node.end);
    }
    ts.getSourceTextOfNode = getSourceTextOfNode;
    // Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__'
    function escapeIdentifier(identifier) {
        return identifier.length >= 2 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ ? "_" + identifier : identifier;
    }
    ts.escapeIdentifier = escapeIdentifier;
    // Remove extra underscore from escaped identifier
    function unescapeIdentifier(identifier) {
        return identifier.length >= 3 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ && identifier.charCodeAt(2) === 95 /* _ */ ? identifier.substr(1) : identifier;
    }
    ts.unescapeIdentifier = unescapeIdentifier;
    // Return display name of an identifier
    function identifierToString(identifier) {
        return identifier.kind === 111 /* Missing */ ? "(Missing)" : getSourceTextOfNode(identifier);
    }
    ts.identifierToString = identifierToString;
    function createDiagnosticForNode(node, message, arg0, arg1, arg2) {
        node = getErrorSpanForNode(node);
        var file = getSourceFileOfNode(node);
        var start = ts.skipTrivia(file.text, node.pos);
        var length = node.end - start;
        return ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2);
    }
    ts.createDiagnosticForNode = createDiagnosticForNode;
    function createDiagnosticForNodeFromMessageChain(node, messageChain, newLine) {
        node = getErrorSpanForNode(node);
        var file = getSourceFileOfNode(node);
        var start = ts.skipTrivia(file.text, node.pos);
        var length = node.end - start;
        return ts.flattenDiagnosticChain(file, start, length, messageChain, newLine);
    }
    ts.createDiagnosticForNodeFromMessageChain = createDiagnosticForNodeFromMessageChain;
    function getErrorSpanForNode(node) {
        var errorSpan;
        switch (node.kind) {
            case 166 /* VariableDeclaration */:
            case 169 /* ClassDeclaration */:
            case 170 /* InterfaceDeclaration */:
            case 172 /* ModuleDeclaration */:
            case 171 /* EnumDeclaration */:
            case 176 /* EnumMember */:
                errorSpan = node.name;
                break;
        }
        // We now have the ideal error span, but it may be a node that is optional and absent
        // (e.g. the name of a function expression), in which case errorSpan will be undefined.
        // Alternatively, it might be required and missing (e.g. the name of a module), in which
        // case its pos will equal its end (length 0). In either of these cases, we should fall
        // back to the original node that the error was issued on.
        return errorSpan && errorSpan.pos < errorSpan.end ? errorSpan : node;
    }
    ts.getErrorSpanForNode = getErrorSpanForNode;
    function isExternalModule(file) {
        return file.externalModuleIndicator !== undefined;
    }
    ts.isExternalModule = isExternalModule;
    function isPrologueDirective(node) {
        return node.kind === 146 /* ExpressionStatement */ && node.expression.kind === 3 /* StringLiteral */;
    }
    ts.isPrologueDirective = isPrologueDirective;
    function isEvalOrArgumentsIdentifier(node) {
        return node.kind === 55 /* Identifier */ && node.text && (node.text === "eval" || node.text === "arguments");
    }
    /// Should be called only on prologue directives (isPrologueDirective(node) should be true)
    function isUseStrictPrologueDirective(node) {
        ts.Debug.assert(isPrologueDirective(node));
        return node.expression.text === "use strict";
    }
    function getLeadingCommentsOfNode(node, sourceFileOfNode) {
        // If parameter/type parameter, the prev token trailing comments are part of this node too
        if (node.kind === 114 /* Parameter */ || node.kind === 113 /* TypeParameter */) {
            // eg     (/** blah */ a, /** blah */ b);
            return ts.concatenate(ts.getTrailingComments(sourceFileOfNode.text, node.pos), ts.getLeadingComments(sourceFileOfNode.text, node.pos));
        }
        else {
            return ts.getLeadingComments(sourceFileOfNode.text, node.pos);
        }
    }
    ts.getLeadingCommentsOfNode = getLeadingCommentsOfNode;
    function getJsDocComments(node, sourceFileOfNode) {
        return ts.filter(getLeadingCommentsOfNode(node, sourceFileOfNode), function (comment) { return isJsDocComment(comment); });
        function isJsDocComment(comment) {
            // js doc is if comment is starting with /** but not if it is /**/
            return sourceFileOfNode.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */ && sourceFileOfNode.text.charCodeAt(comment.pos + 2) === 42 /* asterisk */ && sourceFileOfNode.text.charCodeAt(comment.pos + 3) !== 47 /* slash */;
        }
    }
    ts.getJsDocComments = getJsDocComments;
    ts.fullTripleSlashReferencePathRegEx = /^(\/\/\/\s*<reference\s+path\s*=\s*)('|")(.+?)\2.*?\/>/;
    // Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
    // stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
    // embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
    // a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
    function forEachChild(node, cbNode, cbNodes) {
        function child(node) {
            if (node)
                return cbNode(node);
        }
        function children(nodes) {
            if (nodes) {
                if (cbNodes)
                    return cbNodes(nodes);
                var result;
                for (var i = 0, len = nodes.length; i < len; i++) {
                    if (result = cbNode(nodes[i]))
                        break;
                }
                return result;
            }
        }
        if (!node)
            return;
        switch (node.kind) {
            case 112 /* QualifiedName */:
                return child(node.left) || child(node.right);
            case 113 /* TypeParameter */:
                return child(node.name) || child(node.constraint);
            case 114 /* Parameter */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 115 /* Property */:
            case 129 /* PropertyAssignment */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 120 /* CallSignature */:
            case 121 /* ConstructSignature */:
            case 122 /* IndexSignature */:
                return children(node.typeParameters) || children(node.parameters) || child(node.type);
            case 116 /* Method */:
            case 117 /* Constructor */:
            case 118 /* GetAccessor */:
            case 119 /* SetAccessor */:
            case 136 /* FunctionExpression */:
            case 167 /* FunctionDeclaration */:
            case 137 /* ArrowFunction */:
                return child(node.name) || children(node.typeParameters) || children(node.parameters) || child(node.type) || child(node.body);
            case 123 /* TypeReference */:
                return child(node.typeName) || children(node.typeArguments);
            case 124 /* TypeQuery */:
                return child(node.exprName);
            case 125 /* TypeLiteral */:
                return children(node.members);
            case 126 /* ArrayType */:
                return child(node.elementType);
            case 127 /* ArrayLiteral */:
                return children(node.elements);
            case 128 /* ObjectLiteral */:
                return children(node.properties);
            case 130 /* PropertyAccess */:
                return child(node.left) || child(node.right);
            case 131 /* IndexedAccess */:
                return child(node.object) || child(node.index);
            case 132 /* CallExpression */:
            case 133 /* NewExpression */:
                return child(node.func) || children(node.typeArguments) || children(node.arguments);
            case 134 /* TypeAssertion */:
                return child(node.type) || child(node.operand);
            case 135 /* ParenExpression */:
                return child(node.expression);
            case 138 /* PrefixOperator */:
            case 139 /* PostfixOperator */:
                return child(node.operand);
            case 140 /* BinaryExpression */:
                return child(node.left) || child(node.right);
            case 141 /* ConditionalExpression */:
                return child(node.condition) || child(node.whenTrue) || child(node.whenFalse);
            case 143 /* Block */:
            case 162 /* TryBlock */:
            case 164 /* FinallyBlock */:
            case 168 /* FunctionBlock */:
            case 173 /* ModuleBlock */:
            case 177 /* SourceFile */:
                return children(node.statements);
            case 144 /* VariableStatement */:
                return children(node.declarations);
            case 146 /* ExpressionStatement */:
                return child(node.expression);
            case 147 /* IfStatement */:
                return child(node.expression) || child(node.thenStatement) || child(node.elseStatement);
            case 148 /* DoStatement */:
                return child(node.statement) || child(node.expression);
            case 149 /* WhileStatement */:
                return child(node.expression) || child(node.statement);
            case 150 /* ForStatement */:
                return children(node.declarations) || child(node.initializer) || child(node.condition) || child(node.iterator) || child(node.statement);
            case 151 /* ForInStatement */:
                return child(node.declaration) || child(node.variable) || child(node.expression) || child(node.statement);
            case 152 /* ContinueStatement */:
            case 153 /* BreakStatement */:
                return child(node.label);
            case 154 /* ReturnStatement */:
                return child(node.expression);
            case 155 /* WithStatement */:
                return child(node.expression) || child(node.statement);
            case 156 /* SwitchStatement */:
                return child(node.expression) || children(node.clauses);
            case 157 /* CaseClause */:
            case 158 /* DefaultClause */:
                return child(node.expression) || children(node.statements);
            case 159 /* LabelledStatement */:
                return child(node.label) || child(node.statement);
            case 160 /* ThrowStatement */:
                return child(node.expression);
            case 161 /* TryStatement */:
                return child(node.tryBlock) || child(node.catchBlock) || child(node.finallyBlock);
            case 163 /* CatchBlock */:
                return child(node.variable) || children(node.statements);
            case 166 /* VariableDeclaration */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 169 /* ClassDeclaration */:
                return child(node.name) || children(node.typeParameters) || child(node.baseType) || children(node.implementedTypes) || children(node.members);
            case 170 /* InterfaceDeclaration */:
                return child(node.name) || children(node.typeParameters) || children(node.baseTypes) || children(node.members);
            case 171 /* EnumDeclaration */:
                return child(node.name) || children(node.members);
            case 176 /* EnumMember */:
                return child(node.name) || child(node.initializer);
            case 172 /* ModuleDeclaration */:
                return child(node.name) || child(node.body);
            case 174 /* ImportDeclaration */:
                return child(node.name) || child(node.entityName) || child(node.externalModuleName);
            case 175 /* ExportAssignment */:
                return child(node.exportName);
        }
    }
    ts.forEachChild = forEachChild;
    function hasRestParameters(s) {
        return s.parameters.length > 0 && (s.parameters[s.parameters.length - 1].flags & 8 /* Rest */) !== 0;
    }
    ts.hasRestParameters = hasRestParameters;
    function isInAmbientContext(node) {
        while (node) {
            if (node.flags & (2 /* Ambient */ | 512 /* DeclarationFile */))
                return true;
            node = node.parent;
        }
        return false;
    }
    ts.isInAmbientContext = isInAmbientContext;
    var ParsingContext;
    (function (ParsingContext) {
        ParsingContext[ParsingContext["SourceElements"] = 0] = "SourceElements";
        ParsingContext[ParsingContext["ModuleElements"] = 1] = "ModuleElements";
        ParsingContext[ParsingContext["BlockStatements"] = 2] = "BlockStatements";
        ParsingContext[ParsingContext["SwitchClauses"] = 3] = "SwitchClauses";
        ParsingContext[ParsingContext["SwitchClauseStatements"] = 4] = "SwitchClauseStatements";
        ParsingContext[ParsingContext["TypeMembers"] = 5] = "TypeMembers";
        ParsingContext[ParsingContext["ClassMembers"] = 6] = "ClassMembers";
        ParsingContext[ParsingContext["EnumMembers"] = 7] = "EnumMembers";
        ParsingContext[ParsingContext["BaseTypeReferences"] = 8] = "BaseTypeReferences";
        ParsingContext[ParsingContext["VariableDeclarations"] = 9] = "VariableDeclarations";
        ParsingContext[ParsingContext["ArgumentExpressions"] = 10] = "ArgumentExpressions";
        ParsingContext[ParsingContext["ObjectLiteralMembers"] = 11] = "ObjectLiteralMembers";
        ParsingContext[ParsingContext["ArrayLiteralMembers"] = 12] = "ArrayLiteralMembers";
        ParsingContext[ParsingContext["Parameters"] = 13] = "Parameters";
        ParsingContext[ParsingContext["TypeParameters"] = 14] = "TypeParameters";
        ParsingContext[ParsingContext["TypeArguments"] = 15] = "TypeArguments";
        ParsingContext[ParsingContext["Count"] = 16] = "Count"; // Number of parsing contexts
    })(ParsingContext || (ParsingContext = {}));
    var Tristate;
    (function (Tristate) {
        Tristate[Tristate["False"] = 0] = "False";
        Tristate[Tristate["True"] = 1] = "True";
        Tristate[Tristate["Unknown"] = 2] = "Unknown";
    })(Tristate || (Tristate = {}));
    function parsingContextErrors(context) {
        switch (context) {
            case 0 /* SourceElements */:
                return ts.Diagnostics.Declaration_or_statement_expected;
            case 1 /* ModuleElements */:
                return ts.Diagnostics.Declaration_or_statement_expected;
            case 2 /* BlockStatements */:
                return ts.Diagnostics.Statement_expected;
            case 3 /* SwitchClauses */:
                return ts.Diagnostics.case_or_default_expected;
            case 4 /* SwitchClauseStatements */:
                return ts.Diagnostics.Statement_expected;
            case 5 /* TypeMembers */:
                return ts.Diagnostics.Property_or_signature_expected;
            case 6 /* ClassMembers */:
                return ts.Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected;
            case 7 /* EnumMembers */:
                return ts.Diagnostics.Enum_member_expected;
            case 8 /* BaseTypeReferences */:
                return ts.Diagnostics.Type_reference_expected;
            case 9 /* VariableDeclarations */:
                return ts.Diagnostics.Variable_declaration_expected;
            case 10 /* ArgumentExpressions */:
                return ts.Diagnostics.Argument_expression_expected;
            case 11 /* ObjectLiteralMembers */:
                return ts.Diagnostics.Property_assignment_expected;
            case 12 /* ArrayLiteralMembers */:
                return ts.Diagnostics.Expression_or_comma_expected;
            case 13 /* Parameters */:
                return ts.Diagnostics.Parameter_declaration_expected;
            case 14 /* TypeParameters */:
                return ts.Diagnostics.Type_parameter_declaration_expected;
            case 15 /* TypeArguments */:
                return ts.Diagnostics.Type_argument_expected;
        }
    }
    ;
    var LookAheadMode;
    (function (LookAheadMode) {
        LookAheadMode[LookAheadMode["NotLookingAhead"] = 0] = "NotLookingAhead";
        LookAheadMode[LookAheadMode["NoErrorYet"] = 1] = "NoErrorYet";
        LookAheadMode[LookAheadMode["Error"] = 2] = "Error";
    })(LookAheadMode || (LookAheadMode = {}));
    var ModifierContext;
    (function (ModifierContext) {
        ModifierContext[ModifierContext["SourceElements"] = 0] = "SourceElements";
        ModifierContext[ModifierContext["ModuleElements"] = 1] = "ModuleElements";
        ModifierContext[ModifierContext["ClassMembers"] = 2] = "ClassMembers";
        ModifierContext[ModifierContext["Parameters"] = 3] = "Parameters";
    })(ModifierContext || (ModifierContext = {}));
    var TrailingCommaBehavior;
    (function (TrailingCommaBehavior) {
        TrailingCommaBehavior[TrailingCommaBehavior["Disallow"] = 0] = "Disallow";
        TrailingCommaBehavior[TrailingCommaBehavior["Allow"] = 1] = "Allow";
        TrailingCommaBehavior[TrailingCommaBehavior["Preserve"] = 2] = "Preserve";
    })(TrailingCommaBehavior || (TrailingCommaBehavior = {}));
    // Tracks whether we nested (directly or indirectly) in a certain control block.
    // Used for validating break and continue statements.
    var ControlBlockContext;
    (function (ControlBlockContext) {
        ControlBlockContext[ControlBlockContext["NotNested"] = 0] = "NotNested";
        ControlBlockContext[ControlBlockContext["Nested"] = 1] = "Nested";
        ControlBlockContext[ControlBlockContext["CrossingFunctionBoundary"] = 2] = "CrossingFunctionBoundary";
    })(ControlBlockContext || (ControlBlockContext = {}));
    function createSourceFile(filename, sourceText, languageVersion, version, isOpen) {
        if (isOpen === void 0) { isOpen = false; }
        var file;
        var scanner;
        var token;
        var parsingContext;
        var commentRanges;
        var identifiers = {};
        var identifierCount = 0;
        var nodeCount = 0;
        var lineStarts;
        var isInStrictMode = false;
        var lookAheadMode = 0 /* NotLookingAhead */;
        var inAmbientContext = false;
        var inFunctionBody = false;
        var inSwitchStatement = 0 /* NotNested */;
        var inIterationStatement = 0 /* NotNested */;
        // The following is a state machine that tracks what labels are in our current parsing
        // context. So if we are parsing a node that is nested (arbitrarily deeply) in a label,
        // it will be tracked in this data structure. It is used for checking break/continue
        // statements, and checking for duplicate labels.
        var labelledStatementInfo = (function () {
            // These are initialized on demand because labels are rare, so it is usually
            // not even necessary to allocate these.
            var functionBoundarySentinel;
            var currentLabelSet;
            var labelSetStack;
            var isIterationStack;
            function addLabel(label) {
                if (!currentLabelSet) {
                    currentLabelSet = {};
                }
                currentLabelSet[label.text] = true;
            }
            function pushCurrentLabelSet(isIterationStatement) {
                if (!labelSetStack && !isIterationStack) {
                    labelSetStack = [];
                    isIterationStack = [];
                }
                ts.Debug.assert(currentLabelSet !== undefined);
                labelSetStack.push(currentLabelSet);
                isIterationStack.push(isIterationStatement);
                currentLabelSet = undefined;
            }
            function pushFunctionBoundary() {
                if (!functionBoundarySentinel) {
                    functionBoundarySentinel = {};
                    if (!labelSetStack && !isIterationStack) {
                        labelSetStack = [];
                        isIterationStack = [];
                    }
                }
                ts.Debug.assert(currentLabelSet === undefined);
                labelSetStack.push(functionBoundarySentinel);
                // It does not matter what we push here, since we will never ask if a function boundary
                // is an iteration statement
                isIterationStack.push(false);
            }
            function pop() {
                // Assert that we are in a "pushed" state
                ts.Debug.assert(labelSetStack.length && isIterationStack.length && currentLabelSet === undefined);
                labelSetStack.pop();
                isIterationStack.pop();
            }
            function nodeIsNestedInLabel(label, requireIterationStatement, stopAtFunctionBoundary) {
                if (!requireIterationStatement && currentLabelSet && ts.hasProperty(currentLabelSet, label.text)) {
                    return 1 /* Nested */;
                }
                if (!labelSetStack) {
                    return 0 /* NotNested */;
                }
                // We want to start searching for the label at the lowest point in the tree,
                // and climb up from there. So we start at the end of the labelSetStack array.
                var crossedFunctionBoundary = false;
                for (var i = labelSetStack.length - 1; i >= 0; i--) {
                    var labelSet = labelSetStack[i];
                    // Not allowed to cross function boundaries, so stop if we encounter one
                    if (labelSet === functionBoundarySentinel) {
                        if (stopAtFunctionBoundary) {
                            break;
                        }
                        else {
                            crossedFunctionBoundary = true;
                            continue;
                        }
                    }
                    // If we require an iteration statement, only search in the current
                    // statement if it is an iteration statement
                    if (requireIterationStatement && isIterationStack[i] === false) {
                        continue;
                    }
                    if (ts.hasProperty(labelSet, label.text)) {
                        return crossedFunctionBoundary ? 2 /* CrossingFunctionBoundary */ : 1 /* Nested */;
                    }
                }
                // This is a bit of a misnomer. If the caller passed true for stopAtFunctionBoundary,
                // there actually may be an enclosing label across a function boundary, but we will
                // just return NotNested
                return 0 /* NotNested */;
            }
            return {
                addLabel: addLabel,
                pushCurrentLabelSet: pushCurrentLabelSet,
                pushFunctionBoundary: pushFunctionBoundary,
                pop: pop,
                nodeIsNestedInLabel: nodeIsNestedInLabel
            };
        })();
        function getLineAndCharacterlFromSourcePosition(position) {
            if (!lineStarts) {
                lineStarts = ts.getLineStarts(sourceText);
            }
            return ts.getLineAndCharacterOfPosition(lineStarts, position);
        }
        function getPositionFromSourceLineAndCharacter(line, character) {
            if (!lineStarts) {
                lineStarts = ts.getLineStarts(sourceText);
            }
            return ts.getPositionFromLineAndCharacter(lineStarts, line, character);
        }
        function error(message, arg0, arg1, arg2) {
            var start = scanner.getTokenPos();
            var length = scanner.getTextPos() - start;
            errorAtPos(start, length, message, arg0, arg1, arg2);
        }
        // This is just like createDiagnosticForNode except that it uses the current file
        // being parsed instead of the file containing the node. This is because during
        // parse, the nodes do not have parent pointers to get to the file.
        //
        // It is very intentional that we are not checking or changing the lookAheadMode value
        // here. 'grammarErrorOnNode' is called when we are doing extra grammar checks and not
        // when we are doing the actual parsing to determine what the user wrote.  In other
        // words, this function is called once we have already parsed the node, and are just
        // applying some stricter checks on that node.
        function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
            var span = getErrorSpanForNode(node);
            var start = ts.skipTrivia(file.text, span.pos);
            var length = span.end - start;
            file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
        }
        function reportInvalidUseInStrictMode(node) {
            // identifierToString cannot be used here since it uses backreference to 'parent' that is not yet set
            var name = sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);
            grammarErrorOnNode(node, ts.Diagnostics.Invalid_use_of_0_in_strict_mode, name);
        }
        function grammarErrorAtPos(start, length, message, arg0, arg1, arg2) {
            file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
        }
        function errorAtPos(start, length, message, arg0, arg1, arg2) {
            var lastErrorPos = file.syntacticErrors.length ? file.syntacticErrors[file.syntacticErrors.length - 1].start : -1;
            if (start !== lastErrorPos) {
                file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
            }
            if (lookAheadMode === 1 /* NoErrorYet */) {
                lookAheadMode = 2 /* Error */;
            }
        }
        function scanError(message) {
            var pos = scanner.getTextPos();
            errorAtPos(pos, 0, message);
        }
        function onComment(pos, end) {
            if (commentRanges)
                commentRanges.push({ pos: pos, end: end });
        }
        function getNodePos() {
            return scanner.getStartPos();
        }
        function getNodeEnd() {
            return scanner.getStartPos();
        }
        function nextToken() {
            return token = scanner.scan();
        }
        function getTokenPos(pos) {
            return ts.skipTrivia(sourceText, pos);
        }
        function reScanGreaterToken() {
            return token = scanner.reScanGreaterToken();
        }
        function reScanSlashToken() {
            return token = scanner.reScanSlashToken();
        }
        function lookAheadHelper(callback, alwaysResetState) {
            // Keep track of the state we'll need to rollback to if lookahead fails (or if the
            // caller asked us to always reset our state).
            var saveToken = token;
            var saveSyntacticErrorsLength = file.syntacticErrors.length;
            // Keep track of the current look ahead mode (this matters if we have nested
            // speculative parsing).
            var saveLookAheadMode = lookAheadMode;
            // Mark that we're in speculative parsing and then try to parse out whatever code
            // the callback wants.
            lookAheadMode = 1 /* NoErrorYet */;
            var result = callback();
            // If we switched from 1 to to -1 then a parse error occurred during the callback.
            // If that's the case, then we want to act as if we never got any result at all.
            ts.Debug.assert(lookAheadMode === 2 /* Error */ || lookAheadMode === 1 /* NoErrorYet */);
            if (lookAheadMode === 2 /* Error */) {
                result = undefined;
            }
            // Now restore as appropriate.
            lookAheadMode = saveLookAheadMode;
            if (!result || alwaysResetState) {
                token = saveToken;
                file.syntacticErrors.length = saveSyntacticErrorsLength;
            }
            return result;
        }
        function lookAhead(callback) {
            var result;
            scanner.tryScan(function () {
                result = lookAheadHelper(callback, true);
                // Returning false here indicates to the scanner that it should always jump
                // back to where it started.  This makes sense as 'lookahead' acts as if
                // neither the parser nor scanner was affected by the operation.
                //
                // Note: the rewinding of the parser state is already handled in lookAheadHelper
                // (because we passed 'true' for alwaysResetState).
                return false;
            });
            return result;
        }
        function tryParse(callback) {
            return scanner.tryScan(function () { return lookAheadHelper(callback, false); });
        }
        function isIdentifier() {
            return token === 55 /* Identifier */ || (isInStrictMode ? token > ts.SyntaxKind.LastFutureReservedWord : token > ts.SyntaxKind.LastReservedWord);
        }
        function parseExpected(t) {
            if (token === t) {
                nextToken();
                return true;
            }
            error(ts.Diagnostics._0_expected, ts.tokenToString(t));
            return false;
        }
        function parseOptional(t) {
            if (token === t) {
                nextToken();
                return true;
            }
            return false;
        }
        function canParseSemicolon() {
            // If there's a real semicolon, then we can always parse it out.
            if (token === 13 /* SemicolonToken */) {
                return true;
            }
            // We can parse out an optional semicolon in ASI cases in the following cases.
            return token === 6 /* CloseBraceToken */ || token === 1 /* EndOfFileToken */ || scanner.hasPrecedingLineBreak();
        }
        function parseSemicolon() {
            if (canParseSemicolon()) {
                if (token === 13 /* SemicolonToken */) {
                    // consume the semicolon if it was explicitly provided.
                    nextToken();
                }
            }
            else {
                error(ts.Diagnostics._0_expected, ";");
            }
        }
        function createNode(kind, pos) {
            nodeCount++;
            var node = new (nodeConstructors[kind] || (nodeConstructors[kind] = ts.objectAllocator.getNodeConstructor(kind)))();
            if (!(pos >= 0))
                pos = scanner.getStartPos();
            node.pos = pos;
            node.end = pos;
            return node;
        }
        function finishNode(node) {
            node.end = scanner.getStartPos();
            return node;
        }
        function createMissingNode() {
            return createNode(111 /* Missing */);
        }
        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues
        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for
        // each identifier in order to reduce memory consumption.
        function createIdentifier(isIdentifier) {
            identifierCount++;
            if (isIdentifier) {
                var node = createNode(55 /* Identifier */);
                var text = escapeIdentifier(scanner.getTokenValue());
                node.text = ts.hasProperty(identifiers, text) ? identifiers[text] : (identifiers[text] = text);
                nextToken();
                return finishNode(node);
            }
            error(ts.Diagnostics.Identifier_expected);
            return createMissingNode();
        }
        function parseIdentifier() {
            return createIdentifier(isIdentifier());
        }
        function parseIdentifierName() {
            return createIdentifier(token >= 55 /* Identifier */);
        }
        function isPropertyName() {
            return token >= 55 /* Identifier */ || token === 3 /* StringLiteral */ || token === 2 /* NumericLiteral */;
        }
        function parsePropertyName() {
            if (token === 3 /* StringLiteral */ || token === 2 /* NumericLiteral */) {
                return parsePrimaryExpression();
            }
            return parseIdentifierName();
        }
        function isKeyword(token) {
            return ts.SyntaxKind.FirstKeyword <= token && token <= ts.SyntaxKind.LastKeyword;
        }
        function isModifier(token) {
            switch (token) {
                case 98 /* PublicKeyword */:
                case 96 /* PrivateKeyword */:
                case 99 /* StaticKeyword */:
                case 68 /* ExportKeyword */:
                case 104 /* DeclareKeyword */:
                    return true;
            }
            return false;
        }
        function parseContextualModifier(t) {
            return token === t && tryParse(function () {
                nextToken();
                return token === 9 /* OpenBracketToken */ || isPropertyName();
            });
        }
        function parseAnyContextualModifier() {
            return isModifier(token) && tryParse(function () {
                nextToken();
                return token === 9 /* OpenBracketToken */ || isPropertyName();
            });
        }
        // True if positioned at the start of a list element
        function isListElement(kind, inErrorRecovery) {
            switch (kind) {
                case 0 /* SourceElements */:
                case 1 /* ModuleElements */:
                    return isSourceElement(inErrorRecovery);
                case 2 /* BlockStatements */:
                case 4 /* SwitchClauseStatements */:
                    return isStatement(inErrorRecovery);
                case 3 /* SwitchClauses */:
                    return token === 57 /* CaseKeyword */ || token === 63 /* DefaultKeyword */;
                case 5 /* TypeMembers */:
                    return isTypeMember();
                case 6 /* ClassMembers */:
                    return lookAhead(isClassMemberStart);
                case 7 /* EnumMembers */:
                case 11 /* ObjectLiteralMembers */:
                    return isPropertyName();
                case 8 /* BaseTypeReferences */:
                    return isIdentifier() && ((token !== 69 /* ExtendsKeyword */ && token !== 92 /* ImplementsKeyword */) || !lookAhead(function () { return (nextToken(), isIdentifier()); }));
                case 9 /* VariableDeclarations */:
                case 14 /* TypeParameters */:
                    return isIdentifier();
                case 10 /* ArgumentExpressions */:
                    return isExpression();
                case 12 /* ArrayLiteralMembers */:
                    return token === 14 /* CommaToken */ || isExpression();
                case 13 /* Parameters */:
                    return isParameter();
                case 15 /* TypeArguments */:
                    return isType();
            }
            ts.Debug.fail("Non-exhaustive case in 'isListElement'.");
        }
        // True if positioned at a list terminator
        function isListTerminator(kind) {
            if (token === 1 /* EndOfFileToken */) {
                // Being at the end of the file ends all lists.
                return true;
            }
            switch (kind) {
                case 1 /* ModuleElements */:
                case 2 /* BlockStatements */:
                case 3 /* SwitchClauses */:
                case 5 /* TypeMembers */:
                case 6 /* ClassMembers */:
                case 7 /* EnumMembers */:
                case 11 /* ObjectLiteralMembers */:
                    return token === 6 /* CloseBraceToken */;
                case 4 /* SwitchClauseStatements */:
                    return token === 6 /* CloseBraceToken */ || token === 57 /* CaseKeyword */ || token === 63 /* DefaultKeyword */;
                case 8 /* BaseTypeReferences */:
                    return token === 5 /* OpenBraceToken */ || token === 69 /* ExtendsKeyword */ || token === 92 /* ImplementsKeyword */;
                case 9 /* VariableDeclarations */:
                    return isVariableDeclaratorListTerminator();
                case 14 /* TypeParameters */:
                    // Tokens other than '>' are here for better error recovery
                    return token === 16 /* GreaterThanToken */ || token === 7 /* OpenParenToken */ || token === 5 /* OpenBraceToken */ || token === 69 /* ExtendsKeyword */ || token === 92 /* ImplementsKeyword */;
                case 10 /* ArgumentExpressions */:
                    // Tokens other than ')' are here for better error recovery
                    return token === 8 /* CloseParenToken */ || token === 13 /* SemicolonToken */;
                case 12 /* ArrayLiteralMembers */:
                    return token === 10 /* CloseBracketToken */;
                case 13 /* Parameters */:
                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery
                    return token === 8 /* CloseParenToken */ || token === 10 /* CloseBracketToken */ || token === 5 /* OpenBraceToken */;
                case 15 /* TypeArguments */:
                    // Tokens other than '>' are here for better error recovery
                    return token === 16 /* GreaterThanToken */ || token === 7 /* OpenParenToken */;
            }
        }
        function isVariableDeclaratorListTerminator() {
            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done
            // with parsing the list of  variable declarators.
            if (canParseSemicolon()) {
                return true;
            }
            // in the case where we're parsing the variable declarator of a 'for-in' statement, we
            // are done if we see an 'in' keyword in front of us.
            if (token === 76 /* InKeyword */) {
                return true;
            }
            // ERROR RECOVERY TWEAK:
            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an
            // arrow function here and it's going to be very unlikely that we'll resynchronize and get
            // another variable declaration.
            if (token === 23 /* EqualsGreaterThanToken */) {
                return true;
            }
            // Keep trying to parse out variable declarators.
            return false;
        }
        // True if positioned at element or terminator of the current list or any enclosing list
        function isInSomeParsingContext() {
            for (var kind = 0; kind < 16 /* Count */; kind++) {
                if (parsingContext & (1 << kind)) {
                    if (isListElement(kind, true) || isListTerminator(kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        // Parses a list of elements
        function parseList(kind, checkForStrictMode, parseElement) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var result = [];
            result.pos = getNodePos();
            var saveIsInStrictMode = isInStrictMode;
            while (!isListTerminator(kind)) {
                if (isListElement(kind, false)) {
                    var element = parseElement();
                    result.push(element);
                    // test elements only if we are not already in strict mode
                    if (!isInStrictMode && checkForStrictMode) {
                        if (isPrologueDirective(element)) {
                            if (isUseStrictPrologueDirective(element)) {
                                isInStrictMode = true;
                                checkForStrictMode = false;
                            }
                        }
                        else {
                            checkForStrictMode = false;
                        }
                    }
                }
                else {
                    error(parsingContextErrors(kind));
                    if (isInSomeParsingContext()) {
                        break;
                    }
                    nextToken();
                }
            }
            isInStrictMode = saveIsInStrictMode;
            result.end = getNodeEnd();
            parsingContext = saveParsingContext;
            return result;
        }
        // Parses a comma-delimited list of elements
        function parseDelimitedList(kind, parseElement, trailingCommaBehavior) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var result = [];
            result.pos = getNodePos();
            // Keep track of how many errors we had before the list started. If we don't see any new
            // errors resulting from the list being malformed, we are free to complain about a trailing comma.
            var errorCountBeforeParsingList = file.syntacticErrors.length;
            var commaStart = -1; // Meaning the previous token was not a comma
            while (true) {
                if (isListElement(kind, false)) {
                    result.push(parseElement());
                    commaStart = scanner.getTokenPos();
                    if (parseOptional(14 /* CommaToken */)) {
                        continue;
                    }
                    commaStart = -1; // Back to the state where the last token was not a comma
                    if (isListTerminator(kind)) {
                        break;
                    }
                    error(ts.Diagnostics._0_expected, ",");
                }
                else if (isListTerminator(kind)) {
                    // Check if the last token was a comma.
                    if (commaStart >= 0) {
                        if (trailingCommaBehavior === 0 /* Disallow */) {
                            if (file.syntacticErrors.length === errorCountBeforeParsingList) {
                                // Report a grammar error so we don't affect lookahead
                                grammarErrorAtPos(commaStart, scanner.getStartPos() - commaStart, ts.Diagnostics.Trailing_comma_not_allowed);
                            }
                        }
                        else if (trailingCommaBehavior === 2 /* Preserve */) {
                            result.push(createNode(142 /* OmittedExpression */));
                        }
                    }
                    break;
                }
                else {
                    error(parsingContextErrors(kind));
                    if (isInSomeParsingContext()) {
                        break;
                    }
                    nextToken();
                }
            }
            result.end = getNodeEnd();
            parsingContext = saveParsingContext;
            return result;
        }
        function createMissingList() {
            var pos = getNodePos();
            var result = [];
            result.pos = pos;
            result.end = pos;
            return result;
        }
        function createNodeArray(node) {
            var result = [node];
            result.pos = node.pos;
            result.end = node.end;
            return result;
        }
        function parseBracketedList(kind, parseElement, startToken, endToken) {
            if (parseExpected(startToken)) {
                var result = parseDelimitedList(kind, parseElement, 0 /* Disallow */);
                parseExpected(endToken);
                return result;
            }
            return createMissingList();
        }
        // The allowReservedWords parameter controls whether reserved words are permitted after the first dot
        function parseEntityName(allowReservedWords) {
            var entity = parseIdentifier();
            while (parseOptional(11 /* DotToken */)) {
                var node = createNode(112 /* QualifiedName */, entity.pos);
                node.left = entity;
                node.right = allowReservedWords ? parseIdentifierName() : parseIdentifier();
                entity = finishNode(node);
            }
            return entity;
        }
        function parseTokenNode() {
            var node = createNode(token);
            nextToken();
            return finishNode(node);
        }
        function parseLiteralNode() {
            var node = createNode(token);
            node.text = scanner.getTokenValue();
            var tokenPos = scanner.getTokenPos();
            nextToken();
            finishNode(node);
            // Octal literals are not allowed in strict mode or ES5
            // Note that theoretically the following condition would hold true literals like 009,
            // which is not octal.But because of how the scanner separates the tokens, we would
            // never get a token like this.Instead, we would get 00 and 9 as two separate tokens.
            // We also do not need to check for negatives because any prefix operator would be part of a
            // parent unary expression.
            if (node.kind === 2 /* NumericLiteral */ && sourceText.charCodeAt(tokenPos) === 48 /* _0 */ && ts.isOctalDigit(sourceText.charCodeAt(tokenPos + 1))) {
                if (isInStrictMode) {
                    grammarErrorOnNode(node, ts.Diagnostics.Octal_literals_are_not_allowed_in_strict_mode);
                }
                else if (languageVersion >= 1 /* ES5 */) {
                    grammarErrorOnNode(node, ts.Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher);
                }
            }
            return node;
        }
        function parseStringLiteral() {
            if (token === 3 /* StringLiteral */)
                return parseLiteralNode();
            error(ts.Diagnostics.String_literal_expected);
            return createMissingNode();
        }
        // TYPES
        function parseTypeReference() {
            var node = createNode(123 /* TypeReference */);
            node.typeName = parseEntityName(false);
            if (!scanner.hasPrecedingLineBreak() && token === 15 /* LessThanToken */) {
                node.typeArguments = parseTypeArguments();
            }
            return finishNode(node);
        }
        function parseTypeQuery() {
            var node = createNode(124 /* TypeQuery */);
            parseExpected(87 /* TypeOfKeyword */);
            node.exprName = parseEntityName(true);
            return finishNode(node);
        }
        function parseTypeParameter() {
            var node = createNode(113 /* TypeParameter */);
            node.name = parseIdentifier();
            if (parseOptional(69 /* ExtendsKeyword */)) {
                // It's not uncommon for people to write improper constraints to a generic.  If the
                // user writes a constraint that is an expression and not an actual type, then parse
                // it out as an expression (so we can recover well), but report that a type is needed
                // instead.
                if (isType() || !isExpression()) {
                    node.constraint = parseType();
                }
                else {
                    // It was not a type, and it looked like an expression.  Parse out an expression
                    // here so we recover well.  Note: it is important that we call parseUnaryExpression
                    // and not parseExpression here.  If the user has:
                    //
                    //      <T extends "">
                    //
                    // We do *not* want to consume the  >  as we're consuming the expression for "".
                    var expr = parseUnaryExpression();
                    grammarErrorOnNode(expr, ts.Diagnostics.Type_expected);
                }
            }
            return finishNode(node);
        }
        function parseTypeParameters() {
            if (token === 15 /* LessThanToken */) {
                var pos = getNodePos();
                var result = parseBracketedList(14 /* TypeParameters */, parseTypeParameter, 15 /* LessThanToken */, 16 /* GreaterThanToken */);
                if (!result.length) {
                    var start = getTokenPos(pos);
                    var length = getNodePos() - start;
                    errorAtPos(start, length, ts.Diagnostics.Type_parameter_list_cannot_be_empty);
                }
                return result;
            }
        }
        function parseParameterType() {
            return parseOptional(42 /* ColonToken */) ? token === 3 /* StringLiteral */ ? parseStringLiteral() : parseType() : undefined;
        }
        function isParameter() {
            return token === 12 /* DotDotDotToken */ || isIdentifier() || isModifier(token);
        }
        function parseParameter(flags) {
            if (flags === void 0) { flags = 0; }
            var node = createNode(114 /* Parameter */);
            node.flags |= parseAndCheckModifiers(3 /* Parameters */);
            if (parseOptional(12 /* DotDotDotToken */)) {
                node.flags |= 8 /* Rest */;
            }
            node.name = parseIdentifier();
            if (node.name.kind === 111 /* Missing */ && node.flags === 0 && isModifier(token)) {
                // in cases like
                // 'use strict'
                // function foo(static)
                // isParameter('static') === true, because of isModifier('static')
                // however 'static' is not a legal identifier in a strict mode.
                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)
                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)
                // to avoid this we'll advance cursor to the next token.
                nextToken();
            }
            if (parseOptional(41 /* QuestionToken */)) {
                node.flags |= 4 /* QuestionMark */;
            }
            node.type = parseParameterType();
            node.initializer = parseInitializer(true);
            // Do not check for initializers in an ambient context for parameters. This is not
            // a grammar error because the grammar allows arbitrary call signatures in
            // an ambient context.
            // It is actually not necessary for this to be an error at all. The reason is that
            // function/constructor implementations are syntactically disallowed in ambient
            // contexts. In addition, parameter initializers are semantically disallowed in
            // overload signatures. So parameter initializers are transitively disallowed in
            // ambient contexts.
            return finishNode(node);
        }
        function parseSignature(kind, returnToken) {
            if (kind === 121 /* ConstructSignature */) {
                parseExpected(78 /* NewKeyword */);
            }
            var typeParameters = parseTypeParameters();
            var parameters = parseParameterList(7 /* OpenParenToken */, 8 /* CloseParenToken */);
            checkParameterList(parameters);
            var type = parseOptional(returnToken) ? parseType() : undefined;
            return {
                typeParameters: typeParameters,
                parameters: parameters,
                type: type
            };
        }
        // Because we use this for index signatures as well, we sometimes use
        // parentheses, and sometimes use brackets.
        function parseParameterList(startDelimiter, endDelimiter) {
            return parseBracketedList(13 /* Parameters */, parseParameter, startDelimiter, endDelimiter);
        }
        function checkParameterList(parameters) {
            var seenOptionalParameter = false;
            var parameterCount = parameters.length;
            for (var i = 0; i < parameterCount; i++) {
                var parameter = parameters[i];
                // It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
                // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
                // or if its FunctionBody is strict code(11.1.5).
                // It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a
                // strict mode FunctionDeclaration or FunctionExpression(13.1)
                if (isInStrictMode && isEvalOrArgumentsIdentifier(parameter.name)) {
                    reportInvalidUseInStrictMode(parameter.name);
                    return;
                }
                else if (parameter.flags & 8 /* Rest */) {
                    if (i !== (parameterCount - 1)) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                        return;
                    }
                    if (parameter.flags & 4 /* QuestionMark */) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_be_optional);
                        return;
                    }
                    if (parameter.initializer) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                        return;
                    }
                }
                else if (parameter.flags & 4 /* QuestionMark */ || parameter.initializer) {
                    seenOptionalParameter = true;
                    if (parameter.flags & 4 /* QuestionMark */ && parameter.initializer) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                        return;
                    }
                }
                else {
                    if (seenOptionalParameter) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
                        return;
                    }
                }
            }
        }
        function parseSignatureMember(kind, returnToken) {
            var node = createNode(kind);
            var sig = parseSignature(kind, returnToken);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            parseSemicolon();
            return finishNode(node);
        }
        function parseIndexSignatureMember() {
            var node = createNode(122 /* IndexSignature */);
            var errorCountBeforeIndexSignature = file.syntacticErrors.length;
            var indexerStart = scanner.getTokenPos();
            node.parameters = parseParameterList(9 /* OpenBracketToken */, 10 /* CloseBracketToken */);
            var indexerLength = scanner.getStartPos() - indexerStart;
            node.type = parseTypeAnnotation();
            parseSemicolon();
            if (file.syntacticErrors.length === errorCountBeforeIndexSignature) {
                checkIndexSignature(node, indexerStart, indexerLength);
            }
            return finishNode(node);
        }
        function checkIndexSignature(node, indexerStart, indexerLength) {
            var parameter = node.parameters[0];
            if (node.parameters.length !== 1) {
                var arityDiagnostic = ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter;
                if (parameter) {
                    grammarErrorOnNode(parameter.name, arityDiagnostic);
                }
                else {
                    grammarErrorAtPos(indexerStart, indexerLength, arityDiagnostic);
                }
                return;
            }
            else if (parameter.flags & 8 /* Rest */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
                return;
            }
            else if (parameter.flags & ts.NodeFlags.Modifier) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
                return;
            }
            else if (parameter.flags & 4 /* QuestionMark */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
                return;
            }
            else if (parameter.initializer) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
                return;
            }
            else if (!parameter.type) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
                return;
            }
            else if (parameter.type.kind !== 110 /* StringKeyword */ && parameter.type.kind !== 108 /* NumberKeyword */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_must_be_string_or_number);
                return;
            }
            else if (!node.type) {
                grammarErrorAtPos(indexerStart, indexerLength, ts.Diagnostics.An_index_signature_must_have_a_type_annotation);
                return;
            }
        }
        function parsePropertyOrMethod() {
            var node = createNode(0 /* Unknown */);
            node.name = parsePropertyName();
            if (parseOptional(41 /* QuestionToken */)) {
                node.flags |= 4 /* QuestionMark */;
            }
            if (token === 7 /* OpenParenToken */ || token === 15 /* LessThanToken */) {
                node.kind = 116 /* Method */;
                var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
                node.typeParameters = sig.typeParameters;
                node.parameters = sig.parameters;
                node.type = sig.type;
            }
            else {
                node.kind = 115 /* Property */;
                node.type = parseTypeAnnotation();
            }
            parseSemicolon();
            return finishNode(node);
        }
        function isTypeMember() {
            switch (token) {
                case 7 /* OpenParenToken */:
                case 15 /* LessThanToken */:
                case 9 /* OpenBracketToken */:
                    return true;
                default:
                    return isPropertyName() && lookAhead(function () { return nextToken() === 7 /* OpenParenToken */ || token === 15 /* LessThanToken */ || token === 41 /* QuestionToken */ || token === 42 /* ColonToken */ || canParseSemicolon(); });
            }
        }
        function parseTypeMember() {
            switch (token) {
                case 7 /* OpenParenToken */:
                case 15 /* LessThanToken */:
                    return parseSignatureMember(120 /* CallSignature */, 42 /* ColonToken */);
                case 9 /* OpenBracketToken */:
                    return parseIndexSignatureMember();
                case 78 /* NewKeyword */:
                    if (lookAhead(function () { return nextToken() === 7 /* OpenParenToken */ || token === 15 /* LessThanToken */; })) {
                        return parseSignatureMember(121 /* ConstructSignature */, 42 /* ColonToken */);
                    }
                case 3 /* StringLiteral */:
                case 2 /* NumericLiteral */:
                    return parsePropertyOrMethod();
                default:
                    if (token >= 55 /* Identifier */) {
                        return parsePropertyOrMethod();
                    }
            }
        }
        function parseTypeLiteral() {
            var node = createNode(125 /* TypeLiteral */);
            if (parseExpected(5 /* OpenBraceToken */)) {
                node.members = parseList(5 /* TypeMembers */, false, parseTypeMember);
                parseExpected(6 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            return finishNode(node);
        }
        function parseFunctionType(signatureKind) {
            var node = createNode(125 /* TypeLiteral */);
            var member = createNode(signatureKind);
            var sig = parseSignature(signatureKind, 23 /* EqualsGreaterThanToken */);
            member.typeParameters = sig.typeParameters;
            member.parameters = sig.parameters;
            member.type = sig.type;
            finishNode(member);
            node.members = createNodeArray(member);
            return finishNode(node);
        }
        function parseKeywordAndNoDot() {
            var node = parseTokenNode();
            return token === 11 /* DotToken */ ? undefined : node;
        }
        function parseNonArrayType() {
            switch (token) {
                case 101 /* AnyKeyword */:
                case 110 /* StringKeyword */:
                case 108 /* NumberKeyword */:
                case 102 /* BooleanKeyword */:
                case 89 /* VoidKeyword */:
                    var node = tryParse(parseKeywordAndNoDot);
                    return node || parseTypeReference();
                case 87 /* TypeOfKeyword */:
                    return parseTypeQuery();
                case 5 /* OpenBraceToken */:
                    return parseTypeLiteral();
                case 7 /* OpenParenToken */:
                case 15 /* LessThanToken */:
                    return parseFunctionType(120 /* CallSignature */);
                case 78 /* NewKeyword */:
                    return parseFunctionType(121 /* ConstructSignature */);
                default:
                    if (isIdentifier()) {
                        return parseTypeReference();
                    }
            }
            error(ts.Diagnostics.Type_expected);
            return createMissingNode();
        }
        function isType() {
            switch (token) {
                case 101 /* AnyKeyword */:
                case 110 /* StringKeyword */:
                case 108 /* NumberKeyword */:
                case 102 /* BooleanKeyword */:
                case 89 /* VoidKeyword */:
                case 87 /* TypeOfKeyword */:
                case 5 /* OpenBraceToken */:
                case 15 /* LessThanToken */:
                case 78 /* NewKeyword */:
                    return true;
                case 7 /* OpenParenToken */:
                    // Only consider an ( as the start of a type if we have  ()  or  (id
                    // We don't want to consider things like  (1)  as a function type.
                    return lookAhead(function () {
                        nextToken();
                        return token === 8 /* CloseParenToken */ || isParameter();
                    });
                default:
                    return isIdentifier();
            }
        }
        function parseType() {
            var type = parseNonArrayType();
            while (type && !scanner.hasPrecedingLineBreak() && parseOptional(9 /* OpenBracketToken */)) {
                parseExpected(10 /* CloseBracketToken */);
                var node = createNode(126 /* ArrayType */, type.pos);
                node.elementType = type;
                type = finishNode(node);
            }
            return type;
        }
        function parseTypeAnnotation() {
            return parseOptional(42 /* ColonToken */) ? parseType() : undefined;
        }
        // EXPRESSIONS
        function isExpression() {
            switch (token) {
                case 83 /* ThisKeyword */:
                case 81 /* SuperKeyword */:
                case 79 /* NullKeyword */:
                case 85 /* TrueKeyword */:
                case 70 /* FalseKeyword */:
                case 2 /* NumericLiteral */:
                case 3 /* StringLiteral */:
                case 7 /* OpenParenToken */:
                case 9 /* OpenBracketToken */:
                case 5 /* OpenBraceToken */:
                case 73 /* FunctionKeyword */:
                case 78 /* NewKeyword */:
                case 27 /* SlashToken */:
                case 47 /* SlashEqualsToken */:
                case 24 /* PlusToken */:
                case 25 /* MinusToken */:
                case 38 /* TildeToken */:
                case 37 /* ExclamationToken */:
                case 64 /* DeleteKeyword */:
                case 87 /* TypeOfKeyword */:
                case 89 /* VoidKeyword */:
                case 29 /* PlusPlusToken */:
                case 30 /* MinusMinusToken */:
                case 15 /* LessThanToken */:
                case 55 /* Identifier */:
                    return true;
                default:
                    return isIdentifier();
            }
        }
        function isExpressionStatement() {
            // As per the grammar, neither '{' nor 'function' can start an expression statement.
            return token !== 5 /* OpenBraceToken */ && token !== 73 /* FunctionKeyword */ && isExpression();
        }
        function parseExpression(noIn) {
            var expr = parseAssignmentExpression(noIn);
            while (parseOptional(14 /* CommaToken */)) {
                expr = makeBinaryExpression(expr, 14 /* CommaToken */, parseAssignmentExpression(noIn));
            }
            return expr;
        }
        function parseInitializer(inParameter, noIn) {
            if (token !== 43 /* EqualsToken */) {
                // It's not uncommon during typing for the user to miss writing the '=' token.  Check if
                // there is no newline after the last token and if we're on an expression.  If so, parse
                // this as an equals-value clause with a missing equals.
                // NOTE: There are two places where we allow equals-value clauses.  The first is in a
                // variable declarator.  The second is with a parameter.  For variable declarators
                // it's more likely that a { would be a allowed (as an object literal).  While this
                // is also allowed for parameters, the risk is that we consume the { as an object
                // literal when it really will be for the block following the parameter.
                if (scanner.hasPrecedingLineBreak() || (inParameter && token === 5 /* OpenBraceToken */) || !isExpression()) {
                    // preceding line break, open brace in a parameter (likely a function body) or current token is not an expression -
                    // do not try to parse initializer
                    return undefined;
                }
            }
            parseExpected(43 /* EqualsToken */);
            return parseAssignmentExpression(noIn);
        }
        function parseAssignmentExpression(noIn) {
            // Augmented by TypeScript:
            //
            //  AssignmentExpression[in]:
            //      1) ConditionalExpression[in]
            //      2) LeftHandSideExpression = AssignmentExpression[in]
            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[in]
            //      4) ArrowFunctionExpression <-- added by TypeScript
            //
            // Note: for ease of implementation we treat productions '2' and '3' as the same thing.
            // (i.e. they're both BinaryExpressions with an assignment operator in it).
            // First, check if we have an arrow function (production '4') that starts with a parenthesized
            // parameter list. If we do, we must *not* recurse for productsion 1, 2 or 3. An ArrowFunction is
            // not a  LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done
            // with AssignmentExpression if we see one.
            var arrowExpression = tryParseParenthesizedArrowFunctionExpression();
            if (arrowExpression) {
                return arrowExpression;
            }
            // Now try to handle the rest of the cases.  First, see if we can parse out up to and
            // including a conditional expression.
            var expr = parseConditionalExpression(noIn);
            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized
            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single
            // identifier and the current token is an arrow.
            if (expr.kind === 55 /* Identifier */ && token === 23 /* EqualsGreaterThanToken */) {
                return parseSimpleArrowFunctionExpression(expr);
            }
            // Now see if we might be in cases '2' or '3'.
            // If the expression was a LHS expression, and we  have an assignment operator, then
            // we're in '2' or '3'.  Consume the assignment and return.
            if (isLeftHandSideExpression(expr) && isAssignmentOperator()) {
                if (isInStrictMode && isEvalOrArgumentsIdentifier(expr)) {
                    // ECMA 262 (Annex C) The identifier eval or arguments may not appear as the LeftHandSideExpression of an
                    // Assignment operator(11.13) or of a PostfixExpression(11.3)
                    reportInvalidUseInStrictMode(expr);
                }
                var operator = token;
                nextToken();
                return makeBinaryExpression(expr, operator, parseAssignmentExpression(noIn));
            }
            // otherwise this was production '1'.  Return whatever we parsed so far.
            return expr;
        }
        function isLeftHandSideExpression(expr) {
            if (expr) {
                switch (expr.kind) {
                    case 130 /* PropertyAccess */:
                    case 131 /* IndexedAccess */:
                    case 133 /* NewExpression */:
                    case 132 /* CallExpression */:
                    case 127 /* ArrayLiteral */:
                    case 135 /* ParenExpression */:
                    case 128 /* ObjectLiteral */:
                    case 136 /* FunctionExpression */:
                    case 55 /* Identifier */:
                    case 111 /* Missing */:
                    case 4 /* RegularExpressionLiteral */:
                    case 2 /* NumericLiteral */:
                    case 3 /* StringLiteral */:
                    case 70 /* FalseKeyword */:
                    case 79 /* NullKeyword */:
                    case 83 /* ThisKeyword */:
                    case 85 /* TrueKeyword */:
                    case 81 /* SuperKeyword */:
                        return true;
                }
            }
            return false;
        }
        function parseSimpleArrowFunctionExpression(identifier) {
            ts.Debug.assert(token === 23 /* EqualsGreaterThanToken */, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
            parseExpected(23 /* EqualsGreaterThanToken */);
            var parameter = createNode(114 /* Parameter */, identifier.pos);
            parameter.name = identifier;
            finishNode(parameter);
            var parameters = [];
            parameters.push(parameter);
            parameters.pos = parameter.pos;
            parameters.end = parameter.end;
            var signature = { parameters: parameters };
            return parseArrowExpressionTail(identifier.pos, signature, false);
        }
        function tryParseParenthesizedArrowFunctionExpression() {
            // Indicates whether we are certain that we should parse an arrow expression.
            var triState = isParenthesizedArrowFunctionExpression();
            if (triState === 0 /* False */) {
                return undefined;
            }
            var pos = getNodePos();
            if (triState === 1 /* True */) {
                var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
                // If we have an arrow, then try to parse the body.
                // Even if not, try to parse if we have an opening brace, just in case we're in an error state.
                if (parseExpected(23 /* EqualsGreaterThanToken */) || token === 5 /* OpenBraceToken */) {
                    return parseArrowExpressionTail(pos, sig, false);
                }
                else {
                    // If not, we're probably better off bailing out and returning a bogus function expression.
                    return makeFunctionExpression(137 /* ArrowFunction */, pos, undefined, sig, createMissingNode());
                }
            }
            // *Maybe* we had an arrow function and we need to try to parse it out,
            // rolling back and trying other parses if we fail.
            var sig = tryParseSignatureIfArrowOrBraceFollows();
            if (sig) {
                parseExpected(23 /* EqualsGreaterThanToken */);
                return parseArrowExpressionTail(pos, sig, false);
            }
            else {
                return undefined;
            }
        }
        //  True        -> We definitely expect a parenthesized arrow function here.
        //  False       -> There *cannot* be a parenthesized arrow function here.
        //  Unknown     -> There *might* be a parenthesized arrow function here.
        //                 Speculatively look ahead to be sure, and rollback if not.
        function isParenthesizedArrowFunctionExpression() {
            if (token === 7 /* OpenParenToken */ || token === 15 /* LessThanToken */) {
                return lookAhead(function () {
                    var first = token;
                    var second = nextToken();
                    if (first === 7 /* OpenParenToken */) {
                        if (second === 8 /* CloseParenToken */) {
                            // Simple cases: "() =>", "(): ", and  "() {".
                            // This is an arrow function with no parameters.
                            // The last one is not actually an arrow function,
                            // but this is probably what the user intended.
                            var third = nextToken();
                            switch (third) {
                                case 23 /* EqualsGreaterThanToken */:
                                case 42 /* ColonToken */:
                                case 5 /* OpenBraceToken */:
                                    return 1 /* True */;
                                default:
                                    return 0 /* False */;
                            }
                        }
                        // Simple case: "(..."
                        // This is an arrow function with a rest parameter.
                        if (second === 12 /* DotDotDotToken */) {
                            return 1 /* True */;
                        }
                        // If we had "(" followed by something that's not an identifier,
                        // then this definitely doesn't look like a lambda.
                        // Note: we could be a little more lenient and allow
                        // "(public" or "(private". These would not ever actually be allowed,
                        // but we could provide a good error message instead of bailing out.
                        if (!isIdentifier()) {
                            return 0 /* False */;
                        }
                        // If we have something like "(a:", then we must have a
                        // type-annotated parameter in an arrow function expression.
                        if (nextToken() === 42 /* ColonToken */) {
                            return 1 /* True */;
                        }
                        // This *could* be a parenthesized arrow function.
                        // Return Unknown to let the caller know.
                        return 2 /* Unknown */;
                    }
                    else {
                        ts.Debug.assert(first === 15 /* LessThanToken */);
                        // If we have "<" not followed by an identifier,
                        // then this definitely is not an arrow function.
                        if (!isIdentifier()) {
                            return 0 /* False */;
                        }
                        // This *could* be a parenthesized arrow function.
                        return 2 /* Unknown */;
                    }
                });
            }
            if (token === 23 /* EqualsGreaterThanToken */) {
                // ERROR RECOVERY TWEAK:
                // If we see a standalone => try to parse it as an arrow function expression as that's
                // likely whatthe user intended to write.
                return 1 /* True */;
            }
            // Definitely not a parenthesized arrow function.
            return 0 /* False */;
        }
        function tryParseSignatureIfArrowOrBraceFollows() {
            return tryParse(function () {
                var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
                // Parsing a signature isn't enough.
                // Parenthesized arrow signatures often look like other valid expressions.
                // For instance:
                //  - "(x = 10)" is an assignment expression parsed as a signature with a default parameter value.
                //  - "(x,y)" is a comma expression parsed as a signature with two parameters.
                //  - "a ? (b): c" will have "(b):" parsed as a signature with a return type annotation.
                //
                // So we need just a bit of lookahead to ensure that it can only be a signature.
                if (token === 23 /* EqualsGreaterThanToken */ || token === 5 /* OpenBraceToken */) {
                    return sig;
                }
                return undefined;
            });
        }
        function parseArrowExpressionTail(pos, sig, noIn) {
            var body;
            if (token === 5 /* OpenBraceToken */) {
                body = parseBody(false);
            }
            else if (isStatement(true) && !isExpressionStatement() && token !== 73 /* FunctionKeyword */) {
                // Check if we got a plain statement (i.e. no expression-statements, no functions expressions/declarations)
                //
                // Here we try to recover from a potential error situation in the case where the
                // user meant to supply a block. For example, if the user wrote:
                //
                //  a =>
                //      var v = 0;
                //  }
                //
                // they may be missing an open brace.  Check to see if that's the case so we can
                // try to recover better.  If we don't do this, then the next close curly we see may end
                // up preemptively closing the containing construct.
                //
                // Note: even when 'ignoreMissingOpenBrace' is passed as true, parseBody will still error.
                body = parseBody(true);
            }
            else {
                body = parseAssignmentExpression(noIn);
            }
            return makeFunctionExpression(137 /* ArrowFunction */, pos, undefined, sig, body);
        }
        function isAssignmentOperator() {
            return token >= ts.SyntaxKind.FirstAssignment && token <= ts.SyntaxKind.LastAssignment;
        }
        function parseConditionalExpression(noIn) {
            var expr = parseBinaryExpression(noIn);
            while (parseOptional(41 /* QuestionToken */)) {
                var node = createNode(141 /* ConditionalExpression */, expr.pos);
                node.condition = expr;
                node.whenTrue = parseAssignmentExpression(false);
                parseExpected(42 /* ColonToken */);
                node.whenFalse = parseAssignmentExpression(noIn);
                expr = finishNode(node);
            }
            return expr;
        }
        function parseBinaryExpression(noIn) {
            return parseBinaryOperators(parseUnaryExpression(), 0, noIn);
        }
        function parseBinaryOperators(expr, minPrecedence, noIn) {
            while (true) {
                reScanGreaterToken();
                var precedence = getOperatorPrecedence();
                if (precedence && precedence > minPrecedence && (!noIn || token !== 76 /* InKeyword */)) {
                    var operator = token;
                    nextToken();
                    expr = makeBinaryExpression(expr, operator, parseBinaryOperators(parseUnaryExpression(), precedence, noIn));
                    continue;
                }
                return expr;
            }
        }
        function getOperatorPrecedence() {
            switch (token) {
                case 40 /* BarBarToken */:
                    return 1;
                case 39 /* AmpersandAmpersandToken */:
                    return 2;
                case 35 /* BarToken */:
                    return 3;
                case 36 /* CaretToken */:
                    return 4;
                case 34 /* AmpersandToken */:
                    return 5;
                case 19 /* EqualsEqualsToken */:
                case 20 /* ExclamationEqualsToken */:
                case 21 /* EqualsEqualsEqualsToken */:
                case 22 /* ExclamationEqualsEqualsToken */:
                    return 6;
                case 15 /* LessThanToken */:
                case 16 /* GreaterThanToken */:
                case 17 /* LessThanEqualsToken */:
                case 18 /* GreaterThanEqualsToken */:
                case 77 /* InstanceOfKeyword */:
                case 76 /* InKeyword */:
                    return 7;
                case 31 /* LessThanLessThanToken */:
                case 32 /* GreaterThanGreaterThanToken */:
                case 33 /* GreaterThanGreaterThanGreaterThanToken */:
                    return 8;
                case 24 /* PlusToken */:
                case 25 /* MinusToken */:
                    return 9;
                case 26 /* AsteriskToken */:
                case 27 /* SlashToken */:
                case 28 /* PercentToken */:
                    return 10;
            }
            return undefined;
        }
        function makeBinaryExpression(left, operator, right) {
            var node = createNode(140 /* BinaryExpression */, left.pos);
            node.left = left;
            node.operator = operator;
            node.right = right;
            return finishNode(node);
        }
        function parseUnaryExpression() {
            var pos = getNodePos();
            switch (token) {
                case 24 /* PlusToken */:
                case 25 /* MinusToken */:
                case 38 /* TildeToken */:
                case 37 /* ExclamationToken */:
                case 64 /* DeleteKeyword */:
                case 87 /* TypeOfKeyword */:
                case 89 /* VoidKeyword */:
                case 29 /* PlusPlusToken */:
                case 30 /* MinusMinusToken */:
                    var operator = token;
                    nextToken();
                    var operand = parseUnaryExpression();
                    if (isInStrictMode) {
                        // The identifier eval or arguments may not appear as the LeftHandSideExpression of an
                        // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression
                        // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator
                        if ((token === 29 /* PlusPlusToken */ || token === 30 /* MinusMinusToken */) && isEvalOrArgumentsIdentifier(operand)) {
                            reportInvalidUseInStrictMode(operand);
                        }
                        else if (token === 64 /* DeleteKeyword */ && operand.kind === 55 /* Identifier */) {
                            // When a delete operator occurs within strict mode code, a SyntaxError is thrown if its
                            // UnaryExpression is a direct reference to a variable, function argument, or function name
                            grammarErrorOnNode(operand, ts.Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode);
                        }
                    }
                    return makeUnaryExpression(138 /* PrefixOperator */, pos, operator, operand);
                case 15 /* LessThanToken */:
                    return parseTypeAssertion();
            }
            var primaryExpression = parsePrimaryExpression();
            // TS 1.0 spec (2014): 4.8
            // CallExpression:  ( Modified )
            //  super   (   ArgumentListopt   )
            //  super   .   IdentifierName
            var illegalUsageOfSuperKeyword = primaryExpression.kind === 81 /* SuperKeyword */ && token !== 7 /* OpenParenToken */ && token !== 11 /* DotToken */;
            if (illegalUsageOfSuperKeyword) {
                error(ts.Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);
            }
            var expr = parseCallAndAccess(primaryExpression, false);
            ts.Debug.assert(isLeftHandSideExpression(expr));
            if ((token === 29 /* PlusPlusToken */ || token === 30 /* MinusMinusToken */) && !scanner.hasPrecedingLineBreak()) {
                // The identifier eval or arguments may not appear as the LeftHandSideExpression of an
                // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression
                // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator.
                if (isInStrictMode && isEvalOrArgumentsIdentifier(expr)) {
                    reportInvalidUseInStrictMode(expr);
                }
                var operator = token;
                nextToken();
                expr = makeUnaryExpression(139 /* PostfixOperator */, expr.pos, operator, expr);
            }
            return expr;
        }
        function parseTypeAssertion() {
            var node = createNode(134 /* TypeAssertion */);
            parseExpected(15 /* LessThanToken */);
            node.type = parseType();
            parseExpected(16 /* GreaterThanToken */);
            node.operand = parseUnaryExpression();
            return finishNode(node);
        }
        function makeUnaryExpression(kind, pos, operator, operand) {
            var node = createNode(kind, pos);
            node.operator = operator;
            node.operand = operand;
            return finishNode(node);
        }
        function parseCallAndAccess(expr, inNewExpression) {
            while (true) {
                if (parseOptional(11 /* DotToken */)) {
                    var propertyAccess = createNode(130 /* PropertyAccess */, expr.pos);
                    propertyAccess.left = expr;
                    propertyAccess.right = parseIdentifierName();
                    expr = finishNode(propertyAccess);
                    continue;
                }
                var bracketStart = scanner.getTokenPos();
                if (parseOptional(9 /* OpenBracketToken */)) {
                    var indexedAccess = createNode(131 /* IndexedAccess */, expr.pos);
                    indexedAccess.object = expr;
                    // It's not uncommon for a user to write: "new Type[]".
                    // Check for that common pattern and report a better error message.
                    if (inNewExpression && parseOptional(10 /* CloseBracketToken */)) {
                        indexedAccess.index = createMissingNode();
                        grammarErrorAtPos(bracketStart, scanner.getStartPos() - bracketStart, ts.Diagnostics.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);
                    }
                    else {
                        indexedAccess.index = parseExpression();
                        parseExpected(10 /* CloseBracketToken */);
                    }
                    expr = finishNode(indexedAccess);
                    continue;
                }
                // Try to parse a Call Expression unless we are in a New Expression.
                // If we are parsing a New Expression, then parentheses are optional,
                // and is taken care of by the 'parseNewExpression' caller.
                if ((token === 7 /* OpenParenToken */ || token === 15 /* LessThanToken */) && !inNewExpression) {
                    var callExpr = createNode(132 /* CallExpression */, expr.pos);
                    callExpr.func = expr;
                    if (token === 15 /* LessThanToken */) {
                        if (!(callExpr.typeArguments = tryParse(parseTypeArgumentsAndOpenParen)))
                            return expr;
                    }
                    else {
                        parseExpected(7 /* OpenParenToken */);
                    }
                    callExpr.arguments = parseDelimitedList(10 /* ArgumentExpressions */, parseAssignmentExpression, 0 /* Disallow */);
                    parseExpected(8 /* CloseParenToken */);
                    expr = finishNode(callExpr);
                    continue;
                }
                return expr;
            }
        }
        function parseTypeArgumentsAndOpenParen() {
            var result = parseTypeArguments();
            parseExpected(7 /* OpenParenToken */);
            return result;
        }
        function parseTypeArguments() {
            var typeArgumentListStart = scanner.getTokenPos();
            var errorCountBeforeTypeParameterList = file.syntacticErrors.length;
            var result = parseBracketedList(15 /* TypeArguments */, parseType, 15 /* LessThanToken */, 16 /* GreaterThanToken */);
            if (!result.length && file.syntacticErrors.length === errorCountBeforeTypeParameterList) {
                grammarErrorAtPos(typeArgumentListStart, scanner.getStartPos() - typeArgumentListStart, ts.Diagnostics.Type_argument_list_cannot_be_empty);
            }
            return result;
        }
        function parsePrimaryExpression() {
            switch (token) {
                case 83 /* ThisKeyword */:
                case 81 /* SuperKeyword */:
                case 79 /* NullKeyword */:
                case 85 /* TrueKeyword */:
                case 70 /* FalseKeyword */:
                    return parseTokenNode();
                case 2 /* NumericLiteral */:
                case 3 /* StringLiteral */:
                    return parseLiteralNode();
                case 7 /* OpenParenToken */:
                    return parseParenExpression();
                case 9 /* OpenBracketToken */:
                    return parseArrayLiteral();
                case 5 /* OpenBraceToken */:
                    return parseObjectLiteral();
                case 73 /* FunctionKeyword */:
                    return parseFunctionExpression();
                case 78 /* NewKeyword */:
                    return parseNewExpression();
                case 27 /* SlashToken */:
                case 47 /* SlashEqualsToken */:
                    if (reScanSlashToken() === 4 /* RegularExpressionLiteral */) {
                        return parseLiteralNode();
                    }
                    break;
                default:
                    if (isIdentifier()) {
                        return parseIdentifier();
                    }
            }
            error(ts.Diagnostics.Expression_expected);
            return createMissingNode();
        }
        function parseParenExpression() {
            var node = createNode(135 /* ParenExpression */);
            parseExpected(7 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(8 /* CloseParenToken */);
            return finishNode(node);
        }
        function parseArrayLiteralElement() {
            return token === 14 /* CommaToken */ ? createNode(142 /* OmittedExpression */) : parseAssignmentExpression();
        }
        function parseArrayLiteral() {
            var node = createNode(127 /* ArrayLiteral */);
            parseExpected(9 /* OpenBracketToken */);
            if (scanner.hasPrecedingLineBreak())
                node.flags |= 128 /* MultiLine */;
            node.elements = parseDelimitedList(12 /* ArrayLiteralMembers */, parseArrayLiteralElement, 2 /* Preserve */);
            parseExpected(10 /* CloseBracketToken */);
            return finishNode(node);
        }
        function parsePropertyAssignment() {
            var node = createNode(129 /* PropertyAssignment */);
            node.name = parsePropertyName();
            if (token === 7 /* OpenParenToken */ || token === 15 /* LessThanToken */) {
                var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
                var body = parseBody(false);
                // do not propagate property name as name for function expression
                // for scenarios like
                // var x = 1;
                // var y = { x() { } }
                // otherwise this will bring y.x into the scope of x which is incorrect
                node.initializer = makeFunctionExpression(136 /* FunctionExpression */, node.pos, undefined, sig, body);
            }
            else {
                parseExpected(42 /* ColonToken */);
                node.initializer = parseAssignmentExpression(false);
            }
            return finishNode(node);
        }
        function parseObjectLiteralMember() {
            var initialPos = getNodePos();
            var initialToken = token;
            if (parseContextualModifier(105 /* GetKeyword */) || parseContextualModifier(109 /* SetKeyword */)) {
                var kind = initialToken === 105 /* GetKeyword */ ? 118 /* GetAccessor */ : 119 /* SetAccessor */;
                return parseAndCheckMemberAccessorDeclaration(kind, initialPos, 0);
            }
            return parsePropertyAssignment();
        }
        function parseObjectLiteral() {
            var node = createNode(128 /* ObjectLiteral */);
            parseExpected(5 /* OpenBraceToken */);
            if (scanner.hasPrecedingLineBreak()) {
                node.flags |= 128 /* MultiLine */;
            }
            // ES3 itself does not accept a trailing comma in an object literal, however, we'd like to preserve it in ES5.
            var trailingCommaBehavior = languageVersion === 0 /* ES3 */ ? 1 /* Allow */ : 2 /* Preserve */;
            node.properties = parseDelimitedList(11 /* ObjectLiteralMembers */, parseObjectLiteralMember, trailingCommaBehavior);
            parseExpected(6 /* CloseBraceToken */);
            var seen = {};
            var Property = 1;
            var GetAccessor = 2;
            var SetAccesor = 4;
            var GetOrSetAccessor = GetAccessor | SetAccesor;
            ts.forEach(node.properties, function (p) {
                if (p.kind === 142 /* OmittedExpression */) {
                    return;
                }
                // ECMA-262 11.1.5 Object Initialiser
                // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
                // a.This production is contained in strict code and IsDataDescriptor(previous) is true and
                // IsDataDescriptor(propId.descriptor) is true.
                //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
                //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
                //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true
                // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields
                var currentKind;
                if (p.kind === 129 /* PropertyAssignment */) {
                    currentKind = Property;
                }
                else if (p.kind === 118 /* GetAccessor */) {
                    currentKind = GetAccessor;
                }
                else if (p.kind === 119 /* SetAccessor */) {
                    currentKind = SetAccesor;
                }
                else {
                    ts.Debug.fail("Unexpected syntax kind:" + ts.SyntaxKind[p.kind]);
                }
                if (!ts.hasProperty(seen, p.name.text)) {
                    seen[p.name.text] = currentKind;
                }
                else {
                    var existingKind = seen[p.name.text];
                    if (currentKind === Property && existingKind === Property) {
                        if (isInStrictMode) {
                            grammarErrorOnNode(p.name, ts.Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode);
                        }
                    }
                    else if ((currentKind & GetOrSetAccessor) && (existingKind & GetOrSetAccessor)) {
                        if (existingKind !== GetOrSetAccessor && currentKind !== existingKind) {
                            seen[p.name.text] = currentKind | existingKind;
                        }
                        else {
                            grammarErrorOnNode(p.name, ts.Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                        }
                    }
                    else {
                        grammarErrorOnNode(p.name, ts.Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                    }
                }
            });
            return finishNode(node);
        }
        function parseFunctionExpression() {
            var pos = getNodePos();
            parseExpected(73 /* FunctionKeyword */);
            var name = isIdentifier() ? parseIdentifier() : undefined;
            var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
            var body = parseBody(false);
            if (name && isInStrictMode && isEvalOrArgumentsIdentifier(name)) {
                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the
                // Identifier of a FunctionDeclaration or FunctionExpression or as a formal parameter name(13.1)
                reportInvalidUseInStrictMode(name);
            }
            return makeFunctionExpression(136 /* FunctionExpression */, pos, name, sig, body);
        }
        function makeFunctionExpression(kind, pos, name, sig, body) {
            var node = createNode(kind, pos);
            node.name = name;
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = body;
            return finishNode(node);
        }
        function parseNewExpression() {
            var node = createNode(133 /* NewExpression */);
            parseExpected(78 /* NewKeyword */);
            node.func = parseCallAndAccess(parsePrimaryExpression(), true);
            if (parseOptional(7 /* OpenParenToken */) || token === 15 /* LessThanToken */ && (node.typeArguments = tryParse(parseTypeArgumentsAndOpenParen))) {
                node.arguments = parseDelimitedList(10 /* ArgumentExpressions */, parseAssignmentExpression, 0 /* Disallow */);
                parseExpected(8 /* CloseParenToken */);
            }
            return finishNode(node);
        }
        // STATEMENTS
        function parseBlock(ignoreMissingOpenBrace, checkForStrictMode) {
            var node = createNode(143 /* Block */);
            if (parseExpected(5 /* OpenBraceToken */) || ignoreMissingOpenBrace) {
                node.statements = parseList(2 /* BlockStatements */, checkForStrictMode, parseStatement);
                parseExpected(6 /* CloseBraceToken */);
            }
            else {
                node.statements = createMissingList();
            }
            return finishNode(node);
        }
        function parseBody(ignoreMissingOpenBrace) {
            var saveInFunctionBody = inFunctionBody;
            var saveInSwitchStatement = inSwitchStatement;
            var saveInIterationStatement = inIterationStatement;
            inFunctionBody = true;
            if (inSwitchStatement === 1 /* Nested */) {
                inSwitchStatement = 2 /* CrossingFunctionBoundary */;
            }
            if (inIterationStatement === 1 /* Nested */) {
                inIterationStatement = 2 /* CrossingFunctionBoundary */;
            }
            labelledStatementInfo.pushFunctionBoundary();
            var block = parseBlock(ignoreMissingOpenBrace, true);
            block.kind = 168 /* FunctionBlock */;
            labelledStatementInfo.pop();
            inFunctionBody = saveInFunctionBody;
            inSwitchStatement = saveInSwitchStatement;
            inIterationStatement = saveInIterationStatement;
            return block;
        }
        function parseEmptyStatement() {
            var node = createNode(145 /* EmptyStatement */);
            parseExpected(13 /* SemicolonToken */);
            return finishNode(node);
        }
        function parseIfStatement() {
            var node = createNode(147 /* IfStatement */);
            parseExpected(74 /* IfKeyword */);
            parseExpected(7 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(8 /* CloseParenToken */);
            node.thenStatement = parseStatement();
            node.elseStatement = parseOptional(66 /* ElseKeyword */) ? parseStatement() : undefined;
            return finishNode(node);
        }
        function parseDoStatement() {
            var node = createNode(148 /* DoStatement */);
            parseExpected(65 /* DoKeyword */);
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            node.statement = parseStatement();
            inIterationStatement = saveInIterationStatement;
            parseExpected(90 /* WhileKeyword */);
            parseExpected(7 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(8 /* CloseParenToken */);
            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
            // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in
            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
            //  do;while(0)x will have a semicolon inserted before x.
            parseOptional(13 /* SemicolonToken */);
            return finishNode(node);
        }
        function parseWhileStatement() {
            var node = createNode(149 /* WhileStatement */);
            parseExpected(90 /* WhileKeyword */);
            parseExpected(7 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(8 /* CloseParenToken */);
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            node.statement = parseStatement();
            inIterationStatement = saveInIterationStatement;
            return finishNode(node);
        }
        function parseForOrForInStatement() {
            var pos = getNodePos();
            parseExpected(72 /* ForKeyword */);
            parseExpected(7 /* OpenParenToken */);
            if (token !== 13 /* SemicolonToken */) {
                if (parseOptional(88 /* VarKeyword */)) {
                    var declarations = parseVariableDeclarationList(0, true);
                    if (!declarations.length) {
                        error(ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
                    }
                }
                else {
                    var varOrInit = parseExpression(true);
                }
            }
            var forOrForInStatement;
            if (parseOptional(76 /* InKeyword */)) {
                var forInStatement = createNode(151 /* ForInStatement */, pos);
                if (declarations) {
                    if (declarations.length > 1) {
                        error(ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);
                    }
                    forInStatement.declaration = declarations[0];
                }
                else {
                    forInStatement.variable = varOrInit;
                }
                forInStatement.expression = parseExpression();
                parseExpected(8 /* CloseParenToken */);
                forOrForInStatement = forInStatement;
            }
            else {
                var forStatement = createNode(150 /* ForStatement */, pos);
                if (declarations)
                    forStatement.declarations = declarations;
                if (varOrInit)
                    forStatement.initializer = varOrInit;
                parseExpected(13 /* SemicolonToken */);
                if (token !== 13 /* SemicolonToken */ && token !== 8 /* CloseParenToken */) {
                    forStatement.condition = parseExpression();
                }
                parseExpected(13 /* SemicolonToken */);
                if (token !== 8 /* CloseParenToken */) {
                    forStatement.iterator = parseExpression();
                }
                parseExpected(8 /* CloseParenToken */);
                forOrForInStatement = forStatement;
            }
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            forOrForInStatement.statement = parseStatement();
            inIterationStatement = saveInIterationStatement;
            return finishNode(forOrForInStatement);
        }
        function parseBreakOrContinueStatement(kind) {
            var node = createNode(kind);
            var errorCountBeforeStatement = file.syntacticErrors.length;
            parseExpected(kind === 153 /* BreakStatement */ ? 56 /* BreakKeyword */ : 61 /* ContinueKeyword */);
            if (!canParseSemicolon())
                node.label = parseIdentifier();
            parseSemicolon();
            finishNode(node);
            // In an ambient context, we will already give an error for having a statement.
            if (!inAmbientContext && errorCountBeforeStatement === file.syntacticErrors.length) {
                if (node.label) {
                    checkBreakOrContinueStatementWithLabel(node);
                }
                else {
                    checkBareBreakOrContinueStatement(node);
                }
            }
            return node;
        }
        function checkBareBreakOrContinueStatement(node) {
            if (node.kind === 153 /* BreakStatement */) {
                if (inIterationStatement === 1 /* Nested */ || inSwitchStatement === 1 /* Nested */) {
                    return;
                }
                else if (inIterationStatement === 0 /* NotNested */ && inSwitchStatement === 0 /* NotNested */) {
                    grammarErrorOnNode(node, ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement);
                    return;
                }
            }
            else if (node.kind === 152 /* ContinueStatement */) {
                if (inIterationStatement === 1 /* Nested */) {
                    return;
                }
                else if (inIterationStatement === 0 /* NotNested */) {
                    grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement);
                    return;
                }
            }
            else {
                ts.Debug.fail("checkAnonymousBreakOrContinueStatement");
            }
            ts.Debug.assert(inIterationStatement === 2 /* CrossingFunctionBoundary */ || inSwitchStatement === 2 /* CrossingFunctionBoundary */);
            grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
        }
        function checkBreakOrContinueStatementWithLabel(node) {
            // For error specificity, if the label is not found, we want to distinguish whether it is because
            // it crossed a function boundary or it was simply not found. To do this, we pass false for
            // stopAtFunctionBoundary.
            var nodeIsNestedInLabel = labelledStatementInfo.nodeIsNestedInLabel(node.label, node.kind === 152 /* ContinueStatement */, false);
            if (nodeIsNestedInLabel === 1 /* Nested */) {
                return;
            }
            if (nodeIsNestedInLabel === 2 /* CrossingFunctionBoundary */) {
                grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
                return;
            }
            // It is NotNested
            if (node.kind === 152 /* ContinueStatement */) {
                grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
            }
            else if (node.kind === 153 /* BreakStatement */) {
                grammarErrorOnNode(node, ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement);
            }
            else {
                ts.Debug.fail("checkBreakOrContinueStatementWithLabel");
            }
        }
        function parseReturnStatement() {
            var node = createNode(154 /* ReturnStatement */);
            var errorCountBeforeReturnStatement = file.syntacticErrors.length;
            var returnTokenStart = scanner.getTokenPos();
            var returnTokenLength = scanner.getTextPos() - returnTokenStart;
            parseExpected(80 /* ReturnKeyword */);
            if (!canParseSemicolon())
                node.expression = parseExpression();
            parseSemicolon();
            // In an ambient context, we will already give an error for having a statement.
            if (!inFunctionBody && !inAmbientContext && errorCountBeforeReturnStatement === file.syntacticErrors.length) {
                grammarErrorAtPos(returnTokenStart, returnTokenLength, ts.Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
            }
            return finishNode(node);
        }
        function parseWithStatement() {
            var node = createNode(155 /* WithStatement */);
            var startPos = scanner.getTokenPos();
            parseExpected(91 /* WithKeyword */);
            var endPos = scanner.getStartPos();
            parseExpected(7 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(8 /* CloseParenToken */);
            node.statement = parseStatement();
            node = finishNode(node);
            if (isInStrictMode) {
                // Strict mode code may not include a WithStatement. The occurrence of a WithStatement in such
                // a context is an
                grammarErrorAtPos(startPos, endPos - startPos, ts.Diagnostics.with_statements_are_not_allowed_in_strict_mode);
            }
            return node;
        }
        function parseCaseClause() {
            var node = createNode(157 /* CaseClause */);
            parseExpected(57 /* CaseKeyword */);
            node.expression = parseExpression();
            parseExpected(42 /* ColonToken */);
            node.statements = parseList(4 /* SwitchClauseStatements */, false, parseStatement);
            return finishNode(node);
        }
        function parseDefaultClause() {
            var node = createNode(158 /* DefaultClause */);
            parseExpected(63 /* DefaultKeyword */);
            parseExpected(42 /* ColonToken */);
            node.statements = parseList(4 /* SwitchClauseStatements */, false, parseStatement);
            return finishNode(node);
        }
        function parseCaseOrDefaultClause() {
            return token === 57 /* CaseKeyword */ ? parseCaseClause() : parseDefaultClause();
        }
        function parseSwitchStatement() {
            var node = createNode(156 /* SwitchStatement */);
            parseExpected(82 /* SwitchKeyword */);
            parseExpected(7 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(8 /* CloseParenToken */);
            parseExpected(5 /* OpenBraceToken */);
            var saveInSwitchStatement = inSwitchStatement;
            inSwitchStatement = 1 /* Nested */;
            node.clauses = parseList(3 /* SwitchClauses */, false, parseCaseOrDefaultClause);
            inSwitchStatement = saveInSwitchStatement;
            parseExpected(6 /* CloseBraceToken */);
            // Error on duplicate 'default' clauses.
            var defaultClauses = ts.filter(node.clauses, function (clause) { return clause.kind === 158 /* DefaultClause */; });
            for (var i = 1, n = defaultClauses.length; i < n; i++) {
                var clause = defaultClauses[i];
                var start = ts.skipTrivia(file.text, clause.pos);
                var end = clause.statements.length > 0 ? clause.statements[0].pos : clause.end;
                grammarErrorAtPos(start, end - start, ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
            }
            return finishNode(node);
        }
        function parseThrowStatement() {
            var node = createNode(160 /* ThrowStatement */);
            parseExpected(84 /* ThrowKeyword */);
            if (scanner.hasPrecedingLineBreak()) {
                error(ts.Diagnostics.Line_break_not_permitted_here);
            }
            node.expression = parseExpression();
            parseSemicolon();
            return finishNode(node);
        }
        // TODO: Review for error recovery
        function parseTryStatement() {
            var node = createNode(161 /* TryStatement */);
            node.tryBlock = parseTokenAndBlock(86 /* TryKeyword */, 162 /* TryBlock */);
            if (token === 58 /* CatchKeyword */) {
                node.catchBlock = parseCatchBlock();
            }
            if (token === 71 /* FinallyKeyword */) {
                node.finallyBlock = parseTokenAndBlock(71 /* FinallyKeyword */, 164 /* FinallyBlock */);
            }
            if (!(node.catchBlock || node.finallyBlock)) {
                error(ts.Diagnostics.catch_or_finally_expected);
            }
            return finishNode(node);
        }
        function parseTokenAndBlock(token, kind) {
            var pos = getNodePos();
            parseExpected(token);
            var result = parseBlock(false, false);
            result.kind = kind;
            result.pos = pos;
            return result;
        }
        function parseCatchBlock() {
            var pos = getNodePos();
            parseExpected(58 /* CatchKeyword */);
            parseExpected(7 /* OpenParenToken */);
            var variable = parseIdentifier();
            var typeAnnotationColonStart = scanner.getTokenPos();
            var typeAnnotationColonLength = scanner.getTextPos() - typeAnnotationColonStart;
            var typeAnnotation = parseTypeAnnotation();
            parseExpected(8 /* CloseParenToken */);
            var result = parseBlock(false, false);
            result.kind = 163 /* CatchBlock */;
            result.pos = pos;
            result.variable = variable;
            if (typeAnnotation) {
                errorAtPos(typeAnnotationColonStart, typeAnnotationColonLength, ts.Diagnostics.Catch_clause_parameter_cannot_have_a_type_annotation);
            }
            if (isInStrictMode && isEvalOrArgumentsIdentifier(variable)) {
                // It is a SyntaxError if a TryStatement with a Catch occurs within strict code and the Identifier of the
                // Catch production is eval or arguments
                reportInvalidUseInStrictMode(variable);
            }
            return result;
        }
        function parseDebuggerStatement() {
            var node = createNode(165 /* DebuggerStatement */);
            parseExpected(62 /* DebuggerKeyword */);
            parseSemicolon();
            return finishNode(node);
        }
        function isIterationStatementStart() {
            return token === 90 /* WhileKeyword */ || token === 65 /* DoKeyword */ || token === 72 /* ForKeyword */;
        }
        function parseStatementWithLabelSet() {
            labelledStatementInfo.pushCurrentLabelSet(isIterationStatementStart());
            var statement = parseStatement();
            labelledStatementInfo.pop();
            return statement;
        }
        function isLabel() {
            return isIdentifier() && lookAhead(function () { return nextToken() === 42 /* ColonToken */; });
        }
        function parseLabelledStatement() {
            var node = createNode(159 /* LabelledStatement */);
            node.label = parseIdentifier();
            parseExpected(42 /* ColonToken */);
            if (labelledStatementInfo.nodeIsNestedInLabel(node.label, false, true)) {
                grammarErrorOnNode(node.label, ts.Diagnostics.Duplicate_label_0, getSourceTextOfNodeFromSourceText(sourceText, node.label));
            }
            labelledStatementInfo.addLabel(node.label);
            // We only want to call parseStatementWithLabelSet when the label set is complete
            // Therefore, keep parsing labels until we know we're done.
            node.statement = isLabel() ? parseLabelledStatement() : parseStatementWithLabelSet();
            return finishNode(node);
        }
        function parseExpressionStatement() {
            var node = createNode(146 /* ExpressionStatement */);
            node.expression = parseExpression();
            parseSemicolon();
            return finishNode(node);
        }
        function isStatement(inErrorRecovery) {
            switch (token) {
                case 13 /* SemicolonToken */:
                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.
                    // The problem is that ';' can show up in far too many contexts, and if we see one
                    // and assume it's a statement, then we may bail out innapropriately from whatever
                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then
                    // we really don't want to assume the class is over and we're on a statement in the
                    // outer module.  We just want to consume and move on.
                    return !inErrorRecovery;
                case 5 /* OpenBraceToken */:
                case 88 /* VarKeyword */:
                case 73 /* FunctionKeyword */:
                case 74 /* IfKeyword */:
                case 65 /* DoKeyword */:
                case 90 /* WhileKeyword */:
                case 72 /* ForKeyword */:
                case 61 /* ContinueKeyword */:
                case 56 /* BreakKeyword */:
                case 80 /* ReturnKeyword */:
                case 91 /* WithKeyword */:
                case 82 /* SwitchKeyword */:
                case 84 /* ThrowKeyword */:
                case 86 /* TryKeyword */:
                case 62 /* DebuggerKeyword */:
                case 58 /* CatchKeyword */:
                case 71 /* FinallyKeyword */:
                    return true;
                case 93 /* InterfaceKeyword */:
                case 59 /* ClassKeyword */:
                case 106 /* ModuleKeyword */:
                case 67 /* EnumKeyword */:
                    // When followed by an identifier, these do not start a statement but might
                    // instead be following declarations
                    if (isDeclaration()) {
                        return false;
                    }
                case 98 /* PublicKeyword */:
                case 96 /* PrivateKeyword */:
                case 99 /* StaticKeyword */:
                    // When followed by an identifier or keyword, these do not start a statement but
                    // might instead be following type members
                    if (lookAhead(function () { return nextToken() >= 55 /* Identifier */; })) {
                        return false;
                    }
                default:
                    return isExpression();
            }
        }
        function parseStatement() {
            switch (token) {
                case 5 /* OpenBraceToken */:
                    return parseBlock(false, false);
                case 88 /* VarKeyword */:
                    return parseVariableStatement();
                case 73 /* FunctionKeyword */:
                    return parseFunctionDeclaration();
                case 13 /* SemicolonToken */:
                    return parseEmptyStatement();
                case 74 /* IfKeyword */:
                    return parseIfStatement();
                case 65 /* DoKeyword */:
                    return parseDoStatement();
                case 90 /* WhileKeyword */:
                    return parseWhileStatement();
                case 72 /* ForKeyword */:
                    return parseForOrForInStatement();
                case 61 /* ContinueKeyword */:
                    return parseBreakOrContinueStatement(152 /* ContinueStatement */);
                case 56 /* BreakKeyword */:
                    return parseBreakOrContinueStatement(153 /* BreakStatement */);
                case 80 /* ReturnKeyword */:
                    return parseReturnStatement();
                case 91 /* WithKeyword */:
                    return parseWithStatement();
                case 82 /* SwitchKeyword */:
                    return parseSwitchStatement();
                case 84 /* ThrowKeyword */:
                    return parseThrowStatement();
                case 86 /* TryKeyword */:
                case 58 /* CatchKeyword */:
                case 71 /* FinallyKeyword */:
                    return parseTryStatement();
                case 62 /* DebuggerKeyword */:
                    return parseDebuggerStatement();
                default:
                    if (isLabel()) {
                        return parseLabelledStatement();
                    }
                    return parseExpressionStatement();
            }
        }
        function parseStatementOrFunction() {
            return token === 73 /* FunctionKeyword */ ? parseFunctionDeclaration() : parseStatement();
        }
        function parseAndCheckFunctionBody(isConstructor) {
            var initialPosition = scanner.getTokenPos();
            var errorCountBeforeBody = file.syntacticErrors.length;
            if (token === 5 /* OpenBraceToken */) {
                var body = parseBody(false);
                if (body && inAmbientContext && file.syntacticErrors.length === errorCountBeforeBody) {
                    var diagnostic = isConstructor ? ts.Diagnostics.A_constructor_implementation_cannot_be_declared_in_an_ambient_context : ts.Diagnostics.A_function_implementation_cannot_be_declared_in_an_ambient_context;
                    grammarErrorAtPos(initialPosition, 1, diagnostic);
                }
                return body;
            }
            if (canParseSemicolon()) {
                parseSemicolon();
                return undefined;
            }
            error(ts.Diagnostics.Block_or_expected); // block or ';' expected
        }
        // DECLARATIONS
        function parseVariableDeclaration(flags, noIn) {
            var node = createNode(166 /* VariableDeclaration */);
            node.flags = flags;
            var errorCountBeforeVariableDeclaration = file.syntacticErrors.length;
            node.name = parseIdentifier();
            node.type = parseTypeAnnotation();
            // Issue any initializer-related errors on the equals token
            var initializerStart = scanner.getTokenPos();
            var initializerFirstTokenLength = scanner.getTextPos() - initializerStart;
            node.initializer = parseInitializer(false, noIn);
            if (inAmbientContext && node.initializer && errorCountBeforeVariableDeclaration === file.syntacticErrors.length) {
                grammarErrorAtPos(initializerStart, initializerFirstTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
            }
            if (isInStrictMode && isEvalOrArgumentsIdentifier(node.name)) {
                // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
                // and its Identifier is eval or arguments
                reportInvalidUseInStrictMode(node.name);
            }
            return finishNode(node);
        }
        function parseVariableDeclarationList(flags, noIn) {
            return parseDelimitedList(9 /* VariableDeclarations */, function () { return parseVariableDeclaration(flags, noIn); }, 0 /* Disallow */);
        }
        function parseVariableStatement(pos, flags) {
            var node = createNode(144 /* VariableStatement */, pos);
            if (flags)
                node.flags = flags;
            var errorCountBeforeVarStatement = file.syntacticErrors.length;
            parseExpected(88 /* VarKeyword */);
            node.declarations = parseVariableDeclarationList(flags, false);
            parseSemicolon();
            if (!node.declarations.length && file.syntacticErrors.length === errorCountBeforeVarStatement) {
                grammarErrorOnNode(node, ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
            }
            return finishNode(node);
        }
        function parseFunctionDeclaration(pos, flags) {
            var node = createNode(167 /* FunctionDeclaration */, pos);
            if (flags)
                node.flags = flags;
            parseExpected(73 /* FunctionKeyword */);
            node.name = parseIdentifier();
            var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = parseAndCheckFunctionBody(false);
            if (isInStrictMode && isEvalOrArgumentsIdentifier(node.name)) {
                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the
                // Identifier of a FunctionDeclaration or FunctionExpression or as a formal parameter name(13.1)
                reportInvalidUseInStrictMode(node.name);
            }
            return finishNode(node);
        }
        function parseConstructorDeclaration(pos, flags) {
            var node = createNode(117 /* Constructor */, pos);
            node.flags = flags;
            parseExpected(103 /* ConstructorKeyword */);
            var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = parseAndCheckFunctionBody(true);
            if (node.typeParameters) {
                grammarErrorAtPos(node.typeParameters.pos, node.typeParameters.end - node.typeParameters.pos, ts.Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);
            }
            if (node.type) {
                grammarErrorOnNode(node.type, ts.Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);
            }
            return finishNode(node);
        }
        function parsePropertyMemberDeclaration(pos, flags) {
            var errorCountBeforePropertyDeclaration = file.syntacticErrors.length;
            var name = parsePropertyName();
            var questionStart = scanner.getTokenPos();
            if (parseOptional(41 /* QuestionToken */)) {
                errorAtPos(questionStart, scanner.getStartPos() - questionStart, ts.Diagnostics.A_class_member_cannot_be_declared_optional);
            }
            if (token === 7 /* OpenParenToken */ || token === 15 /* LessThanToken */) {
                var method = createNode(116 /* Method */, pos);
                method.flags = flags;
                method.name = name;
                var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
                method.typeParameters = sig.typeParameters;
                method.parameters = sig.parameters;
                method.type = sig.type;
                method.body = parseAndCheckFunctionBody(false);
                return finishNode(method);
            }
            else {
                var property = createNode(115 /* Property */, pos);
                property.flags = flags;
                property.name = name;
                property.type = parseTypeAnnotation();
                var initializerStart = scanner.getTokenPos();
                var initializerFirstTokenLength = scanner.getTextPos() - initializerStart;
                property.initializer = parseInitializer(false);
                parseSemicolon();
                if (inAmbientContext && property.initializer && errorCountBeforePropertyDeclaration === file.syntacticErrors.length) {
                    grammarErrorAtPos(initializerStart, initializerFirstTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                }
                return finishNode(property);
            }
        }
        function parseAndCheckMemberAccessorDeclaration(kind, pos, flags) {
            var errorCountBeforeAccessor = file.syntacticErrors.length;
            var accessor = parseMemberAccessorDeclaration(kind, pos, flags);
            if (errorCountBeforeAccessor === file.syntacticErrors.length) {
                if (languageVersion < 1 /* ES5 */) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
                }
                else if (inAmbientContext) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_be_declared_in_an_ambient_context);
                }
                else if (accessor.typeParameters) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_have_type_parameters);
                }
                else if (kind === 118 /* GetAccessor */ && accessor.parameters.length) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.A_get_accessor_cannot_have_parameters);
                }
                else if (kind === 119 /* SetAccessor */) {
                    if (accessor.type) {
                        grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
                    }
                    else if (accessor.parameters.length !== 1) {
                        grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter);
                    }
                    else {
                        var parameter = accessor.parameters[0];
                        if (parameter.flags & 8 /* Rest */) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter);
                        }
                        else if (parameter.flags & ts.NodeFlags.Modifier) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                        }
                        else if (parameter.flags & 4 /* QuestionMark */) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
                        }
                        else if (parameter.initializer) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
                        }
                    }
                }
            }
            return accessor;
        }
        function parseMemberAccessorDeclaration(kind, pos, flags) {
            var node = createNode(kind, pos);
            node.flags = flags;
            node.name = parsePropertyName();
            var sig = parseSignature(120 /* CallSignature */, 42 /* ColonToken */);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            // A common error is to try to declare an accessor in an ambient class.
            if (inAmbientContext && canParseSemicolon()) {
                parseSemicolon();
                node.body = createMissingNode();
            }
            else {
                node.body = parseBody(false);
            }
            return finishNode(node);
        }
        function isClassMemberStart() {
            var idToken;
            while (isModifier(token)) {
                idToken = token;
                nextToken();
            }
            // Try to get the first property-like token following all modifiers.
            // This can either be an identifier or the 'get' or 'set' keywords.
            if (isPropertyName()) {
                idToken = token;
                nextToken();
            }
            // Index signatures are class members; we can parse.
            if (token === 9 /* OpenBracketToken */) {
                return true;
            }
            // If we were able to get any potential identifier...
            if (idToken !== undefined) {
                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.
                if (!isKeyword(idToken) || idToken === 109 /* SetKeyword */ || idToken === 105 /* GetKeyword */) {
                    return true;
                }
                switch (token) {
                    case 7 /* OpenParenToken */:
                    case 15 /* LessThanToken */:
                    case 42 /* ColonToken */:
                    case 43 /* EqualsToken */:
                    case 41 /* QuestionToken */:
                        return true;
                    default:
                        // Covers
                        //  - Semicolons     (declaration termination)
                        //  - Closing braces (end-of-class, must be declaration)
                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)
                        //  - Line-breaks    (enabling *automatic semicolon insertion*)
                        return canParseSemicolon();
                }
            }
            return false;
        }
        function parseAndCheckModifiers(context) {
            var flags = 0;
            var lastStaticModifierStart;
            var lastStaticModifierLength;
            var lastDeclareModifierStart;
            var lastDeclareModifierLength;
            var lastPrivateModifierStart;
            var lastPrivateModifierLength;
            while (true) {
                var modifierStart = scanner.getTokenPos();
                var modifierToken = token;
                // Try to parse the modifier
                if (!parseAnyContextualModifier())
                    break;
                var modifierLength = scanner.getStartPos() - modifierStart;
                switch (modifierToken) {
                    case 98 /* PublicKeyword */:
                        if (flags & 32 /* Private */ || flags & 16 /* Public */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 64 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "public", "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "public");
                        }
                        flags |= 16 /* Public */;
                        break;
                    case 96 /* PrivateKeyword */:
                        if (flags & 32 /* Private */ || flags & 16 /* Public */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 64 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "private", "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "private");
                        }
                        lastPrivateModifierStart = modifierStart;
                        lastPrivateModifierLength = modifierLength;
                        flags |= 32 /* Private */;
                        break;
                    case 99 /* StaticKeyword */:
                        if (flags & 64 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "static");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                        }
                        lastStaticModifierStart = modifierStart;
                        lastStaticModifierLength = modifierLength;
                        flags |= 64 /* Static */;
                        break;
                    case 68 /* ExportKeyword */:
                        if (flags & 1 /* Export */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "export");
                        }
                        else if (flags & 2 /* Ambient */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                        }
                        else if (context === 2 /* ClassMembers */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "export");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                        }
                        flags |= 1 /* Export */;
                        break;
                    case 104 /* DeclareKeyword */:
                        if (flags & 2 /* Ambient */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "declare");
                        }
                        else if (context === 2 /* ClassMembers */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "declare");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                        }
                        else if (inAmbientContext && context === 1 /* ModuleElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        }
                        lastDeclareModifierStart = modifierStart;
                        lastDeclareModifierLength = modifierLength;
                        flags |= 2 /* Ambient */;
                        break;
                }
            }
            if (token === 103 /* ConstructorKeyword */ && flags & 64 /* Static */) {
                grammarErrorAtPos(lastStaticModifierStart, lastStaticModifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
            }
            else if (token === 103 /* ConstructorKeyword */ && flags & 32 /* Private */) {
                grammarErrorAtPos(lastPrivateModifierStart, lastPrivateModifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "private");
            }
            else if (token === 75 /* ImportKeyword */) {
                if (flags & 2 /* Ambient */) {
                    grammarErrorAtPos(lastDeclareModifierStart, lastDeclareModifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_with_an_import_declaration, "declare");
                }
            }
            else if (token === 93 /* InterfaceKeyword */) {
                if (flags & 2 /* Ambient */) {
                    grammarErrorAtPos(lastDeclareModifierStart, lastDeclareModifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_with_an_interface_declaration, "declare");
                }
            }
            else if (token !== 68 /* ExportKeyword */ && !(flags & 2 /* Ambient */) && inAmbientContext && context === 0 /* SourceElements */) {
                // A declare modifier is required for any top level .d.ts declaration except export=, interfaces and imports:
                // categories:
                //
                //  DeclarationElement:
                //     ExportAssignment
                //     export_opt   InterfaceDeclaration
                //     export_opt   ImportDeclaration
                //     export_opt   ExternalImportDeclaration
                //     export_opt   AmbientDeclaration
                //
                var declarationStart = scanner.getTokenPos();
                var declarationFirstTokenLength = scanner.getTextPos() - declarationStart;
                grammarErrorAtPos(declarationStart, declarationFirstTokenLength, ts.Diagnostics.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
            }
            return flags;
        }
        function parseClassMemberDeclaration() {
            var pos = getNodePos();
            var flags = parseAndCheckModifiers(2 /* ClassMembers */);
            if (parseContextualModifier(105 /* GetKeyword */)) {
                return parseAndCheckMemberAccessorDeclaration(118 /* GetAccessor */, pos, flags);
            }
            if (parseContextualModifier(109 /* SetKeyword */)) {
                return parseAndCheckMemberAccessorDeclaration(119 /* SetAccessor */, pos, flags);
            }
            if (token === 103 /* ConstructorKeyword */) {
                return parseConstructorDeclaration(pos, flags);
            }
            if (token >= 55 /* Identifier */ || token === 3 /* StringLiteral */ || token === 2 /* NumericLiteral */) {
                return parsePropertyMemberDeclaration(pos, flags);
            }
            if (token === 9 /* OpenBracketToken */) {
                if (flags) {
                    var start = getTokenPos(pos);
                    var length = getNodePos() - start;
                    errorAtPos(start, length, ts.Diagnostics.Modifiers_not_permitted_on_index_signature_members);
                }
                return parseIndexSignatureMember();
            }
            // 'isClassMemberStart' should have hinted not to attempt parsing.
            ts.Debug.fail("Should not have attempted to parse class member declaration.");
        }
        function parseClassDeclaration(pos, flags) {
            var node = createNode(169 /* ClassDeclaration */, pos);
            node.flags = flags;
            var errorCountBeforeClassDeclaration = file.syntacticErrors.length;
            parseExpected(59 /* ClassKeyword */);
            node.name = parseIdentifier();
            node.typeParameters = parseTypeParameters();
            // TODO(jfreeman): Parse arbitrary sequence of heritage clauses and error for order and duplicates
            node.baseType = parseOptional(69 /* ExtendsKeyword */) ? parseTypeReference() : undefined;
            var implementsKeywordStart = scanner.getTokenPos();
            var implementsKeywordLength;
            if (parseOptional(92 /* ImplementsKeyword */)) {
                implementsKeywordLength = scanner.getStartPos() - implementsKeywordStart;
                node.implementedTypes = parseDelimitedList(8 /* BaseTypeReferences */, parseTypeReference, 0 /* Disallow */);
            }
            var errorCountBeforeClassBody = file.syntacticErrors.length;
            if (parseExpected(5 /* OpenBraceToken */)) {
                node.members = parseList(6 /* ClassMembers */, false, parseClassMemberDeclaration);
                parseExpected(6 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            if (node.implementedTypes && !node.implementedTypes.length && errorCountBeforeClassBody === errorCountBeforeClassDeclaration) {
                grammarErrorAtPos(implementsKeywordStart, implementsKeywordLength, ts.Diagnostics._0_list_cannot_be_empty, "implements");
            }
            return finishNode(node);
        }
        function parseInterfaceDeclaration(pos, flags) {
            var node = createNode(170 /* InterfaceDeclaration */, pos);
            node.flags = flags;
            var errorCountBeforeInterfaceDeclaration = file.syntacticErrors.length;
            parseExpected(93 /* InterfaceKeyword */);
            node.name = parseIdentifier();
            node.typeParameters = parseTypeParameters();
            // TODO(jfreeman): Parse arbitrary sequence of heritage clauses and error for order and duplicates
            var extendsKeywordStart = scanner.getTokenPos();
            var extendsKeywordLength;
            if (parseOptional(69 /* ExtendsKeyword */)) {
                extendsKeywordLength = scanner.getStartPos() - extendsKeywordStart;
                node.baseTypes = parseDelimitedList(8 /* BaseTypeReferences */, parseTypeReference, 0 /* Disallow */);
            }
            var errorCountBeforeInterfaceBody = file.syntacticErrors.length;
            node.members = parseTypeLiteral().members;
            if (node.baseTypes && !node.baseTypes.length && errorCountBeforeInterfaceBody === errorCountBeforeInterfaceDeclaration) {
                grammarErrorAtPos(extendsKeywordStart, extendsKeywordLength, ts.Diagnostics._0_list_cannot_be_empty, "extends");
            }
            return finishNode(node);
        }
        function parseAndCheckEnumDeclaration(pos, flags) {
            function isIntegerLiteral(expression) {
                function isInteger(literalExpression) {
                    // Allows for scientific notation since literalExpression.text was formed by
                    // coercing a number to a string. Sometimes this coersion can yield a string
                    // in scientific notation.
                    // We also don't need special logic for hex because a hex integer is converted
                    // to decimal when it is coerced.
                    return /^[0-9]+([eE]\+?[0-9]+)?$/.test(literalExpression.text);
                }
                if (expression.kind === 138 /* PrefixOperator */) {
                    var unaryExpression = expression;
                    if (unaryExpression.operator === 24 /* PlusToken */ || unaryExpression.operator === 25 /* MinusToken */) {
                        expression = unaryExpression.operand;
                    }
                }
                if (expression.kind === 2 /* NumericLiteral */) {
                    return isInteger(expression);
                }
                return false;
            }
            var inConstantEnumMemberSection = true;
            // In an ambient declaration, the grammar only allows integer literals as initializers.
            // In a nonambient declaration, the grammar allows uninitialized members only in a
            // ConstantEnumMemberSection, which starts at the beginning of an enum declaration
            // or any time an integer literal initializer is encountered.
            function parseAndCheckEnumMember() {
                var node = createNode(176 /* EnumMember */);
                var errorCountBeforeEnumMember = file.syntacticErrors.length;
                node.name = parsePropertyName();
                node.initializer = parseInitializer(false);
                if (inAmbientContext) {
                    if (node.initializer && !isIntegerLiteral(node.initializer) && errorCountBeforeEnumMember === file.syntacticErrors.length) {
                        grammarErrorOnNode(node.name, ts.Diagnostics.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    }
                }
                else if (node.initializer) {
                    inConstantEnumMemberSection = isIntegerLiteral(node.initializer);
                }
                else if (!inConstantEnumMemberSection && errorCountBeforeEnumMember === file.syntacticErrors.length) {
                    grammarErrorOnNode(node.name, ts.Diagnostics.Enum_member_must_have_initializer);
                }
                return finishNode(node);
            }
            var node = createNode(171 /* EnumDeclaration */, pos);
            node.flags = flags;
            parseExpected(67 /* EnumKeyword */);
            node.name = parseIdentifier();
            if (parseExpected(5 /* OpenBraceToken */)) {
                node.members = parseDelimitedList(7 /* EnumMembers */, parseAndCheckEnumMember, 1 /* Allow */);
                parseExpected(6 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            return finishNode(node);
        }
        function parseModuleBody() {
            var node = createNode(173 /* ModuleBlock */);
            if (parseExpected(5 /* OpenBraceToken */)) {
                node.statements = parseList(1 /* ModuleElements */, false, parseModuleElement);
                parseExpected(6 /* CloseBraceToken */);
            }
            else {
                node.statements = createMissingList();
            }
            return finishNode(node);
        }
        function parseInternalModuleTail(pos, flags) {
            var node = createNode(172 /* ModuleDeclaration */, pos);
            node.flags = flags;
            node.name = parseIdentifier();
            if (parseOptional(11 /* DotToken */)) {
                node.body = parseInternalModuleTail(getNodePos(), 1 /* Export */);
            }
            else {
                node.body = parseModuleBody();
                ts.forEach(node.body.statements, function (s) {
                    if (s.kind === 175 /* ExportAssignment */) {
                        // Export assignments are not allowed in an internal module
                        grammarErrorOnNode(s, ts.Diagnostics.An_export_assignment_cannot_be_used_in_an_internal_module);
                    }
                    else if (s.kind === 174 /* ImportDeclaration */ && s.externalModuleName) {
                        grammarErrorOnNode(s, ts.Diagnostics.Import_declarations_in_an_internal_module_cannot_reference_an_external_module);
                    }
                });
            }
            return finishNode(node);
        }
        function parseAmbientExternalModuleDeclaration(pos, flags) {
            var node = createNode(172 /* ModuleDeclaration */, pos);
            node.flags = flags;
            node.name = parseStringLiteral();
            if (!inAmbientContext) {
                var errorCount = file.syntacticErrors.length;
                // Only report this error if we have not already errored about a missing declare modifier,
                // which would have been at or after pos
                if (!errorCount || file.syntacticErrors[errorCount - 1].start < getTokenPos(pos)) {
                    grammarErrorOnNode(node.name, ts.Diagnostics.Only_ambient_modules_can_use_quoted_names);
                }
            }
            // For error recovery, just in case the user forgot the declare modifier on this ambient
            // external module, treat it as ambient anyway.
            var saveInAmbientContext = inAmbientContext;
            inAmbientContext = true;
            node.body = parseModuleBody();
            inAmbientContext = saveInAmbientContext;
            return finishNode(node);
        }
        function parseModuleDeclaration(pos, flags) {
            parseExpected(106 /* ModuleKeyword */);
            return token === 3 /* StringLiteral */ ? parseAmbientExternalModuleDeclaration(pos, flags) : parseInternalModuleTail(pos, flags);
        }
        function parseImportDeclaration(pos, flags) {
            var node = createNode(174 /* ImportDeclaration */, pos);
            node.flags = flags;
            parseExpected(75 /* ImportKeyword */);
            node.name = parseIdentifier();
            parseExpected(43 /* EqualsToken */);
            var entityName = parseEntityName(false);
            if (entityName.kind === 55 /* Identifier */ && entityName.text === "require" && parseOptional(7 /* OpenParenToken */)) {
                node.externalModuleName = parseStringLiteral();
                parseExpected(8 /* CloseParenToken */);
            }
            else {
                node.entityName = entityName;
            }
            parseSemicolon();
            return finishNode(node);
        }
        function parseExportAssignmentTail(pos) {
            var node = createNode(175 /* ExportAssignment */, pos);
            node.exportName = parseIdentifier();
            parseSemicolon();
            return finishNode(node);
        }
        function isDeclaration() {
            switch (token) {
                case 88 /* VarKeyword */:
                case 73 /* FunctionKeyword */:
                    return true;
                case 59 /* ClassKeyword */:
                case 93 /* InterfaceKeyword */:
                case 67 /* EnumKeyword */:
                case 75 /* ImportKeyword */:
                    // Not true keywords so ensure an identifier follows
                    return lookAhead(function () { return nextToken() >= 55 /* Identifier */; });
                case 106 /* ModuleKeyword */:
                    // Not a true keyword so ensure an identifier or string literal follows
                    return lookAhead(function () { return nextToken() >= 55 /* Identifier */ || token === 3 /* StringLiteral */; });
                case 68 /* ExportKeyword */:
                    // Check for export assignment or modifier on source element
                    return lookAhead(function () { return nextToken() === 43 /* EqualsToken */ || isDeclaration(); });
                case 104 /* DeclareKeyword */:
                case 98 /* PublicKeyword */:
                case 96 /* PrivateKeyword */:
                case 99 /* StaticKeyword */:
                    // Check for modifier on source element
                    return lookAhead(function () {
                        nextToken();
                        return isDeclaration();
                    });
            }
        }
        function parseDeclaration(modifierContext) {
            var pos = getNodePos();
            var errorCountBeforeModifiers = file.syntacticErrors.length;
            var flags = parseAndCheckModifiers(modifierContext);
            if (token === 68 /* ExportKeyword */) {
                var modifiersEnd = scanner.getStartPos();
                nextToken();
                if (parseOptional(43 /* EqualsToken */)) {
                    var exportAssignmentTail = parseExportAssignmentTail(pos);
                    if (flags !== 0 && errorCountBeforeModifiers === file.syntacticErrors.length) {
                        var modifiersStart = ts.skipTrivia(sourceText, pos);
                        grammarErrorAtPos(modifiersStart, modifiersEnd - modifiersStart, ts.Diagnostics.An_export_assignment_cannot_have_modifiers);
                    }
                    return exportAssignmentTail;
                }
            }
            var saveInAmbientContext = inAmbientContext;
            if (flags & 2 /* Ambient */) {
                inAmbientContext = true;
            }
            var result;
            switch (token) {
                case 88 /* VarKeyword */:
                    result = parseVariableStatement(pos, flags);
                    break;
                case 73 /* FunctionKeyword */:
                    result = parseFunctionDeclaration(pos, flags);
                    break;
                case 59 /* ClassKeyword */:
                    result = parseClassDeclaration(pos, flags);
                    break;
                case 93 /* InterfaceKeyword */:
                    result = parseInterfaceDeclaration(pos, flags);
                    break;
                case 67 /* EnumKeyword */:
                    result = parseAndCheckEnumDeclaration(pos, flags);
                    break;
                case 106 /* ModuleKeyword */:
                    result = parseModuleDeclaration(pos, flags);
                    break;
                case 75 /* ImportKeyword */:
                    result = parseImportDeclaration(pos, flags);
                    break;
                default:
                    error(ts.Diagnostics.Declaration_expected);
            }
            inAmbientContext = saveInAmbientContext;
            return result;
        }
        function isSourceElement(inErrorRecovery) {
            return isDeclaration() || isStatement(inErrorRecovery);
        }
        function parseSourceElement() {
            return parseSourceElementOrModuleElement(0 /* SourceElements */);
        }
        function parseModuleElement() {
            return parseSourceElementOrModuleElement(1 /* ModuleElements */);
        }
        function parseSourceElementOrModuleElement(modifierContext) {
            if (isDeclaration()) {
                return parseDeclaration(modifierContext);
            }
            var statementStart = scanner.getTokenPos();
            var statementFirstTokenLength = scanner.getTextPos() - statementStart;
            var errorCountBeforeStatement = file.syntacticErrors.length;
            var statement = parseStatement();
            if (inAmbientContext && file.syntacticErrors.length === errorCountBeforeStatement) {
                grammarErrorAtPos(statementStart, statementFirstTokenLength, ts.Diagnostics.Statements_are_not_allowed_in_ambient_contexts);
            }
            return statement;
        }
        function processReferenceComments() {
            var referencedFiles = [];
            var amdDependencies = [];
            commentRanges = [];
            token = scanner.scan();
            for (var i = 0; i < commentRanges.length; i++) {
                var range = commentRanges[i];
                var comment = sourceText.substring(range.pos, range.end);
                var simpleReferenceRegEx = /^\/\/\/\s*<reference\s+/gim;
                if (simpleReferenceRegEx.exec(comment)) {
                    var isNoDefaultLibRegEx = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
                    if (isNoDefaultLibRegEx.exec(comment)) {
                        file.hasNoDefaultLib = true;
                    }
                    else {
                        var matchResult = ts.fullTripleSlashReferencePathRegEx.exec(comment);
                        if (!matchResult) {
                            var start = range.pos;
                            var length = range.end - start;
                            errorAtPos(start, length, ts.Diagnostics.Invalid_reference_directive_syntax);
                        }
                        else {
                            referencedFiles.push({
                                pos: range.pos,
                                end: range.end,
                                filename: matchResult[3]
                            });
                        }
                    }
                }
                else {
                    var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path\s*=\s*('|")(.+?)\1/gim;
                    var amdDependencyMatchResult = amdDependencyRegEx.exec(comment);
                    if (amdDependencyMatchResult) {
                        amdDependencies.push(amdDependencyMatchResult[2]);
                    }
                }
            }
            commentRanges = undefined;
            return {
                referencedFiles: referencedFiles,
                amdDependencies: amdDependencies
            };
        }
        function getExternalModuleIndicator() {
            return ts.forEach(file.statements, function (node) { return node.flags & 1 /* Export */ || node.kind === 174 /* ImportDeclaration */ && node.externalModuleName || node.kind === 175 /* ExportAssignment */ ? node : undefined; });
        }
        scanner = ts.createScanner(languageVersion, sourceText, scanError, onComment);
        var rootNodeFlags = 0;
        if (ts.fileExtensionIs(filename, ".d.ts")) {
            rootNodeFlags = 512 /* DeclarationFile */;
            inAmbientContext = true;
        }
        file = createRootNode(177 /* SourceFile */, 0, sourceText.length, rootNodeFlags);
        file.filename = ts.normalizePath(filename);
        file.text = sourceText;
        file.getLineAndCharacterFromPosition = getLineAndCharacterlFromSourcePosition;
        file.getPositionFromLineAndCharacter = getPositionFromSourceLineAndCharacter;
        file.syntacticErrors = [];
        file.semanticErrors = [];
        var referenceComments = processReferenceComments();
        file.referencedFiles = referenceComments.referencedFiles;
        file.amdDependencies = referenceComments.amdDependencies;
        file.statements = parseList(0 /* SourceElements */, true, parseSourceElement);
        file.externalModuleIndicator = getExternalModuleIndicator();
        file.nodeCount = nodeCount;
        file.identifierCount = identifierCount;
        file.version = version;
        file.isOpen = isOpen;
        file.languageVersion = languageVersion;
        return file;
    }
    ts.createSourceFile = createSourceFile;
    function createProgram(rootNames, options, host) {
        var program;
        var files = [];
        var filesByName = {};
        var errors = [];
        var seenNoDefaultLib = options.noLib;
        var commonSourceDirectory;
        ts.forEach(rootNames, function (name) { return processRootFile(name, false); });
        if (!seenNoDefaultLib) {
            processRootFile(host.getDefaultLibFilename(), true);
        }
        verifyCompilerOptions();
        errors.sort(ts.compareDiagnostics);
        program = {
            getSourceFile: getSourceFile,
            getSourceFiles: function () { return files; },
            getCompilerOptions: function () { return options; },
            getCompilerHost: function () { return host; },
            getDiagnostics: getDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getTypeChecker: function (fullTypeCheckMode) { return ts.createTypeChecker(program, fullTypeCheckMode); },
            getCommonSourceDirectory: function () { return commonSourceDirectory; }
        };
        return program;
        function getSourceFile(filename) {
            filename = host.getCanonicalFileName(filename);
            return ts.hasProperty(filesByName, filename) ? filesByName[filename] : undefined;
        }
        function getDiagnostics(sourceFile) {
            return sourceFile ? ts.filter(errors, function (e) { return e.file === sourceFile; }) : errors;
        }
        function getGlobalDiagnostics() {
            return ts.filter(errors, function (e) { return !e.file; });
        }
        function hasExtension(filename) {
            return ts.getBaseFilename(filename).indexOf(".") >= 0;
        }
        function processRootFile(filename, isDefaultLib) {
            processSourceFile(ts.normalizePath(filename), isDefaultLib);
        }
        function processSourceFile(filename, isDefaultLib, refFile, refPos, refEnd) {
            if (refEnd !== undefined && refPos !== undefined) {
                var start = refPos;
                var length = refEnd - refPos;
            }
            if (hasExtension(filename)) {
                if (!ts.fileExtensionIs(filename, ".ts")) {
                    errors.push(ts.createFileDiagnostic(refFile, start, length, ts.Diagnostics.File_0_must_have_extension_ts_or_d_ts, filename));
                }
                else if (!findSourceFile(filename, isDefaultLib, refFile, refPos, refEnd)) {
                    errors.push(ts.createFileDiagnostic(refFile, start, length, ts.Diagnostics.File_0_not_found, filename));
                }
            }
            else {
                if (!(findSourceFile(filename + ".ts", isDefaultLib, refFile, refPos, refEnd) || findSourceFile(filename + ".d.ts", isDefaultLib, refFile, refPos, refEnd))) {
                    errors.push(ts.createFileDiagnostic(refFile, start, length, ts.Diagnostics.File_0_not_found, filename + ".ts"));
                }
            }
        }
        // Get source file from normalized filename
        function findSourceFile(filename, isDefaultLib, refFile, refStart, refLength) {
            // Look through existing source files to see if we've encountered it.
            var canonicalName = host.getCanonicalFileName(filename);
            var file = getSourceFile(filename);
            if (file) {
                if (host.useCaseSensitiveFileNames() && canonicalName !== file.filename) {
                    errors.push(ts.createFileDiagnostic(refFile, refStart, refLength, ts.Diagnostics.Filename_0_differs_from_already_included_filename_1_only_in_casing, filename, file.filename));
                }
            }
            else {
                // If we haven't, read the file.
                file = host.getSourceFile(filename, options.target, function (hostErrorMessage) {
                    errors.push(ts.createFileDiagnostic(refFile, refStart, refLength, ts.Diagnostics.Cannot_read_file_0_Colon_1, filename, hostErrorMessage));
                });
                if (file) {
                    filesByName[host.getCanonicalFileName(filename)] = file;
                    seenNoDefaultLib = seenNoDefaultLib || file.hasNoDefaultLib;
                    if (!options.noResolve) {
                        var basePath = ts.getDirectoryPath(filename);
                        processReferencedFiles(file, basePath);
                        processImportedModules(file, basePath);
                    }
                    if (isDefaultLib) {
                        files.unshift(file);
                    }
                    else {
                        files.push(file);
                    }
                    ts.forEach(file.syntacticErrors, function (e) {
                        errors.push(e);
                    });
                }
            }
            return file;
        }
        function processReferencedFiles(file, basePath) {
            ts.forEach(file.referencedFiles, function (ref) {
                processSourceFile(ts.normalizePath(ts.combinePaths(basePath, ref.filename)), false, file, ref.pos, ref.end);
            });
        }
        function processImportedModules(file, basePath) {
            ts.forEach(file.statements, function (node) {
                if (node.kind === 174 /* ImportDeclaration */ && node.externalModuleName) {
                    var nameLiteral = node.externalModuleName;
                    var moduleName = nameLiteral.text;
                    if (moduleName) {
                        var searchPath = basePath;
                        while (true) {
                            var searchName = ts.normalizePath(ts.combinePaths(searchPath, moduleName));
                            if (findModuleSourceFile(searchName + ".ts", nameLiteral) || findModuleSourceFile(searchName + ".d.ts", nameLiteral)) {
                                break;
                            }
                            var parentPath = ts.getDirectoryPath(searchPath);
                            if (parentPath === searchPath) {
                                break;
                            }
                            searchPath = parentPath;
                        }
                    }
                }
                else if (node.kind === 172 /* ModuleDeclaration */ && node.name.kind === 3 /* StringLiteral */ && (node.flags & 2 /* Ambient */ || file.flags & 512 /* DeclarationFile */)) {
                    // TypeScript 1.0 spec (April 2014): 12.1.6
                    // An AmbientExternalModuleDeclaration declares an external module.
                    // This type of declaration is permitted only in the global module.
                    // The StringLiteral must specify a top - level external module name.
                    // Relative external module names are not permitted
                    forEachChild(node.body, function (node) {
                        if (node.kind === 174 /* ImportDeclaration */ && node.externalModuleName) {
                            var nameLiteral = node.externalModuleName;
                            var moduleName = nameLiteral.text;
                            if (moduleName) {
                                // TypeScript 1.0 spec (April 2014): 12.1.6
                                // An ExternalImportDeclaration in anAmbientExternalModuleDeclaration may reference other external modules
                                // only through top - level external module names. Relative external module names are not permitted.
                                var searchName = ts.normalizePath(ts.combinePaths(basePath, moduleName));
                                var tsFile = findModuleSourceFile(searchName + ".ts", nameLiteral);
                                if (!tsFile) {
                                    findModuleSourceFile(searchName + ".d.ts", nameLiteral);
                                }
                            }
                        }
                    });
                }
            });
            function findModuleSourceFile(filename, nameLiteral) {
                return findSourceFile(filename, false, file, nameLiteral.pos, nameLiteral.end - nameLiteral.pos);
            }
        }
        function verifyCompilerOptions() {
            if (!options.sourceMap && (options.mapRoot || options.sourceRoot)) {
                // Error to specify --mapRoot or --sourceRoot without mapSourceFiles
                if (options.mapRoot) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option));
                }
                if (options.sourceRoot) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option));
                }
                return;
            }
            var firstExternalModule = ts.forEach(files, function (f) { return isExternalModule(f) ? f : undefined; });
            if (firstExternalModule && options.module === 0 /* None */) {
                // We cannot use createDiagnosticFromNode because nodes do not have parents yet
                var externalModuleErrorSpan = getErrorSpanForNode(firstExternalModule.externalModuleIndicator);
                var errorStart = ts.skipTrivia(firstExternalModule.text, externalModuleErrorSpan.pos);
                var errorLength = externalModuleErrorSpan.end - errorStart;
                errors.push(ts.createFileDiagnostic(firstExternalModule, errorStart, errorLength, ts.Diagnostics.Cannot_compile_external_modules_unless_the_module_flag_is_provided));
            }
            // there has to be common source directory if user specified --outdir || --sourcRoot
            // if user specified --mapRoot, there needs to be common source directory if there would be multiple files being emitted
            if (options.outDir || options.sourceRoot || (options.mapRoot && (!options.out || firstExternalModule !== undefined))) {
                var commonPathComponents;
                ts.forEach(files, function (sourceFile) {
                    // Each file contributes into common source file path
                    if (!(sourceFile.flags & 512 /* DeclarationFile */) && !ts.fileExtensionIs(sourceFile.filename, ".js")) {
                        var sourcePathCompoments = ts.getNormalizedPathComponents(sourceFile.filename, host.getCurrentDirectory());
                        sourcePathCompoments.pop(); // FileName is not part of directory
                        if (commonPathComponents) {
                            for (var i = 0; i < Math.min(commonPathComponents.length, sourcePathCompoments.length); i++) {
                                if (commonPathComponents[i] !== sourcePathCompoments[i]) {
                                    if (i === 0) {
                                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_find_the_common_subdirectory_path_for_the_input_files));
                                        return;
                                    }
                                    // New common path found that is 0 -> i-1
                                    commonPathComponents.length = i;
                                    break;
                                }
                            }
                            // If the fileComponent path completely matched and less than already found update the length
                            if (sourcePathCompoments.length < commonPathComponents.length) {
                                commonPathComponents.length = sourcePathCompoments.length;
                            }
                        }
                        else {
                            // first file
                            commonPathComponents = sourcePathCompoments;
                        }
                    }
                });
                commonSourceDirectory = ts.getNormalizedPathFromPathCompoments(commonPathComponents);
                if (commonSourceDirectory) {
                    // Make sure directory path ends with directory separator so this string can directly
                    // used to replace with "" to get the relative path of the source file and the relative path doesnt
                    // start with / making it rooted path
                    commonSourceDirectory += ts.directorySeparator;
                }
            }
        }
    }
    ts.createProgram = createProgram;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
var ts;
(function (ts) {
    function isInstantiated(node) {
        // A module is uninstantiated if it contains only
        // 1. interface declarations
        if (node.kind === 170 /* InterfaceDeclaration */) {
            return false;
        }
        else if (node.kind === 174 /* ImportDeclaration */ && !(node.flags & 1 /* Export */)) {
            return false;
        }
        else if (node.kind === 173 /* ModuleBlock */ && !ts.forEachChild(node, isInstantiated)) {
            return false;
        }
        else if (node.kind === 172 /* ModuleDeclaration */ && !isInstantiated(node.body)) {
            return false;
        }
        else {
            return true;
        }
    }
    ts.isInstantiated = isInstantiated;
    function bindSourceFile(file) {
        var parent;
        var container;
        var lastContainer;
        var symbolCount = 0;
        var Symbol = ts.objectAllocator.getSymbolConstructor();
        if (!file.locals) {
            file.locals = {};
            container = file;
            bind(file);
            file.symbolCount = symbolCount;
        }
        function createSymbol(flags, name) {
            symbolCount++;
            return new Symbol(flags, name);
        }
        function addDeclarationToSymbol(symbol, node, symbolKind) {
            symbol.flags |= symbolKind;
            if (!symbol.declarations)
                symbol.declarations = [];
            symbol.declarations.push(node);
            if (symbolKind & ts.SymbolFlags.HasExports && !symbol.exports)
                symbol.exports = {};
            if (symbolKind & ts.SymbolFlags.HasMembers && !symbol.members)
                symbol.members = {};
            node.symbol = symbol;
            if (symbolKind & ts.SymbolFlags.Value && !symbol.valueDeclaration)
                symbol.valueDeclaration = node;
        }
        function getDeclarationName(node) {
            if (node.name) {
                if (node.kind === 172 /* ModuleDeclaration */ && node.name.kind === 3 /* StringLiteral */) {
                    return '"' + node.name.text + '"';
                }
                return node.name.text;
            }
            switch (node.kind) {
                case 117 /* Constructor */:
                    return "__constructor";
                case 120 /* CallSignature */:
                    return "__call";
                case 121 /* ConstructSignature */:
                    return "__new";
                case 122 /* IndexSignature */:
                    return "__index";
            }
        }
        function getDisplayName(node) {
            return node.name ? ts.identifierToString(node.name) : getDeclarationName(node);
        }
        function declareSymbol(symbols, parent, node, includes, excludes) {
            var name = getDeclarationName(node);
            if (name !== undefined) {
                var symbol = ts.hasProperty(symbols, name) ? symbols[name] : (symbols[name] = createSymbol(0, name));
                if (symbol.flags & excludes) {
                    if (node.name) {
                        node.name.parent = node;
                    }
                    file.semanticErrors.push(ts.createDiagnosticForNode(node.name ? node.name : node, ts.Diagnostics.Duplicate_identifier_0, getDisplayName(node)));
                    symbol = createSymbol(0, name);
                }
            }
            else {
                symbol = createSymbol(0, "__missing");
            }
            addDeclarationToSymbol(symbol, node, includes);
            symbol.parent = parent;
            if (node.kind === 169 /* ClassDeclaration */ && symbol.exports) {
                // TypeScript 1.0 spec (April 2014): 8.4
                // Every class automatically contains a static property member named 'prototype',
                // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
                // It is an error to explicitly declare a static property member with the name 'prototype'.
                var prototypeSymbol = createSymbol(2 /* Property */ | 67108864 /* Prototype */, "prototype");
                if (ts.hasProperty(symbol.exports, prototypeSymbol.name)) {
                    if (node.name) {
                        node.name.parent = node;
                    }
                    file.semanticErrors.push(ts.createDiagnosticForNode(symbol.exports[prototypeSymbol.name].declarations[0], ts.Diagnostics.Duplicate_identifier_0, prototypeSymbol.name));
                }
                symbol.exports[prototypeSymbol.name] = prototypeSymbol;
                prototypeSymbol.parent = symbol;
            }
            return symbol;
        }
        function isAmbientContext(node) {
            while (node) {
                if (node.flags & 2 /* Ambient */)
                    return true;
                node = node.parent;
            }
            return false;
        }
        function declareModuleMember(node, symbolKind, symbolExcludes) {
            // Exported module members are given 2 symbols: A local symbol that is classified with an ExportValue,
            // ExportType, or ExportContainer flag, and an associated export symbol with all the correct flags set
            // on it. There are 2 main reasons:
            //
            //   1. We treat locals and exports of the same name as mutually exclusive within a container.
            //      That means the binder will issue a Duplicate Identifier error if you mix locals and exports
            //      with the same name in the same container.
            //      TODO: Make this a more specific error and decouple it from the exclusion logic.
            //   2. When we checkIdentifier in the checker, we set its resolved symbol to the local symbol,
            //      but return the export symbol (by calling getExportSymbolOfValueSymbolIfExported). That way
            //      when the emitter comes back to it, it knows not to qualify the name if it was found in a containing scope.
            var exportKind = 0;
            if (symbolKind & ts.SymbolFlags.Value) {
                exportKind |= 524288 /* ExportValue */;
            }
            if (symbolKind & ts.SymbolFlags.Type) {
                exportKind |= 1048576 /* ExportType */;
            }
            if (symbolKind & ts.SymbolFlags.Namespace) {
                exportKind |= 2097152 /* ExportNamespace */;
            }
            if (node.flags & 1 /* Export */ || (node.kind !== 174 /* ImportDeclaration */ && isAmbientContext(container))) {
                if (exportKind) {
                    var local = declareSymbol(container.locals, undefined, node, exportKind, symbolExcludes);
                    local.exportSymbol = declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                    node.localSymbol = local;
                }
                else {
                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                }
            }
            else {
                declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);
            }
        }
        // All container nodes are kept on a linked list in declaration order. This list is used by the getLocalNameOfContainer function
        // in the type checker to validate that the local name used for a container is unique.
        function bindChildren(node, symbolKind) {
            if (symbolKind & ts.SymbolFlags.HasLocals) {
                node.locals = {};
            }
            var saveParent = parent;
            var saveContainer = container;
            parent = node;
            if (symbolKind & ts.SymbolFlags.IsContainer) {
                container = node;
                // If container is not on container list, add it to the list
                if (lastContainer !== container && !container.nextContainer) {
                    if (lastContainer) {
                        lastContainer.nextContainer = container;
                    }
                    lastContainer = container;
                }
            }
            ts.forEachChild(node, bind);
            container = saveContainer;
            parent = saveParent;
        }
        function bindDeclaration(node, symbolKind, symbolExcludes) {
            switch (container.kind) {
                case 172 /* ModuleDeclaration */:
                    declareModuleMember(node, symbolKind, symbolExcludes);
                    break;
                case 177 /* SourceFile */:
                    if (ts.isExternalModule(container)) {
                        declareModuleMember(node, symbolKind, symbolExcludes);
                        break;
                    }
                case 120 /* CallSignature */:
                case 121 /* ConstructSignature */:
                case 122 /* IndexSignature */:
                case 116 /* Method */:
                case 117 /* Constructor */:
                case 118 /* GetAccessor */:
                case 119 /* SetAccessor */:
                case 167 /* FunctionDeclaration */:
                case 136 /* FunctionExpression */:
                case 137 /* ArrowFunction */:
                    declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);
                    break;
                case 169 /* ClassDeclaration */:
                    if (node.flags & 64 /* Static */) {
                        declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                        break;
                    }
                case 125 /* TypeLiteral */:
                case 128 /* ObjectLiteral */:
                case 170 /* InterfaceDeclaration */:
                    declareSymbol(container.symbol.members, container.symbol, node, symbolKind, symbolExcludes);
                    break;
                case 171 /* EnumDeclaration */:
                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                    break;
            }
            bindChildren(node, symbolKind);
        }
        function bindConstructorDeclaration(node) {
            bindDeclaration(node, 4096 /* Constructor */, 0);
            ts.forEach(node.parameters, function (p) {
                if (p.flags & (16 /* Public */ | 32 /* Private */)) {
                    bindDeclaration(p, 2 /* Property */, ts.SymbolFlags.PropertyExcludes);
                }
            });
        }
        function bindModuleDeclaration(node) {
            if (node.name.kind === 3 /* StringLiteral */) {
                bindDeclaration(node, 128 /* ValueModule */, ts.SymbolFlags.ValueModuleExcludes);
            }
            else if (isInstantiated(node)) {
                bindDeclaration(node, 128 /* ValueModule */, ts.SymbolFlags.ValueModuleExcludes);
            }
            else {
                bindDeclaration(node, 256 /* NamespaceModule */, 0 /* NamespaceModuleExcludes */);
            }
        }
        function bindAnonymousDeclaration(node, symbolKind, name) {
            var symbol = createSymbol(symbolKind, name);
            addDeclarationToSymbol(symbol, node, symbolKind);
            bindChildren(node, symbolKind);
        }
        function bindCatchVariableDeclaration(node) {
            var symbol = createSymbol(1 /* Variable */, node.variable.text || "__missing");
            addDeclarationToSymbol(symbol, node, 1 /* Variable */);
            var saveParent = parent;
            parent = node;
            ts.forEachChild(node, bind);
            parent = saveParent;
        }
        function bind(node) {
            node.parent = parent;
            switch (node.kind) {
                case 113 /* TypeParameter */:
                    bindDeclaration(node, 262144 /* TypeParameter */, ts.SymbolFlags.TypeParameterExcludes);
                    break;
                case 114 /* Parameter */:
                    bindDeclaration(node, 1 /* Variable */, ts.SymbolFlags.ParameterExcludes);
                    break;
                case 166 /* VariableDeclaration */:
                    bindDeclaration(node, 1 /* Variable */, ts.SymbolFlags.VariableExcludes);
                    break;
                case 115 /* Property */:
                case 129 /* PropertyAssignment */:
                    bindDeclaration(node, 2 /* Property */, ts.SymbolFlags.PropertyExcludes);
                    break;
                case 176 /* EnumMember */:
                    bindDeclaration(node, 4 /* EnumMember */, ts.SymbolFlags.EnumMemberExcludes);
                    break;
                case 120 /* CallSignature */:
                    bindDeclaration(node, 32768 /* CallSignature */, 0);
                    break;
                case 116 /* Method */:
                    bindDeclaration(node, 2048 /* Method */, ts.SymbolFlags.MethodExcludes);
                    break;
                case 121 /* ConstructSignature */:
                    bindDeclaration(node, 65536 /* ConstructSignature */, 0);
                    break;
                case 122 /* IndexSignature */:
                    bindDeclaration(node, 131072 /* IndexSignature */, 0);
                    break;
                case 167 /* FunctionDeclaration */:
                    bindDeclaration(node, 8 /* Function */, ts.SymbolFlags.FunctionExcludes);
                    break;
                case 117 /* Constructor */:
                    bindConstructorDeclaration(node);
                    break;
                case 118 /* GetAccessor */:
                    bindDeclaration(node, 8192 /* GetAccessor */, ts.SymbolFlags.GetAccessorExcludes);
                    break;
                case 119 /* SetAccessor */:
                    bindDeclaration(node, 16384 /* SetAccessor */, ts.SymbolFlags.SetAccessorExcludes);
                    break;
                case 125 /* TypeLiteral */:
                    bindAnonymousDeclaration(node, 512 /* TypeLiteral */, "__type");
                    break;
                case 128 /* ObjectLiteral */:
                    bindAnonymousDeclaration(node, 1024 /* ObjectLiteral */, "__object");
                    break;
                case 136 /* FunctionExpression */:
                case 137 /* ArrowFunction */:
                    bindAnonymousDeclaration(node, 8 /* Function */, "__function");
                    break;
                case 163 /* CatchBlock */:
                    bindCatchVariableDeclaration(node);
                    break;
                case 169 /* ClassDeclaration */:
                    bindDeclaration(node, 16 /* Class */, ts.SymbolFlags.ClassExcludes);
                    break;
                case 170 /* InterfaceDeclaration */:
                    bindDeclaration(node, 32 /* Interface */, ts.SymbolFlags.InterfaceExcludes);
                    break;
                case 171 /* EnumDeclaration */:
                    bindDeclaration(node, 64 /* Enum */, ts.SymbolFlags.EnumExcludes);
                    break;
                case 172 /* ModuleDeclaration */:
                    bindModuleDeclaration(node);
                    break;
                case 174 /* ImportDeclaration */:
                    bindDeclaration(node, 4194304 /* Import */, ts.SymbolFlags.ImportExcludes);
                    break;
                case 177 /* SourceFile */:
                    if (ts.isExternalModule(node)) {
                        bindAnonymousDeclaration(node, 128 /* ValueModule */, '"' + ts.getModuleNameFromFilename(node.filename) + '"');
                        break;
                    }
                default:
                    var saveParent = parent;
                    parent = node;
                    ts.forEachChild(node, bind);
                    parent = saveParent;
            }
        }
    }
    ts.bindSourceFile = bindSourceFile;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
var ts;
(function (ts) {
    var indentStrings = ["", "    "];
    function getIndentString(level) {
        if (indentStrings[level] === undefined) {
            indentStrings[level] = getIndentString(level - 1) + indentStrings[1];
        }
        return indentStrings[level];
    }
    function getIndentSize() {
        return indentStrings[1].length;
    }
    function emitFiles(resolver) {
        var program = resolver.getProgram();
        var compilerHost = program.getCompilerHost();
        var compilerOptions = program.getCompilerOptions();
        var sourceMapDataList = compilerOptions.sourceMap ? [] : undefined;
        var diagnostics = [];
        var newLine = program.getCompilerHost().getNewLine();
        function getSourceFilePathInNewDir(newDirPath, sourceFile) {
            var sourceFilePath = ts.getNormalizedPathFromPathCompoments(ts.getNormalizedPathComponents(sourceFile.filename, compilerHost.getCurrentDirectory()));
            sourceFilePath = sourceFilePath.replace(program.getCommonSourceDirectory(), "");
            return ts.combinePaths(newDirPath, sourceFilePath);
        }
        function shouldEmitToOwnFile(sourceFile) {
            if (!(sourceFile.flags & 512 /* DeclarationFile */)) {
                if ((ts.isExternalModule(sourceFile) || !compilerOptions.out) && !ts.fileExtensionIs(sourceFile.filename, ".js")) {
                    return true;
                }
            }
        }
        function getOwnEmitOutputFilePath(sourceFile, extension) {
            if (program.getCompilerOptions().outDir) {
                var emitOutputFilePathWithoutExtension = ts.getModuleNameFromFilename(getSourceFilePathInNewDir(program.getCompilerOptions().outDir, sourceFile));
            }
            else {
                var emitOutputFilePathWithoutExtension = ts.getModuleNameFromFilename(sourceFile.filename);
            }
            return emitOutputFilePathWithoutExtension + extension;
        }
        function isExternalModuleOrDeclarationFile(sourceFile) {
            return ts.isExternalModule(sourceFile) || (sourceFile.flags & 512 /* DeclarationFile */) !== 0;
        }
        function getFirstConstructorWithBody(node) {
            return ts.forEach(node.members, function (member) {
                if (member.kind === 117 /* Constructor */ && member.body) {
                    return member;
                }
            });
        }
        function getAllAccessorDeclarations(node, accessor) {
            var firstAccessor;
            var getAccessor;
            var setAccessor;
            ts.forEach(node.members, function (member) {
                if ((member.kind === 118 /* GetAccessor */ || member.kind === 119 /* SetAccessor */) && member.name.text === accessor.name.text && (member.flags & 64 /* Static */) === (accessor.flags & 64 /* Static */)) {
                    if (!firstAccessor) {
                        firstAccessor = member;
                    }
                    if (member.kind === 118 /* GetAccessor */ && !getAccessor) {
                        getAccessor = member;
                    }
                    if (member.kind === 119 /* SetAccessor */ && !setAccessor) {
                        setAccessor = member;
                    }
                }
            });
            return {
                firstAccessor: firstAccessor,
                getAccessor: getAccessor,
                setAccessor: setAccessor
            };
        }
        function createTextWriter(writeSymbol) {
            var output = "";
            var indent = 0;
            var lineStart = true;
            var lineCount = 0;
            var linePos = 0;
            function write(s) {
                if (s && s.length) {
                    if (lineStart) {
                        output += getIndentString(indent);
                        lineStart = false;
                    }
                    output += s;
                }
            }
            function rawWrite(s) {
                if (s !== undefined) {
                    if (lineStart) {
                        lineStart = false;
                    }
                    output += s;
                }
            }
            function writeLiteral(s) {
                if (s && s.length) {
                    write(s);
                    var pos = 0;
                    while (pos < s.length) {
                        switch (s.charCodeAt(pos++)) {
                            case 13 /* carriageReturn */:
                                if (pos < s.length && s.charCodeAt(pos) === 10 /* lineFeed */) {
                                    pos++;
                                }
                            case 10 /* lineFeed */:
                                lineCount++;
                                linePos = output.length - s.length + pos;
                                break;
                        }
                    }
                }
            }
            function writeLine() {
                if (!lineStart) {
                    output += newLine;
                    lineCount++;
                    linePos = output.length;
                    lineStart = true;
                }
            }
            return {
                write: write,
                writeSymbol: writeSymbol,
                rawWrite: rawWrite,
                writeLiteral: writeLiteral,
                writeLine: writeLine,
                increaseIndent: function () { return indent++; },
                decreaseIndent: function () { return indent--; },
                getIndent: function () { return indent; },
                getTextPos: function () { return output.length; },
                getLine: function () { return lineCount + 1; },
                getColumn: function () { return lineStart ? indent * getIndentSize() + 1 : output.length - linePos + 1; },
                getText: function () { return output; }
            };
        }
        // Get source text of node in the current source file. Unlike getSourceTextOfNode this function
        // doesn't walk the parent chain to find the containing source file, rather it assumes the node is
        // in the source file currently being processed.
        var currentSourceFile;
        function getSourceTextOfLocalNode(node) {
            var text = currentSourceFile.text;
            return text.substring(ts.skipTrivia(text, node.pos), node.end);
        }
        function getLineOfLocalPosition(pos) {
            return currentSourceFile.getLineAndCharacterFromPosition(pos).line;
        }
        function writeFile(filename, data, writeByteOrderMark) {
            compilerHost.writeFile(filename, data, writeByteOrderMark, function (hostErrorMessage) {
                diagnostics.push(ts.createCompilerDiagnostic(ts.Diagnostics.Could_not_write_file_0_Colon_1, filename, hostErrorMessage));
            });
        }
        function emitComments(comments, trailingSeparator, writer, writeComment) {
            var emitLeadingSpace = !trailingSeparator;
            ts.forEach(comments, function (comment) {
                if (emitLeadingSpace) {
                    writer.write(" ");
                    emitLeadingSpace = false;
                }
                writeComment(comment, writer);
                if (comment.hasTrailingNewLine) {
                    writer.writeLine();
                }
                else if (trailingSeparator) {
                    writer.write(" ");
                }
                else {
                    // Emit leading space to separate comment during next comment emit
                    emitLeadingSpace = true;
                }
            });
        }
        function emitNewLineBeforeLeadingComments(node, leadingComments, writer) {
            // If the leading comments start on different line than the start of node, write new line
            if (leadingComments && leadingComments.length && node.pos !== leadingComments[0].pos && getLineOfLocalPosition(node.pos) !== getLineOfLocalPosition(leadingComments[0].pos)) {
                writer.writeLine();
            }
        }
        function writeCommentRange(comment, writer) {
            if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */) {
                var firstCommentLineAndCharacter = currentSourceFile.getLineAndCharacterFromPosition(comment.pos);
                var firstCommentLineIndent;
                for (var pos = comment.pos, currentLine = firstCommentLineAndCharacter.line; pos < comment.end; currentLine++) {
                    var nextLineStart = currentSourceFile.getPositionFromLineAndCharacter(currentLine + 1, 1);
                    if (pos !== comment.pos) {
                        // If we are not emitting first line, we need to write the spaces to adjust the alignment
                        if (firstCommentLineIndent === undefined) {
                            firstCommentLineIndent = calculateIndent(currentSourceFile.getPositionFromLineAndCharacter(firstCommentLineAndCharacter.line, 1), comment.pos);
                        }
                        // These are number of spaces writer is going to write at current indent
                        var currentWriterIndentSpacing = writer.getIndent() * getIndentSize();
                        // Number of spaces we want to be writing
                        // eg: Assume writer indent
                        // module m {
                        //         /* starts at character 9 this is line 1
                        //    * starts at character pos 4 line                        --1  = 8 - 8 + 3
                        //   More left indented comment */                            --2  = 8 - 8 + 2
                        //     class c { }
                        // }
                        // module m {
                        //     /* this is line 1 -- Assume current writer indent 8
                        //      * line                                                --3 = 8 - 4 + 5
                        //            More right indented comment */                  --4 = 8 - 4 + 11
                        //     class c { }
                        // }
                        var spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(pos, nextLineStart);
                        if (spacesToEmit > 0) {
                            var numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();
                            var indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());
                            // Write indent size string ( in eg 1: = "", 2: "" , 3: string with 8 spaces 4: string with 12 spaces
                            writer.rawWrite(indentSizeSpaceString);
                            while (numberOfSingleSpacesToEmit) {
                                writer.rawWrite(" ");
                                numberOfSingleSpacesToEmit--;
                            }
                        }
                        else {
                            // No spaces to emit write empty string
                            writer.rawWrite("");
                        }
                    }
                    // Write the comment line text
                    writeTrimmedCurrentLine(pos, nextLineStart);
                    pos = nextLineStart;
                }
            }
            else {
                // Single line comment of styly //....
                writer.write(currentSourceFile.text.substring(comment.pos, comment.end));
            }
            function writeTrimmedCurrentLine(pos, nextLineStart) {
                var end = Math.min(comment.end, nextLineStart - 1);
                var currentLineText = currentSourceFile.text.substring(pos, end).replace(/^\s+|\s+$/g, '');
                if (currentLineText) {
                    // trimmed forward and ending spaces text
                    writer.write(currentLineText);
                    if (end !== comment.end) {
                        writer.writeLine();
                    }
                }
                else {
                    // Empty string - make sure we write empty line
                    writer.writeLiteral(newLine);
                }
            }
            function calculateIndent(pos, end) {
                var currentLineIndent = 0;
                while (pos < end && ts.isWhiteSpace(currentSourceFile.text.charCodeAt(pos))) {
                    pos++;
                    if (currentSourceFile.text.charCodeAt(pos) === 9 /* tab */) {
                        // Tabs = size of the indent
                        currentLineIndent += getIndentSize();
                    }
                    else {
                        // Single space
                        currentLineIndent++;
                    }
                }
                return currentLineIndent;
            }
        }
        function emitJavaScript(jsFilePath, root) {
            var writer = createTextWriter(writeSymbol);
            var write = writer.write;
            var writeLine = writer.writeLine;
            var increaseIndent = writer.increaseIndent;
            var decreaseIndent = writer.decreaseIndent;
            var extendsEmitted = false;
            /** write emitted output to disk*/
            var writeEmittedFiles = writeJavaScriptFile;
            /** Emit leading comments of the node */
            var emitLeadingComments = compilerOptions.removeComments ? function (node) {
            } : emitLeadingDeclarationComments;
            /** Emit Trailing comments of the node */
            var emitTrailingComments = compilerOptions.removeComments ? function (node) {
            } : emitTrailingDeclarationComments;
            var emitLeadingCommentsOfPosition = compilerOptions.removeComments ? function (pos) {
            } : emitLeadingCommentsOfLocalPosition;
            var detachedCommentsInfo;
            /** Emit detached comments of the node */
            var emitDetachedComments = compilerOptions.removeComments ? function (node) {
            } : emitDetachedCommentsAtPosition;
            /** Emits /// or pinned which is comment starting with /*! comments */
            var emitPinnedOrTripleSlashComments = compilerOptions.removeComments ? function (node) {
            } : emitPinnedOrTripleSlashCommentsOfNode;
            var writeComment = writeCommentRange;
            /** Emit a node */
            var emit = emitNode;
            /** Called just before starting emit of a node */
            var emitStart = function (node) {
            };
            /** Called once the emit of the node is done */
            var emitEnd = function (node) {
            };
            /** Emit the text for the given token that comes after startPos
              * This by default writes the text provided with the given tokenKind
              * but if optional emitFn callback is provided the text is emitted using the callback instead of default text
              * @param tokenKind the kind of the token to search and emit
              * @param startPos the position in the source to start searching for the token
              * @param emitFn if given will be invoked to emit the text instead of actual token emit */
            var emitToken = emitTokenText;
            /** Called to before starting the lexical scopes as in function/class in the emitted code because of node
              * @param scopeDeclaration node that starts the lexical scope
              * @param scopeName Optional name of this scope instead of deducing one from the declaration node */
            var scopeEmitStart = function (scopeDeclaration, scopeName) {
            };
            /** Called after coming out of the scope */
            var scopeEmitEnd = function () {
            };
            /** Sourcemap data that will get encoded */
            var sourceMapData;
            function writeSymbol(symbol, enclosingDeclaration, meaning) {
            }
            function initializeEmitterWithSourceMaps() {
                var sourceMapDir; // The directory in which sourcemap will be
                // Current source map file and its index in the sources list
                var sourceMapSourceIndex = -1;
                // Names and its index map
                var sourceMapNameIndexMap = {};
                var sourceMapNameIndices = [];
                function getSourceMapNameIndex() {
                    return sourceMapNameIndices.length ? sourceMapNameIndices[sourceMapNameIndices.length - 1] : -1;
                }
                // Last recorded and encoded spans
                var lastRecordedSourceMapSpan;
                var lastEncodedSourceMapSpan = {
                    emittedLine: 1,
                    emittedColumn: 1,
                    sourceLine: 1,
                    sourceColumn: 1,
                    sourceIndex: 0
                };
                var lastEncodedNameIndex = 0;
                // Encoding for sourcemap span
                function encodeLastRecordedSourceMapSpan() {
                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {
                        return;
                    }
                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;
                    // Line/Comma deliminators
                    if (lastEncodedSourceMapSpan.emittedLine == lastRecordedSourceMapSpan.emittedLine) {
                        // Emit comma to separate the entry
                        if (sourceMapData.sourceMapMappings) {
                            sourceMapData.sourceMapMappings += ",";
                        }
                    }
                    else {
                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {
                            sourceMapData.sourceMapMappings += ";";
                        }
                        prevEncodedEmittedColumn = 1;
                    }
                    // 1. Relative Column 0 based
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);
                    // 2. Relative sourceIndex
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);
                    // 3. Relative sourceLine 0 based
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);
                    // 4. Relative sourceColumn 0 based
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);
                    // 5. Relative namePosition 0 based
                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {
                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);
                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;
                    }
                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;
                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);
                    function base64VLQFormatEncode(inValue) {
                        function base64FormatEncode(inValue) {
                            if (inValue < 64) {
                                return 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.charAt(inValue);
                            }
                            throw TypeError(inValue + ": not a 64 based value");
                        }
                        // Add a new least significant bit that has the sign of the value.
                        // if negative number the least significant bit that gets added to the number has value 1
                        // else least significant bit value that gets added is 0
                        // eg. -1 changes to binary : 01 [1] => 3
                        //     +1 changes to binary : 01 [0] => 2
                        if (inValue < 0) {
                            inValue = ((-inValue) << 1) + 1;
                        }
                        else {
                            inValue = inValue << 1;
                        }
                        // Encode 5 bits at a time starting from least significant bits
                        var encodedStr = "";
                        do {
                            var currentDigit = inValue & 31; // 11111
                            inValue = inValue >> 5;
                            if (inValue > 0) {
                                // There are still more digits to decode, set the msb (6th bit)
                                currentDigit = currentDigit | 32;
                            }
                            encodedStr = encodedStr + base64FormatEncode(currentDigit);
                        } while (inValue > 0);
                        return encodedStr;
                    }
                }
                function recordSourceMapSpan(pos) {
                    var sourceLinePos = currentSourceFile.getLineAndCharacterFromPosition(pos);
                    var emittedLine = writer.getLine();
                    var emittedColumn = writer.getColumn();
                    // If this location wasnt recorded or the location in source is going backwards, record the span
                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan.emittedLine != emittedLine || lastRecordedSourceMapSpan.emittedColumn != emittedColumn || (lastRecordedSourceMapSpan.sourceIndex === sourceMapSourceIndex && (lastRecordedSourceMapSpan.sourceLine > sourceLinePos.line || (lastRecordedSourceMapSpan.sourceLine === sourceLinePos.line && lastRecordedSourceMapSpan.sourceColumn > sourceLinePos.character)))) {
                        // Encode the last recordedSpan before assigning new
                        encodeLastRecordedSourceMapSpan();
                        // New span
                        lastRecordedSourceMapSpan = {
                            emittedLine: emittedLine,
                            emittedColumn: emittedColumn,
                            sourceLine: sourceLinePos.line,
                            sourceColumn: sourceLinePos.character,
                            nameIndex: getSourceMapNameIndex(),
                            sourceIndex: sourceMapSourceIndex
                        };
                    }
                    else {
                        // Take the new pos instead since there is no change in emittedLine and column since last location
                        lastRecordedSourceMapSpan.sourceLine = sourceLinePos.line;
                        lastRecordedSourceMapSpan.sourceColumn = sourceLinePos.character;
                        lastRecordedSourceMapSpan.sourceIndex = sourceMapSourceIndex;
                    }
                }
                function recordEmitNodeStartSpan(node) {
                    // Get the token pos after skipping to the token (ignoring the leading trivia)
                    recordSourceMapSpan(ts.skipTrivia(currentSourceFile.text, node.pos));
                }
                function recordEmitNodeEndSpan(node) {
                    recordSourceMapSpan(node.end);
                }
                function writeTextWithSpanRecord(tokenKind, startPos, emitFn) {
                    var tokenStartPos = ts.skipTrivia(currentSourceFile.text, startPos);
                    recordSourceMapSpan(tokenStartPos);
                    var tokenEndPos = emitTokenText(tokenKind, tokenStartPos, emitFn);
                    recordSourceMapSpan(tokenEndPos);
                    return tokenEndPos;
                }
                function recordNewSourceFileStart(node) {
                    // Add the the file to tsFilePaths
                    // If sourceroot option: Use the relative path corresponding to the common directory path
                    // otherwise source locations relative to map file location
                    var sourcesDirectoryPath = compilerOptions.sourceRoot ? program.getCommonSourceDirectory() : sourceMapDir;
                    sourceMapData.sourceMapSources.push(ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, node.filename, compilerHost.getCurrentDirectory(), true));
                    sourceMapSourceIndex = sourceMapData.sourceMapSources.length - 1;
                    // The one that can be used from program to get the actual source file
                    sourceMapData.inputSourceFileNames.push(node.filename);
                }
                function recordScopeNameOfNode(node, scopeName) {
                    function recordScopeNameIndex(scopeNameIndex) {
                        sourceMapNameIndices.push(scopeNameIndex);
                    }
                    function recordScopeNameStart(scopeName) {
                        var scopeNameIndex = -1;
                        if (scopeName) {
                            var parentIndex = getSourceMapNameIndex();
                            if (parentIndex !== -1) {
                                scopeName = sourceMapData.sourceMapNames[parentIndex] + "." + scopeName;
                            }
                            scopeNameIndex = ts.getProperty(sourceMapNameIndexMap, scopeName);
                            if (scopeNameIndex === undefined) {
                                scopeNameIndex = sourceMapData.sourceMapNames.length;
                                sourceMapData.sourceMapNames.push(scopeName);
                                sourceMapNameIndexMap[scopeName] = scopeNameIndex;
                            }
                        }
                        recordScopeNameIndex(scopeNameIndex);
                    }
                    if (scopeName) {
                        // The scope was already given a name  use it
                        recordScopeNameStart(scopeName);
                    }
                    else if (node.kind === 167 /* FunctionDeclaration */ || node.kind === 136 /* FunctionExpression */ || node.kind === 116 /* Method */ || node.kind === 118 /* GetAccessor */ || node.kind === 119 /* SetAccessor */ || node.kind === 172 /* ModuleDeclaration */ || node.kind === 169 /* ClassDeclaration */ || node.kind === 171 /* EnumDeclaration */) {
                        // Declaration and has associated name use it
                        if (node.name) {
                            scopeName = node.name.text;
                        }
                        recordScopeNameStart(scopeName);
                    }
                    else {
                        // Block just use the name from upper level scope
                        recordScopeNameIndex(getSourceMapNameIndex());
                    }
                }
                function recordScopeNameEnd() {
                    sourceMapNameIndices.pop();
                }
                ;
                function writeCommentRangeWithMap(comment, writer) {
                    recordSourceMapSpan(comment.pos);
                    writeCommentRange(comment, writer);
                    recordSourceMapSpan(comment.end);
                }
                function writeJavaScriptAndSourceMapFile(emitOutput, writeByteOrderMark) {
                    // Write source map file
                    encodeLastRecordedSourceMapSpan();
                    writeFile(sourceMapData.sourceMapFilePath, JSON.stringify({
                        version: 3,
                        file: sourceMapData.sourceMapFile,
                        sourceRoot: sourceMapData.sourceMapSourceRoot,
                        sources: sourceMapData.sourceMapSources,
                        names: sourceMapData.sourceMapNames,
                        mappings: sourceMapData.sourceMapMappings
                    }), false);
                    sourceMapDataList.push(sourceMapData);
                    // Write sourcemap url to the js file and write the js file
                    writeJavaScriptFile(emitOutput + "//# sourceMappingURL=" + sourceMapData.jsSourceMappingURL, writeByteOrderMark);
                }
                // Initialize source map data
                var sourceMapJsFile = ts.getBaseFilename(ts.normalizeSlashes(jsFilePath));
                sourceMapData = {
                    sourceMapFilePath: jsFilePath + ".map",
                    jsSourceMappingURL: sourceMapJsFile + ".map",
                    sourceMapFile: sourceMapJsFile,
                    sourceMapSourceRoot: compilerOptions.sourceRoot || "",
                    sourceMapSources: [],
                    inputSourceFileNames: [],
                    sourceMapNames: [],
                    sourceMapMappings: "",
                    sourceMapDecodedMappings: []
                };
                // Normalize source root and make sure it has trailing "/" so that it can be used to combine paths with the
                // relative paths of the sources list in the sourcemap
                sourceMapData.sourceMapSourceRoot = ts.normalizeSlashes(sourceMapData.sourceMapSourceRoot);
                if (sourceMapData.sourceMapSourceRoot.length && sourceMapData.sourceMapSourceRoot.charCodeAt(sourceMapData.sourceMapSourceRoot.length - 1) !== 47 /* slash */) {
                    sourceMapData.sourceMapSourceRoot += ts.directorySeparator;
                }
                if (compilerOptions.mapRoot) {
                    sourceMapDir = ts.normalizeSlashes(compilerOptions.mapRoot);
                    if (root) {
                        // For modules or multiple emit files the mapRoot will have directory structure like the sources
                        // So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
                        sourceMapDir = ts.getDirectoryPath(getSourceFilePathInNewDir(sourceMapDir, root));
                    }
                    if (!ts.isRootedDiskPath(sourceMapDir) && !ts.isUrl(sourceMapDir)) {
                        // The relative paths are relative to the common directory
                        sourceMapDir = ts.combinePaths(program.getCommonSourceDirectory(), sourceMapDir);
                        sourceMapData.jsSourceMappingURL = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(jsFilePath)), ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL), compilerHost.getCurrentDirectory(), true);
                    }
                    else {
                        sourceMapData.jsSourceMappingURL = ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL);
                    }
                }
                else {
                    sourceMapDir = ts.getDirectoryPath(ts.normalizePath(jsFilePath));
                }
                function emitNodeWithMap(node) {
                    if (node) {
                        if (node.kind != 177 /* SourceFile */) {
                            recordEmitNodeStartSpan(node);
                            emitNode(node);
                            recordEmitNodeEndSpan(node);
                        }
                        else {
                            recordNewSourceFileStart(node);
                            emitNode(node);
                        }
                    }
                }
                writeEmittedFiles = writeJavaScriptAndSourceMapFile;
                emit = emitNodeWithMap;
                emitStart = recordEmitNodeStartSpan;
                emitEnd = recordEmitNodeEndSpan;
                emitToken = writeTextWithSpanRecord;
                scopeEmitStart = recordScopeNameOfNode;
                scopeEmitEnd = recordScopeNameEnd;
                writeComment = writeCommentRangeWithMap;
            }
            function writeJavaScriptFile(emitOutput, writeByteOrderMark) {
                writeFile(jsFilePath, emitOutput, writeByteOrderMark);
            }
            function emitTokenText(tokenKind, startPos, emitFn) {
                var tokenString = ts.tokenToString(tokenKind);
                if (emitFn) {
                    emitFn();
                }
                else {
                    write(tokenString);
                }
                return startPos + tokenString.length;
            }
            function emitOptional(prefix, node) {
                if (node) {
                    write(prefix);
                    emit(node);
                }
            }
            function emitCommaList(nodes, count) {
                if (!(count >= 0))
                    count = nodes.length;
                if (nodes) {
                    for (var i = 0; i < count; i++) {
                        if (i)
                            write(", ");
                        emit(nodes[i]);
                    }
                }
            }
            function emitMultiLineList(nodes) {
                if (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i)
                            write(",");
                        writeLine();
                        emit(nodes[i]);
                    }
                }
            }
            function emitLines(nodes) {
                emitLinesStartingAt(nodes, 0);
            }
            function emitLinesStartingAt(nodes, startIndex) {
                for (var i = startIndex; i < nodes.length; i++) {
                    writeLine();
                    emit(nodes[i]);
                }
            }
            function emitLiteral(node) {
                var text = getSourceTextOfLocalNode(node);
                if (node.kind === 3 /* StringLiteral */ && compilerOptions.sourceMap) {
                    writer.writeLiteral(text);
                }
                else {
                    write(text);
                }
            }
            // This function specifically handles numeric/string literals for enum and accessor 'identifiers'.
            // In a sense, it does not actually emit identifiers as much as it declares a name for a specific property.
            function emitQuotedIdentifier(node) {
                if (node.kind === 3 /* StringLiteral */) {
                    emitLiteral(node);
                }
                else {
                    write("\"");
                    if (node.kind === 2 /* NumericLiteral */) {
                        write(node.text);
                    }
                    else {
                        write(getSourceTextOfLocalNode(node));
                    }
                    write("\"");
                }
            }
            function isNonExpressionIdentifier(node) {
                var parent = node.parent;
                switch (parent.kind) {
                    case 114 /* Parameter */:
                    case 166 /* VariableDeclaration */:
                    case 115 /* Property */:
                    case 129 /* PropertyAssignment */:
                    case 176 /* EnumMember */:
                    case 116 /* Method */:
                    case 167 /* FunctionDeclaration */:
                    case 118 /* GetAccessor */:
                    case 119 /* SetAccessor */:
                    case 136 /* FunctionExpression */:
                    case 169 /* ClassDeclaration */:
                    case 170 /* InterfaceDeclaration */:
                    case 171 /* EnumDeclaration */:
                    case 172 /* ModuleDeclaration */:
                    case 174 /* ImportDeclaration */:
                        return parent.name === node;
                    case 153 /* BreakStatement */:
                    case 152 /* ContinueStatement */:
                    case 175 /* ExportAssignment */:
                        return false;
                    case 159 /* LabelledStatement */:
                        return node.parent.label === node;
                    case 163 /* CatchBlock */:
                        return node.parent.variable === node;
                }
            }
            function emitIdentifier(node) {
                if (!isNonExpressionIdentifier(node)) {
                    var prefix = resolver.getExpressionNamePrefix(node);
                    if (prefix) {
                        write(prefix);
                        write(".");
                    }
                }
                write(getSourceTextOfLocalNode(node));
            }
            function emitThis(node) {
                if (resolver.getNodeCheckFlags(node) & 2 /* LexicalThis */) {
                    write("_this");
                }
                else {
                    write("this");
                }
            }
            function emitSuper(node) {
                var flags = resolver.getNodeCheckFlags(node);
                if (flags & 16 /* SuperInstance */) {
                    write("_super.prototype");
                }
                else if (flags & 32 /* SuperStatic */) {
                    write("_super");
                }
                else {
                    write("super");
                }
            }
            function emitArrayLiteral(node) {
                if (node.flags & 128 /* MultiLine */) {
                    write("[");
                    increaseIndent();
                    emitMultiLineList(node.elements);
                    decreaseIndent();
                    writeLine();
                    write("]");
                }
                else {
                    write("[");
                    emitCommaList(node.elements);
                    write("]");
                }
            }
            function emitObjectLiteral(node) {
                if (!node.properties.length) {
                    write("{}");
                }
                else if (node.flags & 128 /* MultiLine */) {
                    write("{");
                    increaseIndent();
                    emitMultiLineList(node.properties);
                    decreaseIndent();
                    writeLine();
                    write("}");
                }
                else {
                    write("{ ");
                    emitCommaList(node.properties);
                    write(" }");
                }
            }
            function emitPropertyAssignment(node) {
                emitLeadingComments(node);
                emit(node.name);
                write(": ");
                emit(node.initializer);
                emitTrailingComments(node);
            }
            function emitPropertyAccess(node) {
                var text = resolver.getPropertyAccessSubstitution(node);
                if (text) {
                    write(text);
                    return;
                }
                emit(node.left);
                write(".");
                emit(node.right);
            }
            function emitIndexedAccess(node) {
                emit(node.object);
                write("[");
                emit(node.index);
                write("]");
            }
            function emitCallExpression(node) {
                var superCall = false;
                if (node.func.kind === 81 /* SuperKeyword */) {
                    write("_super");
                    superCall = true;
                }
                else {
                    emit(node.func);
                    superCall = node.func.kind === 130 /* PropertyAccess */ && node.func.left.kind === 81 /* SuperKeyword */;
                }
                if (superCall) {
                    write(".call(");
                    emitThis(node.func);
                    if (node.arguments.length) {
                        write(", ");
                        emitCommaList(node.arguments);
                    }
                    write(")");
                }
                else {
                    write("(");
                    emitCommaList(node.arguments);
                    write(")");
                }
            }
            function emitNewExpression(node) {
                write("new ");
                emit(node.func);
                if (node.arguments) {
                    write("(");
                    emitCommaList(node.arguments);
                    write(")");
                }
            }
            function emitParenExpression(node) {
                if (node.expression.kind === 134 /* TypeAssertion */) {
                    var operand = node.expression.operand;
                    while (operand.kind == 134 /* TypeAssertion */) {
                        operand = operand.operand;
                    }
                    // We have an expression of the form: (<Type>SubExpr)
                    // Emitting this as (SubExpr) is really not desirable. We would like to emit the subexpr as is.
                    // Omitting the parentheses, however, could cause change in the semantics of the generated
                    // code if the casted expression has a lower precedence than the rest of the expression, e.g.:
                    //      (<any>new A).foo should be emitted as (new A).foo and not new A.foo
                    //      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()
                    //      new (<any>A()) should be emitted as new (A()) and not new A()
                    //      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()
                    if (operand.kind !== 138 /* PrefixOperator */ && operand.kind !== 139 /* PostfixOperator */ && operand.kind !== 133 /* NewExpression */ && !(operand.kind === 132 /* CallExpression */ && node.parent.kind === 133 /* NewExpression */) && !(operand.kind === 136 /* FunctionExpression */ && node.parent.kind === 132 /* CallExpression */)) {
                        emit(operand);
                        return;
                    }
                }
                write("(");
                emit(node.expression);
                write(")");
            }
            function emitUnaryExpression(node) {
                if (node.kind === 138 /* PrefixOperator */) {
                    write(ts.tokenToString(node.operator));
                }
                // In some cases, we need to emit a space between the operator and the operand. One obvious case
                // is when the operator is an identifer, like delete or typeof. We also need to do this for plus
                // and minus expressions in certain cases. Specifically, consider the following two cases (parens
                // are just for clarity of exposition, and not part of the source code):
                //
                //  (+(+1))
                //  (+(++1))
                //
                // We need to emit a space in both cases. In the first case, the absence of a space will make
                // the resulting expression a prefix increment operation. And in the second, it will make the resulting
                // expression a prefix increment whose operand is a plus expression - (++(+x))
                // The same is true of minus of course.
                if (node.operator >= 55 /* Identifier */) {
                    write(" ");
                }
                else if (node.kind === 138 /* PrefixOperator */ && node.operand.kind === 138 /* PrefixOperator */) {
                    var operand = node.operand;
                    if (node.operator === 24 /* PlusToken */ && (operand.operator === 24 /* PlusToken */ || operand.operator === 29 /* PlusPlusToken */)) {
                        write(" ");
                    }
                    else if (node.operator === 25 /* MinusToken */ && (operand.operator === 25 /* MinusToken */ || operand.operator === 30 /* MinusMinusToken */)) {
                        write(" ");
                    }
                }
                emit(node.operand);
                if (node.kind === 139 /* PostfixOperator */) {
                    write(ts.tokenToString(node.operator));
                }
            }
            function emitBinaryExpression(node) {
                emit(node.left);
                if (node.operator !== 14 /* CommaToken */)
                    write(" ");
                write(ts.tokenToString(node.operator));
                write(" ");
                emit(node.right);
            }
            function emitConditionalExpression(node) {
                emit(node.condition);
                write(" ? ");
                emit(node.whenTrue);
                write(" : ");
                emit(node.whenFalse);
            }
            function emitBlock(node) {
                emitToken(5 /* OpenBraceToken */, node.pos);
                increaseIndent();
                scopeEmitStart(node.parent);
                if (node.kind === 173 /* ModuleBlock */) {
                    ts.Debug.assert(node.parent.kind === 172 /* ModuleDeclaration */);
                    emitCaptureThisForNodeIfNecessary(node.parent);
                }
                emitLines(node.statements);
                decreaseIndent();
                writeLine();
                emitToken(6 /* CloseBraceToken */, node.statements.end);
                scopeEmitEnd();
            }
            function emitEmbeddedStatement(node) {
                if (node.kind === 143 /* Block */) {
                    write(" ");
                    emit(node);
                }
                else {
                    increaseIndent();
                    writeLine();
                    emit(node);
                    decreaseIndent();
                }
            }
            function emitExpressionStatement(node) {
                var isArrowExpression = node.expression.kind === 137 /* ArrowFunction */;
                emitLeadingComments(node);
                if (isArrowExpression)
                    write("(");
                emit(node.expression);
                if (isArrowExpression)
                    write(")");
                write(";");
                emitTrailingComments(node);
            }
            function emitIfStatement(node) {
                emitLeadingComments(node);
                var endPos = emitToken(74 /* IfKeyword */, node.pos);
                write(" ");
                endPos = emitToken(7 /* OpenParenToken */, endPos);
                emit(node.expression);
                emitToken(8 /* CloseParenToken */, node.expression.end);
                emitEmbeddedStatement(node.thenStatement);
                if (node.elseStatement) {
                    writeLine();
                    emitToken(66 /* ElseKeyword */, node.thenStatement.end);
                    if (node.elseStatement.kind === 147 /* IfStatement */) {
                        write(" ");
                        emit(node.elseStatement);
                    }
                    else {
                        emitEmbeddedStatement(node.elseStatement);
                    }
                }
                emitTrailingComments(node);
            }
            function emitDoStatement(node) {
                write("do");
                emitEmbeddedStatement(node.statement);
                if (node.statement.kind === 143 /* Block */) {
                    write(" ");
                }
                else {
                    writeLine();
                }
                write("while (");
                emit(node.expression);
                write(");");
            }
            function emitWhileStatement(node) {
                write("while (");
                emit(node.expression);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitForStatement(node) {
                var endPos = emitToken(72 /* ForKeyword */, node.pos);
                write(" ");
                endPos = emitToken(7 /* OpenParenToken */, endPos);
                if (node.declarations) {
                    emitToken(88 /* VarKeyword */, endPos);
                    write(" ");
                    emitCommaList(node.declarations);
                }
                if (node.initializer) {
                    emit(node.initializer);
                }
                write(";");
                emitOptional(" ", node.condition);
                write(";");
                emitOptional(" ", node.iterator);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitForInStatement(node) {
                var endPos = emitToken(72 /* ForKeyword */, node.pos);
                write(" ");
                endPos = emitToken(7 /* OpenParenToken */, endPos);
                if (node.declaration) {
                    emitToken(88 /* VarKeyword */, endPos);
                    write(" ");
                    emit(node.declaration);
                }
                else {
                    emit(node.variable);
                }
                write(" in ");
                emit(node.expression);
                emitToken(8 /* CloseParenToken */, node.expression.end);
                emitEmbeddedStatement(node.statement);
            }
            function emitBreakOrContinueStatement(node) {
                emitToken(node.kind === 153 /* BreakStatement */ ? 56 /* BreakKeyword */ : 61 /* ContinueKeyword */, node.pos);
                emitOptional(" ", node.label);
                write(";");
            }
            function emitReturnStatement(node) {
                emitLeadingComments(node);
                emitToken(80 /* ReturnKeyword */, node.pos);
                emitOptional(" ", node.expression);
                write(";");
                emitTrailingComments(node);
            }
            function emitWithStatement(node) {
                write("with (");
                emit(node.expression);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitSwitchStatement(node) {
                var endPos = emitToken(82 /* SwitchKeyword */, node.pos);
                write(" ");
                emitToken(7 /* OpenParenToken */, endPos);
                emit(node.expression);
                endPos = emitToken(8 /* CloseParenToken */, node.expression.end);
                write(" ");
                emitToken(5 /* OpenBraceToken */, endPos);
                increaseIndent();
                emitLines(node.clauses);
                decreaseIndent();
                writeLine();
                emitToken(6 /* CloseBraceToken */, node.clauses.end);
            }
            function emitCaseOrDefaultClause(node) {
                if (node.kind === 157 /* CaseClause */) {
                    write("case ");
                    emit(node.expression);
                    write(":");
                }
                else {
                    write("default:");
                }
                increaseIndent();
                emitLines(node.statements);
                decreaseIndent();
            }
            function emitThrowStatement(node) {
                write("throw ");
                emit(node.expression);
                write(";");
            }
            function emitTryStatement(node) {
                write("try ");
                emit(node.tryBlock);
                emit(node.catchBlock);
                if (node.finallyBlock) {
                    writeLine();
                    write("finally ");
                    emit(node.finallyBlock);
                }
            }
            function emitCatchBlock(node) {
                writeLine();
                var endPos = emitToken(58 /* CatchKeyword */, node.pos);
                write(" ");
                emitToken(7 /* OpenParenToken */, endPos);
                emit(node.variable);
                emitToken(8 /* CloseParenToken */, node.variable.end);
                write(" ");
                emitBlock(node);
            }
            function emitDebuggerStatement(node) {
                emitToken(62 /* DebuggerKeyword */, node.pos);
                write(";");
            }
            function emitLabelledStatement(node) {
                emit(node.label);
                write(": ");
                emit(node.statement);
            }
            function getContainingModule(node) {
                do {
                    node = node.parent;
                } while (node && node.kind !== 172 /* ModuleDeclaration */);
                return node;
            }
            function emitModuleMemberName(node) {
                emitStart(node.name);
                if (node.flags & 1 /* Export */) {
                    var container = getContainingModule(node);
                    write(container ? resolver.getLocalNameOfContainer(container) : "exports");
                    write(".");
                }
                emitNode(node.name);
                emitEnd(node.name);
            }
            function emitVariableDeclaration(node) {
                emitLeadingComments(node);
                emitModuleMemberName(node);
                emitOptional(" = ", node.initializer);
                emitTrailingComments(node);
            }
            function emitVariableStatement(node) {
                emitLeadingComments(node);
                if (!(node.flags & 1 /* Export */))
                    write("var ");
                emitCommaList(node.declarations);
                write(";");
                emitTrailingComments(node);
            }
            function emitParameter(node) {
                emitLeadingComments(node);
                emit(node.name);
                emitTrailingComments(node);
            }
            function emitDefaultValueAssignments(node) {
                ts.forEach(node.parameters, function (param) {
                    if (param.initializer) {
                        writeLine();
                        emitStart(param);
                        write("if (");
                        emitNode(param.name);
                        write(" === void 0)");
                        emitEnd(param);
                        write(" { ");
                        emitStart(param);
                        emitNode(param.name);
                        write(" = ");
                        emitNode(param.initializer);
                        emitEnd(param);
                        write("; }");
                    }
                });
            }
            function emitRestParameter(node) {
                if (ts.hasRestParameters(node)) {
                    var restIndex = node.parameters.length - 1;
                    var restParam = node.parameters[restIndex];
                    writeLine();
                    emitLeadingComments(restParam);
                    emitStart(restParam);
                    write("var ");
                    emitNode(restParam.name);
                    write(" = [];");
                    emitEnd(restParam);
                    emitTrailingComments(restParam);
                    writeLine();
                    write("for (");
                    emitStart(restParam);
                    write("var _i = " + restIndex + ";");
                    emitEnd(restParam);
                    write(" ");
                    emitStart(restParam);
                    write("_i < arguments.length;");
                    emitEnd(restParam);
                    write(" ");
                    emitStart(restParam);
                    write("_i++");
                    emitEnd(restParam);
                    write(") {");
                    increaseIndent();
                    writeLine();
                    emitStart(restParam);
                    emitNode(restParam.name);
                    write("[_i - " + restIndex + "] = arguments[_i];");
                    emitEnd(restParam);
                    decreaseIndent();
                    writeLine();
                    write("}");
                }
            }
            function emitAccessor(node) {
                emitLeadingComments(node);
                write(node.kind === 118 /* GetAccessor */ ? "get " : "set ");
                emit(node.name);
                emitSignatureAndBody(node);
                emitTrailingComments(node);
            }
            function emitFunctionDeclaration(node) {
                if (!node.body) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                if (node.kind !== 116 /* Method */) {
                    // Methods will emit the comments as part of emitting method declaration
                    emitLeadingComments(node);
                }
                write("function ");
                if (node.kind === 167 /* FunctionDeclaration */ || (node.kind === 136 /* FunctionExpression */ && node.name)) {
                    emit(node.name);
                }
                emitSignatureAndBody(node);
                if (node.kind !== 116 /* Method */) {
                    emitTrailingComments(node);
                }
            }
            function emitCaptureThisForNodeIfNecessary(node) {
                if (resolver.getNodeCheckFlags(node) & 4 /* CaptureThis */) {
                    writeLine();
                    emitStart(node);
                    write("var _this = this;");
                    emitEnd(node);
                }
            }
            function emitSignatureParameters(node) {
                increaseIndent();
                write("(");
                if (node) {
                    emitCommaList(node.parameters, node.parameters.length - (ts.hasRestParameters(node) ? 1 : 0));
                }
                write(")");
                decreaseIndent();
            }
            function emitSignatureAndBody(node) {
                emitSignatureParameters(node);
                write(" {");
                scopeEmitStart(node);
                increaseIndent();
                emitDetachedComments(node.body.kind === 168 /* FunctionBlock */ ? node.body.statements : node.body);
                var startIndex = 0;
                if (node.body.kind === 168 /* FunctionBlock */) {
                    startIndex = emitDirectivePrologues(node.body.statements, true);
                }
                var outPos = writer.getTextPos();
                emitCaptureThisForNodeIfNecessary(node);
                emitDefaultValueAssignments(node);
                emitRestParameter(node);
                if (node.body.kind !== 168 /* FunctionBlock */ && outPos === writer.getTextPos()) {
                    decreaseIndent();
                    write(" ");
                    emitStart(node.body);
                    write("return ");
                    emitNode(node.body);
                    emitEnd(node.body);
                    write("; ");
                    emitStart(node.body);
                    write("}");
                    emitEnd(node.body);
                }
                else {
                    if (node.body.kind === 168 /* FunctionBlock */) {
                        emitLinesStartingAt(node.body.statements, startIndex);
                    }
                    else {
                        writeLine();
                        emitLeadingComments(node.body);
                        write("return ");
                        emit(node.body);
                        write(";");
                        emitTrailingComments(node.body);
                    }
                    writeLine();
                    if (node.body.kind === 168 /* FunctionBlock */) {
                        emitLeadingCommentsOfPosition(node.body.statements.end);
                        decreaseIndent();
                        emitToken(6 /* CloseBraceToken */, node.body.statements.end);
                    }
                    else {
                        decreaseIndent();
                        emitStart(node.body);
                        write("}");
                        emitEnd(node.body);
                    }
                }
                scopeEmitEnd();
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    emitModuleMemberName(node);
                    write(" = ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
            }
            function findInitialSuperCall(ctor) {
                if (ctor.body) {
                    var statement = ctor.body.statements[0];
                    if (statement && statement.kind === 146 /* ExpressionStatement */) {
                        var expr = statement.expression;
                        if (expr && expr.kind === 132 /* CallExpression */) {
                            var func = expr.func;
                            if (func && func.kind === 81 /* SuperKeyword */) {
                                return statement;
                            }
                        }
                    }
                }
            }
            function emitParameterPropertyAssignments(node) {
                ts.forEach(node.parameters, function (param) {
                    if (param.flags & (16 /* Public */ | 32 /* Private */)) {
                        writeLine();
                        emitStart(param);
                        emitStart(param.name);
                        write("this.");
                        emitNode(param.name);
                        emitEnd(param.name);
                        write(" = ");
                        emit(param.name);
                        write(";");
                        emitEnd(param);
                    }
                });
            }
            function emitMemberAccess(memberName) {
                if (memberName.kind === 3 /* StringLiteral */ || memberName.kind === 2 /* NumericLiteral */) {
                    write("[");
                    emitNode(memberName);
                    write("]");
                }
                else {
                    write(".");
                    emitNode(memberName);
                }
            }
            function emitMemberAssignments(node, staticFlag) {
                ts.forEach(node.members, function (member) {
                    if (member.kind === 115 /* Property */ && (member.flags & 64 /* Static */) === staticFlag && member.initializer) {
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        emitStart(member.name);
                        if (staticFlag) {
                            emitNode(node.name);
                        }
                        else {
                            write("this");
                        }
                        emitMemberAccess(member.name);
                        emitEnd(member.name);
                        write(" = ");
                        emit(member.initializer);
                        write(";");
                        emitEnd(member);
                        emitTrailingComments(member);
                    }
                });
            }
            function emitMemberFunctions(node) {
                ts.forEach(node.members, function (member) {
                    if (member.kind === 116 /* Method */) {
                        if (!member.body) {
                            return emitPinnedOrTripleSlashComments(member);
                        }
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        emitStart(member.name);
                        emitNode(node.name);
                        if (!(member.flags & 64 /* Static */)) {
                            write(".prototype");
                        }
                        emitMemberAccess(member.name);
                        emitEnd(member.name);
                        write(" = ");
                        emitStart(member);
                        emitFunctionDeclaration(member);
                        emitEnd(member);
                        emitEnd(member);
                        write(";");
                        emitTrailingComments(member);
                    }
                    else if (member.kind === 118 /* GetAccessor */ || member.kind === 119 /* SetAccessor */) {
                        var accessors = getAllAccessorDeclarations(node, member);
                        if (member === accessors.firstAccessor) {
                            writeLine();
                            emitStart(member);
                            write("Object.defineProperty(");
                            emitStart(member.name);
                            emitNode(node.name);
                            if (!(member.flags & 64 /* Static */)) {
                                write(".prototype");
                            }
                            write(", ");
                            emitQuotedIdentifier(member.name);
                            emitEnd(member.name);
                            write(", {");
                            increaseIndent();
                            if (accessors.getAccessor) {
                                writeLine();
                                emitLeadingComments(accessors.getAccessor);
                                write("get: ");
                                emitStart(accessors.getAccessor);
                                write("function ");
                                emitSignatureAndBody(accessors.getAccessor);
                                emitEnd(accessors.getAccessor);
                                emitTrailingComments(accessors.getAccessor);
                                write(",");
                            }
                            if (accessors.setAccessor) {
                                writeLine();
                                emitLeadingComments(accessors.setAccessor);
                                write("set: ");
                                emitStart(accessors.setAccessor);
                                write("function ");
                                emitSignatureAndBody(accessors.setAccessor);
                                emitEnd(accessors.setAccessor);
                                emitTrailingComments(accessors.setAccessor);
                                write(",");
                            }
                            writeLine();
                            write("enumerable: true,");
                            writeLine();
                            write("configurable: true");
                            decreaseIndent();
                            writeLine();
                            write("});");
                            emitEnd(member);
                        }
                    }
                });
            }
            function emitClassDeclaration(node) {
                emitLeadingComments(node);
                write("var ");
                emit(node.name);
                write(" = (function (");
                if (node.baseType) {
                    write("_super");
                }
                write(") {");
                increaseIndent();
                scopeEmitStart(node);
                if (node.baseType) {
                    writeLine();
                    emitStart(node.baseType);
                    write("__extends(");
                    emit(node.name);
                    write(", _super);");
                    emitEnd(node.baseType);
                }
                writeLine();
                emitConstructorOfClass();
                emitMemberFunctions(node);
                emitMemberAssignments(node, 64 /* Static */);
                writeLine();
                function emitClassReturnStatement() {
                    write("return ");
                    emitNode(node.name);
                }
                emitToken(6 /* CloseBraceToken */, node.members.end, emitClassReturnStatement);
                write(";");
                decreaseIndent();
                writeLine();
                emitToken(6 /* CloseBraceToken */, node.members.end);
                scopeEmitEnd();
                emitStart(node);
                write(")(");
                if (node.baseType) {
                    emit(node.baseType.typeName);
                }
                write(");");
                emitEnd(node);
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    emitModuleMemberName(node);
                    write(" = ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
                emitTrailingComments(node);
                function emitConstructorOfClass() {
                    // Emit the constructor overload pinned comments
                    ts.forEach(node.members, function (member) {
                        if (member.kind === 117 /* Constructor */ && !member.body) {
                            emitPinnedOrTripleSlashComments(member);
                        }
                    });
                    var ctor = getFirstConstructorWithBody(node);
                    if (ctor) {
                        emitLeadingComments(ctor);
                    }
                    emitStart(ctor || node);
                    write("function ");
                    emit(node.name);
                    emitSignatureParameters(ctor);
                    write(" {");
                    scopeEmitStart(node, "constructor");
                    increaseIndent();
                    if (ctor) {
                        emitDetachedComments(ctor.body.statements);
                    }
                    emitCaptureThisForNodeIfNecessary(node);
                    if (ctor) {
                        emitDefaultValueAssignments(ctor);
                        emitRestParameter(ctor);
                        if (node.baseType) {
                            var superCall = findInitialSuperCall(ctor);
                            if (superCall) {
                                writeLine();
                                emit(superCall);
                            }
                        }
                        emitParameterPropertyAssignments(ctor);
                    }
                    else {
                        if (node.baseType) {
                            writeLine();
                            emitStart(node.baseType);
                            write("_super.apply(this, arguments);");
                            emitEnd(node.baseType);
                        }
                    }
                    emitMemberAssignments(node, 0);
                    if (ctor) {
                        var statements = ctor.body.statements;
                        if (superCall)
                            statements = statements.slice(1);
                        emitLines(statements);
                    }
                    writeLine();
                    if (ctor) {
                        emitLeadingCommentsOfPosition(ctor.body.statements.end);
                    }
                    decreaseIndent();
                    emitToken(6 /* CloseBraceToken */, ctor ? ctor.body.statements.end : node.members.end);
                    scopeEmitEnd();
                    emitEnd(ctor || node);
                    if (ctor) {
                        emitTrailingComments(ctor);
                    }
                }
            }
            function emitInterfaceDeclaration(node) {
                emitPinnedOrTripleSlashComments(node);
            }
            function emitEnumDeclaration(node) {
                emitLeadingComments(node);
                if (!(node.flags & 1 /* Export */)) {
                    emitStart(node);
                    write("var ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
                writeLine();
                emitStart(node);
                write("(function (");
                emitStart(node.name);
                write(resolver.getLocalNameOfContainer(node));
                emitEnd(node.name);
                write(") {");
                increaseIndent();
                scopeEmitStart(node);
                emitEnumMemberDeclarations();
                decreaseIndent();
                writeLine();
                emitToken(6 /* CloseBraceToken */, node.members.end);
                scopeEmitEnd();
                write(")(");
                emitModuleMemberName(node);
                write(" || (");
                emitModuleMemberName(node);
                write(" = {}));");
                emitEnd(node);
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    write("var ");
                    emit(node.name);
                    write(" = ");
                    emitModuleMemberName(node);
                    emitEnd(node);
                    write(";");
                }
                emitTrailingComments(node);
                function emitEnumMemberDeclarations() {
                    ts.forEach(node.members, function (member) {
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        write(resolver.getLocalNameOfContainer(node));
                        write("[");
                        write(resolver.getLocalNameOfContainer(node));
                        write("[");
                        emitQuotedIdentifier(member.name);
                        write("] = ");
                        if (member.initializer) {
                            emit(member.initializer);
                        }
                        else {
                            write(resolver.getEnumMemberValue(member).toString());
                        }
                        write("] = ");
                        emitQuotedIdentifier(member.name);
                        emitEnd(member);
                        write(";");
                        emitTrailingComments(member);
                    });
                }
            }
            function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {
                if (moduleDeclaration.body.kind === 172 /* ModuleDeclaration */) {
                    var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);
                    return recursiveInnerModule || moduleDeclaration.body;
                }
            }
            function emitModuleDeclaration(node) {
                if (!ts.isInstantiated(node)) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                emitLeadingComments(node);
                if (!(node.flags & 1 /* Export */)) {
                    emitStart(node);
                    write("var ");
                    emit(node.name);
                    write(";");
                    emitEnd(node);
                    writeLine();
                }
                emitStart(node);
                write("(function (");
                emitStart(node.name);
                write(resolver.getLocalNameOfContainer(node));
                emitEnd(node.name);
                write(") ");
                if (node.body.kind === 173 /* ModuleBlock */) {
                    emit(node.body);
                }
                else {
                    write("{");
                    increaseIndent();
                    scopeEmitStart(node);
                    emitCaptureThisForNodeIfNecessary(node);
                    writeLine();
                    emit(node.body);
                    decreaseIndent();
                    writeLine();
                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;
                    emitToken(6 /* CloseBraceToken */, moduleBlock.statements.end);
                    scopeEmitEnd();
                }
                write(")(");
                emitModuleMemberName(node);
                write(" || (");
                emitModuleMemberName(node);
                write(" = {}));");
                emitEnd(node);
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    write("var ");
                    emit(node.name);
                    write(" = ");
                    emitModuleMemberName(node);
                    emitEnd(node);
                    write(";");
                }
                emitTrailingComments(node);
            }
            function emitImportDeclaration(node) {
                var emitImportDeclaration = resolver.isReferencedImportDeclaration(node);
                if (!emitImportDeclaration) {
                    // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when
                    // - current file is not external module
                    // - import declaration is top level and target is value imported by entity name
                    emitImportDeclaration = !ts.isExternalModule(currentSourceFile) && resolver.isTopLevelValueImportedViaEntityName(node);
                }
                if (emitImportDeclaration) {
                    if (node.externalModuleName && node.parent.kind === 177 /* SourceFile */ && compilerOptions.module === 2 /* AMD */) {
                        if (node.flags & 1 /* Export */) {
                            writeLine();
                            emitLeadingComments(node);
                            emitStart(node);
                            emitModuleMemberName(node);
                            write(" = ");
                            emit(node.name);
                            write(";");
                            emitEnd(node);
                            emitTrailingComments(node);
                        }
                    }
                    else {
                        writeLine();
                        emitLeadingComments(node);
                        emitStart(node);
                        if (!(node.flags & 1 /* Export */))
                            write("var ");
                        emitModuleMemberName(node);
                        write(" = ");
                        if (node.entityName) {
                            emit(node.entityName);
                        }
                        else {
                            write("require(");
                            emitStart(node.externalModuleName);
                            emitLiteral(node.externalModuleName);
                            emitEnd(node.externalModuleName);
                            emitToken(8 /* CloseParenToken */, node.externalModuleName.end);
                        }
                        write(";");
                        emitEnd(node);
                        emitTrailingComments(node);
                    }
                }
            }
            function getExternalImportDeclarations(node) {
                var result = [];
                ts.forEach(node.statements, function (stat) {
                    if (stat.kind === 174 /* ImportDeclaration */ && stat.externalModuleName && resolver.isReferencedImportDeclaration(stat)) {
                        result.push(stat);
                    }
                });
                return result;
            }
            function getFirstExportAssignment(sourceFile) {
                return ts.forEach(sourceFile.statements, function (node) {
                    if (node.kind === 175 /* ExportAssignment */) {
                        return node;
                    }
                });
            }
            function emitAMDModule(node, startIndex) {
                var imports = getExternalImportDeclarations(node);
                writeLine();
                write("define([\"require\", \"exports\"");
                ts.forEach(imports, function (imp) {
                    write(", ");
                    emitLiteral(imp.externalModuleName);
                });
                ts.forEach(node.amdDependencies, function (amdDependency) {
                    var text = "\"" + amdDependency + "\"";
                    write(", ");
                    write(text);
                });
                write("], function (require, exports");
                ts.forEach(imports, function (imp) {
                    write(", ");
                    emit(imp.name);
                });
                write(") {");
                increaseIndent();
                emitCaptureThisForNodeIfNecessary(node);
                emitLinesStartingAt(node.statements, startIndex);
                var exportName = resolver.getExportAssignmentName(node);
                if (exportName) {
                    writeLine();
                    var exportAssignement = getFirstExportAssignment(node);
                    emitStart(exportAssignement);
                    write("return ");
                    emitStart(exportAssignement.exportName);
                    write(exportName);
                    emitEnd(exportAssignement.exportName);
                    write(";");
                    emitEnd(exportAssignement);
                }
                decreaseIndent();
                writeLine();
                write("});");
            }
            function emitCommonJSModule(node, startIndex) {
                emitCaptureThisForNodeIfNecessary(node);
                emitLinesStartingAt(node.statements, startIndex);
                var exportName = resolver.getExportAssignmentName(node);
                if (exportName) {
                    writeLine();
                    var exportAssignement = getFirstExportAssignment(node);
                    emitStart(exportAssignement);
                    write("module.exports = ");
                    emitStart(exportAssignement.exportName);
                    write(exportName);
                    emitEnd(exportAssignement.exportName);
                    write(";");
                    emitEnd(exportAssignement);
                }
            }
            function emitDirectivePrologues(statements, startWithNewLine) {
                for (var i = 0; i < statements.length; ++i) {
                    if (ts.isPrologueDirective(statements[i])) {
                        if (startWithNewLine || i > 0) {
                            writeLine();
                        }
                        emit(statements[i]);
                    }
                    else {
                        // return index of the first non prologue directive
                        return i;
                    }
                }
                return statements.length;
            }
            function emitSourceFile(node) {
                currentSourceFile = node;
                // Start new file on new line
                writeLine();
                emitDetachedComments(node);
                // emit prologue directives prior to __extends
                var startIndex = emitDirectivePrologues(node.statements, false);
                if (!extendsEmitted && resolver.getNodeCheckFlags(node) & 8 /* EmitExtends */) {
                    writeLine();
                    write("var __extends = this.__extends || function (d, b) {");
                    increaseIndent();
                    writeLine();
                    write("for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    writeLine();
                    write("function __() { this.constructor = d; }");
                    writeLine();
                    write("__.prototype = b.prototype;");
                    writeLine();
                    write("d.prototype = new __();");
                    decreaseIndent();
                    writeLine();
                    write("};");
                    extendsEmitted = true;
                }
                if (ts.isExternalModule(node)) {
                    if (compilerOptions.module === 2 /* AMD */) {
                        emitAMDModule(node, startIndex);
                    }
                    else {
                        emitCommonJSModule(node, startIndex);
                    }
                }
                else {
                    emitCaptureThisForNodeIfNecessary(node);
                    emitLinesStartingAt(node.statements, startIndex);
                }
            }
            function emitNode(node) {
                if (!node) {
                    return;
                }
                if (node.flags & 2 /* Ambient */) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                switch (node.kind) {
                    case 55 /* Identifier */:
                        return emitIdentifier(node);
                    case 114 /* Parameter */:
                        return emitParameter(node);
                    case 118 /* GetAccessor */:
                    case 119 /* SetAccessor */:
                        return emitAccessor(node);
                    case 83 /* ThisKeyword */:
                        return emitThis(node);
                    case 81 /* SuperKeyword */:
                        return emitSuper(node);
                    case 79 /* NullKeyword */:
                        return write("null");
                    case 85 /* TrueKeyword */:
                        return write("true");
                    case 70 /* FalseKeyword */:
                        return write("false");
                    case 2 /* NumericLiteral */:
                    case 3 /* StringLiteral */:
                    case 4 /* RegularExpressionLiteral */:
                        return emitLiteral(node);
                    case 112 /* QualifiedName */:
                        return emitPropertyAccess(node);
                    case 127 /* ArrayLiteral */:
                        return emitArrayLiteral(node);
                    case 128 /* ObjectLiteral */:
                        return emitObjectLiteral(node);
                    case 129 /* PropertyAssignment */:
                        return emitPropertyAssignment(node);
                    case 130 /* PropertyAccess */:
                        return emitPropertyAccess(node);
                    case 131 /* IndexedAccess */:
                        return emitIndexedAccess(node);
                    case 132 /* CallExpression */:
                        return emitCallExpression(node);
                    case 133 /* NewExpression */:
                        return emitNewExpression(node);
                    case 134 /* TypeAssertion */:
                        return emit(node.operand);
                    case 135 /* ParenExpression */:
                        return emitParenExpression(node);
                    case 167 /* FunctionDeclaration */:
                    case 136 /* FunctionExpression */:
                    case 137 /* ArrowFunction */:
                        return emitFunctionDeclaration(node);
                    case 138 /* PrefixOperator */:
                    case 139 /* PostfixOperator */:
                        return emitUnaryExpression(node);
                    case 140 /* BinaryExpression */:
                        return emitBinaryExpression(node);
                    case 141 /* ConditionalExpression */:
                        return emitConditionalExpression(node);
                    case 142 /* OmittedExpression */:
                        return;
                    case 143 /* Block */:
                    case 162 /* TryBlock */:
                    case 164 /* FinallyBlock */:
                    case 168 /* FunctionBlock */:
                    case 173 /* ModuleBlock */:
                        return emitBlock(node);
                    case 144 /* VariableStatement */:
                        return emitVariableStatement(node);
                    case 145 /* EmptyStatement */:
                        return write(";");
                    case 146 /* ExpressionStatement */:
                        return emitExpressionStatement(node);
                    case 147 /* IfStatement */:
                        return emitIfStatement(node);
                    case 148 /* DoStatement */:
                        return emitDoStatement(node);
                    case 149 /* WhileStatement */:
                        return emitWhileStatement(node);
                    case 150 /* ForStatement */:
                        return emitForStatement(node);
                    case 151 /* ForInStatement */:
                        return emitForInStatement(node);
                    case 152 /* ContinueStatement */:
                    case 153 /* BreakStatement */:
                        return emitBreakOrContinueStatement(node);
                    case 154 /* ReturnStatement */:
                        return emitReturnStatement(node);
                    case 155 /* WithStatement */:
                        return emitWithStatement(node);
                    case 156 /* SwitchStatement */:
                        return emitSwitchStatement(node);
                    case 157 /* CaseClause */:
                    case 158 /* DefaultClause */:
                        return emitCaseOrDefaultClause(node);
                    case 159 /* LabelledStatement */:
                        return emitLabelledStatement(node);
                    case 160 /* ThrowStatement */:
                        return emitThrowStatement(node);
                    case 161 /* TryStatement */:
                        return emitTryStatement(node);
                    case 163 /* CatchBlock */:
                        return emitCatchBlock(node);
                    case 165 /* DebuggerStatement */:
                        return emitDebuggerStatement(node);
                    case 166 /* VariableDeclaration */:
                        return emitVariableDeclaration(node);
                    case 169 /* ClassDeclaration */:
                        return emitClassDeclaration(node);
                    case 170 /* InterfaceDeclaration */:
                        return emitInterfaceDeclaration(node);
                    case 171 /* EnumDeclaration */:
                        return emitEnumDeclaration(node);
                    case 172 /* ModuleDeclaration */:
                        return emitModuleDeclaration(node);
                    case 174 /* ImportDeclaration */:
                        return emitImportDeclaration(node);
                    case 177 /* SourceFile */:
                        return emitSourceFile(node);
                }
            }
            function hasDetachedComments(pos) {
                return detachedCommentsInfo !== undefined && detachedCommentsInfo[detachedCommentsInfo.length - 1].nodePos === pos;
            }
            function getLeadingCommentsWithoutDetachedComments() {
                // get the leading comments from detachedPos
                var leadingComments = ts.getLeadingComments(currentSourceFile.text, detachedCommentsInfo[detachedCommentsInfo.length - 1].detachedCommentEndPos);
                if (detachedCommentsInfo.length - 1) {
                    detachedCommentsInfo.pop();
                }
                else {
                    detachedCommentsInfo = undefined;
                }
                return leadingComments;
            }
            function getLeadingCommentsToEmit(node) {
                // Emit the leading comments only if the parent's pos doesnt match because parent should take care of emitting these comments
                if (node.parent.kind === 177 /* SourceFile */ || node.pos !== node.parent.pos) {
                    var leadingComments;
                    if (hasDetachedComments(node.pos)) {
                        // get comments without detached comments
                        leadingComments = getLeadingCommentsWithoutDetachedComments();
                    }
                    else {
                        // get the leading comments from the node
                        leadingComments = ts.getLeadingCommentsOfNode(node, currentSourceFile);
                    }
                    return leadingComments;
                }
            }
            function emitLeadingDeclarationComments(node) {
                var leadingComments = getLeadingCommentsToEmit(node);
                emitNewLineBeforeLeadingComments(node, leadingComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(leadingComments, true, writer, writeComment);
            }
            function emitTrailingDeclarationComments(node) {
                // Emit the trailing comments only if the parent's end doesnt match
                if (node.parent.kind === 177 /* SourceFile */ || node.end !== node.parent.end) {
                    var trailingComments = ts.getTrailingComments(currentSourceFile.text, node.end);
                    // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/
                    emitComments(trailingComments, false, writer, writeComment);
                }
            }
            function emitLeadingCommentsOfLocalPosition(pos) {
                var leadingComments;
                if (hasDetachedComments(pos)) {
                    // get comments without detached comments
                    leadingComments = getLeadingCommentsWithoutDetachedComments();
                }
                else {
                    // get the leading comments from the node
                    leadingComments = ts.getLeadingComments(currentSourceFile.text, pos);
                }
                emitNewLineBeforeLeadingComments({ pos: pos, end: pos }, leadingComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(leadingComments, true, writer, writeComment);
            }
            function emitDetachedCommentsAtPosition(node) {
                var leadingComments = ts.getLeadingComments(currentSourceFile.text, node.pos);
                if (leadingComments) {
                    var detachedComments = [];
                    var lastComment;
                    ts.forEach(leadingComments, function (comment) {
                        if (lastComment) {
                            var lastCommentLine = getLineOfLocalPosition(lastComment.end);
                            var commentLine = getLineOfLocalPosition(comment.pos);
                            if (commentLine >= lastCommentLine + 2) {
                                // There was a blank line between the last comment and this comment.  This
                                // comment is not part of the copyright comments.  Return what we have so
                                // far.
                                return detachedComments;
                            }
                        }
                        detachedComments.push(comment);
                        lastComment = comment;
                    });
                    if (detachedComments.length) {
                        // All comments look like they could have been part of the copyright header.  Make
                        // sure there is at least one blank line between it and the node.  If not, it's not
                        // a copyright header.
                        var lastCommentLine = getLineOfLocalPosition(detachedComments[detachedComments.length - 1].end);
                        var astLine = getLineOfLocalPosition(ts.skipTrivia(currentSourceFile.text, node.pos));
                        if (astLine >= lastCommentLine + 2) {
                            // Valid detachedComments
                            emitNewLineBeforeLeadingComments(node, leadingComments, writer);
                            emitComments(detachedComments, true, writer, writeComment);
                            var currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: detachedComments[detachedComments.length - 1].end };
                            if (detachedCommentsInfo) {
                                detachedCommentsInfo.push(currentDetachedCommentInfo);
                            }
                            else {
                                detachedCommentsInfo = [currentDetachedCommentInfo];
                            }
                        }
                    }
                }
            }
            function emitPinnedOrTripleSlashCommentsOfNode(node) {
                var pinnedComments = ts.filter(getLeadingCommentsToEmit(node), isPinnedOrTripleSlashComment);
                function isPinnedOrTripleSlashComment(comment) {
                    if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */) {
                        return currentSourceFile.text.charCodeAt(comment.pos + 2) === 33 /* exclamation */;
                    }
                    else if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 47 /* slash */ && comment.pos + 2 < comment.end && currentSourceFile.text.charCodeAt(comment.pos + 2) === 47 /* slash */ && currentSourceFile.text.substring(comment.pos, comment.end).match(ts.fullTripleSlashReferencePathRegEx)) {
                        return true;
                    }
                }
                emitNewLineBeforeLeadingComments(node, pinnedComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(pinnedComments, true, writer, writeComment);
            }
            if (compilerOptions.sourceMap) {
                initializeEmitterWithSourceMaps();
            }
            if (root) {
                emit(root);
            }
            else {
                ts.forEach(program.getSourceFiles(), function (sourceFile) {
                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {
                        emit(sourceFile);
                    }
                });
            }
            writeLine();
            writeEmittedFiles(writer.getText(), compilerOptions.emitBOM);
        }
        function emitDeclarations(jsFilePath, root) {
            var writer = createTextWriter(writeSymbol);
            var write = writer.write;
            var writeLine = writer.writeLine;
            var increaseIndent = writer.increaseIndent;
            var decreaseIndent = writer.decreaseIndent;
            var enclosingDeclaration;
            var reportedDeclarationError = false;
            var emitJsDocComments = compilerOptions.removeComments ? function (declaration) {
            } : writeJsDocComments;
            var aliasDeclarationEmitInfo = [];
            var getSymbolVisibilityDiagnosticMessage;
            function writeAsychronousImportDeclarations(importDeclarations) {
                var oldWriter = writer;
                ts.forEach(importDeclarations, function (aliasToWrite) {
                    var aliasEmitInfo = ts.forEach(aliasDeclarationEmitInfo, function (declEmitInfo) { return declEmitInfo.declaration === aliasToWrite ? declEmitInfo : undefined; });
                    writer = createTextWriter(writeSymbol);
                    for (var declarationIndent = aliasEmitInfo.indent; declarationIndent; declarationIndent--) {
                        writer.increaseIndent();
                    }
                    writeImportDeclaration(aliasToWrite);
                    aliasEmitInfo.asynchronousOutput = writer.getText();
                });
                writer = oldWriter;
            }
            function writeSymbol(symbol, enclosingDeclaration, meaning) {
                var symbolAccesibilityResult = resolver.isSymbolAccessible(symbol, enclosingDeclaration, meaning);
                if (symbolAccesibilityResult.accessibility === 0 /* Accessible */) {
                    resolver.writeSymbol(symbol, enclosingDeclaration, meaning, writer);
                    // write the aliases
                    if (symbolAccesibilityResult && symbolAccesibilityResult.aliasesToMakeVisible) {
                        writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);
                    }
                }
                else {
                    // Report error
                    reportedDeclarationError = true;
                    var errorInfo = getSymbolVisibilityDiagnosticMessage(symbolAccesibilityResult);
                    if (errorInfo) {
                        if (errorInfo.typeName) {
                            diagnostics.push(ts.createDiagnosticForNode(errorInfo.errorNode, errorInfo.diagnosticMessage, getSourceTextOfLocalNode(errorInfo.typeName), symbolAccesibilityResult.errorSymbolName, symbolAccesibilityResult.errorModuleName));
                        }
                        else {
                            diagnostics.push(ts.createDiagnosticForNode(errorInfo.errorNode, errorInfo.diagnosticMessage, symbolAccesibilityResult.errorSymbolName, symbolAccesibilityResult.errorModuleName));
                        }
                    }
                }
            }
            function emitLines(nodes) {
                for (var i = 0, n = nodes.length; i < n; i++) {
                    emitNode(nodes[i]);
                }
            }
            function emitCommaList(nodes, eachNodeEmitFn) {
                var currentWriterPos = writer.getTextPos();
                for (var i = 0, n = nodes.length; i < n; i++) {
                    if (currentWriterPos !== writer.getTextPos()) {
                        write(", ");
                    }
                    currentWriterPos = writer.getTextPos();
                    eachNodeEmitFn(nodes[i]);
                }
            }
            function writeJsDocComments(declaration) {
                if (declaration) {
                    var jsDocComments = ts.getJsDocComments(declaration, currentSourceFile);
                    emitNewLineBeforeLeadingComments(declaration, jsDocComments, writer);
                    // jsDoc comments are emitted at /*leading comment1 */space/*leading comment*/space
                    emitComments(jsDocComments, true, writer, writeCommentRange);
                }
            }
            function emitSourceTextOfNode(node) {
                write(getSourceTextOfLocalNode(node));
            }
            function emitSourceFile(node) {
                currentSourceFile = node;
                enclosingDeclaration = node;
                emitLines(node.statements);
            }
            function emitExportAssignment(node) {
                write("export = ");
                emitSourceTextOfNode(node.exportName);
                write(";");
                writeLine();
            }
            function emitDeclarationFlags(node) {
                if (node.flags & 64 /* Static */) {
                    if (node.flags & 32 /* Private */) {
                        write("private ");
                    }
                    write("static ");
                }
                else {
                    if (node.flags & 32 /* Private */) {
                        write("private ");
                    }
                    else if (node.parent === currentSourceFile) {
                        // If the node is exported
                        if (node.flags & 1 /* Export */) {
                            write("export ");
                        }
                        if (node.kind !== 170 /* InterfaceDeclaration */) {
                            write("declare ");
                        }
                    }
                }
            }
            function emitImportDeclaration(node) {
                var nodeEmitInfo = {
                    declaration: node,
                    outputPos: writer.getTextPos(),
                    indent: writer.getIndent(),
                    hasWritten: resolver.isDeclarationVisible(node)
                };
                aliasDeclarationEmitInfo.push(nodeEmitInfo);
                if (nodeEmitInfo.hasWritten) {
                    writeImportDeclaration(node);
                }
            }
            function writeImportDeclaration(node) {
                // note usage of writer. methods instead of aliases created, just to make sure we are using
                // correct writer especially to handle asynchronous alias writing
                emitJsDocComments(node);
                if (node.flags & 1 /* Export */) {
                    writer.write("export ");
                }
                writer.write("import ");
                writer.write(getSourceTextOfLocalNode(node.name));
                writer.write(" = ");
                if (node.entityName) {
                    checkEntityNameAccessible();
                    writer.write(getSourceTextOfLocalNode(node.entityName));
                    writer.write(";");
                }
                else {
                    writer.write("require(");
                    writer.write(getSourceTextOfLocalNode(node.externalModuleName));
                    writer.write(");");
                }
                writer.writeLine();
                function checkEntityNameAccessible() {
                    var symbolAccesibilityResult = resolver.isImportDeclarationEntityNameReferenceDeclarationVisibile(node.entityName);
                    if (symbolAccesibilityResult.accessibility === 0 /* Accessible */) {
                        // write the aliases
                        if (symbolAccesibilityResult.aliasesToMakeVisible) {
                            writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);
                        }
                    }
                    else {
                        // Report error
                        reportedDeclarationError = true;
                        diagnostics.push(ts.createDiagnosticForNode(node, ts.Diagnostics.Import_declaration_0_is_using_private_name_1, getSourceTextOfLocalNode(node.name), symbolAccesibilityResult.errorSymbolName));
                    }
                }
            }
            function emitModuleDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("module ");
                    emitSourceTextOfNode(node.name);
                    while (node.body.kind !== 173 /* ModuleBlock */) {
                        node = node.body;
                        write(".");
                        emitSourceTextOfNode(node.name);
                    }
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.body.statements);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitEnumDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("enum ");
                    emitSourceTextOfNode(node.name);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                }
            }
            function emitEnumMemberDeclaration(node) {
                emitJsDocComments(node);
                emitSourceTextOfNode(node.name);
                var enumMemberValue = resolver.getEnumMemberValue(node);
                if (enumMemberValue !== undefined) {
                    write(" = ");
                    write(enumMemberValue.toString());
                }
                write(",");
                writeLine();
            }
            function emitTypeParameters(typeParameters) {
                function emitTypeParameter(node) {
                    function getTypeParameterConstraintVisibilityError(symbolAccesibilityResult) {
                        // Type parameter constraints are named by user so we should always be able to name it
                        var diagnosticMessage;
                        switch (node.parent.kind) {
                            case 169 /* ClassDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_private_name_1;
                                break;
                            case 170 /* InterfaceDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 121 /* ConstructSignature */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 120 /* CallSignature */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 116 /* Method */:
                                if (node.parent.flags & 64 /* Static */) {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;
                                }
                                else if (node.parent.parent.kind === 169 /* ClassDeclaration */) {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;
                                }
                                else {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;
                                }
                                break;
                            case 167 /* FunctionDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_private_name_1;
                                break;
                            default:
                                ts.Debug.fail("This is unknown parent for type parameter: " + ts.SyntaxKind[node.parent.kind]);
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node,
                            typeName: node.name
                        };
                    }
                    increaseIndent();
                    emitJsDocComments(node);
                    decreaseIndent();
                    emitSourceTextOfNode(node.name);
                    // If there is constraint present and this is not a type parameter of the private method emit the constraint
                    if (node.constraint && (node.parent.kind !== 116 /* Method */ || !(node.parent.flags & 32 /* Private */))) {
                        write(" extends ");
                        getSymbolVisibilityDiagnosticMessage = getTypeParameterConstraintVisibilityError;
                        resolver.writeTypeAtLocation(node.constraint, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                }
                if (typeParameters) {
                    write("<");
                    emitCommaList(typeParameters, emitTypeParameter);
                    write(">");
                }
            }
            function emitHeritageClause(typeReferences, isImplementsList) {
                if (typeReferences) {
                    write(isImplementsList ? " implements " : " extends ");
                    emitCommaList(typeReferences, emitTypeOfTypeReference);
                }
                function emitTypeOfTypeReference(node) {
                    getSymbolVisibilityDiagnosticMessage = getHeritageClauseVisibilityError;
                    resolver.writeTypeAtLocation(node, enclosingDeclaration, 1 /* WriteArrayAsGenericType */ | 2 /* UseTypeOfFunction */, writer);
                    function getHeritageClauseVisibilityError(symbolAccesibilityResult) {
                        var diagnosticMessage;
                        // Heritage clause is written by user so it can always be named
                        if (node.parent.kind === 169 /* ClassDeclaration */) {
                            // Class
                            if (symbolAccesibilityResult.errorModuleName) {
                                // Module is inaccessible
                                diagnosticMessage = isImplementsList ? ts.Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2;
                            }
                            else {
                                // Class or Interface implemented/extended is inaccessible
                                diagnosticMessage = isImplementsList ? ts.Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_private_name_1 : ts.Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_private_name_1;
                            }
                        }
                        else {
                            if (symbolAccesibilityResult.errorModuleName) {
                                // Module is inaccessible
                                diagnosticMessage = ts.Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_name_1_from_private_module_2;
                            }
                            else {
                                // interface is inaccessible
                                diagnosticMessage = ts.Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1;
                            }
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node,
                            typeName: node.parent.name
                        };
                    }
                }
            }
            function emitClassDeclaration(node) {
                function emitParameterProperties(constructorDeclaration) {
                    if (constructorDeclaration) {
                        ts.forEach(constructorDeclaration.parameters, function (param) {
                            if (param.flags & (16 /* Public */ | 32 /* Private */)) {
                                emitPropertyDeclaration(param);
                            }
                        });
                    }
                }
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("class ");
                    emitSourceTextOfNode(node.name);
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    emitTypeParameters(node.typeParameters);
                    if (node.baseType) {
                        emitHeritageClause([node.baseType], false);
                    }
                    emitHeritageClause(node.implementedTypes, true);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitParameterProperties(getFirstConstructorWithBody(node));
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitInterfaceDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("interface ");
                    emitSourceTextOfNode(node.name);
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    emitTypeParameters(node.typeParameters);
                    emitHeritageClause(node.baseTypes, false);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitPropertyDeclaration(node) {
                emitJsDocComments(node);
                emitDeclarationFlags(node);
                emitVariableDeclaration(node);
                write(";");
                writeLine();
            }
            function emitVariableDeclaration(node) {
                // If we are emitting property it isnt moduleElement and hence we already know it needs to be emitted
                // so there is no check needed to see if declaration is visible
                if (node.kind !== 166 /* VariableDeclaration */ || resolver.isDeclarationVisible(node)) {
                    emitSourceTextOfNode(node.name);
                    // If optional property emit ?
                    if (node.kind === 115 /* Property */ && (node.flags & 4 /* QuestionMark */)) {
                        write("?");
                    }
                    if (!(node.flags & 32 /* Private */)) {
                        write(": ");
                        getSymbolVisibilityDiagnosticMessage = getVariableDeclarationTypeVisibilityError;
                        resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                }
                function getVariableDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    if (node.kind === 166 /* VariableDeclaration */) {
                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Exported_variable_0_has_or_is_using_private_name_1;
                    }
                    else if (node.kind === 115 /* Property */) {
                        if (node.flags & 64 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_private_name_1;
                        }
                        else if (node.parent.kind === 169 /* ClassDeclaration */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_private_name_1;
                        }
                        else {
                            // Interfaces cannot have types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_private_name_1;
                        }
                    }
                    return diagnosticMessage !== undefined ? {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node,
                        typeName: node.name
                    } : undefined;
                }
            }
            function emitVariableStatement(node) {
                var hasDeclarationWithEmit = ts.forEach(node.declarations, function (varDeclaration) { return resolver.isDeclarationVisible(varDeclaration); });
                if (hasDeclarationWithEmit) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("var ");
                    emitCommaList(node.declarations, emitVariableDeclaration);
                    write(";");
                    writeLine();
                }
            }
            function emitAccessorDeclaration(node) {
                var accessors = getAllAccessorDeclarations(node.parent, node);
                if (node === accessors.firstAccessor) {
                    emitJsDocComments(accessors.getAccessor);
                    emitJsDocComments(accessors.setAccessor);
                    emitDeclarationFlags(node);
                    emitSourceTextOfNode(node.name);
                    if (!(node.flags & 32 /* Private */)) {
                        write(": ");
                        getSymbolVisibilityDiagnosticMessage = getAccessorDeclarationTypeVisibilityError;
                        resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                    write(";");
                    writeLine();
                }
                function getAccessorDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    if (node.kind === 119 /* SetAccessor */) {
                        // Setters have to have type named and cannot infer it so, the type should always be named
                        if (node.parent.flags & 64 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1;
                        }
                        else {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1;
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node.parameters[0],
                            typeName: node.name
                        };
                    }
                    else {
                        if (node.flags & 64 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0;
                        }
                        else {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0;
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node.name,
                            typeName: undefined
                        };
                    }
                }
            }
            function emitFunctionDeclaration(node) {
                // If we are emitting Method/Constructor it isnt moduleElement and hence already determined to be emitting
                // so no need to verify if the declaration is visible
                if ((node.kind !== 167 /* FunctionDeclaration */ || resolver.isDeclarationVisible(node)) && !resolver.isImplementationOfOverload(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    if (node.kind === 167 /* FunctionDeclaration */) {
                        write("function ");
                        emitSourceTextOfNode(node.name);
                    }
                    else if (node.kind === 117 /* Constructor */) {
                        write("constructor");
                    }
                    else {
                        emitSourceTextOfNode(node.name);
                        if (node.flags & 4 /* QuestionMark */) {
                            write("?");
                        }
                    }
                    emitSignatureDeclaration(node);
                }
            }
            function emitConstructSignatureDeclaration(node) {
                emitJsDocComments(node);
                write("new ");
                emitSignatureDeclaration(node);
            }
            function emitSignatureDeclaration(node) {
                if (node.kind === 120 /* CallSignature */ || node.kind === 122 /* IndexSignature */) {
                    // Only index and call signatures are emitted directly, so emit their js doc comments, rest will do that in their own functions
                    emitJsDocComments(node);
                }
                emitTypeParameters(node.typeParameters);
                if (node.kind === 122 /* IndexSignature */) {
                    write("[");
                }
                else {
                    write("(");
                }
                // Parameters
                emitCommaList(node.parameters, emitParameterDeclaration);
                if (node.kind === 122 /* IndexSignature */) {
                    write("]");
                }
                else {
                    write(")");
                }
                // If this is not a constructor and is not private, emit the return type
                if (node.kind !== 117 /* Constructor */ && !(node.flags & 32 /* Private */)) {
                    write(": ");
                    getSymbolVisibilityDiagnosticMessage = getReturnTypeVisibilityError;
                    resolver.writeReturnTypeOfSignatureDeclaration(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                }
                write(";");
                writeLine();
                function getReturnTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    switch (node.kind) {
                        case 121 /* ConstructSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 120 /* CallSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 122 /* IndexSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 116 /* Method */:
                            if (node.flags & 64 /* Static */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0;
                            }
                            else if (node.parent.kind === 169 /* ClassDeclaration */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0;
                            }
                            else {
                                // Interfaces cannot have return types that cannot be named
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0;
                            }
                            break;
                        case 167 /* FunctionDeclaration */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_private_name_0;
                            break;
                        default:
                            ts.Debug.fail("This is unknown kind for signature: " + ts.SyntaxKind[node.kind]);
                    }
                    return {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node.name || node
                    };
                }
            }
            function emitParameterDeclaration(node) {
                increaseIndent();
                emitJsDocComments(node);
                if (node.flags & 8 /* Rest */) {
                    write("...");
                }
                emitSourceTextOfNode(node.name);
                if (node.initializer || (node.flags & 4 /* QuestionMark */)) {
                    write("?");
                }
                decreaseIndent();
                if (!(node.parent.flags & 32 /* Private */)) {
                    write(": ");
                    getSymbolVisibilityDiagnosticMessage = getParameterDeclarationTypeVisibilityError;
                    resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                }
                function getParameterDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    switch (node.parent.kind) {
                        case 117 /* Constructor */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1;
                            break;
                        case 121 /* ConstructSignature */:
                            // Interfaces cannot have parameter types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;
                            break;
                        case 120 /* CallSignature */:
                            // Interfaces cannot have parameter types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;
                            break;
                        case 116 /* Method */:
                            if (node.parent.flags & 64 /* Static */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;
                            }
                            else if (node.parent.parent.kind === 169 /* ClassDeclaration */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;
                            }
                            else {
                                // Interfaces cannot have parameter types that cannot be named
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;
                            }
                            break;
                        case 167 /* FunctionDeclaration */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_private_name_1;
                            break;
                        default:
                            ts.Debug.fail("This is unknown parent for parameter: " + ts.SyntaxKind[node.parent.kind]);
                    }
                    return {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node,
                        typeName: node.name
                    };
                }
            }
            function emitNode(node) {
                switch (node.kind) {
                    case 117 /* Constructor */:
                    case 167 /* FunctionDeclaration */:
                    case 116 /* Method */:
                        return emitFunctionDeclaration(node);
                    case 121 /* ConstructSignature */:
                        return emitConstructSignatureDeclaration(node);
                    case 120 /* CallSignature */:
                    case 122 /* IndexSignature */:
                        return emitSignatureDeclaration(node);
                    case 118 /* GetAccessor */:
                    case 119 /* SetAccessor */:
                        return emitAccessorDeclaration(node);
                    case 144 /* VariableStatement */:
                        return emitVariableStatement(node);
                    case 115 /* Property */:
                        return emitPropertyDeclaration(node);
                    case 170 /* InterfaceDeclaration */:
                        return emitInterfaceDeclaration(node);
                    case 169 /* ClassDeclaration */:
                        return emitClassDeclaration(node);
                    case 176 /* EnumMember */:
                        return emitEnumMemberDeclaration(node);
                    case 171 /* EnumDeclaration */:
                        return emitEnumDeclaration(node);
                    case 172 /* ModuleDeclaration */:
                        return emitModuleDeclaration(node);
                    case 174 /* ImportDeclaration */:
                        return emitImportDeclaration(node);
                    case 175 /* ExportAssignment */:
                        return emitExportAssignment(node);
                    case 177 /* SourceFile */:
                        return emitSourceFile(node);
                }
            }
            function resolveScriptReference(sourceFile, reference) {
                var referenceFileName = compilerOptions.noResolve ? reference.filename : ts.normalizePath(ts.combinePaths(ts.getDirectoryPath(sourceFile.filename), reference.filename));
                return program.getSourceFile(referenceFileName);
            }
            // Contains the reference paths that needs to go in the declaration file.
            // Collecting this separately because reference paths need to be first thing in the declaration file
            // and we could be collecting these paths from multiple files into single one with --out option
            var referencePathsOutput = "";
            function writeReferencePath(referencedFile) {
                var declFileName = referencedFile.flags & 512 /* DeclarationFile */ ? referencedFile.filename : shouldEmitToOwnFile(referencedFile) ? getOwnEmitOutputFilePath(referencedFile, ".d.ts") : ts.getModuleNameFromFilename(compilerOptions.out) + ".d.ts"; // Global out file
                declFileName = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizeSlashes(jsFilePath)), declFileName, compilerHost.getCurrentDirectory(), false);
                referencePathsOutput += "/// <reference path='" + declFileName + "' />" + newLine;
            }
            if (root) {
                // Emiting single file so emit references in this file only
                var addedGlobalFileReference = false;
                ts.forEach(root.referencedFiles, function (fileReference) {
                    var referencedFile = resolveScriptReference(root, fileReference);
                    // All the references that are not going to be part of same file
                    if ((referencedFile.flags & 512 /* DeclarationFile */) || shouldEmitToOwnFile(referencedFile) || !addedGlobalFileReference) {
                        writeReferencePath(referencedFile);
                        if (!isExternalModuleOrDeclarationFile(referencedFile)) {
                            addedGlobalFileReference = true;
                        }
                    }
                });
                emitNode(root);
            }
            else {
                // Emit references corresponding to this file
                var emittedReferencedFiles = [];
                ts.forEach(program.getSourceFiles(), function (sourceFile) {
                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {
                        // Check what references need to be added
                        ts.forEach(sourceFile.referencedFiles, function (fileReference) {
                            var referencedFile = resolveScriptReference(sourceFile, fileReference);
                            // If the reference file is declaration file or external module emit that reference
                            if (isExternalModuleOrDeclarationFile(referencedFile) && !ts.contains(emittedReferencedFiles, referencedFile)) {
                                writeReferencePath(referencedFile);
                                emittedReferencedFiles.push(referencedFile);
                            }
                        });
                        emitNode(sourceFile);
                    }
                });
            }
            // TODO(shkamat): Should we not write any declaration file if any of them can produce error,
            // or should we just not write this file like we are doing now
            if (!reportedDeclarationError) {
                var declarationOutput = referencePathsOutput;
                var synchronousDeclarationOutput = writer.getText();
                // apply additions
                var appliedSyncOutputPos = 0;
                ts.forEach(aliasDeclarationEmitInfo, function (aliasEmitInfo) {
                    if (aliasEmitInfo.asynchronousOutput) {
                        declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos, aliasEmitInfo.outputPos);
                        declarationOutput += aliasEmitInfo.asynchronousOutput;
                        appliedSyncOutputPos = aliasEmitInfo.outputPos;
                    }
                });
                declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos);
                writeFile(ts.getModuleNameFromFilename(jsFilePath) + ".d.ts", declarationOutput, compilerOptions.emitBOM);
            }
        }
        var shouldEmitDeclarations = resolver.shouldEmitDeclarations();
        function emitFile(jsFilePath, sourceFile) {
            emitJavaScript(jsFilePath, sourceFile);
            if (shouldEmitDeclarations) {
                emitDeclarations(jsFilePath, sourceFile);
            }
        }
        ts.forEach(program.getSourceFiles(), function (sourceFile) {
            if (shouldEmitToOwnFile(sourceFile)) {
                var jsFilePath = getOwnEmitOutputFilePath(sourceFile, ".js");
                emitFile(jsFilePath, sourceFile);
            }
        });
        if (compilerOptions.out) {
            emitFile(compilerOptions.out);
        }
        // Sort and make the unique list of diagnostics
        diagnostics.sort(ts.compareDiagnostics);
        diagnostics = ts.deduplicateSortedDiagnostics(diagnostics);
        return {
            errors: diagnostics,
            sourceMaps: sourceMapDataList
        };
    }
    ts.emitFiles = emitFiles;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
/// <reference path="binder.ts"/>
/// <reference path="emitter.ts"/>
var ts;
(function (ts) {
    var nextSymbolId = 1;
    var nextNodeId = 1;
    var nextMergeId = 1;
    /// fullTypeCheck denotes if this instance of the typechecker will be used to get semantic diagnostics.
    /// If fullTypeCheck === true - then typechecker should do every possible check to produce all errors
    /// If fullTypeCheck === false - typechecker can shortcut and skip checks that only produce errors.
    /// NOTE: checks that somehow affects decisions being made during typechecking should be executed in both cases.
    function createTypeChecker(program, fullTypeCheck) {
        var Symbol = ts.objectAllocator.getSymbolConstructor();
        var Type = ts.objectAllocator.getTypeConstructor();
        var Signature = ts.objectAllocator.getSignatureConstructor();
        var typeCount = 0;
        var emptyArray = [];
        var emptySymbols = {};
        var checker = {
            getProgram: function () { return program; },
            getDiagnostics: getDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getNodeCount: function () { return ts.sum(program.getSourceFiles(), "nodeCount"); },
            getIdentifierCount: function () { return ts.sum(program.getSourceFiles(), "identifierCount"); },
            getSymbolCount: function () { return ts.sum(program.getSourceFiles(), "symbolCount"); },
            getTypeCount: function () { return typeCount; },
            checkProgram: checkProgram,
            emitFiles: invokeEmitter,
            getParentOfSymbol: getParentOfSymbol,
            getTypeOfSymbol: getTypeOfSymbol,
            getPropertiesOfType: getPropertiesOfType,
            getPropertyOfType: getPropertyOfType,
            getSignaturesOfType: getSignaturesOfType,
            getIndexTypeOfType: getIndexTypeOfType,
            getReturnTypeOfSignature: getReturnTypeOfSignature,
            getSymbolsInScope: getSymbolsInScope,
            getSymbolInfo: getSymbolInfo,
            getTypeOfNode: getTypeOfNode,
            getApparentType: getApparentType,
            typeToString: typeToString,
            symbolToString: symbolToString,
            getAugmentedPropertiesOfApparentType: getAugmentedPropertiesOfApparentType
        };
        var undefinedSymbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, "undefined");
        var argumentsSymbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, "arguments");
        var unknownSymbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, "unknown");
        var resolvingSymbol = createSymbol(33554432 /* Transient */, "__resolving__");
        var anyType = createIntrinsicType(1 /* Any */, "any");
        var stringType = createIntrinsicType(2 /* String */, "string");
        var numberType = createIntrinsicType(4 /* Number */, "number");
        var booleanType = createIntrinsicType(8 /* Boolean */, "boolean");
        var voidType = createIntrinsicType(16 /* Void */, "void");
        var undefinedType = createIntrinsicType(32 /* Undefined */, "undefined");
        var nullType = createIntrinsicType(64 /* Null */, "null");
        var unknownType = createIntrinsicType(1 /* Any */, "unknown");
        var resolvingType = createIntrinsicType(1 /* Any */, "__resolving__");
        var emptyObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var anyFunctionType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var noConstraintType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var anySignature = createSignature(undefined, undefined, emptyArray, anyType, 0, false, false);
        var unknownSignature = createSignature(undefined, undefined, emptyArray, unknownType, 0, false, false);
        var globals = {};
        var globalArraySymbol;
        var globalObjectType;
        var globalFunctionType;
        var globalArrayType;
        var globalStringType;
        var globalNumberType;
        var globalBooleanType;
        var globalRegExpType;
        var stringLiteralTypes = {};
        var emitExtends = false;
        var mergedSymbols = [];
        var symbolLinks = [];
        var nodeLinks = [];
        var potentialThisCollisions = [];
        var diagnostics = [];
        var diagnosticsModified = false;
        function addDiagnostic(diagnostic) {
            diagnostics.push(diagnostic);
            diagnosticsModified = true;
        }
        function error(location, message, arg0, arg1, arg2) {
            var diagnostic = location ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2) : ts.createCompilerDiagnostic(message, arg0, arg1, arg2);
            addDiagnostic(diagnostic);
        }
        function createSymbol(flags, name) {
            return new Symbol(flags, name);
        }
        function getExcludedSymbolFlags(flags) {
            var result = 0;
            if (flags & 1 /* Variable */)
                result |= ts.SymbolFlags.VariableExcludes;
            if (flags & 2 /* Property */)
                result |= ts.SymbolFlags.PropertyExcludes;
            if (flags & 4 /* EnumMember */)
                result |= ts.SymbolFlags.EnumMemberExcludes;
            if (flags & 8 /* Function */)
                result |= ts.SymbolFlags.FunctionExcludes;
            if (flags & 16 /* Class */)
                result |= ts.SymbolFlags.ClassExcludes;
            if (flags & 32 /* Interface */)
                result |= ts.SymbolFlags.InterfaceExcludes;
            if (flags & 64 /* Enum */)
                result |= ts.SymbolFlags.EnumExcludes;
            if (flags & 128 /* ValueModule */)
                result |= ts.SymbolFlags.ValueModuleExcludes;
            if (flags & 2048 /* Method */)
                result |= ts.SymbolFlags.MethodExcludes;
            if (flags & 8192 /* GetAccessor */)
                result |= ts.SymbolFlags.GetAccessorExcludes;
            if (flags & 16384 /* SetAccessor */)
                result |= ts.SymbolFlags.SetAccessorExcludes;
            if (flags & 262144 /* TypeParameter */)
                result |= ts.SymbolFlags.TypeParameterExcludes;
            if (flags & 4194304 /* Import */)
                result |= ts.SymbolFlags.ImportExcludes;
            return result;
        }
        function recordMergedSymbol(target, source) {
            if (!source.mergeId)
                source.mergeId = nextMergeId++;
            mergedSymbols[source.mergeId] = target;
        }
        function cloneSymbol(symbol) {
            var result = createSymbol(symbol.flags | 16777216 /* Merged */, symbol.name);
            result.declarations = symbol.declarations.slice(0);
            result.parent = symbol.parent;
            if (symbol.valueDeclaration)
                result.valueDeclaration = symbol.valueDeclaration;
            if (symbol.members)
                result.members = cloneSymbolTable(symbol.members);
            if (symbol.exports)
                result.exports = cloneSymbolTable(symbol.exports);
            recordMergedSymbol(result, symbol);
            return result;
        }
        function extendSymbol(target, source) {
            if (!(target.flags & getExcludedSymbolFlags(source.flags))) {
                target.flags |= source.flags;
                if (!target.valueDeclaration && source.valueDeclaration)
                    target.valueDeclaration = source.valueDeclaration;
                ts.forEach(source.declarations, function (node) {
                    target.declarations.push(node);
                });
                if (source.members) {
                    if (!target.members)
                        target.members = {};
                    extendSymbolTable(target.members, source.members);
                }
                if (source.exports) {
                    if (!target.exports)
                        target.exports = {};
                    extendSymbolTable(target.exports, source.exports);
                }
                recordMergedSymbol(target, source);
            }
            else {
                ts.forEach(source.declarations, function (node) {
                    error(node.name ? node.name : node, ts.Diagnostics.Duplicate_identifier_0, symbolToString(source));
                });
            }
        }
        function cloneSymbolTable(symbolTable) {
            var result = {};
            for (var id in symbolTable) {
                if (ts.hasProperty(symbolTable, id)) {
                    result[id] = symbolTable[id];
                }
            }
            return result;
        }
        function extendSymbolTable(target, source) {
            for (var id in source) {
                if (ts.hasProperty(source, id)) {
                    if (!ts.hasProperty(target, id)) {
                        target[id] = source[id];
                    }
                    else {
                        var symbol = target[id];
                        if (!(symbol.flags & 16777216 /* Merged */)) {
                            target[id] = symbol = cloneSymbol(symbol);
                        }
                        extendSymbol(symbol, source[id]);
                    }
                }
            }
        }
        function getSymbolLinks(symbol) {
            if (symbol.flags & 33554432 /* Transient */)
                return symbol;
            if (!symbol.id)
                symbol.id = nextSymbolId++;
            return symbolLinks[symbol.id] || (symbolLinks[symbol.id] = {});
        }
        function getNodeLinks(node) {
            if (!node.id)
                node.id = nextNodeId++;
            return nodeLinks[node.id] || (nodeLinks[node.id] = {});
        }
        function getSourceFile(node) {
            return getAncestor(node, 177 /* SourceFile */);
        }
        function isGlobalSourceFile(node) {
            return node.kind === 177 /* SourceFile */ && !ts.isExternalModule(node);
        }
        function getSymbol(symbols, name, meaning) {
            if (meaning && ts.hasProperty(symbols, name)) {
                var symbol = symbols[name];
                ts.Debug.assert((symbol.flags & 8388608 /* Instantiated */) === 0, "Should never get an instantiated symbol here.");
                if (symbol.flags & meaning) {
                    return symbol;
                }
                if (symbol.flags & 4194304 /* Import */) {
                    var target = resolveImport(symbol);
                    // unknown symbol will mean that there were reported error during import resolution
                    // treat it as positive answer to avoid cascading errors
                    if (target === unknownSymbol || target.flags & meaning) {
                        return symbol;
                    }
                }
            }
            // return undefined if we can't find a symbol.
        }
        function resolveName(location, name, meaning, nameNotFoundMessage, nameArg) {
            var errorLocation = location;
            var result;
            var lastLocation;
            var memberWithInitializerThatReferencesIdentifierFromConstructor;
            function returnResolvedSymbol(s) {
                // we've seen member with initializer that references identifier defined in constructor during the search.
                // if this was the only result with given name then just report default 'nameNotFound' message.
                // however if we met something else that was 'shadowed' by the identifier in constructor - report more specific error
                if (s && memberWithInitializerThatReferencesIdentifierFromConstructor) {
                    var propertyName = memberWithInitializerThatReferencesIdentifierFromConstructor.name;
                    error(errorLocation, ts.Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, ts.identifierToString(propertyName), nameArg);
                    return undefined;
                }
                if (!s && nameNotFoundMessage) {
                    error(errorLocation, nameNotFoundMessage, nameArg);
                }
                return s;
            }
            while (location) {
                // Locals of a source file are not in scope (because they get merged into the global symbol table)
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = getSymbol(location.locals, name, meaning)) {
                        return returnResolvedSymbol(result);
                    }
                }
                switch (location.kind) {
                    case 177 /* SourceFile */:
                        if (!ts.isExternalModule(location))
                            break;
                    case 172 /* ModuleDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & ts.SymbolFlags.ModuleMember)) {
                            return returnResolvedSymbol(result);
                        }
                        break;
                    case 171 /* EnumDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & 4 /* EnumMember */)) {
                            return returnResolvedSymbol(result);
                        }
                        break;
                    case 115 /* Property */:
                        // TypeScript 1.0 spec (April 2014): 8.4.1
                        // Initializer expressions for instance member variables are evaluated in the scope
                        // of the class constructor body but are not permitted to reference parameters or
                        // local variables of the constructor.This effectively means that entities from outer scopes
                        // by the same name as a constructor parameter or local variable are inaccessible
                        // in initializer expressions for instance member variables.
                        if (location.parent.kind === 169 /* ClassDeclaration */ && !(location.flags & 64 /* Static */)) {
                            var ctor = findConstructorDeclaration(location.parent);
                            if (ctor && ctor.locals) {
                                if (getSymbol(ctor.locals, name, meaning & ts.SymbolFlags.Value)) {
                                    // save the property node - later it will be used by 'returnResolvedSymbol' to report appropriate error
                                    memberWithInitializerThatReferencesIdentifierFromConstructor = location;
                                }
                            }
                        }
                        break;
                    case 169 /* ClassDeclaration */:
                    case 170 /* InterfaceDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).members, name, meaning & ts.SymbolFlags.Type)) {
                            if (lastLocation && lastLocation.flags & 64 /* Static */) {
                                // TypeScript 1.0 spec (April 2014): 3.4.1
                                // The scope of a type parameter extends over the entire declaration
                                // with which the type parameter list is associated, with the exception of static member declarations in classes.
                                error(errorLocation, ts.Diagnostics.Static_members_cannot_reference_class_type_parameters);
                                return undefined;
                            }
                            else {
                                return returnResolvedSymbol(result);
                            }
                        }
                        break;
                    case 116 /* Method */:
                    case 117 /* Constructor */:
                    case 118 /* GetAccessor */:
                    case 119 /* SetAccessor */:
                    case 167 /* FunctionDeclaration */:
                    case 137 /* ArrowFunction */:
                        if (name === "arguments") {
                            return returnResolvedSymbol(argumentsSymbol);
                        }
                        break;
                    case 136 /* FunctionExpression */:
                        if (name === "arguments") {
                            return returnResolvedSymbol(argumentsSymbol);
                        }
                        var id = location.name;
                        if (id && name === id.text) {
                            return returnResolvedSymbol(location.symbol);
                        }
                        break;
                    case 163 /* CatchBlock */:
                        var id = location.variable;
                        if (name === id.text) {
                            return returnResolvedSymbol(location.symbol);
                        }
                        break;
                }
                lastLocation = location;
                location = location.parent;
            }
            if (result = getSymbol(globals, name, meaning)) {
                return returnResolvedSymbol(result);
            }
            return returnResolvedSymbol(undefined);
        }
        function resolveImport(symbol) {
            ts.Debug.assert((symbol.flags & 4194304 /* Import */) !== 0, "Should only get Imports here.");
            var links = getSymbolLinks(symbol);
            if (!links.target) {
                links.target = resolvingSymbol;
                var node = getDeclarationOfKind(symbol, 174 /* ImportDeclaration */);
                var target = node.externalModuleName ? resolveExternalModuleName(node, node.externalModuleName) : getSymbolOfPartOfRightHandSideOfImport(node.entityName, node);
                if (links.target === resolvingSymbol) {
                    links.target = target || unknownSymbol;
                }
                else {
                    error(node, ts.Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
                }
            }
            else if (links.target === resolvingSymbol) {
                links.target = unknownSymbol;
            }
            return links.target;
        }
        // This function is only for imports with entity names
        function getSymbolOfPartOfRightHandSideOfImport(entityName, importDeclaration) {
            if (!importDeclaration) {
                importDeclaration = getAncestor(entityName, 174 /* ImportDeclaration */);
                ts.Debug.assert(importDeclaration);
            }
            // There are three things we might try to look for. In the following examples,
            // the search term is enclosed in |...|:
            //
            //     import a = |b|; // Namespace
            //     import a = |b.c|; // Value, type, namespace
            //     import a = |b.c|.d; // Namespace
            if (entityName.kind === 55 /* Identifier */ && isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            // Check for case 1 and 3 in the above example
            if (entityName.kind === 55 /* Identifier */ || entityName.parent.kind === 112 /* QualifiedName */) {
                return resolveEntityName(importDeclaration, entityName, ts.SymbolFlags.Namespace);
            }
            else {
                // Case 2 in above example
                // entityName.kind could be a QualifiedName or a Missing identifier
                ts.Debug.assert(entityName.parent.kind === 174 /* ImportDeclaration */);
                return resolveEntityName(importDeclaration, entityName, ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace);
            }
        }
        function getFullyQualifiedName(symbol) {
            return symbol.parent ? getFullyQualifiedName(symbol.parent) + "." + symbolToString(symbol) : symbolToString(symbol);
        }
        // Resolves a qualified name and any involved import aliases
        function resolveEntityName(location, name, meaning) {
            if (name.kind === 55 /* Identifier */) {
                // TODO: Investigate error recovery for symbols not found
                var symbol = resolveName(location, name.text, meaning, ts.Diagnostics.Cannot_find_name_0, ts.identifierToString(name));
                if (!symbol) {
                    return;
                }
            }
            else if (name.kind === 112 /* QualifiedName */) {
                var namespace = resolveEntityName(location, name.left, ts.SymbolFlags.Namespace);
                if (!namespace || namespace === unknownSymbol || name.right.kind === 111 /* Missing */)
                    return;
                var symbol = getSymbol(namespace.exports, name.right.text, meaning);
                if (!symbol) {
                    error(location, ts.Diagnostics.Module_0_has_no_exported_member_1, getFullyQualifiedName(namespace), ts.identifierToString(name.right));
                    return;
                }
            }
            else {
                // Missing identifier
                return;
            }
            ts.Debug.assert((symbol.flags & 8388608 /* Instantiated */) === 0, "Should never get an instantiated symbol here.");
            return symbol.flags & meaning ? symbol : resolveImport(symbol);
        }
        function isExternalModuleNameRelative(moduleName) {
            // TypeScript 1.0 spec (April 2014): 11.2.1
            // An external module name is "relative" if the first term is "." or "..".
            return moduleName.substr(0, 2) === "./" || moduleName.substr(0, 3) === "../" || moduleName.substr(0, 2) === ".\\" || moduleName.substr(0, 3) === "..\\";
        }
        function resolveExternalModuleName(location, moduleLiteral) {
            var searchPath = ts.getDirectoryPath(getSourceFile(location).filename);
            var moduleName = moduleLiteral.text;
            if (!moduleName)
                return;
            var isRelative = isExternalModuleNameRelative(moduleName);
            if (!isRelative) {
                var symbol = getSymbol(globals, '"' + moduleName + '"', 128 /* ValueModule */);
                if (symbol) {
                    return getResolvedExportSymbol(symbol);
                }
            }
            while (true) {
                var filename = ts.normalizePath(ts.combinePaths(searchPath, moduleName));
                var sourceFile = program.getSourceFile(filename + ".ts") || program.getSourceFile(filename + ".d.ts");
                if (sourceFile || isRelative)
                    break;
                var parentPath = ts.getDirectoryPath(searchPath);
                if (parentPath === searchPath)
                    break;
                searchPath = parentPath;
            }
            if (sourceFile) {
                if (sourceFile.symbol) {
                    return getResolvedExportSymbol(sourceFile.symbol);
                }
                error(moduleLiteral, ts.Diagnostics.File_0_is_not_an_external_module, sourceFile.filename);
                return;
            }
            error(moduleLiteral, ts.Diagnostics.Cannot_find_external_module_0, moduleName);
        }
        function getResolvedExportSymbol(moduleSymbol) {
            var symbol = getExportAssignmentSymbol(moduleSymbol);
            if (symbol) {
                if (symbol.flags & (ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace)) {
                    return symbol;
                }
                if (symbol.flags & 4194304 /* Import */) {
                    return resolveImport(symbol);
                }
            }
            return moduleSymbol;
        }
        function getExportAssignmentSymbol(symbol) {
            checkTypeOfExportAssignmentSymbol(symbol);
            var symbolLinks = getSymbolLinks(symbol);
            return symbolLinks.exportAssignSymbol === unknownSymbol ? undefined : symbolLinks.exportAssignSymbol;
        }
        function checkTypeOfExportAssignmentSymbol(containerSymbol) {
            var symbolLinks = getSymbolLinks(containerSymbol);
            if (!symbolLinks.exportAssignSymbol) {
                var exportInformation = collectExportInformationForSourceFileOrModule(containerSymbol);
                if (exportInformation.exportAssignments.length) {
                    if (exportInformation.exportAssignments.length > 1) {
                        // TypeScript 1.0 spec (April 2014): 11.2.4
                        // It is an error for an external module to contain more than one export assignment.
                        ts.forEach(exportInformation.exportAssignments, function (node) { return error(node, ts.Diagnostics.A_module_cannot_have_more_than_one_export_assignment); });
                    }
                    var node = exportInformation.exportAssignments[0];
                    if (exportInformation.hasExportedMember) {
                        // TypeScript 1.0 spec (April 2014): 11.2.3
                        // If an external module contains an export assignment it is an error
                        // for the external module to also contain export declarations.
                        // The two types of exports are mutually exclusive.
                        error(node, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                    }
                    if (node.exportName.text) {
                        var meaning = ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace;
                        var exportSymbol = resolveName(node, node.exportName.text, meaning, ts.Diagnostics.Cannot_find_name_0, ts.identifierToString(node.exportName));
                    }
                }
                symbolLinks.exportAssignSymbol = exportSymbol || unknownSymbol;
            }
        }
        function collectExportInformationForSourceFileOrModule(symbol) {
            var seenExportedMember = false;
            var result = [];
            ts.forEach(symbol.declarations, function (declaration) {
                var block = (declaration.kind === 177 /* SourceFile */ ? declaration : declaration.body);
                ts.forEach(block.statements, function (node) {
                    if (node.kind === 175 /* ExportAssignment */) {
                        result.push(node);
                    }
                    else {
                        seenExportedMember = seenExportedMember || (node.flags & 1 /* Export */) !== 0;
                    }
                });
            });
            return {
                hasExportedMember: seenExportedMember,
                exportAssignments: result
            };
        }
        function getMergedSymbol(symbol) {
            var merged;
            return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
        }
        function getSymbolOfNode(node) {
            return getMergedSymbol(node.symbol);
        }
        function getParentOfSymbol(symbol) {
            return getMergedSymbol(symbol.parent);
        }
        function getExportSymbolOfValueSymbolIfExported(symbol) {
            return symbol && (symbol.flags & 524288 /* ExportValue */) !== 0 ? getMergedSymbol(symbol.exportSymbol) : symbol;
        }
        function symbolIsValue(symbol) {
            // If the symbol has the value flag, it is trivially a value.
            if (symbol.flags & ts.SymbolFlags.Value) {
                return true;
            }
            // If it is an import, then it is a value if the symbol it resolves to is a value.
            if (symbol.flags & 4194304 /* Import */) {
                return (resolveImport(symbol).flags & ts.SymbolFlags.Value) !== 0;
            }
            // If it is an instantiated symbol, then it is a value if hte symbol it is an
            // instantiation of is a value.
            if (symbol.flags & 8388608 /* Instantiated */) {
                return (getSymbolLinks(symbol).target.flags & ts.SymbolFlags.Value) !== 0;
            }
            return false;
        }
        function getDeclarationOfKind(symbol, kind) {
            var declarations = symbol.declarations;
            for (var i = 0; i < declarations.length; i++) {
                var declaration = declarations[i];
                if (declaration.kind === kind) {
                    return declaration;
                }
            }
            return undefined;
        }
        function findConstructorDeclaration(node) {
            var members = node.members;
            for (var i = 0; i < members.length; i++) {
                var member = members[i];
                if (member.kind === 117 /* Constructor */ && member.body) {
                    return member;
                }
            }
        }
        function createType(flags) {
            var result = new Type(checker, flags);
            result.id = typeCount++;
            return result;
        }
        function createIntrinsicType(kind, intrinsicName) {
            var type = createType(kind);
            type.intrinsicName = intrinsicName;
            return type;
        }
        function createObjectType(kind, symbol) {
            var type = createType(kind);
            type.symbol = symbol;
            return type;
        }
        // A reserved member name starts with two underscores followed by a non-underscore
        function isReservedMemberName(name) {
            return name.charCodeAt(0) === 95 /* _ */ && name.charCodeAt(1) === 95 /* _ */ && name.charCodeAt(2) !== 95 /* _ */;
        }
        function getNamedMembers(members) {
            var result;
            for (var id in members) {
                if (ts.hasProperty(members, id)) {
                    if (!isReservedMemberName(id)) {
                        if (!result)
                            result = [];
                        var symbol = members[id];
                        if (symbolIsValue(symbol)) {
                            result.push(symbol);
                        }
                    }
                }
            }
            return result || emptyArray;
        }
        function setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType) {
            type.members = members;
            type.properties = getNamedMembers(members);
            type.callSignatures = callSignatures;
            type.constructSignatures = constructSignatures;
            if (stringIndexType)
                type.stringIndexType = stringIndexType;
            if (numberIndexType)
                type.numberIndexType = numberIndexType;
            return type;
        }
        function createAnonymousType(symbol, members, callSignatures, constructSignatures, stringIndexType, numberIndexType) {
            return setObjectTypeMembers(createObjectType(8192 /* Anonymous */, symbol), members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function isOptionalProperty(propertySymbol) {
            if (propertySymbol.flags & 67108864 /* Prototype */) {
                return false;
            }
            //  class C {
            //      constructor(public x?) { }
            //  }
            //
            // x is an optional parameter, but it is a required property.
            return (propertySymbol.valueDeclaration.flags & 4 /* QuestionMark */) && propertySymbol.valueDeclaration.kind !== 114 /* Parameter */;
        }
        function forEachSymbolTableInScope(enclosingDeclaration, callback) {
            var result;
            for (var location = enclosingDeclaration; location; location = location.parent) {
                // Locals of a source file are not in scope (because they get merged into the global symbol table)
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = callback(location.locals)) {
                        return result;
                    }
                }
                switch (location.kind) {
                    case 177 /* SourceFile */:
                        if (!ts.isExternalModule(location)) {
                            break;
                        }
                    case 172 /* ModuleDeclaration */:
                        if (result = callback(getSymbolOfNode(location).exports)) {
                            return result;
                        }
                        break;
                    case 169 /* ClassDeclaration */:
                    case 170 /* InterfaceDeclaration */:
                        if (result = callback(getSymbolOfNode(location).members)) {
                            return result;
                        }
                        break;
                }
            }
            return callback(globals);
        }
        function getQualifiedLeftMeaning(rightMeaning) {
            // If we are looking in value space, the parent meaning is value, other wise it is namespace
            return rightMeaning === ts.SymbolFlags.Value ? ts.SymbolFlags.Value : ts.SymbolFlags.Namespace;
        }
        function getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning) {
            function getAccessibleSymbolChainFromSymbolTable(symbols) {
                function canQualifySymbol(symbolFromSymbolTable, meaning) {
                    // If the symbol is equivalent and doesnt need futher qualification, this symbol is accessible
                    if (!needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning)) {
                        return true;
                    }
                    // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
                    var accessibleParent = getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning));
                    return !!accessibleParent;
                }
                function isAccessible(symbolFromSymbolTable, resolvedAliasSymbol) {
                    if (symbol === (resolvedAliasSymbol || symbolFromSymbolTable)) {
                        // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
                        // and if symbolfrom symbolTable or alias resolution matches the symbol,
                        // check the symbol can be qualified, it is only then this symbol is accessible
                        return !ts.forEach(symbolFromSymbolTable.declarations, function (declaration) { return hasExternalModuleSymbol(declaration); }) && canQualifySymbol(symbolFromSymbolTable, meaning);
                    }
                }
                // If symbol is directly available by its name in the symbol table
                if (isAccessible(ts.lookUp(symbols, symbol.name))) {
                    return [symbol];
                }
                // Check if symbol is any of the alias
                return ts.forEachValue(symbols, function (symbolFromSymbolTable) {
                    if (symbolFromSymbolTable.flags & 4194304 /* Import */) {
                        var resolvedImportedSymbol = resolveImport(symbolFromSymbolTable);
                        if (isAccessible(symbolFromSymbolTable, resolveImport(symbolFromSymbolTable))) {
                            return [symbolFromSymbolTable];
                        }
                        // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
                        // but only if the symbolFromSymbolTable can be qualified
                        var accessibleSymbolsFromExports = resolvedImportedSymbol.exports ? getAccessibleSymbolChainFromSymbolTable(resolvedImportedSymbol.exports) : undefined;
                        if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                            return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
                        }
                    }
                });
            }
            if (symbol) {
                return forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
            }
        }
        function needsQualification(symbol, enclosingDeclaration, meaning) {
            var qualify = false;
            forEachSymbolTableInScope(enclosingDeclaration, function (symbolTable) {
                // If symbol of this name is not available in the symbol table we are ok
                if (!ts.hasProperty(symbolTable, symbol.name)) {
                    // Continue to the next symbol table
                    return false;
                }
                // If the symbol with this name is present it should refer to the symbol
                var symbolFromSymbolTable = symbolTable[symbol.name];
                if (symbolFromSymbolTable === symbol) {
                    // No need to qualify
                    return true;
                }
                // Qualify if the symbol from symbol table has same meaning as expected
                symbolFromSymbolTable = (symbolFromSymbolTable.flags & 4194304 /* Import */) ? resolveImport(symbolFromSymbolTable) : symbolFromSymbolTable;
                if (symbolFromSymbolTable.flags & meaning) {
                    qualify = true;
                    return true;
                }
                // Continue to the next symbol table
                return false;
            });
            return qualify;
        }
        function isSymbolAccessible(symbol, enclosingDeclaration, meaning) {
            if (symbol && enclosingDeclaration && !(symbol.flags & 262144 /* TypeParameter */)) {
                var initialSymbol = symbol;
                var meaningToLook = meaning;
                while (symbol) {
                    // Symbol is accessible if it by itself is accessible
                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaningToLook);
                    if (accessibleSymbolChain) {
                        var hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0]);
                        if (!hasAccessibleDeclarations) {
                            return {
                                accessibility: 1 /* NotAccessible */,
                                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                                errorModuleName: symbol !== initialSymbol ? symbolToString(symbol, enclosingDeclaration, ts.SymbolFlags.Namespace) : undefined
                            };
                        }
                        return { accessibility: 0 /* Accessible */, aliasesToMakeVisible: hasAccessibleDeclarations.aliasesToMakeVisible };
                    }
                    // If we havent got the accessible symbol doesnt mean the symbol is actually inaccessible.
                    // It could be qualified symbol and hence verify the path
                    // eg:
                    // module m {
                    //     export class c {
                    //     }
                    // }
                    // var x: typeof m.c
                    // In the above example when we start with checking if typeof m.c symbol is accessible,
                    // we are going to see if c can be accessed in scope directly.
                    // But it cant, hence the accessible is going to be undefined, but that doesnt mean m.c is accessible
                    // It is accessible if the parent m is accessible because then m.c can be accessed through qualification
                    meaningToLook = getQualifiedLeftMeaning(meaning);
                    symbol = getParentOfSymbol(symbol);
                }
                // This could be a symbol that is not exported in the external module
                // or it could be a symbol from different external module that is not aliased and hence cannot be named
                var symbolExternalModule = ts.forEach(initialSymbol.declarations, function (declaration) { return getExternalModuleContainer(declaration); });
                if (symbolExternalModule) {
                    var enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
                    if (symbolExternalModule !== enclosingExternalModule) {
                        // name from different external module that is not visibile
                        return {
                            accessibility: 2 /* CannotBeNamed */,
                            errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                            errorModuleName: symbolToString(symbolExternalModule)
                        };
                    }
                }
                // Just a local name that is not accessible
                return {
                    accessibility: 1 /* NotAccessible */,
                    errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning)
                };
            }
            return { accessibility: 0 /* Accessible */ };
            function getExternalModuleContainer(declaration) {
                for (; declaration; declaration = declaration.parent) {
                    if (hasExternalModuleSymbol(declaration)) {
                        return getSymbolOfNode(declaration);
                    }
                }
            }
        }
        function hasExternalModuleSymbol(declaration) {
            return (declaration.kind === 172 /* ModuleDeclaration */ && declaration.name.kind === 3 /* StringLiteral */) || (declaration.kind === 177 /* SourceFile */ && ts.isExternalModule(declaration));
        }
        function hasVisibleDeclarations(symbol) {
            var aliasesToMakeVisible;
            if (ts.forEach(symbol.declarations, function (declaration) { return !getIsDeclarationVisible(declaration); })) {
                return undefined;
            }
            return { aliasesToMakeVisible: aliasesToMakeVisible };
            function getIsDeclarationVisible(declaration) {
                if (!isDeclarationVisible(declaration)) {
                    // Mark the unexported alias as visible if its parent is visible
                    // because these kind of aliases can be used to name types in declaration file
                    if (declaration.kind === 174 /* ImportDeclaration */ && !(declaration.flags & 1 /* Export */) && isDeclarationVisible(declaration.parent)) {
                        getNodeLinks(declaration).isVisible = true;
                        if (aliasesToMakeVisible) {
                            if (!ts.contains(aliasesToMakeVisible, declaration)) {
                                aliasesToMakeVisible.push(declaration);
                            }
                        }
                        else {
                            aliasesToMakeVisible = [declaration];
                        }
                        return true;
                    }
                    // Declaration is not visible
                    return false;
                }
                return true;
            }
        }
        function isImportDeclarationEntityNameReferenceDeclarationVisibile(entityName) {
            var firstIdentifier = getFirstIdentifier(entityName);
            var firstIdentifierName = ts.identifierToString(firstIdentifier);
            var symbolOfNameSpace = resolveName(entityName.parent, firstIdentifier.text, ts.SymbolFlags.Namespace, ts.Diagnostics.Cannot_find_name_0, firstIdentifierName);
            // Verify if the symbol is accessible
            var hasNamespaceDeclarationsVisibile = hasVisibleDeclarations(symbolOfNameSpace);
            return hasNamespaceDeclarationsVisibile ? { accessibility: 0 /* Accessible */, aliasesToMakeVisible: hasNamespaceDeclarationsVisibile.aliasesToMakeVisible } : { accessibility: 1 /* NotAccessible */, errorSymbolName: firstIdentifierName };
        }
        // Enclosing declaration is optional when we dont want to get qualified name in the enclosing declaration scope
        // Meaning needs to be specified if the enclosing declaration is given
        function symbolToString(symbol, enclosingDeclaration, meaning) {
            function getSymbolName(symbol) {
                if (symbol.declarations && symbol.declarations.length > 0) {
                    var declaration = symbol.declarations[0];
                    if (declaration.name) {
                        return ts.identifierToString(declaration.name);
                    }
                }
                return symbol.name;
            }
            // Get qualified name
            if (enclosingDeclaration && !(symbol.flags & ts.SymbolFlags.PropertyOrAccessor & ts.SymbolFlags.Signature & 4096 /* Constructor */ & 2048 /* Method */ & 262144 /* TypeParameter */)) {
                var symbolName;
                while (symbol) {
                    var isFirstName = !symbolName;
                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning);
                    var currentSymbolName;
                    if (accessibleSymbolChain) {
                        currentSymbolName = ts.map(accessibleSymbolChain, function (accessibleSymbol) { return getSymbolName(accessibleSymbol); }).join(".");
                    }
                    else {
                        // If we didnt find accessible symbol chain for this symbol, break if this is external module
                        if (!isFirstName && ts.forEach(symbol.declarations, function (declaration) { return hasExternalModuleSymbol(declaration); })) {
                            break;
                        }
                        currentSymbolName = getSymbolName(symbol);
                    }
                    symbolName = currentSymbolName + (isFirstName ? "" : ("." + symbolName));
                    if (accessibleSymbolChain && !needsQualification(accessibleSymbolChain[0], enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {
                        break;
                    }
                    symbol = getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol);
                    meaning = getQualifiedLeftMeaning(meaning);
                }
                return symbolName;
            }
            return getSymbolName(symbol);
        }
        function writeSymbolToTextWriter(symbol, enclosingDeclaration, meaning, writer) {
            writer.write(symbolToString(symbol, enclosingDeclaration, meaning));
        }
        function createSingleLineTextWriter() {
            var result = "";
            return {
                write: function (s) {
                    result += s;
                },
                writeSymbol: function (symbol, enclosingDeclaration, meaning) {
                    writeSymbolToTextWriter(symbol, enclosingDeclaration, meaning, this);
                },
                writeLine: function () {
                    result += " ";
                },
                increaseIndent: function () {
                },
                decreaseIndent: function () {
                },
                getText: function () {
                    return result;
                }
            };
        }
        function typeToString(type, enclosingDeclaration, flags) {
            var stringWriter = createSingleLineTextWriter();
            // TODO(shkamat): typeToString should take enclosingDeclaration as input, once we have implemented enclosingDeclaration
            writeTypeToTextWriter(type, enclosingDeclaration, flags, stringWriter);
            return stringWriter.getText();
        }
        function writeTypeToTextWriter(type, enclosingDeclaration, flags, writer) {
            var typeStack;
            return writeType(type, true);
            function writeType(type, allowFunctionOrConstructorTypeLiteral) {
                if (type.flags & ts.TypeFlags.Intrinsic) {
                    writer.write(type.intrinsicName);
                }
                else if (type.flags & 4096 /* Reference */) {
                    writeTypeReference(type);
                }
                else if (type.flags & (1024 /* Class */ | 2048 /* Interface */ | 128 /* Enum */ | 512 /* TypeParameter */)) {
                    writer.writeSymbol(type.symbol, enclosingDeclaration, ts.SymbolFlags.Type);
                }
                else if (type.flags & 8192 /* Anonymous */) {
                    writeAnonymousType(type, allowFunctionOrConstructorTypeLiteral);
                }
                else if (type.flags & 256 /* StringLiteral */) {
                    writer.write(type.text);
                }
                else {
                    // Should never get here
                    writer.write("{ ... }");
                }
            }
            function writeTypeReference(type) {
                if (type.target === globalArrayType && !(flags & 1 /* WriteArrayAsGenericType */)) {
                    // If we are writing array element type the arrow style signatures are not allowed as
                    // we need to surround it by curlies, eg. { (): T; }[]; as () => T[] would mean something different
                    writeType(type.typeArguments[0], false);
                    writer.write("[]");
                }
                else {
                    writer.writeSymbol(type.target.symbol, enclosingDeclaration, ts.SymbolFlags.Type);
                    writer.write("<");
                    for (var i = 0; i < type.typeArguments.length; i++) {
                        if (i > 0) {
                            writer.write(", ");
                        }
                        writeType(type.typeArguments[i], true);
                    }
                    writer.write(">");
                }
            }
            function writeAnonymousType(type, allowFunctionOrConstructorTypeLiteral) {
                // Always use 'typeof T' for type of class, enum, and module objects
                if (type.symbol && type.symbol.flags & (16 /* Class */ | 64 /* Enum */ | 128 /* ValueModule */)) {
                    writeTypeofSymbol(type);
                }
                else if (shouldWriteTypeOfFunctionSymbol()) {
                    writeTypeofSymbol(type);
                }
                else if (typeStack && ts.contains(typeStack, type)) {
                    // Recursive usage, use any
                    writer.write("any");
                }
                else {
                    if (!typeStack) {
                        typeStack = [];
                    }
                    typeStack.push(type);
                    writeLiteralType(type, allowFunctionOrConstructorTypeLiteral);
                    typeStack.pop();
                }
                function shouldWriteTypeOfFunctionSymbol() {
                    if (type.symbol) {
                        var isStaticMethodSymbol = !!(type.symbol.flags & 2048 /* Method */ && ts.forEach(type.symbol.declarations, function (declaration) { return declaration.flags & 64 /* Static */; }));
                        var isNonLocalFunctionSymbol = !!(type.symbol.flags & 8 /* Function */) && (type.symbol.parent || ts.forEach(type.symbol.declarations, function (declaration) { return declaration.parent.kind === 177 /* SourceFile */ || declaration.parent.kind === 173 /* ModuleBlock */; }));
                        if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                            // typeof is allowed only for static/non local functions
                            return !!(flags & 2 /* UseTypeOfFunction */) || (typeStack && ts.contains(typeStack, type)); // it is type of the symbol uses itself recursively
                        }
                    }
                }
            }
            function writeTypeofSymbol(type) {
                writer.write("typeof ");
                writer.writeSymbol(type.symbol, enclosingDeclaration, ts.SymbolFlags.Value);
            }
            function writeLiteralType(type, allowFunctionOrConstructorTypeLiteral) {
                var resolved = resolveObjectTypeMembers(type);
                if (!resolved.properties.length && !resolved.stringIndexType && !resolved.numberIndexType) {
                    if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                        writer.write("{}");
                        return;
                    }
                    if (allowFunctionOrConstructorTypeLiteral) {
                        if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                            writeSignature(resolved.callSignatures[0], true);
                            return;
                        }
                        if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                            writer.write("new ");
                            writeSignature(resolved.constructSignatures[0], true);
                            return;
                        }
                    }
                }
                writer.write("{");
                writer.writeLine();
                writer.increaseIndent();
                for (var i = 0; i < resolved.callSignatures.length; i++) {
                    writeSignature(resolved.callSignatures[i]);
                    writer.write(";");
                    writer.writeLine();
                }
                for (var i = 0; i < resolved.constructSignatures.length; i++) {
                    writer.write("new ");
                    writeSignature(resolved.constructSignatures[i]);
                    writer.write(";");
                    writer.writeLine();
                }
                if (resolved.stringIndexType) {
                    writer.write("[x: string]: ");
                    writeType(resolved.stringIndexType, true);
                    writer.write(";");
                    writer.writeLine();
                }
                if (resolved.numberIndexType) {
                    writer.write("[x: number]: ");
                    writeType(resolved.numberIndexType, true);
                    writer.write(";");
                    writer.writeLine();
                }
                for (var i = 0; i < resolved.properties.length; i++) {
                    var p = resolved.properties[i];
                    var t = getTypeOfSymbol(p);
                    if (p.flags & (8 /* Function */ | 2048 /* Method */) && !getPropertiesOfType(t).length) {
                        var signatures = getSignaturesOfType(t, 0 /* Call */);
                        for (var j = 0; j < signatures.length; j++) {
                            writer.writeSymbol(p);
                            if (isOptionalProperty(p)) {
                                writer.write("?");
                            }
                            writeSignature(signatures[j]);
                            writer.write(";");
                            writer.writeLine();
                        }
                    }
                    else {
                        writer.writeSymbol(p);
                        if (isOptionalProperty(p)) {
                            writer.write("?");
                        }
                        writer.write(": ");
                        writeType(t, true);
                        writer.write(";");
                        writer.writeLine();
                    }
                }
                writer.decreaseIndent();
                writer.write("}");
            }
            function writeSignature(signature, arrowStyle) {
                if (signature.typeParameters) {
                    writer.write("<");
                    for (var i = 0; i < signature.typeParameters.length; i++) {
                        if (i > 0) {
                            writer.write(", ");
                        }
                        var tp = signature.typeParameters[i];
                        writer.writeSymbol(tp.symbol);
                        var constraint = getConstraintOfTypeParameter(tp);
                        if (constraint) {
                            writer.write(" extends ");
                            writeType(constraint, true);
                        }
                    }
                    writer.write(">");
                }
                writer.write("(");
                for (var i = 0; i < signature.parameters.length; i++) {
                    if (i > 0) {
                        writer.write(", ");
                    }
                    var p = signature.parameters[i];
                    if (getDeclarationFlagsFromSymbol(p) & 8 /* Rest */) {
                        writer.write("...");
                    }
                    writer.writeSymbol(p);
                    if (p.valueDeclaration.flags & 4 /* QuestionMark */ || p.valueDeclaration.initializer) {
                        writer.write("?");
                    }
                    writer.write(": ");
                    writeType(getTypeOfSymbol(p), true);
                }
                writer.write(arrowStyle ? ") => " : "): ");
                writeType(getReturnTypeOfSignature(signature), true);
            }
        }
        function isDeclarationVisible(node) {
            function getContainingExternalModule(node) {
                for (; node; node = node.parent) {
                    if (node.kind === 172 /* ModuleDeclaration */) {
                        if (node.name.kind === 3 /* StringLiteral */) {
                            return node;
                        }
                    }
                    else if (node.kind === 177 /* SourceFile */) {
                        return ts.isExternalModule(node) ? node : undefined;
                    }
                }
                ts.Debug.fail("getContainingModule cant reach here");
            }
            function isUsedInExportAssignment(node) {
                // Get source File and see if it is external module and has export assigned symbol
                var externalModule = getContainingExternalModule(node);
                if (externalModule) {
                    // This is export assigned symbol node
                    var externalModuleSymbol = getSymbolOfNode(externalModule);
                    var exportAssignmentSymbol = getExportAssignmentSymbol(externalModuleSymbol);
                    var resolvedExportSymbol;
                    var symbolOfNode = getSymbolOfNode(node);
                    if (isSymbolUsedInExportAssignment(symbolOfNode)) {
                        return true;
                    }
                    // if symbolOfNode is import declaration, resolve the symbol declaration and check
                    if (symbolOfNode.flags & 4194304 /* Import */) {
                        return isSymbolUsedInExportAssignment(resolveImport(symbolOfNode));
                    }
                }
                // Check if the symbol is used in export assignment
                function isSymbolUsedInExportAssignment(symbol) {
                    if (exportAssignmentSymbol === symbol) {
                        return true;
                    }
                    if (exportAssignmentSymbol && !!(exportAssignmentSymbol.flags & 4194304 /* Import */)) {
                        // if export assigned symbol is import declaration, resolve the import
                        resolvedExportSymbol = resolvedExportSymbol || resolveImport(exportAssignmentSymbol);
                        if (resolvedExportSymbol === symbol) {
                            return true;
                        }
                        // Container of resolvedExportSymbol is visible
                        return ts.forEach(resolvedExportSymbol.declarations, function (declaration) {
                            while (declaration) {
                                if (declaration === node) {
                                    return true;
                                }
                                declaration = declaration.parent;
                            }
                        });
                    }
                }
            }
            function determineIfDeclarationIsVisible() {
                switch (node.kind) {
                    case 166 /* VariableDeclaration */:
                    case 172 /* ModuleDeclaration */:
                    case 169 /* ClassDeclaration */:
                    case 170 /* InterfaceDeclaration */:
                    case 167 /* FunctionDeclaration */:
                    case 171 /* EnumDeclaration */:
                    case 174 /* ImportDeclaration */:
                        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
                        var parent = node.kind === 166 /* VariableDeclaration */ ? node.parent.parent : node.parent;
                        // If the node is not exported or it is not ambient module element (except import declaration)
                        if (!(node.flags & 1 /* Export */) && !(node.kind !== 174 /* ImportDeclaration */ && parent.kind !== 177 /* SourceFile */ && ts.isInAmbientContext(parent))) {
                            return isGlobalSourceFile(parent) || isUsedInExportAssignment(node);
                        }
                        // Exported members/ambient module elements (exception import declaraiton) are visible if parent is visible
                        return isDeclarationVisible(parent);
                    case 115 /* Property */:
                    case 116 /* Method */:
                        if (node.flags & 32 /* Private */) {
                            // Private properties/methods are not visible
                            return false;
                        }
                    case 117 /* Constructor */:
                    case 121 /* ConstructSignature */:
                    case 120 /* CallSignature */:
                    case 122 /* IndexSignature */:
                    case 114 /* Parameter */:
                    case 173 /* ModuleBlock */:
                        return isDeclarationVisible(node.parent);
                    case 177 /* SourceFile */:
                        return true;
                    default:
                        ts.Debug.fail("isDeclarationVisible unknown: SyntaxKind: " + ts.SyntaxKind[node.kind]);
                }
            }
            if (node) {
                var links = getNodeLinks(node);
                if (links.isVisible === undefined) {
                    links.isVisible = !!determineIfDeclarationIsVisible();
                }
                return links.isVisible;
            }
        }
        function getApparentType(type) {
            if (type.flags & 512 /* TypeParameter */) {
                do {
                    type = getConstraintOfTypeParameter(type);
                } while (type && type.flags & 512 /* TypeParameter */);
                if (!type)
                    type = emptyObjectType;
            }
            if (type.flags & ts.TypeFlags.StringLike) {
                type = globalStringType;
            }
            else if (type.flags & ts.TypeFlags.NumberLike) {
                type = globalNumberType;
            }
            else if (type.flags & 8 /* Boolean */) {
                type = globalBooleanType;
            }
            return type;
        }
        function getTypeOfPrototypeProperty(prototype) {
            // TypeScript 1.0 spec (April 2014): 8.4
            // Every class automatically contains a static property member named 'prototype',
            // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
            // It is an error to explicitly declare a static property member with the name 'prototype'.
            var classType = getDeclaredTypeOfSymbol(prototype.parent);
            return classType.typeParameters ? createTypeReference(classType, ts.map(classType.typeParameters, function (_) { return anyType; })) : classType;
        }
        function getTypeOfVariableDeclaration(declaration) {
            // A variable declared in a for..in statement is always of type any
            if (declaration.parent.kind === 151 /* ForInStatement */) {
                return anyType;
            }
            // Use type from type annotation if one is present
            if (declaration.type) {
                return getTypeFromTypeNode(declaration.type);
            }
            if (declaration.kind === 114 /* Parameter */) {
                var func = declaration.parent;
                // For a parameter of a set accessor, use the type of the get accessor if one is present
                if (func.kind === 119 /* SetAccessor */) {
                    var getter = getDeclarationOfKind(declaration.parent.symbol, 118 /* GetAccessor */);
                    if (getter) {
                        return getReturnTypeOfSignature(getSignatureFromDeclaration(getter));
                    }
                }
                // Use contextual parameter type if one is available
                var type = getContextuallyTypedParameterType(declaration);
                if (type) {
                    return type;
                }
            }
            // Use the type of the initializer expression if one is present
            if (declaration.initializer) {
                var unwidenedType = checkAndMarkExpression(declaration.initializer);
                var type = getWidenedType(unwidenedType);
                if (type !== unwidenedType) {
                    checkImplicitAny(type);
                }
                return type;
            }
            // Rest parameters default to type any[], other parameters default to type any
            var type = declaration.flags & 8 /* Rest */ ? createArrayType(anyType) : anyType;
            checkImplicitAny(type);
            return type;
            function checkImplicitAny(type) {
                if (!fullTypeCheck || !program.getCompilerOptions().noImplicitAny) {
                    return;
                }
                // We need to have ended up with 'any', 'any[]', 'any[][]', etc.
                if (getInnermostTypeOfNestedArrayTypes(type) !== anyType) {
                    return;
                }
                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.
                // (e.g. privates within .d.ts files do not expose type information)
                if (isPrivateWithinAmbient(declaration) || (declaration.kind === 114 /* Parameter */ && isPrivateWithinAmbient(declaration.parent))) {
                    return;
                }
                switch (declaration.kind) {
                    case 115 /* Property */:
                        var diagnostic = ts.Diagnostics.Member_0_implicitly_has_an_1_type;
                        break;
                    case 114 /* Parameter */:
                        var diagnostic = declaration.flags & 8 /* Rest */ ? ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : ts.Diagnostics.Parameter_0_implicitly_has_an_1_type;
                        break;
                    default:
                        var diagnostic = ts.Diagnostics.Variable_0_implicitly_has_an_1_type;
                }
                error(declaration, diagnostic, ts.identifierToString(declaration.name), typeToString(type));
            }
        }
        function getTypeOfVariableOrParameterOrProperty(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                // Handle prototype property
                if (symbol.flags & 67108864 /* Prototype */) {
                    return links.type = getTypeOfPrototypeProperty(symbol);
                }
                // Handle catch clause variables
                var declaration = symbol.valueDeclaration;
                if (declaration.kind === 163 /* CatchBlock */) {
                    return links.type = anyType;
                }
                // Handle variable, parameter or property
                links.type = resolvingType;
                var type = getTypeOfVariableDeclaration(declaration);
                if (links.type === resolvingType) {
                    links.type = type;
                }
            }
            else if (links.type === resolvingType) {
                links.type = anyType;
            }
            return links.type;
        }
        function getSetAccessorTypeAnnotationNode(accessor) {
            return accessor && accessor.parameters.length > 0 && accessor.parameters[0].type;
        }
        function getAnnotatedAccessorType(accessor) {
            if (accessor) {
                if (accessor.kind === 118 /* GetAccessor */) {
                    return accessor.type && getTypeFromTypeNode(accessor.type);
                }
                else {
                    var setterTypeAnnotation = getSetAccessorTypeAnnotationNode(accessor);
                    return setterTypeAnnotation && getTypeFromTypeNode(setterTypeAnnotation);
                }
            }
            return undefined;
        }
        function getTypeOfAccessors(symbol) {
            var links = getSymbolLinks(symbol);
            checkAndStoreTypeOfAccessors(symbol, links);
            return links.type;
        }
        function checkAndStoreTypeOfAccessors(symbol, links) {
            links = links || getSymbolLinks(symbol);
            if (!links.type) {
                links.type = resolvingType;
                var getter = getDeclarationOfKind(symbol, 118 /* GetAccessor */);
                var setter = getDeclarationOfKind(symbol, 119 /* SetAccessor */);
                var type;
                // First try to see if the user specified a return type on the get-accessor.
                var getterReturnType = getAnnotatedAccessorType(getter);
                if (getterReturnType) {
                    type = getterReturnType;
                }
                else {
                    // If the user didn't specify a return type, try to use the set-accessor's parameter type.
                    var setterParameterType = getAnnotatedAccessorType(setter);
                    if (setterParameterType) {
                        type = setterParameterType;
                    }
                    else {
                        // If there are no specified types, try to infer it from the body of the get accessor if it exists.
                        if (getter) {
                            type = getReturnTypeFromBody(getter);
                        }
                        else {
                            if (program.getCompilerOptions().noImplicitAny) {
                                error(setter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation, symbol.name);
                            }
                            type = anyType;
                        }
                    }
                }
                if (links.type === resolvingType) {
                    links.type = type;
                }
            }
            else if (links.type === resolvingType) {
                links.type = anyType;
            }
        }
        function getTypeOfFuncClassEnumModule(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = createObjectType(8192 /* Anonymous */, symbol);
            }
            return links.type;
        }
        function getTypeOfEnumMember(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
            }
            return links.type;
        }
        function getTypeOfImport(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = getTypeOfSymbol(resolveImport(symbol));
            }
            return links.type;
        }
        function getTypeOfInstantiatedSymbol(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = instantiateType(getTypeOfSymbol(links.target), links.mapper);
            }
            return links.type;
        }
        function getTypeOfSymbol(symbol) {
            if (symbol.flags & (1 /* Variable */ | 2 /* Property */)) {
                return getTypeOfVariableOrParameterOrProperty(symbol);
            }
            if (symbol.flags & (8 /* Function */ | 2048 /* Method */ | 16 /* Class */ | 64 /* Enum */ | 128 /* ValueModule */)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            if (symbol.flags & 4 /* EnumMember */) {
                return getTypeOfEnumMember(symbol);
            }
            if (symbol.flags & ts.SymbolFlags.Accessor) {
                return getTypeOfAccessors(symbol);
            }
            if (symbol.flags & 4194304 /* Import */) {
                return getTypeOfImport(symbol);
            }
            if (symbol.flags & 8388608 /* Instantiated */) {
                return getTypeOfInstantiatedSymbol(symbol);
            }
            return unknownType;
        }
        function getTargetType(type) {
            return type.flags & 4096 /* Reference */ ? type.target : type;
        }
        function hasBaseType(type, checkBase) {
            return check(type);
            function check(type) {
                var target = getTargetType(type);
                return target === checkBase || ts.forEach(target.baseTypes, check);
            }
        }
        // Return combined list of type parameters from all declarations of a class or interface. Elsewhere we check they're all
        // the same, but even if they're not we still need the complete list to ensure instantiations supply type arguments
        // for all type parameters.
        function getTypeParametersOfClassOrInterface(symbol) {
            var result;
            ts.forEach(symbol.declarations, function (node) {
                if (node.kind === 170 /* InterfaceDeclaration */ || node.kind === 169 /* ClassDeclaration */) {
                    var declaration = node;
                    if (declaration.typeParameters && declaration.typeParameters.length) {
                        ts.forEach(declaration.typeParameters, function (node) {
                            var tp = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
                            if (!result) {
                                result = [tp];
                            }
                            else if (!ts.contains(result, tp)) {
                                result.push(tp);
                            }
                        });
                    }
                }
            });
            return result;
        }
        function getDeclaredTypeOfClass(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = links.declaredType = createObjectType(1024 /* Class */, symbol);
                var typeParameters = getTypeParametersOfClassOrInterface(symbol);
                if (typeParameters) {
                    type.flags |= 4096 /* Reference */;
                    type.typeParameters = typeParameters;
                    type.instantiations = {};
                    type.instantiations[getTypeListId(type.typeParameters)] = type;
                    type.target = type;
                    type.typeArguments = type.typeParameters;
                }
                type.baseTypes = [];
                var declaration = getDeclarationOfKind(symbol, 169 /* ClassDeclaration */);
                if (declaration.baseType) {
                    var baseType = getTypeFromTypeReferenceNode(declaration.baseType);
                    if (baseType !== unknownType) {
                        if (getTargetType(baseType).flags & 1024 /* Class */) {
                            if (type !== baseType && !hasBaseType(baseType, type)) {
                                type.baseTypes.push(baseType);
                            }
                            else {
                                error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */));
                            }
                        }
                        else {
                            error(declaration.baseType, ts.Diagnostics.A_class_may_only_extend_another_class);
                        }
                    }
                }
                type.declaredProperties = getNamedMembers(symbol.members);
                type.declaredCallSignatures = emptyArray;
                type.declaredConstructSignatures = emptyArray;
                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfInterface(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = links.declaredType = createObjectType(2048 /* Interface */, symbol);
                var typeParameters = getTypeParametersOfClassOrInterface(symbol);
                if (typeParameters) {
                    type.flags |= 4096 /* Reference */;
                    type.typeParameters = typeParameters;
                    type.instantiations = {};
                    type.instantiations[getTypeListId(type.typeParameters)] = type;
                    type.target = type;
                    type.typeArguments = type.typeParameters;
                }
                type.baseTypes = [];
                ts.forEach(symbol.declarations, function (declaration) {
                    if (declaration.kind === 170 /* InterfaceDeclaration */ && declaration.baseTypes) {
                        ts.forEach(declaration.baseTypes, function (node) {
                            var baseType = getTypeFromTypeReferenceNode(node);
                            if (baseType !== unknownType) {
                                if (getTargetType(baseType).flags & (1024 /* Class */ | 2048 /* Interface */)) {
                                    if (type !== baseType && !hasBaseType(baseType, type)) {
                                        type.baseTypes.push(baseType);
                                    }
                                    else {
                                        error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */));
                                    }
                                }
                                else {
                                    error(node, ts.Diagnostics.An_interface_may_only_extend_a_class_or_another_interface);
                                }
                            }
                        });
                    }
                });
                type.declaredProperties = getNamedMembers(symbol.members);
                type.declaredCallSignatures = getSignaturesOfSymbol(symbol.members["__call"]);
                type.declaredConstructSignatures = getSignaturesOfSymbol(symbol.members["__new"]);
                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfEnum(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = createType(128 /* Enum */);
                type.symbol = symbol;
                links.declaredType = type;
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfTypeParameter(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = createType(512 /* TypeParameter */);
                type.symbol = symbol;
                if (!getDeclarationOfKind(symbol, 113 /* TypeParameter */).constraint) {
                    type.constraint = noConstraintType;
                }
                links.declaredType = type;
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfImport(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                links.declaredType = getDeclaredTypeOfSymbol(resolveImport(symbol));
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfSymbol(symbol) {
            if (symbol.flags & 16 /* Class */) {
                return getDeclaredTypeOfClass(symbol);
            }
            if (symbol.flags & 32 /* Interface */) {
                return getDeclaredTypeOfInterface(symbol);
            }
            if (symbol.flags & 64 /* Enum */) {
                return getDeclaredTypeOfEnum(symbol);
            }
            if (symbol.flags & 262144 /* TypeParameter */) {
                return getDeclaredTypeOfTypeParameter(symbol);
            }
            if (symbol.flags & 4194304 /* Import */) {
                return getDeclaredTypeOfImport(symbol);
            }
            ts.Debug.assert((symbol.flags & 8388608 /* Instantiated */) === 0);
            return unknownType;
        }
        function createSymbolTable(symbols) {
            var result = {};
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                result[symbol.name] = symbol;
            }
            return result;
        }
        function createInstantiatedSymbolTable(symbols, mapper) {
            var result = {};
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                result[symbol.name] = instantiateSymbol(symbol, mapper);
            }
            return result;
        }
        function addInheritedMembers(symbols, baseSymbols) {
            for (var i = 0; i < baseSymbols.length; i++) {
                var s = baseSymbols[i];
                if (!ts.hasProperty(symbols, s.name)) {
                    symbols[s.name] = s;
                }
            }
        }
        function addInheritedSignatures(signatures, baseSignatures) {
            if (baseSignatures) {
                for (var i = 0; i < baseSignatures.length; i++) {
                    signatures.push(baseSignatures[i]);
                }
            }
        }
        function resolveClassOrInterfaceMembers(type) {
            var members = type.symbol.members;
            var callSignatures = type.declaredCallSignatures;
            var constructSignatures = type.declaredConstructSignatures;
            var stringIndexType = type.declaredStringIndexType;
            var numberIndexType = type.declaredNumberIndexType;
            if (type.baseTypes.length) {
                members = createSymbolTable(type.declaredProperties);
                ts.forEach(type.baseTypes, function (baseType) {
                    addInheritedMembers(members, getPropertiesOfType(baseType));
                    callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(baseType, 0 /* Call */));
                    constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(baseType, 1 /* Construct */));
                    stringIndexType = stringIndexType || getIndexTypeOfType(baseType, 0 /* String */);
                    numberIndexType = numberIndexType || getIndexTypeOfType(baseType, 1 /* Number */);
                });
            }
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function resolveTypeReferenceMembers(type) {
            var target = type.target;
            var mapper = createTypeMapper(target.typeParameters, type.typeArguments);
            var members = createInstantiatedSymbolTable(target.declaredProperties, mapper);
            var callSignatures = instantiateList(target.declaredCallSignatures, mapper, instantiateSignature);
            var constructSignatures = instantiateList(target.declaredConstructSignatures, mapper, instantiateSignature);
            var stringIndexType = target.declaredStringIndexType ? instantiateType(target.declaredStringIndexType, mapper) : undefined;
            var numberIndexType = target.declaredNumberIndexType ? instantiateType(target.declaredNumberIndexType, mapper) : undefined;
            ts.forEach(target.baseTypes, function (baseType) {
                var instantiatedBaseType = instantiateType(baseType, mapper);
                addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
                callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0 /* Call */));
                constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1 /* Construct */));
                stringIndexType = stringIndexType || getIndexTypeOfType(instantiatedBaseType, 0 /* String */);
                numberIndexType = numberIndexType || getIndexTypeOfType(instantiatedBaseType, 1 /* Number */);
            });
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function createSignature(declaration, typeParameters, parameters, resolvedReturnType, minArgumentCount, hasRestParameter, hasStringLiterals) {
            var sig = new Signature(checker);
            sig.declaration = declaration;
            sig.typeParameters = typeParameters;
            sig.parameters = parameters;
            sig.resolvedReturnType = resolvedReturnType;
            sig.minArgumentCount = minArgumentCount;
            sig.hasRestParameter = hasRestParameter;
            sig.hasStringLiterals = hasStringLiterals;
            return sig;
        }
        function cloneSignature(sig) {
            return createSignature(sig.declaration, sig.typeParameters, sig.parameters, sig.resolvedReturnType, sig.minArgumentCount, sig.hasRestParameter, sig.hasStringLiterals);
        }
        function getDefaultConstructSignatures(classType) {
            if (classType.baseTypes.length) {
                var baseType = classType.baseTypes[0];
                var baseSignatures = getSignaturesOfType(getTypeOfSymbol(baseType.symbol), 1 /* Construct */);
                return ts.map(baseSignatures, function (baseSignature) {
                    var signature = baseType.flags & 4096 /* Reference */ ? getSignatureInstantiation(baseSignature, baseType.typeArguments) : cloneSignature(baseSignature);
                    signature.typeParameters = classType.typeParameters;
                    signature.resolvedReturnType = classType;
                    return signature;
                });
            }
            return [createSignature(undefined, classType.typeParameters, emptyArray, classType, 0, false, false)];
        }
        function resolveAnonymousTypeMembers(type) {
            var symbol = type.symbol;
            var members = emptySymbols;
            var callSignatures = emptyArray;
            var constructSignatures = emptyArray;
            if (symbol.flags & ts.SymbolFlags.HasExports) {
                members = symbol.exports;
            }
            if (symbol.flags & (8 /* Function */ | 2048 /* Method */)) {
                callSignatures = getSignaturesOfSymbol(symbol);
            }
            if (symbol.flags & 16 /* Class */) {
                var classType = getDeclaredTypeOfClass(symbol);
                constructSignatures = getSignaturesOfSymbol(symbol.members["__constructor"]);
                if (!constructSignatures.length)
                    constructSignatures = getDefaultConstructSignatures(classType);
                if (classType.baseTypes.length) {
                    var members = createSymbolTable(getNamedMembers(members));
                    addInheritedMembers(members, getPropertiesOfType(getTypeOfSymbol(classType.baseTypes[0].symbol)));
                }
            }
            var numberIndexType = (symbol.flags & 64 /* Enum */) ? stringType : undefined;
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, undefined, numberIndexType);
        }
        function resolveObjectTypeMembers(type) {
            if (!type.members) {
                if (type.flags & (1024 /* Class */ | 2048 /* Interface */)) {
                    resolveClassOrInterfaceMembers(type);
                }
                else if (type.flags & 8192 /* Anonymous */) {
                    resolveAnonymousTypeMembers(type);
                }
                else {
                    resolveTypeReferenceMembers(type);
                }
            }
            return type;
        }
        function getPropertiesOfType(type) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                return resolveObjectTypeMembers(type).properties;
            }
            return emptyArray;
        }
        function getPropertyOfType(type, name) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                if (ts.hasProperty(resolved.members, name)) {
                    var symbol = resolved.members[name];
                    if (symbolIsValue(symbol)) {
                        return symbol;
                    }
                }
            }
        }
        function getPropertyOfApparentType(type, name) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                if (ts.hasProperty(resolved.members, name)) {
                    var symbol = resolved.members[name];
                    if (symbolIsValue(symbol)) {
                        return symbol;
                    }
                }
                if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {
                    var symbol = getPropertyOfType(globalFunctionType, name);
                    if (symbol)
                        return symbol;
                }
                return getPropertyOfType(globalObjectType, name);
            }
        }
        function getSignaturesOfType(type, kind) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                return kind === 0 /* Call */ ? resolved.callSignatures : resolved.constructSignatures;
            }
            return emptyArray;
        }
        function getIndexTypeOfType(type, kind) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                return kind === 0 /* String */ ? resolved.stringIndexType : resolved.numberIndexType;
            }
        }
        // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
        // type checking functions).
        function getTypeParametersFromDeclaration(typeParameterDeclarations) {
            var result = [];
            ts.forEach(typeParameterDeclarations, function (node) {
                var tp = getDeclaredTypeOfTypeParameter(node.symbol);
                if (!ts.contains(result, tp)) {
                    result.push(tp);
                }
            });
            return result;
        }
        function getSignatureFromDeclaration(declaration) {
            var links = getNodeLinks(declaration);
            if (!links.resolvedSignature) {
                var classType = declaration.kind === 117 /* Constructor */ ? getDeclaredTypeOfClass(declaration.parent.symbol) : undefined;
                var typeParameters = classType ? classType.typeParameters : declaration.typeParameters ? getTypeParametersFromDeclaration(declaration.typeParameters) : undefined;
                var parameters = [];
                var hasStringLiterals = false;
                var minArgumentCount = -1;
                for (var i = 0, n = declaration.parameters.length; i < n; i++) {
                    var param = declaration.parameters[i];
                    parameters.push(param.symbol);
                    if (param.type && param.type.kind === 3 /* StringLiteral */) {
                        hasStringLiterals = true;
                    }
                    if (minArgumentCount < 0) {
                        if (param.initializer || param.flags & (4 /* QuestionMark */ | 8 /* Rest */)) {
                            minArgumentCount = i;
                        }
                    }
                }
                if (minArgumentCount < 0) {
                    minArgumentCount = declaration.parameters.length;
                }
                var returnType;
                if (classType) {
                    returnType = classType;
                }
                else if (declaration.type) {
                    returnType = getTypeFromTypeNode(declaration.type);
                }
                else {
                    // TypeScript 1.0 spec (April 2014):
                    // If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.
                    if (declaration.kind === 118 /* GetAccessor */) {
                        var setter = getDeclarationOfKind(declaration.symbol, 119 /* SetAccessor */);
                        returnType = getAnnotatedAccessorType(setter);
                    }
                    if (!returnType && !declaration.body) {
                        returnType = anyType;
                    }
                }
                links.resolvedSignature = createSignature(declaration, typeParameters, parameters, returnType, minArgumentCount, ts.hasRestParameters(declaration), hasStringLiterals);
            }
            return links.resolvedSignature;
        }
        function getSignaturesOfSymbol(symbol) {
            if (!symbol)
                return emptyArray;
            var result = [];
            for (var i = 0, len = symbol.declarations.length; i < len; i++) {
                var node = symbol.declarations[i];
                switch (node.kind) {
                    case 167 /* FunctionDeclaration */:
                    case 116 /* Method */:
                    case 117 /* Constructor */:
                    case 120 /* CallSignature */:
                    case 121 /* ConstructSignature */:
                    case 122 /* IndexSignature */:
                    case 118 /* GetAccessor */:
                    case 119 /* SetAccessor */:
                    case 136 /* FunctionExpression */:
                    case 137 /* ArrowFunction */:
                        // Don't include signature if node is the implementation of an overloaded function. A node is considered
                        // an implementation node if it has a body and the previous node is of the same kind and immediately
                        // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
                        if (i > 0 && node.body) {
                            var previous = symbol.declarations[i - 1];
                            if (node.parent === previous.parent && node.kind === previous.kind && node.pos === previous.end) {
                                break;
                            }
                        }
                        result.push(getSignatureFromDeclaration(node));
                }
            }
            return result;
        }
        function getReturnTypeOfSignature(signature) {
            if (!signature.resolvedReturnType) {
                signature.resolvedReturnType = resolvingType;
                if (signature.target) {
                    var type = instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper);
                }
                else {
                    var type = getReturnTypeFromBody(signature.declaration);
                }
                if (signature.resolvedReturnType === resolvingType) {
                    signature.resolvedReturnType = type;
                }
            }
            else if (signature.resolvedReturnType === resolvingType) {
                signature.resolvedReturnType = anyType;
            }
            return signature.resolvedReturnType;
        }
        function getRestTypeOfSignature(signature) {
            if (signature.hasRestParameter) {
                var type = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                if (type.flags & 4096 /* Reference */ && type.target === globalArrayType) {
                    return type.typeArguments[0];
                }
            }
            return anyType;
        }
        function getSignatureInstantiation(signature, typeArguments) {
            return instantiateSignature(signature, createTypeMapper(signature.typeParameters, typeArguments), true);
        }
        function getErasedSignature(signature) {
            if (!signature.typeParameters)
                return signature;
            if (!signature.erasedSignatureCache) {
                if (signature.target) {
                    signature.erasedSignatureCache = instantiateSignature(getErasedSignature(signature.target), signature.mapper);
                }
                else {
                    signature.erasedSignatureCache = instantiateSignature(signature, createTypeEraser(signature.typeParameters), true);
                }
            }
            return signature.erasedSignatureCache;
        }
        function getOrCreateTypeFromSignature(signature) {
            // There are two ways to declare a construct signature, one is by declaring a class constructor
            // using the constructor keyword, and the other is declaring a bare construct signature in an
            // object type literal or interface (using the new keyword). Each way of declaring a constructor
            // will result in a different declaration kind.
            if (!signature.isolatedSignatureType) {
                var isConstructor = signature.declaration.kind === 117 /* Constructor */ || signature.declaration.kind === 121 /* ConstructSignature */;
                var type = createObjectType(8192 /* Anonymous */ | 16384 /* FromSignature */);
                type.members = emptySymbols;
                type.properties = emptyArray;
                type.callSignatures = !isConstructor ? [signature] : emptyArray;
                type.constructSignatures = isConstructor ? [signature] : emptyArray;
                signature.isolatedSignatureType = type;
            }
            return signature.isolatedSignatureType;
        }
        function getIndexSymbol(symbol) {
            return symbol.members["__index"];
        }
        function getIndexDeclarationOfSymbol(symbol, kind) {
            var syntaxKind = kind === 1 /* Number */ ? 108 /* NumberKeyword */ : 110 /* StringKeyword */;
            var indexSymbol = getIndexSymbol(symbol);
            if (indexSymbol) {
                var len = indexSymbol.declarations.length;
                for (var i = 0; i < len; i++) {
                    var node = indexSymbol.declarations[i];
                    if (node.parameters.length === 1) {
                        var parameter = node.parameters[0];
                        if (parameter && parameter.type && parameter.type.kind === syntaxKind) {
                            return node;
                        }
                    }
                }
            }
            return undefined;
        }
        function getIndexTypeOfSymbol(symbol, kind) {
            var declaration = getIndexDeclarationOfSymbol(symbol, kind);
            return declaration ? declaration.type ? getTypeFromTypeNode(declaration.type) : anyType : undefined;
        }
        function getConstraintOfTypeParameter(type) {
            if (!type.constraint) {
                if (type.target) {
                    var targetConstraint = getConstraintOfTypeParameter(type.target);
                    type.constraint = targetConstraint ? instantiateType(targetConstraint, type.mapper) : noConstraintType;
                }
                else {
                    type.constraint = getTypeFromTypeNode(getDeclarationOfKind(type.symbol, 113 /* TypeParameter */).constraint);
                }
            }
            return type.constraint === noConstraintType ? undefined : type.constraint;
        }
        function getTypeListId(types) {
            switch (types.length) {
                case 1:
                    return "" + types[0].id;
                case 2:
                    return types[0].id + "," + types[1].id;
                default:
                    var result = "";
                    for (var i = 0; i < types.length; i++) {
                        if (i > 0)
                            result += ",";
                        result += types[i].id;
                    }
                    return result;
            }
        }
        function createTypeReference(target, typeArguments) {
            var id = getTypeListId(typeArguments);
            var type = target.instantiations[id];
            if (!type) {
                type = target.instantiations[id] = createObjectType(4096 /* Reference */, target.symbol);
                type.target = target;
                type.typeArguments = typeArguments;
            }
            return type;
        }
        function isTypeParameterReferenceIllegalInConstraint(typeReferenceNode, typeParameterSymbol) {
            var links = getNodeLinks(typeReferenceNode);
            if (links.isIllegalTypeReferenceInConstraint !== undefined) {
                return links.isIllegalTypeReferenceInConstraint;
            }
            // bubble up to the declaration
            var currentNode = typeReferenceNode;
            while (!ts.forEach(typeParameterSymbol.declarations, function (d) { return d.parent === currentNode.parent; })) {
                currentNode = currentNode.parent;
            }
            // if last step was made from the type parameter this means that path has started somewhere in constraint which is illegal
            links.isIllegalTypeReferenceInConstraint = currentNode.kind === 113 /* TypeParameter */;
            return links.isIllegalTypeReferenceInConstraint;
        }
        function checkTypeParameterHasIllegalReferencesInConstraint(typeParameter) {
            var typeParameterSymbol;
            function check(n) {
                if (n.kind === 123 /* TypeReference */ && n.typeName.kind === 55 /* Identifier */) {
                    var links = getNodeLinks(n);
                    if (links.isIllegalTypeReferenceInConstraint === undefined) {
                        var symbol = resolveName(typeParameter, n.typeName.text, ts.SymbolFlags.Type, undefined, undefined);
                        if (symbol && (symbol.flags & 262144 /* TypeParameter */)) {
                            // TypeScript 1.0 spec (April 2014): 3.4.1
                            // Type parameters declared in a particular type parameter list
                            // may not be referenced in constraints in that type parameter list
                            // symbol.declaration.parent === typeParameter.parent
                            // -> typeParameter and symbol.declaration originate from the same type parameter list
                            // -> illegal for all declarations in symbol
                            // forEach === exists
                            links.isIllegalTypeReferenceInConstraint = ts.forEach(symbol.declarations, function (d) { return d.parent == typeParameter.parent; });
                        }
                    }
                    if (links.isIllegalTypeReferenceInConstraint) {
                        error(typeParameter, ts.Diagnostics.Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list);
                    }
                }
                ts.forEachChild(n, check);
            }
            if (typeParameter.constraint) {
                typeParameterSymbol = getSymbolOfNode(typeParameter);
                check(typeParameter.constraint);
            }
        }
        function getTypeFromTypeReferenceNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var symbol = resolveEntityName(node, node.typeName, ts.SymbolFlags.Type);
                if (symbol) {
                    var type;
                    if ((symbol.flags & 262144 /* TypeParameter */) && isTypeParameterReferenceIllegalInConstraint(node, symbol)) {
                        // TypeScript 1.0 spec (April 2014): 3.4.1
                        // Type parameters declared in a particular type parameter list
                        // may not be referenced in constraints in that type parameter list
                        // Implementation: such type references are resolved to 'unknown' type that usually denotes error
                        type = unknownType;
                    }
                    else {
                        type = getDeclaredTypeOfSymbol(symbol);
                        if (type.flags & (1024 /* Class */ | 2048 /* Interface */) && type.flags & 4096 /* Reference */) {
                            var typeParameters = type.typeParameters;
                            if (node.typeArguments && node.typeArguments.length === typeParameters.length) {
                                type = createTypeReference(type, ts.map(node.typeArguments, function (t) { return getTypeFromTypeNode(t); }));
                            }
                            else {
                                error(node, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */), typeParameters.length);
                                type = undefined;
                            }
                        }
                        else {
                            if (node.typeArguments) {
                                error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));
                                type = undefined;
                            }
                        }
                    }
                }
                links.resolvedType = type || unknownType;
            }
            return links.resolvedType;
        }
        function getTypeFromTypeQueryNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // TypeScript 1.0 spec (April 2014): 3.6.3
                // The expression is processed as an identifier expression (section 4.3)
                // or property access expression(section 4.10),
                // the widened type(section 3.9) of which becomes the result.
                links.resolvedType = getWidenedType(checkExpression(node.exprName));
            }
            return links.resolvedType;
        }
        function getTypeOfGlobalSymbol(symbol, arity) {
            function getTypeDeclaration(symbol) {
                var declarations = symbol.declarations;
                for (var i = 0; i < declarations.length; i++) {
                    var declaration = declarations[i];
                    switch (declaration.kind) {
                        case 169 /* ClassDeclaration */:
                        case 170 /* InterfaceDeclaration */:
                        case 171 /* EnumDeclaration */:
                            return declaration;
                    }
                }
            }
            if (!symbol) {
                return emptyObjectType;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            var name = symbol.name;
            if (!(type.flags & ts.TypeFlags.ObjectType)) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, name);
                return emptyObjectType;
            }
            if ((type.typeParameters ? type.typeParameters.length : 0) !== arity) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, name, arity);
                return emptyObjectType;
            }
            return type;
        }
        function getGlobalSymbol(name) {
            return resolveName(undefined, name, ts.SymbolFlags.Type, ts.Diagnostics.Cannot_find_global_type_0, name);
        }
        function getGlobalType(name) {
            return getTypeOfGlobalSymbol(getGlobalSymbol(name), 0);
        }
        function createArrayType(elementType) {
            // globalArrayType will be undefined if we get here during creation of the Array type. This for example happens if
            // user code augments the Array type with call or construct signatures that have an array type as the return type.
            // We instead use globalArraySymbol to obtain the (not yet fully constructed) Array type.
            var arrayType = globalArrayType || getDeclaredTypeOfSymbol(globalArraySymbol);
            return arrayType !== emptyObjectType ? createTypeReference(arrayType, [elementType]) : emptyObjectType;
        }
        function getTypeFromArrayTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = createArrayType(getTypeFromTypeNode(node.elementType));
            }
            return links.resolvedType;
        }
        function getTypeFromTypeLiteralNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var symbol = node.symbol;
                var members = symbol.members;
                var callSignatures = getSignaturesOfSymbol(members["__call"]);
                var constructSignatures = getSignaturesOfSymbol(members["__new"]);
                var stringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                var numberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
                links.resolvedType = createAnonymousType(symbol, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
            }
            return links.resolvedType;
        }
        function getStringLiteralType(node) {
            if (ts.hasProperty(stringLiteralTypes, node.text))
                return stringLiteralTypes[node.text];
            var type = stringLiteralTypes[node.text] = createType(256 /* StringLiteral */);
            type.text = ts.getSourceTextOfNode(node);
            return type;
        }
        function getTypeFromStringLiteral(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getStringLiteralType(node);
            }
            return links.resolvedType;
        }
        function getTypeFromTypeNode(node) {
            switch (node.kind) {
                case 101 /* AnyKeyword */:
                    return anyType;
                case 110 /* StringKeyword */:
                    return stringType;
                case 108 /* NumberKeyword */:
                    return numberType;
                case 102 /* BooleanKeyword */:
                    return booleanType;
                case 89 /* VoidKeyword */:
                    return voidType;
                case 3 /* StringLiteral */:
                    return getTypeFromStringLiteral(node);
                case 123 /* TypeReference */:
                    return getTypeFromTypeReferenceNode(node);
                case 124 /* TypeQuery */:
                    return getTypeFromTypeQueryNode(node);
                case 126 /* ArrayType */:
                    return getTypeFromArrayTypeNode(node);
                case 125 /* TypeLiteral */:
                    return getTypeFromTypeLiteralNode(node);
                case 55 /* Identifier */:
                case 112 /* QualifiedName */:
                    var symbol = getSymbolInfo(node);
                    return getDeclaredTypeOfSymbol(symbol);
                default:
                    return unknownType;
            }
        }
        function instantiateList(items, mapper, instantiator) {
            if (items && items.length) {
                var result = [];
                for (var i = 0; i < items.length; i++) {
                    result.push(instantiator(items[i], mapper));
                }
                return result;
            }
            return items;
        }
        function createUnaryTypeMapper(source, target) {
            return function (t) { return t === source ? target : t; };
        }
        function createBinaryTypeMapper(source1, target1, source2, target2) {
            return function (t) { return t === source1 ? target1 : t === source2 ? target2 : t; };
        }
        function createTypeMapper(sources, targets) {
            switch (sources.length) {
                case 1:
                    return createUnaryTypeMapper(sources[0], targets[0]);
                case 2:
                    return createBinaryTypeMapper(sources[0], targets[0], sources[1], targets[1]);
            }
            return function (t) {
                for (var i = 0; i < sources.length; i++) {
                    if (t === sources[i])
                        return targets[i];
                }
                return t;
            };
        }
        function createUnaryTypeEraser(source) {
            return function (t) { return t === source ? anyType : t; };
        }
        function createBinaryTypeEraser(source1, source2) {
            return function (t) { return t === source1 || t === source2 ? anyType : t; };
        }
        function createTypeEraser(sources) {
            switch (sources.length) {
                case 1:
                    return createUnaryTypeEraser(sources[0]);
                case 2:
                    return createBinaryTypeEraser(sources[0], sources[1]);
            }
            return function (t) {
                for (var i = 0; i < sources.length; i++) {
                    if (t === sources[i])
                        return anyType;
                }
                return t;
            };
        }
        function createInferenceMapper(context) {
            return function (t) {
                for (var i = 0; i < context.typeParameters.length; i++) {
                    if (t === context.typeParameters[i]) {
                        return getInferredType(context, i);
                    }
                }
                return t;
            };
        }
        function identityMapper(type) {
            return type;
        }
        function combineTypeMappers(mapper1, mapper2) {
            return function (t) { return mapper2(mapper1(t)); };
        }
        function instantiateTypeParameter(typeParameter, mapper) {
            var result = createType(512 /* TypeParameter */);
            result.symbol = typeParameter.symbol;
            if (typeParameter.constraint) {
                result.constraint = instantiateType(typeParameter.constraint, mapper);
            }
            else {
                result.target = typeParameter;
                result.mapper = mapper;
            }
            return result;
        }
        function instantiateSignature(signature, mapper, eraseTypeParameters) {
            if (signature.typeParameters && !eraseTypeParameters) {
                var freshTypeParameters = instantiateList(signature.typeParameters, mapper, instantiateTypeParameter);
                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
            }
            var result = createSignature(signature.declaration, freshTypeParameters, instantiateList(signature.parameters, mapper, instantiateSymbol), signature.resolvedReturnType ? instantiateType(signature.resolvedReturnType, mapper) : undefined, signature.minArgumentCount, signature.hasRestParameter, signature.hasStringLiterals);
            result.target = signature;
            result.mapper = mapper;
            return result;
        }
        function instantiateSymbol(symbol, mapper) {
            if (symbol.flags & 8388608 /* Instantiated */) {
                var links = getSymbolLinks(symbol);
                // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
                // type mappers. This ensures that original type identities are properly preserved and that aliases
                // always reference a non-aliases.
                symbol = links.target;
                mapper = combineTypeMappers(links.mapper, mapper);
            }
            // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
            // also transient so that we can just store data on it directly.
            var result = createSymbol(8388608 /* Instantiated */ | 33554432 /* Transient */, symbol.name);
            result.declarations = symbol.declarations;
            result.parent = symbol.parent;
            result.target = symbol;
            result.mapper = mapper;
            if (symbol.valueDeclaration) {
                result.valueDeclaration = symbol.valueDeclaration;
            }
            return result;
        }
        function instantiateAnonymousType(type, mapper) {
            var result = createObjectType(8192 /* Anonymous */, type.symbol);
            result.properties = instantiateList(getPropertiesOfType(type), mapper, instantiateSymbol);
            result.members = createSymbolTable(result.properties);
            result.callSignatures = instantiateList(getSignaturesOfType(type, 0 /* Call */), mapper, instantiateSignature);
            result.constructSignatures = instantiateList(getSignaturesOfType(type, 1 /* Construct */), mapper, instantiateSignature);
            var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
            var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
            if (stringIndexType)
                result.stringIndexType = instantiateType(stringIndexType, mapper);
            if (numberIndexType)
                result.numberIndexType = instantiateType(numberIndexType, mapper);
            return result;
        }
        function instantiateType(type, mapper) {
            if (mapper !== identityMapper) {
                if (type.flags & 512 /* TypeParameter */) {
                    return mapper(type);
                }
                if (type.flags & 8192 /* Anonymous */) {
                    return type.symbol && type.symbol.flags & (8 /* Function */ | 2048 /* Method */ | 512 /* TypeLiteral */ | 1024 /* ObjectLiteral */) ? instantiateAnonymousType(type, mapper) : type;
                }
                if (type.flags & 4096 /* Reference */) {
                    return createTypeReference(type.target, instantiateList(type.typeArguments, mapper, instantiateType));
                }
            }
            return type;
        }
        // Returns true if the given expression contains (at any level of nesting) a function or arrow expression
        // that is subject to contextual typing.
        function isContextSensitiveExpression(node) {
            switch (node.kind) {
                case 136 /* FunctionExpression */:
                case 137 /* ArrowFunction */:
                    return !node.typeParameters && !ts.forEach(node.parameters, function (p) { return p.type; });
                case 128 /* ObjectLiteral */:
                    return ts.forEach(node.properties, function (p) { return p.kind === 129 /* PropertyAssignment */ && isContextSensitiveExpression(p.initializer); });
                case 127 /* ArrayLiteral */:
                    return ts.forEach(node.elements, function (e) { return isContextSensitiveExpression(e); });
                case 141 /* ConditionalExpression */:
                    return isContextSensitiveExpression(node.whenTrue) || isContextSensitiveExpression(node.whenFalse);
                case 140 /* BinaryExpression */:
                    return node.operator === 40 /* BarBarToken */ && (isContextSensitiveExpression(node.left) || isContextSensitiveExpression(node.right));
            }
            return false;
        }
        function getTypeWithoutConstructors(type) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                if (resolved.constructSignatures.length) {
                    var result = createObjectType(8192 /* Anonymous */, type.symbol);
                    result.members = resolved.members;
                    result.properties = resolved.properties;
                    result.callSignatures = resolved.callSignatures;
                    result.constructSignatures = emptyArray;
                    type = result;
                }
            }
            return type;
        }
        // TYPE CHECKING
        var subtypeRelation = {};
        var assignableRelation = {};
        var identityRelation = {};
        function isTypeIdenticalTo(source, target) {
            return checkTypeRelatedTo(source, target, identityRelation, undefined, undefined, undefined);
        }
        function isTypeSubtypeOf(source, target) {
            return checkTypeSubtypeOf(source, target, undefined, undefined, undefined);
        }
        function checkTypeSubtypeOf(source, target, errorNode, chainedMessage, terminalMessage) {
            return checkTypeRelatedTo(source, target, subtypeRelation, errorNode, chainedMessage, terminalMessage);
        }
        function isTypeAssignableTo(source, target) {
            return checkTypeAssignableTo(source, target, undefined, undefined, undefined);
        }
        function checkTypeAssignableTo(source, target, errorNode, chainedMessage, terminalMessage) {
            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, chainedMessage, terminalMessage);
        }
        function isTypeRelatedTo(source, target, relation) {
            return checkTypeRelatedTo(source, target, relation, undefined, undefined, undefined);
        }
        function isSignatureAssignableTo(source, target) {
            var sourceType = getOrCreateTypeFromSignature(source);
            var targetType = getOrCreateTypeFromSignature(target);
            return checkTypeRelatedTo(sourceType, targetType, assignableRelation, undefined, undefined, undefined);
        }
        function isPropertyIdenticalTo(sourceProp, targetProp) {
            return isPropertyIdenticalToRecursive(sourceProp, targetProp, false, function (s, t, _reportErrors) { return isTypeIdenticalTo(s, t); });
        }
        function checkInheritedPropertiesAreIdentical(type, typeNode) {
            if (!type.baseTypes.length || type.baseTypes.length === 1) {
                return true;
            }
            var seen = {};
            ts.forEach(type.declaredProperties, function (p) {
                seen[p.name] = { prop: p, containingType: type };
            });
            var ok = true;
            for (var i = 0, len = type.baseTypes.length; i < len; ++i) {
                var base = type.baseTypes[i];
                var properties = getPropertiesOfType(base);
                for (var j = 0, proplen = properties.length; j < proplen; ++j) {
                    var prop = properties[j];
                    if (!ts.hasProperty(seen, prop.name)) {
                        seen[prop.name] = { prop: prop, containingType: base };
                    }
                    else {
                        var existing = seen[prop.name];
                        var isInheritedProperty = existing.containingType !== type;
                        if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
                            ok = false;
                            var typeName1 = typeToString(existing.containingType);
                            var typeName2 = typeToString(base);
                            var errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Named_properties_0_of_types_1_and_2_are_not_identical, prop.name, typeName1, typeName2);
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2_Colon, typeToString(type), typeName1, typeName2);
                            addDiagnostic(ts.createDiagnosticForNodeFromMessageChain(typeNode, errorInfo, program.getCompilerHost().getNewLine()));
                        }
                    }
                }
            }
            return ok;
        }
        function isPropertyIdenticalToRecursive(sourceProp, targetProp, reportErrors, relate) {
            ts.Debug.assert(sourceProp);
            if (!targetProp) {
                return false;
            }
            // Two members are considered identical when
            // - they are public properties with identical names, optionality, and types,
            // - they are private properties originating in the same declaration and having identical types
            var sourcePropIsPrivate = getDeclarationFlagsFromSymbol(sourceProp) & 32 /* Private */;
            var targetPropIsPrivate = getDeclarationFlagsFromSymbol(targetProp) & 32 /* Private */;
            if (sourcePropIsPrivate !== targetPropIsPrivate) {
                return false;
            }
            if (sourcePropIsPrivate) {
                return (getTargetSymbol(sourceProp).parent === getTargetSymbol(targetProp).parent) && relate(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);
            }
            else {
                return isOptionalProperty(sourceProp) === isOptionalProperty(targetProp) && relate(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);
            }
        }
        function checkTypeRelatedTo(source, target, relation, errorNode, chainedMessage, terminalMessage) {
            var errorInfo;
            var sourceStack;
            var targetStack;
            var expandingFlags;
            var depth = 0;
            var overflow = false;
            ts.Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");
            var result = isRelatedToWithCustomErrors(source, target, errorNode !== undefined, chainedMessage, terminalMessage);
            if (overflow) {
                error(errorNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
            }
            else if (errorInfo) {
                addDiagnostic(ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo, program.getCompilerHost().getNewLine()));
            }
            return result;
            function reportError(message, arg0, arg1) {
                errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1);
            }
            function isRelatedTo(source, target, reportErrors) {
                return isRelatedToWithCustomErrors(source, target, reportErrors, undefined, undefined);
            }
            function isRelatedToWithCustomErrors(source, target, reportErrors, chainedMessage, terminalMessage) {
                if (relation === identityRelation) {
                    // both types are the same - covers 'they are the same primitive type or both are Any' or the same type parameter cases
                    if (source === target)
                        return true;
                }
                else {
                    if (source === target)
                        return true;
                    if (target.flags & 1 /* Any */)
                        return true;
                    if (source === undefinedType)
                        return true;
                    if (source === nullType && target !== undefinedType)
                        return true;
                    if (source.flags & 128 /* Enum */ && target === numberType)
                        return true;
                    if (source.flags & 256 /* StringLiteral */ && target === stringType)
                        return true;
                    if (relation === assignableRelation) {
                        if (source.flags & 1 /* Any */)
                            return true;
                        if (source === numberType && target.flags & 128 /* Enum */)
                            return true;
                    }
                }
                if (source.flags & 512 /* TypeParameter */ && target.flags & 512 /* TypeParameter */) {
                    if (typeParameterRelatedTo(source, target, reportErrors)) {
                        return true;
                    }
                }
                else {
                    var saveErrorInfo = errorInfo;
                    if (source.flags & 4096 /* Reference */ && target.flags & 4096 /* Reference */ && source.target === target.target) {
                        // We have type references to same target type, see if relationship holds for all type arguments
                        if (typesRelatedTo(source.typeArguments, target.typeArguments, reportErrors)) {
                            return true;
                        }
                    }
                    // Even if relationship doesn't hold for type arguments, it may hold in a structural comparison
                    // Report structural errors only if we haven't reported any errors yet
                    var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo;
                    // identity relation does not use apparent type
                    var sourceOrApparentType = relation === identityRelation ? source : getApparentType(source);
                    if (sourceOrApparentType.flags & ts.TypeFlags.ObjectType && target.flags & ts.TypeFlags.ObjectType && objectTypeRelatedTo(sourceOrApparentType, target, reportStructuralErrors)) {
                        errorInfo = saveErrorInfo;
                        return true;
                    }
                }
                if (reportErrors) {
                    // The error should end in a period when this is the deepest error in the chain
                    // (when errorInfo is undefined). Otherwise, it has a colon before the nested
                    // error.
                    chainedMessage = chainedMessage || ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Colon;
                    terminalMessage = terminalMessage || ts.Diagnostics.Type_0_is_not_assignable_to_type_1;
                    var diagnosticKey = errorInfo ? chainedMessage : terminalMessage;
                    ts.Debug.assert(diagnosticKey);
                    reportError(diagnosticKey, typeToString(source), typeToString(target));
                }
                return false;
            }
            function typesRelatedTo(sources, targets, reportErrors) {
                for (var i = 0, len = sources.length; i < len; i++) {
                    if (!isRelatedTo(sources[i], targets[i], reportErrors))
                        return false;
                }
                return true;
            }
            function typeParameterRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    if (source.symbol.name !== target.symbol.name) {
                        return false;
                    }
                    // covers case when both type parameters does not have constraint (both equal to noConstraintType)
                    if (source.constraint === target.constraint) {
                        return true;
                    }
                    if (source.constraint === noConstraintType || target.constraint === noConstraintType) {
                        return false;
                    }
                    return isRelatedTo(source.constraint, target.constraint, reportErrors);
                }
                else {
                    while (true) {
                        var constraint = getConstraintOfTypeParameter(source);
                        if (constraint === target)
                            return true;
                        if (!(constraint && constraint.flags & 512 /* TypeParameter */))
                            break;
                        source = constraint;
                    }
                    return false;
                }
            }
            // Determine if two object types are related by structure. First, check if the result is already available in the global cache.
            // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
            // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
            // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
            // and issue an error. Otherwise, actually compare the structure of the two types.
            function objectTypeRelatedTo(source, target, reportErrors) {
                if (overflow)
                    return false;
                var result;
                var id = source.id + "," + target.id;
                if ((result = relation[id]) !== undefined)
                    return result;
                if (depth > 0) {
                    for (var i = 0; i < depth; i++) {
                        if (source === sourceStack[i] && target === targetStack[i])
                            return true;
                    }
                    if (depth === 100) {
                        overflow = true;
                        return false;
                    }
                }
                else {
                    sourceStack = [];
                    targetStack = [];
                    expandingFlags = 0;
                }
                sourceStack[depth] = source;
                targetStack[depth] = target;
                depth++;
                var saveExpandingFlags = expandingFlags;
                if (!(expandingFlags & 1) && isDeeplyNestedGeneric(source, sourceStack))
                    expandingFlags |= 1;
                if (!(expandingFlags & 2) && isDeeplyNestedGeneric(target, targetStack))
                    expandingFlags |= 2;
                result = expandingFlags === 3 || propertiesRelatedTo(source, target, reportErrors) && signaturesRelatedTo(source, target, 0 /* Call */, reportErrors) && signaturesRelatedTo(source, target, 1 /* Construct */, reportErrors) && stringIndexTypesRelatedTo(source, target, reportErrors) && numberIndexTypesRelatedTo(source, target, reportErrors);
                expandingFlags = saveExpandingFlags;
                depth--;
                if (depth === 0) {
                    relation[id] = result;
                }
                return result;
            }
            // Return true if the given type is part of a deeply nested chain of generic instantiations. We consider this to be the case
            // when structural type comparisons have been started for 10 or more instantiations of the same generic type. It is possible,
            // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely expanding.
            // Effectively, we will generate a false positive when two types are structurally equal to at least 10 levels, but unequal at
            // some level beyond that.
            function isDeeplyNestedGeneric(type, stack) {
                if (type.flags & 4096 /* Reference */ && depth >= 10) {
                    var target = type.target;
                    var count = 0;
                    for (var i = 0; i < depth; i++) {
                        var t = stack[i];
                        if (t.flags & 4096 /* Reference */ && t.target === target) {
                            count++;
                            if (count >= 10)
                                return true;
                        }
                    }
                }
                return false;
            }
            function propertiesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return propertiesAreIdenticalTo(source, target, reportErrors);
                }
                else {
                    return propertiesAreSubtypeOrAssignableTo(source, target, reportErrors);
                }
            }
            function propertiesAreIdenticalTo(source, target, reportErrors) {
                if (source === target) {
                    return true;
                }
                var sourceProperties = getPropertiesOfType(source);
                var targetProperties = getPropertiesOfType(target);
                if (sourceProperties.length !== targetProperties.length) {
                    return false;
                }
                for (var i = 0, len = sourceProperties.length; i < len; ++i) {
                    var sourceProp = sourceProperties[i];
                    var targetProp = getPropertyOfType(target, sourceProp.name);
                    if (!isPropertyIdenticalToRecursive(sourceProp, targetProp, reportErrors, isRelatedTo)) {
                        return false;
                    }
                }
                return true;
            }
            function propertiesAreSubtypeOrAssignableTo(source, target, reportErrors) {
                var properties = getPropertiesOfType(target);
                for (var i = 0; i < properties.length; i++) {
                    var targetProp = properties[i];
                    var sourceProp = getPropertyOfApparentType(source, targetProp.name);
                    if (sourceProp === targetProp) {
                        continue;
                    }
                    var targetPropIsOptional = isOptionalProperty(targetProp);
                    if (!sourceProp) {
                        if (!targetPropIsOptional) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Property_0_is_missing_in_type_1, symbolToString(targetProp), typeToString(source));
                            }
                            return false;
                        }
                    }
                    else if (sourceProp !== targetProp) {
                        if (targetProp.flags & 67108864 /* Prototype */) {
                            continue;
                        }
                        if (getDeclarationFlagsFromSymbol(sourceProp) & 32 /* Private */ || getDeclarationFlagsFromSymbol(targetProp) & 32 /* Private */) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Private_property_0_cannot_be_reimplemented, symbolToString(targetProp));
                            }
                            return false;
                        }
                        if (!isRelatedTo(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors)) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Types_of_property_0_are_incompatible_Colon, symbolToString(targetProp));
                            }
                            return false;
                        }
                        else if (isOptionalProperty(sourceProp) && !targetPropIsOptional) {
                            // TypeScript 1.0 spec (April 2014): 3.8.3
                            // S is a subtype of a type T, and T is a supertype of S if ...
                            // S' and T are object types and, for each member M in T..
                            // M is a property and S' contains a property N where
                            // if M is a required property, N is also a required property
                            // (M - property in T)
                            // (N - property in S)
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Required_property_0_cannot_be_reimplemented_with_optional_property_in_1, targetProp.name, typeToString(source));
                            }
                            return false;
                        }
                    }
                }
                return true;
            }
            function signaturesRelatedTo(source, target, kind, reportErrors) {
                if (relation === identityRelation) {
                    return areSignaturesIdenticalTo(source, target, kind, reportErrors);
                }
                else {
                    return areSignaturesSubtypeOrAssignableTo(source, target, kind, reportErrors);
                }
            }
            function areSignaturesIdenticalTo(source, target, kind, reportErrors) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                if (sourceSignatures.length !== targetSignatures.length) {
                    return false;
                }
                for (var i = 0, len = sourceSignatures.length; i < len; ++i) {
                    if (!isSignatureIdenticalTo(sourceSignatures[i], targetSignatures[i], reportErrors)) {
                        return false;
                    }
                }
                return true;
            }
            function isSignatureIdenticalTo(source, target, reportErrors) {
                if (source === target) {
                    return true;
                }
                if (source.hasRestParameter !== target.hasRestParameter) {
                    return false;
                }
                if (source.parameters.length !== target.parameters.length) {
                    return false;
                }
                if (source.minArgumentCount !== target.minArgumentCount) {
                    return false;
                }
                if (source.typeParameters && target.typeParameters) {
                    if (source.typeParameters.length !== target.typeParameters.length) {
                        return false;
                    }
                    for (var i = 0, len = source.typeParameters.length; i < len; ++i) {
                        if (!isRelatedTo(source.typeParameters[i], target.typeParameters[i], reportErrors)) {
                            return false;
                        }
                    }
                }
                else if (source.typeParameters || source.typeParameters) {
                    return false;
                }
                // Spec 1.0 Section 3.8.3 & 3.8.4:
                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
                source = getErasedSignature(source);
                target = getErasedSignature(target);
                for (var i = 0, len = source.parameters.length; i < len; i++) {
                    var s = source.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(source) : getTypeOfSymbol(source.parameters[i]);
                    var t = target.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(target) : getTypeOfSymbol(target.parameters[i]);
                    if (!isRelatedTo(s, t, reportErrors)) {
                        return false;
                    }
                }
                var t = getReturnTypeOfSignature(target);
                var s = getReturnTypeOfSignature(source);
                return isRelatedTo(s, t, reportErrors);
            }
            function areSignaturesSubtypeOrAssignableTo(source, target, kind, reportErrors) {
                if (target === anyFunctionType || source === anyFunctionType)
                    return true;
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                var saveErrorInfo = errorInfo;
                outer: for (var i = 0; i < targetSignatures.length; i++) {
                    var t = targetSignatures[i];
                    if (!t.hasStringLiterals || target.flags & 16384 /* FromSignature */) {
                        var localErrors = reportErrors;
                        for (var j = 0; j < sourceSignatures.length; j++) {
                            var s = sourceSignatures[j];
                            if (!s.hasStringLiterals || source.flags & 16384 /* FromSignature */) {
                                if (isSignatureSubtypeOrAssignableTo(s, t, localErrors)) {
                                    errorInfo = saveErrorInfo;
                                    continue outer;
                                }
                                // Only report errors from the first failure
                                localErrors = false;
                            }
                        }
                        return false;
                    }
                }
                return true;
            }
            function isSignatureSubtypeOrAssignableTo(source, target, reportErrors) {
                if (source === target) {
                    return true;
                }
                if (!target.hasRestParameter && source.minArgumentCount > target.parameters.length) {
                    return false;
                }
                var sourceMax = source.parameters.length;
                var targetMax = target.parameters.length;
                var checkCount;
                if (source.hasRestParameter && target.hasRestParameter) {
                    checkCount = sourceMax > targetMax ? sourceMax : targetMax;
                    sourceMax--;
                    targetMax--;
                }
                else if (source.hasRestParameter) {
                    sourceMax--;
                    checkCount = targetMax;
                }
                else if (target.hasRestParameter) {
                    targetMax--;
                    checkCount = sourceMax;
                }
                else {
                    checkCount = sourceMax < targetMax ? sourceMax : targetMax;
                }
                // Spec 1.0 Section 3.8.3 & 3.8.4:
                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
                source = getErasedSignature(source);
                target = getErasedSignature(target);
                for (var i = 0; i < checkCount; i++) {
                    var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);
                    var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);
                    var saveErrorInfo = errorInfo;
                    if (!isRelatedTo(s, t, reportErrors)) {
                        if (!isRelatedTo(t, s, false)) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Types_of_parameters_0_and_1_are_incompatible_Colon, source.parameters[i < sourceMax ? i : sourceMax].name, target.parameters[i < targetMax ? i : targetMax].name);
                            }
                            return false;
                        }
                        errorInfo = saveErrorInfo;
                    }
                }
                var t = getReturnTypeOfSignature(target);
                if (t === voidType)
                    return true;
                var s = getReturnTypeOfSignature(source);
                return isRelatedTo(s, t, reportErrors);
            }
            function stringIndexTypesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return areIndexTypesIdenticalTo(0 /* String */, source, target, reportErrors);
                }
                else {
                    var targetType = getIndexTypeOfType(target, 0 /* String */);
                    if (targetType) {
                        var sourceType = getIndexTypeOfType(source, 0 /* String */);
                        if (!sourceType) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));
                            }
                            return false;
                        }
                        if (!isRelatedTo(sourceType, targetType, reportErrors)) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Index_signatures_are_incompatible_Colon);
                            }
                            return false;
                        }
                    }
                    return true;
                }
            }
            function numberIndexTypesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return areIndexTypesIdenticalTo(1 /* Number */, source, target, reportErrors);
                }
                else {
                    var targetType = getIndexTypeOfType(target, 1 /* Number */);
                    if (targetType) {
                        var sourceStringType = getIndexTypeOfType(source, 0 /* String */);
                        var sourceNumberType = getIndexTypeOfType(source, 1 /* Number */);
                        if (!(sourceStringType || sourceNumberType)) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));
                            }
                            return false;
                        }
                        if (sourceStringType && sourceNumberType) {
                            // If we know for sure we're testing both string and numeric index types then only report errors from the second one
                            var compatible = isRelatedTo(sourceStringType, targetType, false) || isRelatedTo(sourceNumberType, targetType, reportErrors);
                        }
                        else {
                            var compatible = isRelatedTo(sourceStringType || sourceNumberType, targetType, reportErrors);
                        }
                        if (!compatible) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Index_signatures_are_incompatible_Colon);
                            }
                            return false;
                        }
                    }
                    return true;
                }
            }
            function areIndexTypesIdenticalTo(indexKind, source, target, reportErrors) {
                var targetType = getIndexTypeOfType(target, indexKind);
                var sourceType = getIndexTypeOfType(source, indexKind);
                return (!sourceType && !targetType) || (sourceType && targetType && isRelatedTo(sourceType, targetType, reportErrors));
            }
        }
        function isSupertypeOfEach(candidate, types) {
            for (var i = 0, len = types.length; i < len; i++) {
                if (candidate !== types[i] && !isTypeSubtypeOf(types[i], candidate))
                    return false;
            }
            return true;
        }
        function getBestCommonType(types, contextualType, candidatesOnly) {
            if (contextualType && isSupertypeOfEach(contextualType, types))
                return contextualType;
            return ts.forEach(types, function (t) { return isSupertypeOfEach(t, types) ? t : undefined; }) || (candidatesOnly ? undefined : emptyObjectType);
        }
        function isTypeOfObjectLiteral(type) {
            return (type.flags & 8192 /* Anonymous */) && type.symbol && (type.symbol.flags & 1024 /* ObjectLiteral */) ? true : false;
        }
        function getWidenedTypeOfObjectLiteral(type) {
            var properties = getPropertiesOfType(type);
            if (properties.length) {
                var widenedTypes = [];
                var propTypeWasWidened = false;
                ts.forEach(properties, function (p) {
                    var propType = getTypeOfSymbol(p);
                    var widenedType = getWidenedType(propType);
                    if (propType !== widenedType) {
                        propTypeWasWidened = true;
                        if (program.getCompilerOptions().noImplicitAny && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                            error(p.valueDeclaration, ts.Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, p.name, typeToString(widenedType));
                        }
                    }
                    widenedTypes.push(widenedType);
                });
                if (propTypeWasWidened) {
                    var members = {};
                    var index = 0;
                    ts.forEach(properties, function (p) {
                        var symbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, p.name);
                        symbol.declarations = p.declarations;
                        symbol.parent = p.parent;
                        symbol.type = widenedTypes[index++];
                        if (p.valueDeclaration)
                            symbol.valueDeclaration = p.valueDeclaration;
                        members[symbol.name] = symbol;
                    });
                    var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
                    var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
                    if (stringIndexType)
                        stringIndexType = getWidenedType(stringIndexType);
                    if (numberIndexType)
                        numberIndexType = getWidenedType(numberIndexType);
                    type = createAnonymousType(type.symbol, members, emptyArray, emptyArray, stringIndexType, numberIndexType);
                }
            }
            return type;
        }
        function isArrayType(type) {
            return type.flags & 4096 /* Reference */ && type.target === globalArrayType;
        }
        function getInnermostTypeOfNestedArrayTypes(type) {
            while (isArrayType(type)) {
                type = type.typeArguments[0];
            }
            return type;
        }
        function getWidenedTypeOfArrayLiteral(type) {
            var elementType = type.typeArguments[0];
            var widenedType = getWidenedType(elementType);
            type = elementType !== widenedType ? createArrayType(widenedType) : type;
            return type;
        }
        /* If we are widening on a literal, then we may need to the 'node' parameter for reporting purposes */
        function getWidenedType(type) {
            if (type.flags & (32 /* Undefined */ | 64 /* Null */)) {
                return anyType;
            }
            if (isTypeOfObjectLiteral(type)) {
                return getWidenedTypeOfObjectLiteral(type);
            }
            if (isArrayType(type)) {
                return getWidenedTypeOfArrayLiteral(type);
            }
            return type;
        }
        function forEachMatchingParameterType(source, target, callback) {
            var sourceMax = source.parameters.length;
            var targetMax = target.parameters.length;
            var count;
            if (source.hasRestParameter && target.hasRestParameter) {
                count = sourceMax > targetMax ? sourceMax : targetMax;
                sourceMax--;
                targetMax--;
            }
            else if (source.hasRestParameter) {
                sourceMax--;
                count = targetMax;
            }
            else if (target.hasRestParameter) {
                targetMax--;
                count = sourceMax;
            }
            else {
                count = sourceMax < targetMax ? sourceMax : targetMax;
            }
            for (var i = 0; i < count; i++) {
                var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);
                var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);
                callback(s, t);
            }
        }
        function createInferenceContext(typeParameters) {
            var inferences = [];
            for (var i = 0; i < typeParameters.length; i++)
                inferences.push([]);
            return {
                typeParameters: typeParameters,
                inferences: inferences,
                inferredTypes: new Array(typeParameters.length)
            };
        }
        function inferTypes(context, source, target) {
            var sourceStack;
            var targetStack;
            var depth = 0;
            inferFromTypes(source, target);
            function isInProcess(source, target) {
                for (var i = 0; i < depth; i++) {
                    if (source === sourceStack[i] && target === targetStack[i])
                        return true;
                }
                return false;
            }
            function isWithinDepthLimit(type, stack) {
                if (depth >= 5) {
                    var target = type.target;
                    var count = 0;
                    for (var i = 0; i < depth; i++) {
                        var t = stack[i];
                        if (t.flags & 4096 /* Reference */ && t.target === target)
                            count++;
                    }
                    return count < 5;
                }
                return true;
            }
            function inferFromTypes(source, target) {
                if (target.flags & 512 /* TypeParameter */) {
                    // If target is a type parameter, make an inference
                    var typeParameters = context.typeParameters;
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (target === typeParameters[i]) {
                            var inferences = context.inferences[i];
                            if (!ts.contains(inferences, source))
                                inferences.push(source);
                            break;
                        }
                    }
                }
                else if (source.flags & 4096 /* Reference */ && target.flags & 4096 /* Reference */ && source.target === target.target) {
                    // If source and target are references to the same generic type, infer from type arguments
                    var sourceTypes = source.typeArguments;
                    var targetTypes = target.typeArguments;
                    for (var i = 0; i < sourceTypes.length; i++) {
                        inferFromTypes(sourceTypes[i], targetTypes[i]);
                    }
                }
                else if (source.flags & ts.TypeFlags.ObjectType && (target.flags & 4096 /* Reference */ || (target.flags & 8192 /* Anonymous */) && target.symbol && target.symbol.flags & (2048 /* Method */ | 512 /* TypeLiteral */))) {
                    // If source is an object type, and target is a type reference, the type of a method, or a type literal, infer from members
                    if (!isInProcess(source, target) && isWithinDepthLimit(source, sourceStack) && isWithinDepthLimit(target, targetStack)) {
                        if (depth === 0) {
                            sourceStack = [];
                            targetStack = [];
                        }
                        sourceStack[depth] = source;
                        targetStack[depth] = target;
                        depth++;
                        inferFromProperties(source, target);
                        inferFromSignatures(source, target, 0 /* Call */);
                        inferFromSignatures(source, target, 1 /* Construct */);
                        inferFromIndexTypes(source, target, 0 /* String */, 0 /* String */);
                        inferFromIndexTypes(source, target, 1 /* Number */, 1 /* Number */);
                        inferFromIndexTypes(source, target, 0 /* String */, 1 /* Number */);
                        depth--;
                    }
                }
            }
            function inferFromProperties(source, target) {
                var properties = getPropertiesOfType(target);
                for (var i = 0; i < properties.length; i++) {
                    var targetProp = properties[i];
                    var sourceProp = getPropertyOfType(source, targetProp.name);
                    if (sourceProp) {
                        inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
                    }
                }
            }
            function inferFromSignatures(source, target, kind) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                var sourceLen = sourceSignatures.length;
                var targetLen = targetSignatures.length;
                var len = sourceLen < targetLen ? sourceLen : targetLen;
                for (var i = 0; i < len; i++) {
                    inferFromSignature(getErasedSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]));
                }
            }
            function inferFromSignature(source, target) {
                forEachMatchingParameterType(source, target, inferFromTypes);
                inferFromTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
            }
            function inferFromIndexTypes(source, target, sourceKind, targetKind) {
                var targetIndexType = getIndexTypeOfType(target, targetKind);
                if (targetIndexType) {
                    var sourceIndexType = getIndexTypeOfType(source, sourceKind);
                    if (sourceIndexType) {
                        inferFromTypes(sourceIndexType, targetIndexType);
                    }
                }
            }
        }
        function getInferredType(context, index) {
            var result = context.inferredTypes[index];
            if (!result) {
                var commonType = getWidenedType(getBestCommonType(context.inferences[index]));
                var constraint = getConstraintOfTypeParameter(context.typeParameters[index]);
                var result = constraint && !isTypeAssignableTo(commonType, constraint) ? constraint : commonType;
                context.inferredTypes[index] = result;
            }
            return result;
        }
        function getInferredTypes(context) {
            for (var i = 0; i < context.inferredTypes.length; i++) {
                getInferredType(context, i);
            }
            context.inferences = undefined;
            return context.inferredTypes;
        }
        function hasAncestor(node, kind) {
            return getAncestor(node, kind) !== undefined;
        }
        function getAncestor(node, kind) {
            switch (kind) {
                case 169 /* ClassDeclaration */:
                    while (node) {
                        switch (node.kind) {
                            case 169 /* ClassDeclaration */:
                                return node;
                            case 171 /* EnumDeclaration */:
                            case 170 /* InterfaceDeclaration */:
                            case 172 /* ModuleDeclaration */:
                            case 174 /* ImportDeclaration */:
                                // early exit cases - declarations cannot be nested in classes
                                return undefined;
                            default:
                                node = node.parent;
                                continue;
                        }
                    }
                    break;
                default:
                    while (node) {
                        if (node.kind === kind) {
                            return node;
                        }
                        else {
                            node = node.parent;
                        }
                    }
                    break;
            }
            return undefined;
        }
        // EXPRESSION TYPE CHECKING
        function checkIdentifier(node) {
            function isInTypeQuery(node) {
                while (node) {
                    switch (node.kind) {
                        case 124 /* TypeQuery */:
                            return true;
                        case 55 /* Identifier */:
                        case 112 /* QualifiedName */:
                            node = node.parent;
                            continue;
                        default:
                            return false;
                    }
                }
                ts.Debug.fail("should not get here");
            }
            var symbol = resolveName(node, node.text, ts.SymbolFlags.Value | 524288 /* ExportValue */, ts.Diagnostics.Cannot_find_name_0, ts.identifierToString(node));
            if (!symbol) {
                symbol = unknownSymbol;
            }
            if (symbol.flags & 4194304 /* Import */) {
                // Mark the import as referenced so that we emit it in the final .js file.
                // exception: identifiers that appear in type queries
                getSymbolLinks(symbol).referenced = !isInTypeQuery(node);
            }
            getNodeLinks(node).resolvedSymbol = symbol;
            checkCollisionWithCapturedSuperVariable(node, node);
            checkCollisionWithCapturedThisVariable(node, node);
            checkCollisionWithIndexVariableInGeneratedCode(node, node);
            return getTypeOfSymbol(getExportSymbolOfValueSymbolIfExported(symbol));
        }
        function getThisContainer(node) {
            while (true) {
                node = node.parent;
                if (!node) {
                    return node;
                }
                switch (node.kind) {
                    case 167 /* FunctionDeclaration */:
                    case 136 /* FunctionExpression */:
                    case 172 /* ModuleDeclaration */:
                    case 115 /* Property */:
                    case 116 /* Method */:
                    case 117 /* Constructor */:
                    case 118 /* GetAccessor */:
                    case 119 /* SetAccessor */:
                    case 171 /* EnumDeclaration */:
                    case 177 /* SourceFile */:
                    case 137 /* ArrowFunction */:
                        return node;
                }
            }
        }
        function captureLexicalThis(node, container) {
            var classNode = container.parent && container.parent.kind === 169 /* ClassDeclaration */ ? container.parent : undefined;
            getNodeLinks(node).flags |= 2 /* LexicalThis */;
            if (container.kind === 115 /* Property */ || container.kind === 117 /* Constructor */) {
                getNodeLinks(classNode).flags |= 4 /* CaptureThis */;
            }
            else {
                getNodeLinks(container).flags |= 4 /* CaptureThis */;
            }
        }
        function checkThisExpression(node) {
            var container = getThisContainer(node);
            var needToCaptureLexicalThis = false;
            while (container.kind === 137 /* ArrowFunction */) {
                container = getThisContainer(container);
                needToCaptureLexicalThis = true;
            }
            switch (container.kind) {
                case 172 /* ModuleDeclaration */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_module_body);
                    break;
                case 171 /* EnumDeclaration */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                    break;
                case 117 /* Constructor */:
                    if (isInConstructorArgumentInitializer(node, container)) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_constructor_arguments);
                    }
                    break;
                case 115 /* Property */:
                    if (container.flags & 64 /* Static */) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_static_property_initializer);
                    }
                    break;
            }
            if (needToCaptureLexicalThis) {
                captureLexicalThis(node, container);
            }
            var classNode = container.parent && container.parent.kind === 169 /* ClassDeclaration */ ? container.parent : undefined;
            if (classNode) {
                var symbol = getSymbolOfNode(classNode);
                return container.flags & 64 /* Static */ ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol);
            }
            return anyType;
        }
        function getSuperContainer(node) {
            while (true) {
                node = node.parent;
                if (!node)
                    return node;
                switch (node.kind) {
                    case 167 /* FunctionDeclaration */:
                    case 136 /* FunctionExpression */:
                    case 137 /* ArrowFunction */:
                    case 115 /* Property */:
                    case 116 /* Method */:
                    case 117 /* Constructor */:
                    case 118 /* GetAccessor */:
                    case 119 /* SetAccessor */:
                        return node;
                }
            }
        }
        function isInConstructorArgumentInitializer(node, constructorDecl) {
            for (var n = node; n && n !== constructorDecl; n = n.parent) {
                if (n.kind === 114 /* Parameter */) {
                    return true;
                }
            }
            return false;
        }
        function checkSuperExpression(node, isCallExpression) {
            var enclosingClass = getAncestor(node, 169 /* ClassDeclaration */);
            var baseClass;
            if (enclosingClass && enclosingClass.baseType) {
                var classType = getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingClass));
                baseClass = classType.baseTypes.length && classType.baseTypes[0];
            }
            if (!baseClass) {
                error(node, ts.Diagnostics.super_can_only_be_referenced_in_a_derived_class);
                return unknownType;
            }
            var container = getSuperContainer(node);
            if (container) {
                var canUseSuperExpression = false;
                if (isCallExpression) {
                    // TS 1.0 SPEC (April 2014): 4.8.1
                    // Super calls are only permitted in constructors of derived classes
                    canUseSuperExpression = container.kind === 117 /* Constructor */;
                }
                else {
                    // TS 1.0 SPEC (April 2014)
                    // 'super' property access is allowed
                    // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
                    // - In a static member function or static member accessor
                    // super property access might appear in arrow functions with arbitrary deep nesting
                    var needToCaptureLexicalThis = false;
                    while (container && container.kind === 137 /* ArrowFunction */) {
                        container = getSuperContainer(container);
                        needToCaptureLexicalThis = true;
                    }
                    // topmost container must be something that is directly nested in the class declaration
                    if (container && container.parent && container.parent.kind === 169 /* ClassDeclaration */) {
                        if (container.flags & 64 /* Static */) {
                            canUseSuperExpression = container.kind === 116 /* Method */ || container.kind === 118 /* GetAccessor */ || container.kind === 119 /* SetAccessor */;
                        }
                        else {
                            canUseSuperExpression = container.kind === 116 /* Method */ || container.kind === 118 /* GetAccessor */ || container.kind === 119 /* SetAccessor */ || container.kind === 115 /* Property */ || container.kind === 117 /* Constructor */;
                        }
                    }
                }
                if (canUseSuperExpression) {
                    var returnType;
                    if ((container.flags & 64 /* Static */) || isCallExpression) {
                        getNodeLinks(node).flags |= 32 /* SuperStatic */;
                        returnType = getTypeOfSymbol(baseClass.symbol);
                    }
                    else {
                        getNodeLinks(node).flags |= 16 /* SuperInstance */;
                        returnType = baseClass;
                    }
                    if (container.kind === 117 /* Constructor */ && isInConstructorArgumentInitializer(node, container)) {
                        // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
                        error(node, ts.Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
                        returnType = unknownType;
                    }
                    if (!isCallExpression && needToCaptureLexicalThis) {
                        // call expressions are allowed only in constructors so they should always capture correct 'this'
                        // super property access expressions can also appear in arrow functions -
                        // in this case they should also use correct lexical this
                        captureLexicalThis(node.parent, container);
                    }
                    return returnType;
                }
            }
            if (isCallExpression) {
                error(node, ts.Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
            }
            else {
                error(node, ts.Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
            }
            return unknownType;
        }
        // Return contextual type of parameter or undefined if no contextual type is available
        function getContextuallyTypedParameterType(parameter) {
            var func = parameter.parent;
            if (func.kind === 136 /* FunctionExpression */ || func.kind === 137 /* ArrowFunction */) {
                if (isContextSensitiveExpression(func)) {
                    var signature = getContextualSignature(func);
                    if (signature) {
                        return getTypeAtPosition(signature, ts.indexOf(func.parameters, parameter));
                    }
                }
            }
            return undefined;
        }
        function getContextualTypeForInitializerExpression(node) {
            var declaration = node.parent;
            if (node === declaration.initializer) {
                if (declaration.type) {
                    return getTypeFromTypeNode(declaration.type);
                }
                if (declaration.kind === 114 /* Parameter */) {
                    return getContextuallyTypedParameterType(declaration);
                }
            }
            return undefined;
        }
        function getContextualTypeForReturnExpression(node) {
            var func = getContainingFunction(node);
            if (func) {
                // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
                // corresponding set accessor has a type annotation, return statements in the function are contextually typed
                if (func.type || func.kind === 117 /* Constructor */ || func.kind === 118 /* GetAccessor */ && getSetAccessorTypeAnnotationNode(getDeclarationOfKind(func.symbol, 119 /* SetAccessor */))) {
                    return getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                }
                // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
                // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
                var signature = getContextualSignature(func);
                if (signature) {
                    return getReturnTypeOfSignature(signature);
                }
            }
            return undefined;
        }
        function getContextualTypeForArgument(node) {
            var callExpression = node.parent;
            var argIndex = ts.indexOf(callExpression.arguments, node);
            if (argIndex >= 0) {
                var signature = getResolvedSignature(callExpression);
                return getTypeAtPosition(signature, argIndex);
            }
            return undefined;
        }
        function getContextualTypeForBinaryOperand(node) {
            var binaryExpression = node.parent;
            var operator = binaryExpression.operator;
            if (operator >= ts.SyntaxKind.FirstAssignment && operator <= ts.SyntaxKind.LastAssignment) {
                if (node === binaryExpression.right) {
                    return checkExpression(binaryExpression.left);
                }
            }
            else if (operator === 40 /* BarBarToken */) {
                var type = getContextualType(binaryExpression);
                if (!type && node === binaryExpression.right) {
                    type = checkExpression(binaryExpression.left);
                }
                return type;
            }
            return undefined;
        }
        function getContextualTypeForPropertyExpression(node) {
            var declaration = node.parent;
            var objectLiteral = declaration.parent;
            var type = getContextualType(objectLiteral);
            var name = declaration.name.text;
            if (type && name) {
                var prop = getPropertyOfType(type, name);
                if (prop) {
                    return getTypeOfSymbol(prop);
                }
                return isNumericName(name) && getIndexTypeOfType(type, 1 /* Number */) || getIndexTypeOfType(type, 0 /* String */);
            }
            return undefined;
        }
        function getContextualTypeForElementExpression(node) {
            var arrayLiteral = node.parent;
            var type = getContextualType(arrayLiteral);
            return type ? getIndexTypeOfType(type, 1 /* Number */) : undefined;
        }
        function getContextualTypeForConditionalOperand(node) {
            var conditional = node.parent;
            return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional) : undefined;
        }
        function getContextualType(node) {
            if (node.contextualType) {
                return node.contextualType;
            }
            var parent = node.parent;
            switch (parent.kind) {
                case 166 /* VariableDeclaration */:
                case 114 /* Parameter */:
                case 115 /* Property */:
                    return getContextualTypeForInitializerExpression(node);
                case 137 /* ArrowFunction */:
                case 154 /* ReturnStatement */:
                    return getContextualTypeForReturnExpression(node);
                case 132 /* CallExpression */:
                case 133 /* NewExpression */:
                    return getContextualTypeForArgument(node);
                case 134 /* TypeAssertion */:
                    return getTypeFromTypeNode(parent.type);
                case 140 /* BinaryExpression */:
                    return getContextualTypeForBinaryOperand(node);
                case 129 /* PropertyAssignment */:
                    return getContextualTypeForPropertyExpression(node);
                case 127 /* ArrayLiteral */:
                    return getContextualTypeForElementExpression(node);
                case 141 /* ConditionalExpression */:
                    return getContextualTypeForConditionalOperand(node);
            }
            return undefined;
        }
        function getContextualSignature(node) {
            var type = getContextualType(node);
            if (type) {
                var signatures = getSignaturesOfType(type, 0 /* Call */);
                if (signatures.length === 1) {
                    var signature = signatures[0];
                    if (!signature.typeParameters) {
                        return signature;
                    }
                }
            }
            return undefined;
        }
        // Presence of a contextual type mapper indicates inferential typing, except the identityMapper object is
        // used as a special marker for other purposes.
        function isInferentialContext(mapper) {
            return mapper && mapper !== identityMapper;
        }
        function checkArrayLiteral(node, contextualMapper) {
            var elementTypes = [];
            ts.forEach(node.elements, function (element) {
                if (element.kind !== 142 /* OmittedExpression */) {
                    var type = checkExpression(element, contextualMapper);
                    if (!ts.contains(elementTypes, type))
                        elementTypes.push(type);
                }
            });
            var contextualType = isInferentialContext(contextualMapper) ? undefined : getContextualType(node);
            var contextualElementType = contextualType && getIndexTypeOfType(contextualType, 1 /* Number */);
            var elementType = getBestCommonType(elementTypes, contextualElementType, true);
            if (!elementType)
                elementType = elementTypes.length ? emptyObjectType : undefinedType;
            return createArrayType(elementType);
        }
        function isNumericName(name) {
            return !isNaN(name);
        }
        function checkObjectLiteral(node, contextualMapper) {
            var members = node.symbol.members;
            var properties = {};
            var contextualType = getContextualType(node);
            for (var id in members) {
                if (ts.hasProperty(members, id)) {
                    var member = members[id];
                    if (member.flags & 2 /* Property */) {
                        var type = checkExpression(member.declarations[0].initializer, contextualMapper);
                        var prop = createSymbol(2 /* Property */ | 33554432 /* Transient */, member.name);
                        prop.declarations = member.declarations;
                        prop.parent = member.parent;
                        if (member.valueDeclaration)
                            prop.valueDeclaration = member.valueDeclaration;
                        prop.type = type;
                        member = prop;
                    }
                    else {
                        // TypeScript 1.0 spec (April 2014)
                        // A get accessor declaration is processed in the same manner as
                        // an ordinary function declaration(section 6.1) with no parameters.
                        // A set accessor declaration is processed in the same manner
                        // as an ordinary function declaration with a single parameter and a Void return type.
                        var getAccessor = getDeclarationOfKind(member, 118 /* GetAccessor */);
                        if (getAccessor) {
                            checkAccessorDeclaration(getAccessor);
                        }
                        var setAccessor = getDeclarationOfKind(member, 119 /* SetAccessor */);
                        if (setAccessor) {
                            checkAccessorDeclaration(setAccessor);
                        }
                    }
                    properties[member.name] = member;
                }
            }
            var stringIndexType = getIndexType(0 /* String */);
            var numberIndexType = getIndexType(1 /* Number */);
            return createAnonymousType(node.symbol, properties, emptyArray, emptyArray, stringIndexType, numberIndexType);
            function getIndexType(kind) {
                if (contextualType) {
                    var indexType = getIndexTypeOfType(contextualType, kind);
                    if (indexType) {
                        var propTypes = [];
                        for (var id in properties) {
                            if (ts.hasProperty(properties, id)) {
                                if (kind === 0 /* String */ || isNumericName(id)) {
                                    var type = getTypeOfSymbol(properties[id]);
                                    if (!ts.contains(propTypes, type))
                                        propTypes.push(type);
                                }
                            }
                        }
                        return getBestCommonType(propTypes, isInferentialContext(contextualMapper) ? undefined : indexType);
                    }
                }
            }
        }
        function getDeclarationKindFromSymbol(s) {
            return s.flags & 67108864 /* Prototype */ ? 115 /* Property */ : s.valueDeclaration.kind;
        }
        function getDeclarationFlagsFromSymbol(s) {
            return s.flags & 67108864 /* Prototype */ ? 16 /* Public */ | 64 /* Static */ : s.valueDeclaration.flags;
        }
        function checkPropertyAccess(node) {
            var type = checkExpression(node.left);
            if (type === unknownType)
                return type;
            if (type !== anyType) {
                var apparentType = getApparentType(getWidenedType(type));
                if (apparentType === unknownType) {
                    // handle cases when type is Type parameter with invalid constraint
                    return unknownType;
                }
                var prop = getPropertyOfApparentType(apparentType, node.right.text);
                if (!prop) {
                    if (node.right.text) {
                        error(node.right, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.identifierToString(node.right), typeToString(type));
                    }
                    return unknownType;
                }
                getNodeLinks(node).resolvedSymbol = prop;
                if (prop.parent && prop.parent.flags & 16 /* Class */) {
                    // TS 1.0 spec (April 2014): 4.8.2
                    // - In a constructor, instance member function, instance member accessor, or
                    //   instance member variable initializer where this references a derived class instance,
                    //   a super property access is permitted and must specify a public instance member function of the base class.
                    // - In a static member function or static member accessor
                    //   where this references the constructor function object of a derived class,
                    //   a super property access is permitted and must specify a public static member function of the base class.
                    if (node.left.kind === 81 /* SuperKeyword */ && getDeclarationKindFromSymbol(prop) !== 116 /* Method */) {
                        error(node.right, ts.Diagnostics.Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                    }
                    else if (getDeclarationFlagsFromSymbol(prop) & 32 /* Private */) {
                        var classDeclaration = getAncestor(node, 169 /* ClassDeclaration */);
                        if (!classDeclaration || !ts.contains(prop.parent.declarations, classDeclaration)) {
                            error(node, ts.Diagnostics.Property_0_is_inaccessible, getFullyQualifiedName(prop));
                        }
                    }
                }
                return getTypeOfSymbol(prop);
            }
            return anyType;
        }
        function checkIndexedAccess(node) {
            var objectType = checkExpression(node.object);
            var indexType = checkExpression(node.index);
            if (objectType === unknownType)
                return unknownType;
            // TypeScript 1.0 spec (April 2014): 4.10 Property Access
            // - If IndexExpr is a string literal or a numeric literal and ObjExpr's apparent type has a property with the name
            //    given by that literal(converted to its string representation in the case of a numeric literal), the property access is of the type of that property.
            // - Otherwise, if ObjExpr's apparent type has a numeric index signature and IndexExpr is of type Any, the Number primitive type, or an enum type,
            //    the property access is of the type of that index signature.
            // - Otherwise, if ObjExpr's apparent type has a string index signature and IndexExpr is of type Any, the String or Number primitive type, or an enum type,
            //    the property access is of the type of that index signature.
            // - Otherwise, if IndexExpr is of type Any, the String or Number primitive type, or an enum type, the property access is of type Any.
            // See if we can index as a property.
            var apparentType = getApparentType(objectType);
            if (apparentType === unknownType) {
                // handle cases when objectType is type parameter with invalid type
                return unknownType;
            }
            if (node.index.kind === 3 /* StringLiteral */ || node.index.kind === 2 /* NumericLiteral */) {
                var name = node.index.text;
                var prop = getPropertyOfApparentType(apparentType, name);
                if (prop) {
                    return getTypeOfSymbol(prop);
                }
            }
            // Check for compatible indexer types.
            if (indexType.flags & (1 /* Any */ | ts.TypeFlags.StringLike | ts.TypeFlags.NumberLike)) {
                // Try to use a number indexer.
                if (indexType.flags & (1 /* Any */ | ts.TypeFlags.NumberLike)) {
                    var numberIndexType = getIndexTypeOfType(apparentType, 1 /* Number */);
                    if (numberIndexType) {
                        return numberIndexType;
                    }
                }
                // Try to use string indexing.
                var stringIndexType = getIndexTypeOfType(apparentType, 0 /* String */);
                if (stringIndexType) {
                    return stringIndexType;
                }
                // Fall back to any.
                if (program.getCompilerOptions().noImplicitAny && objectType !== anyType) {
                    error(node, ts.Diagnostics.Index_signature_of_object_type_implicitly_has_an_any_type);
                }
                return anyType;
            }
            // REVIEW: Users should know the type that was actually used.
            error(node, ts.Diagnostics.An_index_expression_argument_must_be_of_type_string_number_or_any);
            return unknownType;
        }
        function resolveUntypedCall(node) {
            ts.forEach(node.arguments, function (argument) {
                checkExpression(argument);
            });
            return anySignature;
        }
        function resolveErrorCall(node) {
            resolveUntypedCall(node);
            return unknownSignature;
        }
        function isCandidateSignature(node, signature) {
            var args = node.arguments || emptyArray;
            return args.length >= signature.minArgumentCount && (signature.hasRestParameter || args.length <= signature.parameters.length) && (!node.typeArguments || signature.typeParameters && node.typeArguments.length === signature.typeParameters.length);
        }
        // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
        // A nit here is that we reorder only signatures that belong to the same symbol,
        // so order how inherited signatures are processed is still preserved.
        // interface A { (x: string): void }
        // interface B extends A { (x: 'foo'): string }
        // var b: B;
        // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
        function collectCandidates(node, signatures) {
            var result = [];
            var lastParent;
            var lastSymbol;
            var cutoffPos = 0;
            var pos;
            for (var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (isCandidateSignature(node, signature)) {
                    var symbol = signature.declaration && getSymbolOfNode(signature.declaration);
                    var parent = signature.declaration && signature.declaration.parent;
                    if (!lastSymbol || symbol === lastSymbol) {
                        if (lastParent && parent === lastParent) {
                            pos++;
                        }
                        else {
                            lastParent = parent;
                            pos = cutoffPos;
                        }
                    }
                    else {
                        // current declaration belongs to a different symbol
                        // set cutoffPos so reorderings in the future won't change result set from 0 to cutoffPos
                        pos = cutoffPos = result.length;
                        lastParent = parent;
                    }
                    lastSymbol = symbol;
                    for (var j = result.length; j > pos; j--) {
                        result[j] = result[j - 1];
                    }
                    result[pos] = signature;
                }
            }
            return result;
        }
        // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
        function getSingleCallSignature(type) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 && resolved.properties.length === 0 && !resolved.stringIndexType && !resolved.numberIndexType) {
                    return resolved.callSignatures[0];
                }
            }
            return undefined;
        }
        // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
        function instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper) {
            var context = createInferenceContext(signature.typeParameters);
            forEachMatchingParameterType(contextualSignature, signature, function (source, target) {
                // Type parameters from outer context referenced by source type are fixed by instantiation of the source type
                inferTypes(context, instantiateType(source, contextualMapper), target);
            });
            return getSignatureInstantiation(signature, getInferredTypes(context));
        }
        // Inferentially type an expression by a contextual parameter type (section 4.12.2 in TypeScript spec)
        function inferentiallyTypeExpession(expr, contextualType, contextualMapper) {
            var type = checkExpressionWithContextualType(expr, contextualType, contextualMapper);
            var signature = getSingleCallSignature(type);
            if (signature && signature.typeParameters) {
                var contextualSignature = getSingleCallSignature(contextualType);
                if (contextualSignature && !contextualSignature.typeParameters) {
                    type = getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper));
                }
            }
            return type;
        }
        function inferTypeArguments(signature, args, excludeArgument) {
            var typeParameters = signature.typeParameters;
            var context = createInferenceContext(typeParameters);
            var mapper = createInferenceMapper(context);
            for (var i = 0; i < args.length; i++) {
                if (!excludeArgument || excludeArgument[i] === undefined) {
                    var parameterType = getTypeAtPosition(signature, i);
                    inferTypes(context, inferentiallyTypeExpession(args[i], parameterType, mapper), parameterType);
                }
            }
            // Next, infer from those context sensitive arguments that are no longer excluded
            if (excludeArgument) {
                for (var i = 0; i < args.length; i++) {
                    if (excludeArgument[i] === false) {
                        var parameterType = getTypeAtPosition(signature, i);
                        inferTypes(context, inferentiallyTypeExpession(args[i], parameterType, mapper), parameterType);
                    }
                }
            }
            return getInferredTypes(context);
        }
        function checkTypeArguments(signature, typeArguments) {
            var typeParameters = signature.typeParameters;
            var result = [];
            for (var i = 0; i < typeParameters.length; i++) {
                var typeArgNode = typeArguments[i];
                var typeArgument = getTypeFromTypeNode(typeArgNode);
                var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                if (constraint && fullTypeCheck) {
                    checkTypeAssignableTo(typeArgument, constraint, typeArgNode, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1_Colon, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                }
                result.push(typeArgument);
            }
            return result;
        }
        function checkApplicableSignature(node, signature, relation, excludeArgument, reportErrors) {
            if (node.arguments) {
                for (var i = 0; i < node.arguments.length; i++) {
                    var arg = node.arguments[i];
                    var paramType = getTypeAtPosition(signature, i);
                    // String literals get string literal types unless we're reporting errors
                    var argType = arg.kind === 3 /* StringLiteral */ && !reportErrors ? getStringLiteralType(arg) : checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);
                    // Use argument expression as error location when reporting errors
                    var isValidArgument = checkTypeRelatedTo(argType, paramType, relation, reportErrors ? arg : undefined, ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1, ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1);
                    if (!isValidArgument) {
                        return false;
                    }
                }
            }
            return true;
        }
        function resolveCall(node, signatures) {
            ts.forEach(node.typeArguments, checkSourceElement);
            var candidates = collectCandidates(node, signatures);
            if (!candidates.length) {
                error(node, ts.Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);
                return resolveErrorCall(node);
            }
            var args = node.arguments || emptyArray;
            var excludeArgument;
            for (var i = 0; i < args.length; i++) {
                if (isContextSensitiveExpression(args[i])) {
                    if (!excludeArgument)
                        excludeArgument = new Array(args.length);
                    excludeArgument[i] = true;
                }
            }
            var relation = candidates.length === 1 ? assignableRelation : subtypeRelation;
            while (true) {
                for (var i = 0; i < candidates.length; i++) {
                    while (true) {
                        var candidate = candidates[i];
                        if (candidate.typeParameters) {
                            var typeArguments = node.typeArguments ? checkTypeArguments(candidate, node.typeArguments) : inferTypeArguments(candidate, args, excludeArgument);
                            candidate = getSignatureInstantiation(candidate, typeArguments);
                        }
                        if (!checkApplicableSignature(node, candidate, relation, excludeArgument, false)) {
                            break;
                        }
                        var index = excludeArgument ? ts.indexOf(excludeArgument, true) : -1;
                        if (index < 0) {
                            return candidate;
                        }
                        excludeArgument[index] = false;
                    }
                }
                if (relation === assignableRelation) {
                    break;
                }
                relation = assignableRelation;
            }
            // No signatures were applicable. Now report errors based on the last applicable signature with
            // no arguments excluded from assignability checks.
            checkApplicableSignature(node, candidate, relation, undefined, true);
            return resolveErrorCall(node);
        }
        function resolveCallExpression(node) {
            if (node.func.kind === 81 /* SuperKeyword */) {
                var superType = checkSuperExpression(node.func, true);
                if (superType !== unknownType) {
                    return resolveCall(node, getSignaturesOfType(superType, 1 /* Construct */));
                }
                return resolveUntypedCall(node);
            }
            var funcType = checkExpression(node.func);
            if (funcType === unknownType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            var apparentType = getApparentType(funcType);
            if (apparentType === unknownType) {
                // handler cases when funcType is type parameter with invalid constraint
                // Another error was already reported
                return resolveErrorCall(node);
            }
            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including call signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
            var constructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */);
            // TS 1.0 spec: 4.12
            // If FuncExpr is of type Any, or of an object type that has no call or construct signatures
            // but is a subtype of the Function interface, the call is an untyped function call. In an
            // untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
            // types are provided for the argument expressions, and the result is always of type Any.
            if ((funcType === anyType) || (!callSignatures.length && !constructSignatures.length && isTypeAssignableTo(funcType, globalFunctionType))) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
            // TypeScript employs overload resolution in typed function calls in order to support functions
            // with multiple call signatures.
            if (!callSignatures.length) {
                if (constructSignatures.length) {
                    error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
                }
                else {
                    error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);
                }
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures);
        }
        function resolveNewExpression(node) {
            var expressionType = checkExpression(node.func);
            if (expressionType === unknownType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            // TS 1.0 spec: 4.11
            // If ConstructExpr is of type Any, Args can be any argument
            // list and the result of the operation is of type Any.
            if (expressionType === anyType) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            // If ConstructExpr's apparent type(section 3.8.1) is an object type with one or
            // more construct signatures, the expression is processed in the same manner as a
            // function call, but using the construct signatures as the initial set of candidate
            // signatures for overload resolution.The result type of the function call becomes
            // the result type of the operation.
            expressionType = getApparentType(expressionType);
            if (expressionType === unknownType) {
                // handler cases when original expressionType is a type parameter with invalid constraint
                // another error has already been reported
                return resolveErrorCall(node);
            }
            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including construct signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var constructSignatures = getSignaturesOfType(expressionType, 1 /* Construct */);
            if (constructSignatures.length) {
                return resolveCall(node, constructSignatures);
            }
            // If ConstructExpr's apparent type is an object type with no construct signatures but
            // one or more call signatures, the expression is processed as a function call. A compile-time
            // error occurs if the result of the function call is not Void. The type of the result of the
            // operation is Any.
            var callSignatures = getSignaturesOfType(expressionType, 0 /* Call */);
            if (callSignatures.length) {
                var signature = resolveCall(node, callSignatures);
                if (getReturnTypeOfSignature(signature) !== voidType) {
                    error(node, ts.Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                }
                return signature;
            }
            error(node, ts.Diagnostics.Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature);
            return resolveErrorCall(node);
        }
        function getResolvedSignature(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedSignature) {
                links.resolvedSignature = anySignature;
                links.resolvedSignature = node.kind === 132 /* CallExpression */ ? resolveCallExpression(node) : resolveNewExpression(node);
            }
            return links.resolvedSignature;
        }
        function checkCallExpression(node) {
            var signature = getResolvedSignature(node);
            if (node.func.kind === 81 /* SuperKeyword */) {
                return voidType;
            }
            if (node.kind === 133 /* NewExpression */) {
                var declaration = signature.declaration;
                if (declaration && (declaration.kind !== 117 /* Constructor */ && declaration.kind !== 121 /* ConstructSignature */)) {
                    // When resolved signature is a call signature (and not a construct signature) the result type is any
                    if (program.getCompilerOptions().noImplicitAny) {
                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                    }
                    return anyType;
                }
            }
            return getReturnTypeOfSignature(signature);
        }
        function checkTypeAssertion(node) {
            var exprType = checkExpression(node.operand);
            var targetType = getTypeFromTypeNode(node.type);
            if (fullTypeCheck && targetType !== unknownType) {
                var widenedType = getWidenedType(exprType);
                if (!(isTypeAssignableTo(exprType, targetType) || isTypeAssignableTo(targetType, widenedType))) {
                    checkTypeAssignableTo(targetType, widenedType, node, ts.Diagnostics.Neither_type_0_nor_type_1_is_assignable_to_the_other_Colon, ts.Diagnostics.Neither_type_0_nor_type_1_is_assignable_to_the_other);
                }
            }
            return targetType;
        }
        function getTypeAtPosition(signature, pos) {
            return signature.hasRestParameter ? pos < signature.parameters.length - 1 ? getTypeOfSymbol(signature.parameters[pos]) : getRestTypeOfSignature(signature) : pos < signature.parameters.length ? getTypeOfSymbol(signature.parameters[pos]) : anyType;
        }
        function assignContextualParameterTypes(signature, context, mapper) {
            var len = signature.parameters.length - (signature.hasRestParameter ? 1 : 0);
            for (var i = 0; i < len; i++) {
                var parameter = signature.parameters[i];
                var links = getSymbolLinks(parameter);
                links.type = instantiateType(getTypeAtPosition(context, i), mapper);
            }
            if (signature.hasRestParameter && context.hasRestParameter && signature.parameters.length >= context.parameters.length) {
                var parameter = signature.parameters[signature.parameters.length - 1];
                var links = getSymbolLinks(parameter);
                links.type = instantiateType(getTypeOfSymbol(context.parameters[context.parameters.length - 1]), mapper);
            }
        }
        function getReturnTypeFromBody(func, contextualMapper) {
            if (func.body.kind !== 168 /* FunctionBlock */) {
                var unwidenedType = checkAndMarkExpression(func.body, contextualMapper);
                var widenedType = getWidenedType(unwidenedType);
                if (fullTypeCheck && program.getCompilerOptions().noImplicitAny && widenedType !== unwidenedType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                    error(func, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeToString(widenedType));
                }
                return widenedType;
            }
            // Aggregate the types of expressions within all the return statements.
            var types = checkAndAggregateReturnExpressionTypes(func.body, contextualMapper);
            // Try to return the best common type if we have any return expressions.
            if (types.length > 0) {
                var commonType = getBestCommonType(types, undefined, true);
                if (!commonType) {
                    error(func, ts.Diagnostics.No_best_common_type_exists_among_return_expressions);
                    return unknownType;
                }
                var widenedType = getWidenedType(commonType);
                // Check and report for noImplicitAny if the best common type implicitly gets widened to an 'any'/arrays-of-'any' type.
                if (fullTypeCheck && program.getCompilerOptions().noImplicitAny && widenedType !== commonType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                    var typeName = typeToString(widenedType);
                    if (func.name) {
                        error(func, ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, ts.identifierToString(func.name), typeName);
                    }
                    else {
                        error(func, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);
                    }
                }
                return widenedType;
            }
            return voidType;
        }
        // WARNING: This has the same semantics as the forEach family of functions,
        //          in that traversal terminates in the event that 'visitor' supplies a truthy value.
        function forEachReturnStatement(body, visitor) {
            return traverse(body);
            function traverse(node) {
                switch (node.kind) {
                    case 154 /* ReturnStatement */:
                        return visitor(node);
                    case 143 /* Block */:
                    case 168 /* FunctionBlock */:
                    case 147 /* IfStatement */:
                    case 148 /* DoStatement */:
                    case 149 /* WhileStatement */:
                    case 150 /* ForStatement */:
                    case 151 /* ForInStatement */:
                    case 155 /* WithStatement */:
                    case 156 /* SwitchStatement */:
                    case 157 /* CaseClause */:
                    case 158 /* DefaultClause */:
                    case 159 /* LabelledStatement */:
                    case 161 /* TryStatement */:
                    case 162 /* TryBlock */:
                    case 163 /* CatchBlock */:
                    case 164 /* FinallyBlock */:
                        return ts.forEachChild(node, traverse);
                }
            }
        }
        /// Returns a set of types relating to every return expression relating to a function block.
        function checkAndAggregateReturnExpressionTypes(body, contextualMapper) {
            var aggregatedTypes = [];
            forEachReturnStatement(body, function (returnStatement) {
                var expr = returnStatement.expression;
                if (expr) {
                    var type = checkAndMarkExpression(expr, contextualMapper);
                    if (!ts.contains(aggregatedTypes, type)) {
                        aggregatedTypes.push(type);
                    }
                }
            });
            return aggregatedTypes;
        }
        function bodyContainsAReturnStatement(funcBody) {
            return forEachReturnStatement(funcBody, function (returnStatement) {
                return true;
            });
        }
        function bodyContainsSingleThrowStatement(body) {
            return (body.statements.length === 1) && (body.statements[0].kind === 160 /* ThrowStatement */);
        }
        // TypeScript Specification 1.0 (6.3) - July 2014
        // An explicitly typed function whose return type isn't the Void or the Any type
        // must have at least one return statement somewhere in its body.
        // An exception to this rule is if the function implementation consists of a single 'throw' statement.
        function checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(func, returnType) {
            if (!fullTypeCheck) {
                return;
            }
            // Functions that return 'void' or 'any' don't need any return expressions.
            if (returnType === voidType || returnType === anyType) {
                return;
            }
            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
            if (!func.body || func.body.kind !== 168 /* FunctionBlock */) {
                return;
            }
            var bodyBlock = func.body;
            // Ensure the body has at least one return expression.
            if (bodyContainsAReturnStatement(bodyBlock)) {
                return;
            }
            // If there are no return expressions, then we need to check if
            // the function body consists solely of a throw statement;
            // this is to make an exception for unimplemented functions.
            if (bodyContainsSingleThrowStatement(bodyBlock)) {
                return;
            }
            // This function does not conform to the specification.
            error(func.type, ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement);
        }
        function checkFunctionExpression(node, contextualMapper) {
            // The identityMapper object is used to indicate that function expressions are wildcards
            if (contextualMapper === identityMapper) {
                return anyFunctionType;
            }
            var links = getNodeLinks(node);
            var type = getTypeOfSymbol(node.symbol);
            // Check if function expression is contextually typed and assign parameter types if so
            if (!(links.flags & 64 /* ContextChecked */)) {
                var contextualSignature = getContextualSignature(node);
                // If a type check is started at a function expression that is an argument of a function call, obtaining the
                // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
                // already assigned contextual types.
                if (!(links.flags & 64 /* ContextChecked */)) {
                    links.flags |= 64 /* ContextChecked */;
                    if (contextualSignature) {
                        var signature = getSignaturesOfType(type, 0 /* Call */)[0];
                        if (isContextSensitiveExpression(node)) {
                            assignContextualParameterTypes(signature, contextualSignature, contextualMapper || identityMapper);
                        }
                        if (!node.type) {
                            signature.resolvedReturnType = resolvingType;
                            var returnType = getReturnTypeFromBody(node, contextualMapper);
                            if (signature.resolvedReturnType === resolvingType) {
                                signature.resolvedReturnType = returnType;
                            }
                        }
                    }
                }
            }
            if (fullTypeCheck && !(links.flags & 1 /* TypeChecked */)) {
                checkSignatureDeclaration(node);
                if (node.type) {
                    checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));
                }
                if (node.body.kind === 168 /* FunctionBlock */) {
                    checkSourceElement(node.body);
                }
                else {
                    var exprType = checkExpression(node.body);
                    if (node.type) {
                        checkTypeAssignableTo(exprType, getTypeFromTypeNode(node.type), node.body, undefined, undefined);
                    }
                }
                links.flags |= 1 /* TypeChecked */;
            }
            return type;
        }
        function checkArithmeticOperandType(operand, type, diagnostic) {
            if (!(type.flags & (1 /* Any */ | ts.TypeFlags.NumberLike))) {
                error(operand, diagnostic);
                return false;
            }
            return true;
        }
        function checkReferenceExpression(n, message) {
            function findSymbol(n) {
                var symbol = getNodeLinks(n).resolvedSymbol;
                // Because we got the symbol from the resolvedSymbol property, it might be of kind
                // SymbolFlags.ExportValue. In this case it is necessary to get the actual export
                // symbol, which will have the correct flags set on it.
                return symbol && getExportSymbolOfValueSymbolIfExported(symbol);
            }
            function isReferenceOrErrorExpression(n) {
                switch (n.kind) {
                    case 55 /* Identifier */:
                        var symbol = findSymbol(n);
                        // TypeScript 1.0 spec (April 2014): 4.3
                        // An identifier expression that references a variable or parameter is classified as a reference.
                        // An identifier expression that references any other kind of entity is classified as a value(and therefore cannot be the target of an assignment).
                        return !symbol || symbol === unknownSymbol || symbol === argumentsSymbol || (symbol.flags & 1 /* Variable */) !== 0;
                    case 130 /* PropertyAccess */:
                        var symbol = findSymbol(n);
                        // TypeScript 1.0 spec (April 2014): 4.10
                        // A property access expression is always classified as a reference.
                        // NOTE (not in spec): assignment to enum members should not be allowed
                        return !symbol || symbol === unknownSymbol || (symbol.flags & ~4 /* EnumMember */) !== 0;
                    case 131 /* IndexedAccess */:
                        //  old compiler doesn't check indexed assess
                        return true;
                    case 135 /* ParenExpression */:
                        return isReferenceOrErrorExpression(n.expression);
                    default:
                        return false;
                }
            }
            if (!isReferenceOrErrorExpression(n)) {
                error(n, message);
                return false;
            }
            return true;
        }
        function checkPrefixExpression(node) {
            var operandType = checkExpression(node.operand);
            switch (node.operator) {
                case 24 /* PlusToken */:
                case 25 /* MinusToken */:
                case 38 /* TildeToken */:
                    return numberType;
                case 37 /* ExclamationToken */:
                case 64 /* DeleteKeyword */:
                    return booleanType;
                case 87 /* TypeOfKeyword */:
                    return stringType;
                case 89 /* VoidKeyword */:
                    return undefinedType;
                case 29 /* PlusPlusToken */:
                case 30 /* MinusMinusToken */:
                    var ok = checkArithmeticOperandType(node.operand, operandType, ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
                    if (ok) {
                        // run check only if former checks succeeded to avoid reporting cascading errors
                        checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer);
                    }
                    return numberType;
            }
            return unknownType;
        }
        function checkPostfixExpression(node) {
            var operandType = checkExpression(node.operand);
            var ok = checkArithmeticOperandType(node.operand, operandType, ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
            if (ok) {
                // run check only if former checks succeeded to avoid reporting cascading errors
                checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer);
            }
            return numberType;
        }
        function isTypeAnyTypeObjectTypeOrTypeParameter(type) {
            return type === anyType || ((type.flags & (ts.TypeFlags.ObjectType | 512 /* TypeParameter */)) !== 0);
        }
        function checkInstanceOfExpression(node, leftType, rightType) {
            // TypeScript 1.0 spec (April 2014): 4.15.4
            // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
            // and the right operand to be of type Any or a subtype of the 'Function' interface type.
            // The result is always of the Boolean primitive type.
            if (!isTypeAnyTypeObjectTypeOrTypeParameter(leftType)) {
                error(node.left, ts.Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            if (rightType !== anyType && !isTypeSubtypeOf(rightType, globalFunctionType)) {
                error(node.right, ts.Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
            }
            return booleanType;
        }
        function checkInExpression(node, leftType, rightType) {
            // TypeScript 1.0 spec (April 2014): 4.15.5
            // The in operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type,
            // and the right operand to be of type Any, an object type, or a type parameter type.
            // The result is always of the Boolean primitive type.
            if (leftType !== anyType && leftType !== stringType && leftType !== numberType) {
                error(node.left, ts.Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number);
            }
            if (!isTypeAnyTypeObjectTypeOrTypeParameter(rightType)) {
                error(node.right, ts.Diagnostics.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            return booleanType;
        }
        function checkBinaryExpression(node, contextualMapper) {
            var operator = node.operator;
            var leftType = checkExpression(node.left, contextualMapper);
            var rightType = checkExpression(node.right, contextualMapper);
            switch (operator) {
                case 26 /* AsteriskToken */:
                case 46 /* AsteriskEqualsToken */:
                case 27 /* SlashToken */:
                case 47 /* SlashEqualsToken */:
                case 28 /* PercentToken */:
                case 48 /* PercentEqualsToken */:
                case 25 /* MinusToken */:
                case 45 /* MinusEqualsToken */:
                case 31 /* LessThanLessThanToken */:
                case 49 /* LessThanLessThanEqualsToken */:
                case 32 /* GreaterThanGreaterThanToken */:
                case 50 /* GreaterThanGreaterThanEqualsToken */:
                case 33 /* GreaterThanGreaterThanGreaterThanToken */:
                case 51 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 35 /* BarToken */:
                case 53 /* BarEqualsToken */:
                case 36 /* CaretToken */:
                case 54 /* CaretEqualsToken */:
                case 34 /* AmpersandToken */:
                case 52 /* AmpersandEqualsToken */:
                    // TypeScript 1.0 spec (April 2014): 4.15.1
                    // These operators require their operands to be of type Any, the Number primitive type,
                    // or an enum type. Operands of an enum type are treated
                    // as having the primitive type Number. If one operand is the null or undefined value,
                    // it is treated as having the type of the other operand.
                    // The result is always of the Number primitive type.
                    if (leftType.flags & (32 /* Undefined */ | 64 /* Null */))
                        leftType = rightType;
                    if (rightType.flags & (32 /* Undefined */ | 64 /* Null */))
                        rightType = leftType;
                    var leftOk = checkArithmeticOperandType(node.left, leftType, ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                    var rightOk = checkArithmeticOperandType(node.right, rightType, ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                    if (leftOk && rightOk) {
                        checkAssignmentOperator(numberType);
                    }
                    return numberType;
                case 24 /* PlusToken */:
                case 44 /* PlusEqualsToken */:
                    // TypeScript 1.0 spec (April 2014): 4.15.2
                    // The binary + operator requires both operands to be of the Number primitive type or an enum type,
                    // or at least one of the operands to be of type Any or the String primitive type.
                    // If one operand is the null or undefined value, it is treated as having the type of the other operand.
                    if (leftType.flags & (32 /* Undefined */ | 64 /* Null */))
                        leftType = rightType;
                    if (rightType.flags & (32 /* Undefined */ | 64 /* Null */))
                        rightType = leftType;
                    var resultType;
                    if (leftType.flags & ts.TypeFlags.NumberLike && rightType.flags & ts.TypeFlags.NumberLike) {
                        // Operands of an enum type are treated as having the primitive type Number.
                        // If both operands are of the Number primitive type, the result is of the Number primitive type.
                        resultType = numberType;
                    }
                    else if (leftType.flags & ts.TypeFlags.StringLike || rightType.flags & ts.TypeFlags.StringLike) {
                        // If one or both operands are of the String primitive type, the result is of the String primitive type.
                        resultType = stringType;
                    }
                    else if (leftType.flags & 1 /* Any */ || leftType === unknownType || rightType.flags & 1 /* Any */ || rightType === unknownType) {
                        // Otherwise, the result is of type Any.
                        // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
                        resultType = anyType;
                    }
                    if (!resultType) {
                        reportOperatorError();
                        return anyType;
                    }
                    if (operator === 44 /* PlusEqualsToken */) {
                        checkAssignmentOperator(resultType);
                    }
                    return resultType;
                case 19 /* EqualsEqualsToken */:
                case 20 /* ExclamationEqualsToken */:
                case 21 /* EqualsEqualsEqualsToken */:
                case 22 /* ExclamationEqualsEqualsToken */:
                case 15 /* LessThanToken */:
                case 16 /* GreaterThanToken */:
                case 17 /* LessThanEqualsToken */:
                case 18 /* GreaterThanEqualsToken */:
                    if (!isTypeSubtypeOf(leftType, rightType) && !isTypeSubtypeOf(rightType, leftType)) {
                        reportOperatorError();
                    }
                    return booleanType;
                case 77 /* InstanceOfKeyword */:
                    return checkInstanceOfExpression(node, leftType, rightType);
                case 76 /* InKeyword */:
                    return checkInExpression(node, leftType, rightType);
                case 39 /* AmpersandAmpersandToken */:
                    return rightType;
                case 40 /* BarBarToken */:
                    return getBestCommonType([leftType, rightType], isInferentialContext(contextualMapper) ? undefined : getContextualType(node));
                case 43 /* EqualsToken */:
                    checkAssignmentOperator(rightType);
                    return rightType;
                case 14 /* CommaToken */:
                    return rightType;
            }
            function checkAssignmentOperator(valueType) {
                if (fullTypeCheck && operator >= ts.SyntaxKind.FirstAssignment && operator <= ts.SyntaxKind.LastAssignment) {
                    // TypeScript 1.0 spec (April 2014): 4.17
                    // An assignment of the form
                    //    VarExpr = ValueExpr
                    // requires VarExpr to be classified as a reference
                    // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
                    // and the type of the non - compound operation to be assignable to the type of VarExpr.
                    var ok = checkReferenceExpression(node.left, ts.Diagnostics.Invalid_left_hand_side_of_assignment_expression);
                    // Use default messages
                    if (ok) {
                        // to avoid cascading errors check assignability only if 'isReference' check succeded and no errors were reported
                        checkTypeAssignableTo(valueType, leftType, node.left, undefined, undefined);
                    }
                }
            }
            function reportOperatorError() {
                error(node, ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, ts.tokenToString(node.operator), typeToString(leftType), typeToString(rightType));
            }
        }
        function checkConditionalExpression(node, contextualMapper) {
            checkExpression(node.condition);
            var type1 = checkExpression(node.whenTrue, contextualMapper);
            var type2 = checkExpression(node.whenFalse, contextualMapper);
            var contextualType = isInferentialContext(contextualMapper) ? undefined : getContextualType(node);
            var resultType = getBestCommonType([type1, type2], contextualType, true);
            if (!resultType) {
                if (contextualType) {
                    error(node, ts.Diagnostics.No_best_common_type_exists_between_0_1_and_2, typeToString(contextualType), typeToString(type1), typeToString(type2));
                }
                else {
                    error(node, ts.Diagnostics.No_best_common_type_exists_between_0_and_1, typeToString(type1), typeToString(type2));
                }
                resultType = emptyObjectType;
            }
            return resultType;
        }
        function checkExpressionWithContextualType(node, contextualType, contextualMapper) {
            var saveContextualType = node.contextualType;
            node.contextualType = contextualType;
            var result = checkExpression(node, contextualMapper);
            node.contextualType = saveContextualType;
            return result;
        }
        function checkAndMarkExpression(node, contextualMapper) {
            var result = checkExpression(node, contextualMapper);
            getNodeLinks(node).flags |= 1 /* TypeChecked */;
            return result;
        }
        // Checks an expression and returns its type. The contextualMapper parameter serves two purposes: When
        // contextualMapper is not undefined and not equal to the identityMapper function object it indicates that the
        // expression is being inferentially typed (section 4.12.2 in spec) and provides the type mapper to use in
        // conjuction with the generic contextual type. When contextualMapper is equal to the identityMapper function
        // object, it serves as an indicator that all contained function and arrow expressions should be considered to
        // have the wildcard function type; this form of type check is used during overload resolution to exclude
        // contextually typed function and arrow expressions in the initial phase.
        function checkExpression(node, contextualMapper) {
            switch (node.kind) {
                case 55 /* Identifier */:
                    return checkIdentifier(node);
                case 83 /* ThisKeyword */:
                    return checkThisExpression(node);
                case 81 /* SuperKeyword */:
                    return checkSuperExpression(node, false);
                case 79 /* NullKeyword */:
                    return nullType;
                case 85 /* TrueKeyword */:
                case 70 /* FalseKeyword */:
                    return booleanType;
                case 2 /* NumericLiteral */:
                    return numberType;
                case 3 /* StringLiteral */:
                    return stringType;
                case 4 /* RegularExpressionLiteral */:
                    return globalRegExpType;
                case 112 /* QualifiedName */:
                    return checkPropertyAccess(node);
                case 127 /* ArrayLiteral */:
                    return checkArrayLiteral(node, contextualMapper);
                case 128 /* ObjectLiteral */:
                    return checkObjectLiteral(node, contextualMapper);
                case 130 /* PropertyAccess */:
                    return checkPropertyAccess(node);
                case 131 /* IndexedAccess */:
                    return checkIndexedAccess(node);
                case 132 /* CallExpression */:
                case 133 /* NewExpression */:
                    return checkCallExpression(node);
                case 134 /* TypeAssertion */:
                    return checkTypeAssertion(node);
                case 135 /* ParenExpression */:
                    return checkExpression(node.expression);
                case 136 /* FunctionExpression */:
                case 137 /* ArrowFunction */:
                    return checkFunctionExpression(node, contextualMapper);
                case 138 /* PrefixOperator */:
                    return checkPrefixExpression(node);
                case 139 /* PostfixOperator */:
                    return checkPostfixExpression(node);
                case 140 /* BinaryExpression */:
                    return checkBinaryExpression(node, contextualMapper);
                case 141 /* ConditionalExpression */:
                    return checkConditionalExpression(node, contextualMapper);
            }
            return unknownType;
        }
        // DECLARATION AND STATEMENT TYPE CHECKING
        function checkTypeParameter(node) {
            checkSourceElement(node.constraint);
            if (fullTypeCheck) {
                checkTypeParameterHasIllegalReferencesInConstraint(node);
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);
            }
            // TODO: Check multiple declarations are identical
        }
        function checkParameter(parameterDeclaration) {
            checkVariableDeclaration(parameterDeclaration);
            if (fullTypeCheck) {
                checkCollisionWithIndexVariableInGeneratedCode(parameterDeclaration, parameterDeclaration.name);
                if (parameterDeclaration.flags & (16 /* Public */ | 32 /* Private */) && !(parameterDeclaration.parent.kind === 117 /* Constructor */ && parameterDeclaration.parent.body)) {
                    error(parameterDeclaration, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                }
                if (parameterDeclaration.flags & 8 /* Rest */) {
                    if (!isArrayType(getTypeOfSymbol(parameterDeclaration.symbol))) {
                        error(parameterDeclaration, ts.Diagnostics.A_rest_parameter_must_be_of_an_array_type);
                    }
                }
                else {
                    if (parameterDeclaration.initializer && !parameterDeclaration.parent.body) {
                        error(parameterDeclaration, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
                    }
                }
            }
            function checkReferencesInInitializer(n) {
                if (n.kind === 55 /* Identifier */) {
                    var referencedSymbol = getNodeLinks(n).resolvedSymbol;
                    // check FunctionDeclaration.locals (stores parameters\function local variable)
                    // if it contains entry with a specified name and if this entry matches the resolved symbol
                    if (referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol(parameterDeclaration.parent.locals, referencedSymbol.name, ts.SymbolFlags.Value) === referencedSymbol) {
                        if (referencedSymbol.valueDeclaration.kind === 114 /* Parameter */) {
                            if (referencedSymbol.valueDeclaration === parameterDeclaration) {
                                error(n, ts.Diagnostics.Parameter_0_cannot_be_referenced_in_its_initializer, ts.identifierToString(parameterDeclaration.name));
                                return;
                            }
                            var enclosingOrReferencedParameter = ts.forEach(parameterDeclaration.parent.parameters, function (p) { return p === parameterDeclaration || p === referencedSymbol.valueDeclaration ? p : undefined; });
                            if (enclosingOrReferencedParameter === referencedSymbol.valueDeclaration) {
                                // legal case - parameter initializer references some parameter strictly on left of current parameter declaration
                                return;
                            }
                        }
                        error(n, ts.Diagnostics.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, ts.identifierToString(parameterDeclaration.name), ts.identifierToString(n));
                    }
                }
                else {
                    ts.forEachChild(n, checkReferencesInInitializer);
                }
            }
            if (parameterDeclaration.initializer) {
                checkReferencesInInitializer(parameterDeclaration.initializer);
            }
        }
        function checkSignatureDeclaration(node) {
            checkTypeParameters(node.typeParameters);
            ts.forEach(node.parameters, checkParameter);
            if (node.type) {
                checkSourceElement(node.type);
            }
            if (fullTypeCheck) {
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithArgumentsInGeneratedCode(node);
                if (program.getCompilerOptions().noImplicitAny && !node.type) {
                    switch (node.kind) {
                        case 121 /* ConstructSignature */:
                            error(node, ts.Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                        case 120 /* CallSignature */:
                            error(node, ts.Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                    }
                }
            }
            checkSpecializedSignatureDeclaration(node);
        }
        function checkTypeForDuplicateIndexSignatures(node) {
            if (node.kind === 170 /* InterfaceDeclaration */) {
                var nodeSymbol = getSymbolOfNode(node);
                // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
                // to prevent this run check only for the first declaration of a given kind
                if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                    return;
                }
            }
            // TypeScript 1.0 spec (April 2014)
            // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
            // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
            var indexSymbol = getIndexSymbol(getSymbolOfNode(node));
            if (indexSymbol) {
                var seenNumericIndexer = false;
                var seenStringIndexer = false;
                for (var i = 0, len = indexSymbol.declarations.length; i < len; ++i) {
                    var declaration = indexSymbol.declarations[i];
                    if (declaration.parameters.length == 1 && declaration.parameters[0].type) {
                        switch (declaration.parameters[0].type.kind) {
                            case 110 /* StringKeyword */:
                                if (!seenStringIndexer) {
                                    seenStringIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_string_index_signature);
                                }
                                break;
                            case 108 /* NumberKeyword */:
                                if (!seenNumericIndexer) {
                                    seenNumericIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_number_index_signature);
                                }
                                break;
                        }
                    }
                }
            }
        }
        function checkPropertyDeclaration(node) {
            // TODO
            checkVariableDeclaration(node);
        }
        function checkMethodDeclaration(node) {
            // TODO
            checkFunctionDeclaration(node);
        }
        function checkConstructorDeclaration(node) {
            // TODO
            checkSignatureDeclaration(node);
            checkSourceElement(node.body);
            var symbol = getSymbolOfNode(node);
            var firstDeclaration = getDeclarationOfKind(symbol, node.kind);
            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(symbol);
            }
            // exit early in the case of signature - super checks are not relevant to them
            if (!node.body) {
                return;
            }
            if (!fullTypeCheck) {
                return;
            }
            function isSuperCallExpression(n) {
                return n.kind === 132 /* CallExpression */ && n.func.kind === 81 /* SuperKeyword */;
            }
            function containsSuperCall(n) {
                if (isSuperCallExpression(n)) {
                    return true;
                }
                switch (n.kind) {
                    case 136 /* FunctionExpression */:
                    case 167 /* FunctionDeclaration */:
                    case 137 /* ArrowFunction */:
                    case 128 /* ObjectLiteral */:
                        return false;
                    default:
                        return ts.forEachChild(n, containsSuperCall);
                }
            }
            function markThisReferencesAsErrors(n) {
                if (n.kind === 83 /* ThisKeyword */) {
                    error(n, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                }
                else if (n.kind !== 136 /* FunctionExpression */ && n.kind !== 167 /* FunctionDeclaration */) {
                    ts.forEachChild(n, markThisReferencesAsErrors);
                }
            }
            function isInstancePropertyWithInitializer(n) {
                return n.kind === 115 /* Property */ && !(n.flags & 64 /* Static */) && !!n.initializer;
            }
            // TS 1.0 spec (April 2014): 8.3.2
            // Constructors of classes with no extends clause may not contain super calls, whereas
            // constructors of derived classes must contain at least one super call somewhere in their function body.
            if (node.parent.baseType) {
                if (containsSuperCall(node.body)) {
                    // The first statement in the body of a constructor must be a super call if both of the following are true:
                    // - The containing class is a derived class.
                    // - The constructor declares parameter properties
                    //   or the containing class declares instance member variables with initializers.
                    var superCallShouldBeFirst = ts.forEach(node.parent.members, isInstancePropertyWithInitializer) || ts.forEach(node.parameters, function (p) { return p.flags & (16 /* Public */ | 32 /* Private */); });
                    if (superCallShouldBeFirst) {
                        var statements = node.body.statements;
                        if (!statements.length || statements[0].kind !== 146 /* ExpressionStatement */ || !isSuperCallExpression(statements[0].expression)) {
                            error(node, ts.Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties);
                        }
                        else {
                            // In such a required super call, it is a compile-time error for argument expressions to reference this.
                            markThisReferencesAsErrors(statements[0].expression);
                        }
                    }
                }
                else {
                    error(node, ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }
        function checkAccessorDeclaration(node) {
            if (fullTypeCheck) {
                if (node.kind === 118 /* GetAccessor */) {
                    if (!ts.isInAmbientContext(node) && node.body && !(bodyContainsAReturnStatement(node.body) || bodyContainsSingleThrowStatement(node.body))) {
                        error(node.name, ts.Diagnostics.A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement);
                    }
                }
                // TypeScript 1.0 spec (April 2014): 8.4.3
                // Accessors for the same member name must specify the same accessibility.
                var otherKind = node.kind === 118 /* GetAccessor */ ? 119 /* SetAccessor */ : 118 /* GetAccessor */;
                var otherAccessor = getDeclarationOfKind(node.symbol, otherKind);
                if (otherAccessor) {
                    var visibilityFlags = 32 /* Private */ | 16 /* Public */;
                    if (((node.flags & visibilityFlags) !== (otherAccessor.flags & visibilityFlags))) {
                        error(node.name, ts.Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);
                    }
                    var thisType = getAnnotatedAccessorType(node);
                    var otherType = getAnnotatedAccessorType(otherAccessor);
                    // TypeScript 1.0 spec (April 2014): 4.5
                    // If both accessors include type annotations, the specified types must be identical.
                    if (thisType && otherType) {
                        if (!isTypeIdenticalTo(thisType, otherType)) {
                            error(node, ts.Diagnostics.get_and_set_accessor_must_have_the_same_type);
                        }
                    }
                }
            }
            checkFunctionDeclaration(node);
            checkAndStoreTypeOfAccessors(getSymbolOfNode(node));
        }
        function checkTypeReference(node) {
            var type = getTypeFromTypeReferenceNode(node);
            if (type !== unknownType && node.typeArguments) {
                // Do type argument local checks only if referenced type is successfully resolved
                var len = node.typeArguments.length;
                for (var i = 0; i < len; i++) {
                    checkSourceElement(node.typeArguments[i]);
                    var constraint = getConstraintOfTypeParameter(type.target.typeParameters[i]);
                    if (fullTypeCheck && constraint) {
                        var typeArgument = type.typeArguments[i];
                        checkTypeAssignableTo(typeArgument, constraint, node, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1_Colon, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                    }
                }
            }
        }
        function checkTypeQuery(node) {
            getTypeFromTypeQueryNode(node);
        }
        function checkTypeLiteral(node) {
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                var type = getTypeFromTypeLiteralNode(node);
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function checkArrayType(node) {
            getTypeFromArrayTypeNode(node);
        }
        function isPrivateWithinAmbient(node) {
            return (node.flags & 32 /* Private */) && ts.isInAmbientContext(node);
        }
        function checkSpecializedSignatureDeclaration(signatureDeclarationNode) {
            if (!fullTypeCheck) {
                return;
            }
            var signature = getSignatureFromDeclaration(signatureDeclarationNode);
            if (!signature.hasStringLiterals) {
                return;
            }
            // TypeScript 1.0 spec (April 2014): 3.7.2.2
            // Specialized signatures are not permitted in conjunction with a function body
            if (signatureDeclarationNode.body) {
                error(signatureDeclarationNode, ts.Diagnostics.A_signature_with_an_implementation_cannot_use_a_string_literal_type);
                return;
            }
            var symbol = getSymbolOfNode(signatureDeclarationNode);
            // TypeScript 1.0 spec (April 2014): 3.7.2.4
            // Every specialized call or construct signature in an object type must be assignable
            // to at least one non-specialized call or construct signature in the same object type
            var signaturesToCheck;
            // Unnamed (call\construct) signatures in interfaces are inherited and not shadowed so examining just node symbol won't give complete answer.
            // Use declaring type to obtain full list of signatures.
            if (!signatureDeclarationNode.name && signatureDeclarationNode.parent && signatureDeclarationNode.parent.kind === 170 /* InterfaceDeclaration */) {
                ts.Debug.assert(signatureDeclarationNode.kind === 120 /* CallSignature */ || signatureDeclarationNode.kind === 121 /* ConstructSignature */);
                var signatureKind = signatureDeclarationNode.kind === 120 /* CallSignature */ ? 0 /* Call */ : 1 /* Construct */;
                var containingSymbol = getSymbolOfNode(signatureDeclarationNode.parent);
                var containingType = getDeclaredTypeOfSymbol(containingSymbol);
                signaturesToCheck = getSignaturesOfType(containingType, signatureKind);
            }
            else {
                signaturesToCheck = getSignaturesOfSymbol(getSymbolOfNode(signatureDeclarationNode));
            }
            for (var i = 0; i < signaturesToCheck.length; i++) {
                var otherSignature = signaturesToCheck[i];
                if (!otherSignature.hasStringLiterals && isSignatureAssignableTo(signature, otherSignature)) {
                    return;
                }
            }
            error(signatureDeclarationNode, ts.Diagnostics.Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature);
        }
        function getEffectiveDeclarationFlags(n, flagsToCheck) {
            var flags = n.flags;
            if (n.parent.kind !== 170 /* InterfaceDeclaration */ && ts.isInAmbientContext(n)) {
                if (!(flags & 2 /* Ambient */)) {
                    // It is nested in an ambient context, which means it is automatically exported
                    flags |= 1 /* Export */;
                }
                flags |= 2 /* Ambient */;
            }
            return flags & flagsToCheck;
        }
        function checkFunctionOrConstructorSymbol(symbol) {
            if (!fullTypeCheck) {
                return;
            }
            function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck, someOverloadFlags, allOverloadFlags) {
                // Error if some overloads have a flag that is not shared by all overloads. To find the
                // deviations, we XOR someOverloadFlags with allOverloadFlags
                var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
                if (someButNotAllOverloadFlags !== 0) {
                    // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
                    // Error on all deviations from this canonical set of flags
                    // The caveat is that if some overloads are defined in lib.d.ts, we don't want to
                    // report the errors on those. To achieve this, we will say that the implementation is
                    // the canonical signature only if it is in the same container as the first overload
                    var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
                    var canonicalFlags = implementationSharesContainerWithFirstOverload ? getEffectiveDeclarationFlags(implementation, flagsToCheck) : getEffectiveDeclarationFlags(overloads[0], flagsToCheck);
                    ts.forEach(overloads, function (o) {
                        var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;
                        if (deviation & 1 /* Export */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_exported_or_not_exported);
                        }
                        else if (deviation & 2 /* Ambient */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                        }
                        else if (deviation & 32 /* Private */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_public_or_private);
                        }
                        else if (deviation & 4 /* QuestionMark */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                        }
                    });
                }
            }
            var flagsToCheck = 1 /* Export */ | 2 /* Ambient */ | 32 /* Private */ | 4 /* QuestionMark */;
            var someNodeFlags = 0;
            var allNodeFlags = flagsToCheck;
            var hasOverloads = false;
            var bodyDeclaration;
            var lastSeenNonAmbientDeclaration;
            var previousDeclaration;
            var declarations = symbol.declarations;
            var isConstructor = (symbol.flags & 4096 /* Constructor */) !== 0;
            function reportImplementationExpectedError(node) {
                var seen = false;
                var subsequentNode = ts.forEachChild(node.parent, function (c) {
                    if (seen) {
                        return c;
                    }
                    else {
                        seen = c === node;
                    }
                });
                if (subsequentNode) {
                    if (subsequentNode.kind === node.kind) {
                        var errorNode = subsequentNode.name || subsequentNode;
                        if (node.name && subsequentNode.name && node.name.text === subsequentNode.name.text) {
                            // the only situation when this is possible (same kind\same name but different symbol) - mixed static and instance class members
                            ts.Debug.assert(node.kind === 116 /* Method */);
                            ts.Debug.assert((node.flags & 64 /* Static */) !== (subsequentNode.flags & 64 /* Static */));
                            var diagnostic = node.flags & 64 /* Static */ ? ts.Diagnostics.Function_overload_must_be_static : ts.Diagnostics.Function_overload_must_not_be_static;
                            error(errorNode, diagnostic);
                            return;
                        }
                        else if (subsequentNode.body) {
                            error(errorNode, ts.Diagnostics.Function_implementation_name_must_be_0, ts.identifierToString(node.name));
                            return;
                        }
                    }
                }
                var errorNode = node.name || node;
                if (isConstructor) {
                    error(errorNode, ts.Diagnostics.Constructor_implementation_is_missing);
                }
                else {
                    error(errorNode, ts.Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                }
            }
            // when checking exported function declarations across modules check only duplicate implementations
            // names and consistensy of modifiers are verified when we check local symbol
            var isExportSymbolInsideModule = symbol.parent && symbol.parent.flags & ts.SymbolFlags.Module;
            for (var i = 0; i < declarations.length; i++) {
                var node = declarations[i];
                var inAmbientContext = ts.isInAmbientContext(node);
                var inAmbientContextOrInterface = node.parent.kind === 170 /* InterfaceDeclaration */ || node.parent.kind === 125 /* TypeLiteral */ || inAmbientContext;
                if (inAmbientContextOrInterface) {
                    // check if declarations are consecutive only if they are non-ambient
                    // 1. ambient declarations can be interleaved
                    // i.e. this is legal
                    //     declare function foo();
                    //     declare function bar();
                    //     declare function foo();
                    // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
                    previousDeclaration = undefined;
                }
                if (node.kind === 167 /* FunctionDeclaration */ || node.kind === 116 /* Method */ || node.kind === 117 /* Constructor */) {
                    var currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    if (node.body && bodyDeclaration) {
                        if (isConstructor) {
                            error(node, ts.Diagnostics.Multiple_constructor_implementations_are_not_allowed);
                        }
                        else {
                            error(node, ts.Diagnostics.Duplicate_function_implementation);
                        }
                    }
                    else if (!isExportSymbolInsideModule && previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {
                        reportImplementationExpectedError(previousDeclaration);
                    }
                    if (node.body) {
                        if (!bodyDeclaration) {
                            bodyDeclaration = node;
                        }
                    }
                    else {
                        hasOverloads = true;
                    }
                    previousDeclaration = node;
                    if (!inAmbientContextOrInterface) {
                        lastSeenNonAmbientDeclaration = node;
                    }
                }
            }
            if (!isExportSymbolInsideModule && lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body) {
                reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
            }
            if (hasOverloads) {
                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                if (bodyDeclaration) {
                    var signatures = getSignaturesOfSymbol(symbol);
                    var bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                    // If the implementation signature has string literals, we will have reported an error in
                    // checkSpecializedSignatureDeclaration
                    if (!bodySignature.hasStringLiterals) {
                        for (var i = 0, len = signatures.length; i < len; ++i) {
                            if (!signatures[i].hasStringLiterals && !isSignatureAssignableTo(bodySignature, signatures[i])) {
                                error(signatures[i].declaration, ts.Diagnostics.Overload_signature_is_not_compatible_with_function_implementation);
                                break;
                            }
                        }
                    }
                }
            }
        }
        function checkExportsOnMergedDeclarations(node) {
            if (!fullTypeCheck) {
                return;
            }
            var symbol;
            // Exports should be checked only if enclosing module contains both exported and non exported declarations.
            // In case if all declarations are non-exported check is unnecesary.
            // if localSymbol is defined on node then node itself is exported - check is required
            var symbol = node.localSymbol;
            if (!symbol) {
                // local symbol is undefined => this declaration is non-exported.
                // however symbol might contain other declarations that are exported
                symbol = getSymbolOfNode(node);
                if (!(symbol.flags & ts.SymbolFlags.Export)) {
                    // this is a pure local symbol (all declarations are non-exported) - no need to check anything
                    return;
                }
            }
            // run the check only for the first declaration in the list
            if (getDeclarationOfKind(symbol, node.kind) !== node) {
                return;
            }
            // we use SymbolFlags.ExportValue, SymbolFlags.ExportType and SymbolFlags.ExportNamespace
            // to denote disjoint declarationSpaces (without making new enum type).
            var exportedDeclarationSpaces = 0;
            var nonExportedDeclarationSpaces = 0;
            ts.forEach(symbol.declarations, function (d) {
                var declarationSpaces = getDeclarationSpaces(d);
                if (getEffectiveDeclarationFlags(d, 1 /* Export */)) {
                    exportedDeclarationSpaces |= declarationSpaces;
                }
                else {
                    nonExportedDeclarationSpaces |= declarationSpaces;
                }
            });
            var commonDeclarationSpace = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
            if (commonDeclarationSpace) {
                // declaration spaces for exported and non-exported declarations intersect
                ts.forEach(symbol.declarations, function (d) {
                    if (getDeclarationSpaces(d) & commonDeclarationSpace) {
                        error(d.name, ts.Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, ts.identifierToString(d.name));
                    }
                });
            }
            function getDeclarationSpaces(d) {
                switch (d.kind) {
                    case 170 /* InterfaceDeclaration */:
                        return 1048576 /* ExportType */;
                    case 172 /* ModuleDeclaration */:
                        return d.name.kind === 3 /* StringLiteral */ || ts.isInstantiated(d) ? 2097152 /* ExportNamespace */ | 524288 /* ExportValue */ : 2097152 /* ExportNamespace */;
                    case 169 /* ClassDeclaration */:
                    case 171 /* EnumDeclaration */:
                        return 1048576 /* ExportType */ | 524288 /* ExportValue */;
                    case 174 /* ImportDeclaration */:
                        var result = 0;
                        var target = resolveImport(getSymbolOfNode(d));
                        ts.forEach(target.declarations, function (d) {
                            result |= getDeclarationSpaces(d);
                        });
                        return result;
                    default:
                        return 524288 /* ExportValue */;
                }
            }
        }
        function checkFunctionDeclaration(node) {
            checkSignatureDeclaration(node);
            var symbol = getSymbolOfNode(node);
            // first we want to check the local symbol that contain this declaration
            // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
            // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
            var localSymbol = node.localSymbol || symbol;
            var firstDeclaration = getDeclarationOfKind(localSymbol, node.kind);
            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(localSymbol);
            }
            if (symbol.parent) {
                // run check once for the first declaration
                if (getDeclarationOfKind(symbol, node.kind) === node) {
                    // run check on export symbol to check that modifiers agree across all exported declarations
                    checkFunctionOrConstructorSymbol(symbol);
                }
            }
            checkSourceElement(node.body);
            if (node.type && !isAccessor(node.kind)) {
                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));
            }
            // If there is no body and no explicit return type, then report an error.
            if (fullTypeCheck && program.getCompilerOptions().noImplicitAny && !node.body && !node.type) {
                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.
                // (e.g. privates within .d.ts files do not expose type information)
                if (!isPrivateWithinAmbient(node)) {
                    var typeName = typeToString(anyType);
                    if (node.name) {
                        error(node, ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, ts.identifierToString(node.name), typeName);
                    }
                    else {
                        error(node, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);
                    }
                }
            }
        }
        function checkBlock(node) {
            ts.forEach(node.statements, checkSourceElement);
        }
        function checkCollisionWithArgumentsInGeneratedCode(node) {
            // no rest parameters \ declaration context \ overload - no codegen impact
            if (!ts.hasRestParameters(node) || ts.isInAmbientContext(node) || !node.body) {
                return;
            }
            ts.forEach(node.parameters, function (p) {
                if (p.name && p.name.text === argumentsSymbol.name) {
                    error(p, ts.Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
                }
            });
        }
        function checkCollisionWithIndexVariableInGeneratedCode(node, name) {
            if (!(name && name.text === "_i")) {
                return;
            }
            if (node.kind === 114 /* Parameter */) {
                // report error if parameter has name '_i' when:
                // - function has implementation (not a signature)
                // - function has rest parameters
                // - context is not ambient (otherwise no codegen impact)
                if (node.parent.body && ts.hasRestParameters(node.parent) && !ts.isInAmbientContext(node)) {
                    error(node, ts.Diagnostics.Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter);
                }
                return;
            }
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol === unknownSymbol) {
                return;
            }
            // we would like to discover cases like one below:
            //
            // var _i = "!";
            // function foo(...a) {
            //    function bar() {
            //        var x = { get baz() { return _i; } }
            //    }
            // }
            //
            // at runtime '_i' referenced in getter will be resolved to the generated index variable '_i' used to initialize rest parameters.
            // legitimate case: when '_i' is defined inside the function declaration with rest parameters.
            //
            // function foo(...a) {
            //    var _i = "!";
            //    function bar() {
            //        var x = { get baz() { return _i; } }
            //    }
            // }
            ////  if resolved symbol for node has more than one declaration - this is definitely an error
            ////  (there is nothing value-like in the language that can be nested in function and consists of multiple declarations)
            //if (symbol.declarations.length > 1) {
            //    error(node, Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);
            //    return;
            //}
            // short gist of the check:
            // - otherwise
            // - walk to the top of the tree starting from the 'node'
            // - at every step check if 'current' node contains any declaration of original node
            //   yes - return
            //   no - check if current declaration is function with rest parameters
            //        yes - report error since '_i' from this function will shadow '_i' defined in the outer scope
            //        no - go up to the next level
            var current = node;
            while (current) {
                var definedOnCurrentLevel = ts.forEach(symbol.declarations, function (d) { return d.parent === current ? d : undefined; });
                if (definedOnCurrentLevel) {
                    return;
                }
                switch (current.kind) {
                    case 167 /* FunctionDeclaration */:
                    case 136 /* FunctionExpression */:
                    case 116 /* Method */:
                    case 137 /* ArrowFunction */:
                    case 117 /* Constructor */:
                        if (ts.hasRestParameters(current)) {
                            error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);
                            return;
                        }
                        break;
                }
                current = current.parent;
            }
        }
        function needCollisionCheckForIdentifier(node, identifier, name) {
            if (!(identifier && identifier.text === name)) {
                return false;
            }
            if (node.kind === 115 /* Property */ || node.kind === 116 /* Method */ || node.kind === 118 /* GetAccessor */ || node.kind === 119 /* SetAccessor */) {
                // it is ok to have member named '_super' or '_this' - member access is always qualified
                return false;
            }
            if (ts.isInAmbientContext(node)) {
                // ambient context - no codegen impact
                return false;
            }
            if (node.kind === 114 /* Parameter */ && !node.parent.body) {
                // just an overload - no codegen impact
                return false;
            }
            return true;
        }
        function checkCollisionWithCapturedThisVariable(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "_this")) {
                return;
            }
            potentialThisCollisions.push(node);
        }
        // this function will run after checking the source file so 'CaptureThis' is correct for all nodes
        function checkIfThisIsCapturedInEnclosingScope(node) {
            var current = node;
            while (current) {
                if (getNodeCheckFlags(current) & 4 /* CaptureThis */) {
                    var isDeclaration = node.kind !== 55 /* Identifier */;
                    if (isDeclaration) {
                        error(node.name, ts.Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                    }
                    return;
                }
                current = current.parent;
            }
        }
        function checkCollisionWithCapturedSuperVariable(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "_super")) {
                return;
            }
            // bubble up and find containing type
            var enclosingClass = getAncestor(node, 169 /* ClassDeclaration */);
            // if containing type was not found or it is ambient - exit (no codegen)
            if (!enclosingClass || ts.isInAmbientContext(enclosingClass)) {
                return;
            }
            if (enclosingClass.baseType) {
                var isDeclaration = node.kind !== 55 /* Identifier */;
                if (isDeclaration) {
                    error(node, ts.Diagnostics.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference);
                }
                else {
                    error(node, ts.Diagnostics.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference);
                }
            }
        }
        function checkVariableDeclaration(node) {
            checkSourceElement(node.type);
            checkExportsOnMergedDeclarations(node);
            if (fullTypeCheck) {
                var symbol = getSymbolOfNode(node);
                var typeOfValueDeclaration = getTypeOfVariableOrParameterOrProperty(symbol);
                var type;
                var useTypeFromValueDeclaration = node === symbol.valueDeclaration;
                if (useTypeFromValueDeclaration) {
                    type = typeOfValueDeclaration;
                }
                else {
                    type = getTypeOfVariableDeclaration(node);
                }
                if (node.initializer) {
                    if (!(getNodeLinks(node.initializer).flags & 1 /* TypeChecked */)) {
                        // Use default messages
                        checkTypeAssignableTo(checkAndMarkExpression(node.initializer), type, node, undefined, undefined);
                    }
                }
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                if (!useTypeFromValueDeclaration) {
                    // TypeScript 1.0 spec (April 2014): 5.1
                    // Multiple declarations for the same variable name in the same declaration space are permitted,
                    // provided that each declaration associates the same type with the variable.
                    if (typeOfValueDeclaration !== unknownType && type !== unknownType && !isTypeIdenticalTo(typeOfValueDeclaration, type)) {
                        error(node.name, ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, ts.identifierToString(node.name), typeToString(typeOfValueDeclaration), typeToString(type));
                    }
                }
            }
        }
        function checkVariableStatement(node) {
            ts.forEach(node.declarations, checkVariableDeclaration);
        }
        function checkExpressionStatement(node) {
            checkExpression(node.expression);
        }
        function checkIfStatement(node) {
            checkExpression(node.expression);
            checkSourceElement(node.thenStatement);
            checkSourceElement(node.elseStatement);
        }
        function checkDoStatement(node) {
            checkSourceElement(node.statement);
            checkExpression(node.expression);
        }
        function checkWhileStatement(node) {
            checkExpression(node.expression);
            checkSourceElement(node.statement);
        }
        function checkForStatement(node) {
            if (node.declarations)
                ts.forEach(node.declarations, checkVariableDeclaration);
            if (node.initializer)
                checkExpression(node.initializer);
            if (node.condition)
                checkExpression(node.condition);
            if (node.iterator)
                checkExpression(node.iterator);
            checkSourceElement(node.statement);
        }
        function checkForInStatement(node) {
            // TypeScript 1.0 spec  (April 2014): 5.4
            // In a 'for-in' statement of the form
            // for (var VarDecl in Expr) Statement
            //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            if (node.declaration) {
                checkVariableDeclaration(node.declaration);
                if (node.declaration.type) {
                    error(node.declaration, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation);
                }
            }
            // In a 'for-in' statement of the form
            // for (Var in Expr) Statement
            //   Var must be an expression classified as a reference of type Any or the String primitive type,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            if (node.variable) {
                var exprType = checkExpression(node.variable);
                if (exprType !== anyType && exprType !== stringType) {
                    error(node.variable, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
                }
                else {
                    // run check only former check succeeded to avoid cascading errors
                    checkReferenceExpression(node.variable, ts.Diagnostics.Invalid_left_hand_side_in_for_in_statement);
                }
            }
            var exprType = checkExpression(node.expression);
            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
            // in this case error about missing name is already reported - do not report extra one
            if (!isTypeAnyTypeObjectTypeOrTypeParameter(exprType) && exprType !== unknownType) {
                error(node.expression, ts.Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            checkSourceElement(node.statement);
        }
        function checkBreakOrContinueStatement(node) {
            // TODO: Check that target label is valid
        }
        function getContainingFunction(node) {
            while (true) {
                node = node.parent;
                if (!node || node.kind === 167 /* FunctionDeclaration */ || node.kind === 136 /* FunctionExpression */ || node.kind === 137 /* ArrowFunction */ || node.kind === 116 /* Method */ || node.kind === 117 /* Constructor */ || node.kind === 118 /* GetAccessor */ || node.kind === 119 /* SetAccessor */) {
                    return node;
                }
            }
        }
        function checkReturnStatement(node) {
            if (node.expression && !(getNodeLinks(node.expression).flags & 1 /* TypeChecked */)) {
                var func = getContainingFunction(node);
                if (func) {
                    if (func.kind === 119 /* SetAccessor */) {
                        if (node.expression) {
                            error(node.expression, ts.Diagnostics.Setters_cannot_return_a_value);
                        }
                    }
                    else {
                        var returnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                        // do assignability check only if we short circuited in determining return type
                        // - function has explicit type annotation
                        // - function is getter with no type annotation and setter parameter type is used
                        // - function is a constructor (will be special cased below)
                        var checkAssignability = func.type || (func.kind === 118 /* GetAccessor */ && getSetAccessorTypeAnnotationNode(getDeclarationOfKind(func.symbol, 119 /* SetAccessor */)));
                        if (checkAssignability) {
                            checkTypeAssignableTo(checkExpression(node.expression), returnType, node.expression, undefined, undefined);
                        }
                        else if (func.kind == 117 /* Constructor */) {
                            // constructor doesn't have explicit return type annontation and yet its return type is known - declaring type
                            // handle constructors and issue specialized error message for them.
                            if (!isTypeAssignableTo(checkExpression(node.expression), returnType)) {
                                error(node.expression, ts.Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                            }
                        }
                    }
                }
            }
        }
        function checkWithStatement(node) {
            checkExpression(node.expression);
            error(node.expression, ts.Diagnostics.All_symbols_within_a_with_block_will_be_resolved_to_any);
        }
        function checkSwitchStatement(node) {
            var expressionType = checkExpression(node.expression);
            ts.forEach(node.clauses, function (clause) {
                if (fullTypeCheck && clause.expression) {
                    // TypeScript 1.0 spec (April 2014):5.9
                    // In a 'switch' statement, each 'case' expression must be of a type that is assignable to or from the type of the 'switch' expression.
                    var caseType = checkExpression(clause.expression);
                    if (!isTypeAssignableTo(expressionType, caseType)) {
                        // check 'expressionType isAssignableTo caseType' failed, try the reversed check and report errors if it fails
                        checkTypeAssignableTo(caseType, expressionType, clause.expression, undefined, undefined);
                    }
                }
                checkBlock(clause);
            });
        }
        function checkLabelledStatement(node) {
            checkSourceElement(node.statement);
        }
        function checkThrowStatement(node) {
            checkExpression(node.expression);
        }
        function checkTryStatement(node) {
            checkBlock(node.tryBlock);
            if (node.catchBlock)
                checkBlock(node.catchBlock);
            if (node.finallyBlock)
                checkBlock(node.finallyBlock);
        }
        function checkIndexConstraints(type) {
            function checkIndexConstraintForProperty(prop, propertyType, indexDeclaration, indexType, indexKind) {
                if (!indexType) {
                    return;
                }
                // index is numeric and property name is not valid numeric literal
                if (indexKind === 1 /* Number */ && !isNumericName(prop.name)) {
                    return;
                }
                // perform property check if property or indexer is declared in 'type'
                // this allows to rule out cases when both property and indexer are inherited from the base class
                var errorNode;
                if (prop.parent === type.symbol) {
                    errorNode = prop.valueDeclaration;
                }
                else if (indexDeclaration) {
                    errorNode = indexDeclaration;
                }
                else if (type.flags & 2048 /* Interface */) {
                    // for interfaces property and indexer might be inherited from different bases
                    // check if any base class already has both property and indexer.
                    // check should be performed only if 'type' is the first type that brings property\indexer together
                    var someBaseClassHasBothPropertyAndIndexer = ts.forEach(type.baseTypes, function (base) { return getPropertyOfType(base, prop.name) && getIndexTypeOfType(base, indexKind); });
                    errorNode = someBaseClassHasBothPropertyAndIndexer ? undefined : type.symbol.declarations[0];
                }
                if (errorNode && !isTypeAssignableTo(propertyType, indexType)) {
                    var errorMessage = indexKind === 0 /* String */ ? ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_string_index_type_2 : ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;
                    error(errorNode, errorMessage, symbolToString(prop), typeToString(propertyType), typeToString(indexType));
                }
            }
            var declaredNumberIndexer = getIndexDeclarationOfSymbol(type.symbol, 1 /* Number */);
            var declaredStringIndexer = getIndexDeclarationOfSymbol(type.symbol, 0 /* String */);
            var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
            var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
            if (stringIndexType || numberIndexType) {
                ts.forEach(getPropertiesOfType(type), function (prop) {
                    var propType = getTypeOfSymbol(prop);
                    checkIndexConstraintForProperty(prop, propType, declaredStringIndexer, stringIndexType, 0 /* String */);
                    checkIndexConstraintForProperty(prop, propType, declaredNumberIndexer, numberIndexType, 1 /* Number */);
                });
            }
            var errorNode;
            if (stringIndexType && numberIndexType) {
                errorNode = declaredNumberIndexer || declaredStringIndexer;
                // condition 'errorNode === undefined' may appear if types does not declare nor string neither number indexer
                if (!errorNode && (type.flags & 2048 /* Interface */)) {
                    var someBaseTypeHasBothIndexers = ts.forEach(type.baseTypes, function (base) { return getIndexTypeOfType(base, 0 /* String */) && getIndexTypeOfType(base, 1 /* Number */); });
                    errorNode = someBaseTypeHasBothIndexers ? undefined : type.symbol.declarations[0];
                }
            }
            if (errorNode && !isTypeAssignableTo(numberIndexType, stringIndexType)) {
                error(errorNode, ts.Diagnostics.Numeric_index_type_0_is_not_assignable_to_string_index_type_1, typeToString(numberIndexType), typeToString(stringIndexType));
            }
        }
        function checkTypeNameIsReserved(name, message) {
            switch (name.text) {
                case "any":
                case "number":
                case "boolean":
                case "string":
                case "void":
                    error(name, message, name.text);
            }
        }
        // Check each type parameter and check that list has no duplicate type parameter declarations
        function checkTypeParameters(typeParameterDeclarations) {
            if (typeParameterDeclarations) {
                for (var i = 0; i < typeParameterDeclarations.length; i++) {
                    var node = typeParameterDeclarations[i];
                    checkTypeParameter(node);
                    if (fullTypeCheck) {
                        for (var j = 0; j < i; j++) {
                            if (typeParameterDeclarations[j].symbol === node.symbol) {
                                error(node.name, ts.Diagnostics.Duplicate_identifier_0, ts.identifierToString(node.name));
                            }
                        }
                    }
                }
            }
        }
        function checkClassDeclaration(node) {
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Class_name_cannot_be_0);
            checkTypeParameters(node.typeParameters);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkExportsOnMergedDeclarations(node);
            var symbol = getSymbolOfNode(node);
            var type = getDeclaredTypeOfSymbol(symbol);
            var staticType = getTypeOfSymbol(symbol);
            if (node.baseType) {
                emitExtends = emitExtends || !ts.isInAmbientContext(node);
                checkTypeReference(node.baseType);
            }
            if (type.baseTypes.length) {
                if (fullTypeCheck) {
                    var baseType = type.baseTypes[0];
                    checkTypeAssignableTo(type, baseType, node.name, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1_Colon, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1);
                    var staticBaseType = getTypeOfSymbol(baseType.symbol);
                    checkTypeAssignableTo(staticType, getTypeWithoutConstructors(staticBaseType), node.name, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1_Colon, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                    if (baseType.symbol !== resolveEntityName(node, node.baseType.typeName, ts.SymbolFlags.Value)) {
                        error(node.baseType, ts.Diagnostics.Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0, typeToString(baseType));
                    }
                    checkKindsOfPropertyMemberOverrides(type, baseType);
                }
                // Check that base type can be evaluated as expression
                checkExpression(node.baseType.typeName);
            }
            if (node.implementedTypes) {
                ts.forEach(node.implementedTypes, function (typeRefNode) {
                    checkTypeReference(typeRefNode);
                    if (fullTypeCheck) {
                        var t = getTypeFromTypeReferenceNode(typeRefNode);
                        if (t !== unknownType) {
                            var declaredType = (t.flags & 4096 /* Reference */) ? t.target : t;
                            if (declaredType.flags & (1024 /* Class */ | 2048 /* Interface */)) {
                                checkTypeAssignableTo(type, t, node.name, ts.Diagnostics.Class_0_incorrectly_implements_interface_1_Colon, ts.Diagnostics.Class_0_incorrectly_implements_interface_1);
                            }
                            else {
                                error(typeRefNode, ts.Diagnostics.A_class_may_only_implement_another_class_or_interface);
                            }
                        }
                    }
                });
            }
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function getTargetSymbol(s) {
            // if symbol is instantiated it's flags are not copied from the 'target'
            // so we'll need to get back original 'target' symbol to work with correct set of flags
            return s.flags & 8388608 /* Instantiated */ ? getSymbolLinks(s).target : s;
        }
        function checkKindsOfPropertyMemberOverrides(type, baseType) {
            // TypeScript 1.0 spec (April 2014): 8.2.3
            // A derived class inherits all members from its base class it doesn't override.
            // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
            // Both public and private property members are inherited, but only public property members can be overridden.
            // A property member in a derived class is said to override a property member in a base class
            // when the derived class property member has the same name and kind(instance or static)
            // as the base class property member.
            // The type of an overriding property member must be assignable(section 3.8.4)
            // to the type of the overridden property member, or otherwise a compile - time error occurs.
            // Base class instance member functions can be overridden by derived class instance member functions,
            // but not by other kinds of members.
            // Base class instance member variables and accessors can be overridden by
            // derived class instance member variables and accessors, but not by other kinds of members.
            // NOTE: assignability is checked in checkClassDeclaration
            var baseProperties = getPropertiesOfType(baseType);
            for (var i = 0, len = baseProperties.length; i < len; ++i) {
                var base = getTargetSymbol(baseProperties[i]);
                if (base.flags & 67108864 /* Prototype */) {
                    continue;
                }
                var derived = getTargetSymbol(getPropertyOfType(type, base.name));
                if (derived) {
                    var baseDeclarationFlags = getDeclarationFlagsFromSymbol(base);
                    var derivedDeclarationFlags = getDeclarationFlagsFromSymbol(derived);
                    if ((baseDeclarationFlags & 32 /* Private */) || (derivedDeclarationFlags & 32 /* Private */)) {
                        continue;
                    }
                    if ((baseDeclarationFlags & 64 /* Static */) !== (derivedDeclarationFlags & 64 /* Static */)) {
                        continue;
                    }
                    if ((base.flags & derived.flags & 2048 /* Method */) || ((base.flags & ts.SymbolFlags.PropertyOrAccessor) && (derived.flags & ts.SymbolFlags.PropertyOrAccessor))) {
                        continue;
                    }
                    var errorMessage;
                    if (base.flags & 2048 /* Method */) {
                        if (derived.flags & ts.SymbolFlags.Accessor) {
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                        }
                        else {
                            ts.Debug.assert(derived.flags & 2 /* Property */);
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                        }
                    }
                    else if (base.flags & 2 /* Property */) {
                        ts.Debug.assert(derived.flags & 2048 /* Method */);
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    else {
                        ts.Debug.assert(base.flags & ts.SymbolFlags.Accessor);
                        ts.Debug.assert(derived.flags & 2048 /* Method */);
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    error(derived.valueDeclaration.name, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
                }
            }
        }
        function isAccessor(kind) {
            return kind === 118 /* GetAccessor */ || kind === 119 /* SetAccessor */;
        }
        function areTypeParametersIdentical(list1, list2) {
            if (!list1 && !list2) {
                return true;
            }
            if (!list1 || !list2 || list1.length !== list2.length) {
                return false;
            }
            for (var i = 0, len = list1.length; i < len; i++) {
                var tp1 = list1[i];
                var tp2 = list2[i];
                if (tp1.name.text !== tp2.name.text) {
                    return false;
                }
                if (!tp1.constraint && !tp2.constraint) {
                    continue;
                }
                if (!tp1.constraint || !tp2.constraint) {
                    return false;
                }
                if (!isTypeIdenticalTo(getTypeFromTypeNode(tp1.constraint), getTypeFromTypeNode(tp2.constraint))) {
                    return false;
                }
            }
            return true;
        }
        function checkInterfaceDeclaration(node) {
            checkTypeParameters(node.typeParameters);
            if (fullTypeCheck) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Interface_name_cannot_be_0);
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                var firstInterfaceDecl = getDeclarationOfKind(symbol, 170 /* InterfaceDeclaration */);
                if (symbol.declarations.length > 1) {
                    if (node !== firstInterfaceDecl && !areTypeParametersIdentical(firstInterfaceDecl.typeParameters, node.typeParameters)) {
                        error(node.name, ts.Diagnostics.All_declarations_of_an_interface_must_have_identical_type_parameters);
                    }
                }
                // Only check this symbol once
                if (node === firstInterfaceDecl) {
                    var type = getDeclaredTypeOfSymbol(symbol);
                    // run subsequent checks only if first set succeeded
                    if (checkInheritedPropertiesAreIdentical(type, node.name)) {
                        ts.forEach(type.baseTypes, function (baseType) {
                            checkTypeAssignableTo(type, baseType, node.name, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1_Colon, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1);
                        });
                        checkIndexConstraints(type);
                    }
                }
            }
            ts.forEach(node.baseTypes, checkTypeReference);
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function getConstantValue(node) {
            var isNegative = false;
            if (node.kind === 138 /* PrefixOperator */) {
                var unaryExpression = node;
                if (unaryExpression.operator === 25 /* MinusToken */ || unaryExpression.operator === 24 /* PlusToken */) {
                    node = unaryExpression.operand;
                    isNegative = unaryExpression.operator === 25 /* MinusToken */;
                }
            }
            if (node.kind === 2 /* NumericLiteral */) {
                var literalText = node.text;
                return isNegative ? -literalText : +literalText;
            }
            return undefined;
        }
        function checkEnumDeclaration(node) {
            if (!fullTypeCheck) {
                return;
            }
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Enum_name_cannot_be_0);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkExportsOnMergedDeclarations(node);
            var enumSymbol = getSymbolOfNode(node);
            var enumType = getDeclaredTypeOfSymbol(enumSymbol);
            var autoValue = 0;
            var ambient = ts.isInAmbientContext(node);
            ts.forEach(node.members, function (member) {
                var initializer = member.initializer;
                if (initializer) {
                    autoValue = getConstantValue(initializer);
                    if (autoValue === undefined && !ambient) {
                        // Only here do we need to check that the initializer is assignable to the enum type.
                        // If it is a constant value (not undefined), it is syntactically constrained to be a number.
                        // Also, we do not need to check this for ambients because there is already
                        // a syntax error if it is not a constant.
                        checkTypeAssignableTo(checkExpression(initializer), enumType, initializer, undefined, undefined);
                    }
                }
                else if (ambient) {
                    autoValue = undefined;
                }
                if (autoValue !== undefined) {
                    getNodeLinks(member).enumMemberValue = autoValue++;
                }
            });
            // Spec 2014 - Section 9.3:
            // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
            // and when an enum type has multiple declarations, only one declaration is permitted to omit a value
            // for the first member.
            //
            // Only perform this check once per symbol
            var firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);
            if (node === firstDeclaration) {
                var seenEnumMissingInitialInitializer = false;
                ts.forEach(enumSymbol.declarations, function (declaration) {
                    // return true if we hit a violation of the rule, false otherwise
                    if (declaration.kind !== 171 /* EnumDeclaration */) {
                        return false;
                    }
                    var enumDeclaration = declaration;
                    if (!enumDeclaration.members.length) {
                        return false;
                    }
                    var firstEnumMember = enumDeclaration.members[0];
                    if (!firstEnumMember.initializer) {
                        if (seenEnumMissingInitialInitializer) {
                            error(firstEnumMember.name, ts.Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                        }
                        else {
                            seenEnumMissingInitialInitializer = true;
                        }
                    }
                });
            }
        }
        function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
            var declarations = symbol.declarations;
            for (var i = 0; i < declarations.length; i++) {
                var declaration = declarations[i];
                if ((declaration.kind === 169 /* ClassDeclaration */ || (declaration.kind === 167 /* FunctionDeclaration */ && declaration.body)) && !ts.isInAmbientContext(declaration)) {
                    return declaration;
                }
            }
            return undefined;
        }
        function checkModuleDeclaration(node) {
            if (fullTypeCheck) {
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                if (symbol.flags & 128 /* ValueModule */ && symbol.declarations.length > 1 && !ts.isInAmbientContext(node)) {
                    var classOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
                    if (classOrFunc) {
                        if (ts.getSourceFileOfNode(node) !== ts.getSourceFileOfNode(classOrFunc)) {
                            error(node.name, ts.Diagnostics.A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                        }
                        else if (node.pos < classOrFunc.pos) {
                            error(node.name, ts.Diagnostics.A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                        }
                    }
                }
                if (node.name.kind === 3 /* StringLiteral */) {
                    if (!isGlobalSourceFile(node.parent)) {
                        error(node.name, ts.Diagnostics.Ambient_external_modules_cannot_be_nested_in_other_modules);
                    }
                    if (isExternalModuleNameRelative(node.name.text)) {
                        error(node.name, ts.Diagnostics.Ambient_external_module_declaration_cannot_specify_relative_module_name);
                    }
                }
            }
            checkSourceElement(node.body);
        }
        function getFirstIdentifier(node) {
            while (node.kind === 112 /* QualifiedName */) {
                node = node.left;
            }
            return node;
        }
        function checkImportDeclaration(node) {
            checkCollisionWithCapturedThisVariable(node, node.name);
            var symbol = getSymbolOfNode(node);
            var target;
            if (node.entityName) {
                target = resolveImport(symbol);
                // Import declaration for an internal module
                if (target !== unknownSymbol) {
                    if (target.flags & ts.SymbolFlags.Value) {
                        // Target is a value symbol, check that it is not hidden by a local declaration with the same name and
                        // ensure it can be evaluated as an expression
                        var moduleName = getFirstIdentifier(node.entityName);
                        if (resolveEntityName(node, moduleName, ts.SymbolFlags.Value | ts.SymbolFlags.Namespace).flags & ts.SymbolFlags.Namespace) {
                            checkExpression(node.entityName);
                        }
                        else {
                            error(moduleName, ts.Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, ts.identifierToString(moduleName));
                        }
                    }
                    if (target.flags & ts.SymbolFlags.Type) {
                        checkTypeNameIsReserved(node.name, ts.Diagnostics.Import_name_cannot_be_0);
                    }
                }
            }
            else {
                // Import declaration for an external module
                if (node.parent.kind === 177 /* SourceFile */) {
                    target = resolveImport(symbol);
                }
                else if (node.parent.kind === 173 /* ModuleBlock */ && node.parent.parent.name.kind === 3 /* StringLiteral */) {
                    // TypeScript 1.0 spec (April 2013): 12.1.6
                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference
                    // other external modules only through top - level external module names.
                    // Relative external module names are not permitted.
                    if (isExternalModuleNameRelative(node.externalModuleName.text)) {
                        error(node, ts.Diagnostics.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name);
                        target = unknownSymbol;
                    }
                    else {
                        target = resolveImport(symbol);
                    }
                }
                else {
                    // Parent is an internal module (syntax error is already reported)
                    target = unknownSymbol;
                }
            }
            if (target !== unknownSymbol) {
                var excludedMeanings = (symbol.flags & ts.SymbolFlags.Value ? ts.SymbolFlags.Value : 0) | (symbol.flags & ts.SymbolFlags.Type ? ts.SymbolFlags.Type : 0) | (symbol.flags & ts.SymbolFlags.Namespace ? ts.SymbolFlags.Namespace : 0);
                if (target.flags & excludedMeanings) {
                    error(node, ts.Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0, symbolToString(symbol));
                }
            }
        }
        function checkExportAssignment(node) {
            var container = node.parent;
            if (container.kind !== 177 /* SourceFile */) {
                // In a module, the immediate parent will be a block, so climb up one more parent
                container = container.parent;
            }
            checkTypeOfExportAssignmentSymbol(getSymbolOfNode(container));
        }
        function checkSourceElement(node) {
            if (!node)
                return;
            switch (node.kind) {
                case 113 /* TypeParameter */:
                    return checkTypeParameter(node);
                case 114 /* Parameter */:
                    return checkParameter(node);
                case 115 /* Property */:
                    return checkPropertyDeclaration(node);
                case 120 /* CallSignature */:
                case 121 /* ConstructSignature */:
                case 122 /* IndexSignature */:
                    return checkSignatureDeclaration(node);
                case 116 /* Method */:
                    return checkMethodDeclaration(node);
                case 117 /* Constructor */:
                    return checkConstructorDeclaration(node);
                case 118 /* GetAccessor */:
                case 119 /* SetAccessor */:
                    return checkAccessorDeclaration(node);
                case 123 /* TypeReference */:
                    return checkTypeReference(node);
                case 124 /* TypeQuery */:
                    return checkTypeQuery(node);
                case 125 /* TypeLiteral */:
                    return checkTypeLiteral(node);
                case 126 /* ArrayType */:
                    return checkArrayType(node);
                case 167 /* FunctionDeclaration */:
                    return checkFunctionDeclaration(node);
                case 143 /* Block */:
                case 168 /* FunctionBlock */:
                case 173 /* ModuleBlock */:
                    return checkBlock(node);
                case 144 /* VariableStatement */:
                    return checkVariableStatement(node);
                case 146 /* ExpressionStatement */:
                    return checkExpressionStatement(node);
                case 147 /* IfStatement */:
                    return checkIfStatement(node);
                case 148 /* DoStatement */:
                    return checkDoStatement(node);
                case 149 /* WhileStatement */:
                    return checkWhileStatement(node);
                case 150 /* ForStatement */:
                    return checkForStatement(node);
                case 151 /* ForInStatement */:
                    return checkForInStatement(node);
                case 152 /* ContinueStatement */:
                case 153 /* BreakStatement */:
                    return checkBreakOrContinueStatement(node);
                case 154 /* ReturnStatement */:
                    return checkReturnStatement(node);
                case 155 /* WithStatement */:
                    return checkWithStatement(node);
                case 156 /* SwitchStatement */:
                    return checkSwitchStatement(node);
                case 159 /* LabelledStatement */:
                    return checkLabelledStatement(node);
                case 160 /* ThrowStatement */:
                    return checkThrowStatement(node);
                case 161 /* TryStatement */:
                    return checkTryStatement(node);
                case 166 /* VariableDeclaration */:
                    return ts.Debug.fail("Checker encountered variable declaration");
                case 169 /* ClassDeclaration */:
                    return checkClassDeclaration(node);
                case 170 /* InterfaceDeclaration */:
                    return checkInterfaceDeclaration(node);
                case 171 /* EnumDeclaration */:
                    return checkEnumDeclaration(node);
                case 172 /* ModuleDeclaration */:
                    return checkModuleDeclaration(node);
                case 174 /* ImportDeclaration */:
                    return checkImportDeclaration(node);
                case 175 /* ExportAssignment */:
                    return checkExportAssignment(node);
            }
        }
        // Fully type check a source file and collect the relevant diagnostics.
        function checkSourceFile(node) {
            var links = getNodeLinks(node);
            if (!(links.flags & 1 /* TypeChecked */)) {
                emitExtends = false;
                potentialThisCollisions.length = 0;
                ts.forEach(node.statements, checkSourceElement);
                if (ts.isExternalModule(node)) {
                    var symbol = getExportAssignmentSymbol(node.symbol);
                    if (symbol && symbol.flags & 4194304 /* Import */) {
                        // Mark the import as referenced so that we emit it in the final .js file.
                        getSymbolLinks(symbol).referenced = true;
                    }
                }
                if (potentialThisCollisions.length) {
                    ts.forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
                    potentialThisCollisions.length = 0;
                }
                if (emitExtends)
                    links.flags |= 8 /* EmitExtends */;
                links.flags |= 1 /* TypeChecked */;
            }
        }
        function checkProgram() {
            ts.forEach(program.getSourceFiles(), checkSourceFile);
        }
        function getSortedDiagnostics() {
            ts.Debug.assert(fullTypeCheck, "diagnostics are available only in the full typecheck mode");
            if (diagnosticsModified) {
                diagnostics.sort(ts.compareDiagnostics);
                diagnostics = ts.deduplicateSortedDiagnostics(diagnostics);
                diagnosticsModified = false;
            }
            return diagnostics;
        }
        function getDiagnostics(sourceFile) {
            if (sourceFile) {
                checkSourceFile(sourceFile);
                return ts.filter(getSortedDiagnostics(), function (d) { return d.file === sourceFile; });
            }
            checkProgram();
            return getSortedDiagnostics();
        }
        function getGlobalDiagnostics() {
            return ts.filter(getSortedDiagnostics(), function (d) { return !d.file; });
        }
        // Language service support
        function getNodeAtPosition(sourceFile, position) {
            function findChildAtPosition(parent) {
                var child = ts.forEachChild(parent, function (node) {
                    if (position >= node.pos && position <= node.end && position >= ts.getTokenPosOfNode(node)) {
                        return findChildAtPosition(node);
                    }
                });
                return child || parent;
            }
            if (position < sourceFile.pos)
                position = sourceFile.pos;
            if (position > sourceFile.end)
                position = sourceFile.end;
            return findChildAtPosition(sourceFile);
        }
        function getSymbolsInScope(location, meaning) {
            var symbols = {};
            var memberFlags = 0;
            function copySymbol(symbol, meaning) {
                if (symbol.flags & meaning) {
                    var id = symbol.name;
                    if (!isReservedMemberName(id) && !ts.hasProperty(symbols, id)) {
                        symbols[id] = symbol;
                    }
                }
            }
            function copySymbols(source, meaning) {
                if (meaning) {
                    for (var id in source) {
                        if (ts.hasProperty(source, id)) {
                            copySymbol(source[id], meaning);
                        }
                    }
                }
            }
            while (location) {
                if (location.locals && !isGlobalSourceFile(location)) {
                    copySymbols(location.locals, meaning);
                }
                switch (location.kind) {
                    case 177 /* SourceFile */:
                        if (!ts.isExternalModule(location))
                            break;
                    case 172 /* ModuleDeclaration */:
                        copySymbols(getSymbolOfNode(location).exports, meaning & ts.SymbolFlags.ModuleMember);
                        break;
                    case 171 /* EnumDeclaration */:
                        copySymbols(getSymbolOfNode(location).exports, meaning & 4 /* EnumMember */);
                        break;
                    case 169 /* ClassDeclaration */:
                    case 170 /* InterfaceDeclaration */:
                        if (!(memberFlags & 64 /* Static */)) {
                            copySymbols(getSymbolOfNode(location).members, meaning & ts.SymbolFlags.Type);
                        }
                        break;
                    case 136 /* FunctionExpression */:
                        if (location.name) {
                            copySymbol(location.symbol, meaning);
                        }
                        break;
                    case 163 /* CatchBlock */:
                        if (location.variable.text) {
                            copySymbol(location.symbol, meaning);
                        }
                        break;
                }
                memberFlags = location.flags;
                location = location.parent;
            }
            copySymbols(globals, meaning);
            return ts.mapToArray(symbols);
        }
        // True if the given identifier is the name of a type declaration node (class, interface, enum, type parameter, etc)
        function isTypeDeclarationName(name) {
            return name.kind == 55 /* Identifier */ && isTypeDeclaration(name.parent) && name.parent.name === name;
        }
        // True if the given identifier, string literal, or number literal is the name of a declaration node
        function isDeclarationOrFunctionExpressionOrCatchVariableName(name) {
            if (name.kind !== 55 /* Identifier */ && name.kind !== 3 /* StringLiteral */ && name.kind !== 2 /* NumericLiteral */) {
                return false;
            }
            var parent = name.parent;
            if (isDeclaration(parent) || parent.kind === 136 /* FunctionExpression */) {
                return parent.name === name;
            }
            if (parent.kind === 163 /* CatchBlock */) {
                return parent.variable === name;
            }
            return false;
        }
        function isTypeDeclaration(node) {
            switch (node.kind) {
                case 113 /* TypeParameter */:
                case 169 /* ClassDeclaration */:
                case 170 /* InterfaceDeclaration */:
                case 171 /* EnumDeclaration */:
                    return true;
            }
        }
        function isDeclaration(node) {
            switch (node.kind) {
                case 113 /* TypeParameter */:
                case 114 /* Parameter */:
                case 166 /* VariableDeclaration */:
                case 115 /* Property */:
                case 129 /* PropertyAssignment */:
                case 176 /* EnumMember */:
                case 116 /* Method */:
                case 167 /* FunctionDeclaration */:
                case 118 /* GetAccessor */:
                case 119 /* SetAccessor */:
                case 169 /* ClassDeclaration */:
                case 170 /* InterfaceDeclaration */:
                case 171 /* EnumDeclaration */:
                case 172 /* ModuleDeclaration */:
                case 174 /* ImportDeclaration */:
                    return true;
            }
            return false;
        }
        // True if the given identifier is part of a type reference
        function isTypeReferenceIdentifier(entityName) {
            var node = entityName;
            while (node.parent && node.parent.kind === 112 /* QualifiedName */)
                node = node.parent;
            return node.parent && node.parent.kind === 123 /* TypeReference */;
        }
        function isExpression(node) {
            switch (node.kind) {
                case 83 /* ThisKeyword */:
                case 81 /* SuperKeyword */:
                case 79 /* NullKeyword */:
                case 85 /* TrueKeyword */:
                case 70 /* FalseKeyword */:
                case 4 /* RegularExpressionLiteral */:
                case 127 /* ArrayLiteral */:
                case 128 /* ObjectLiteral */:
                case 130 /* PropertyAccess */:
                case 131 /* IndexedAccess */:
                case 132 /* CallExpression */:
                case 133 /* NewExpression */:
                case 134 /* TypeAssertion */:
                case 135 /* ParenExpression */:
                case 136 /* FunctionExpression */:
                case 137 /* ArrowFunction */:
                case 138 /* PrefixOperator */:
                case 139 /* PostfixOperator */:
                case 140 /* BinaryExpression */:
                case 141 /* ConditionalExpression */:
                case 142 /* OmittedExpression */:
                    return true;
                case 112 /* QualifiedName */:
                    while (node.parent.kind === 112 /* QualifiedName */)
                        node = node.parent;
                    return node.parent.kind === 124 /* TypeQuery */;
                case 55 /* Identifier */:
                    if (node.parent.kind === 124 /* TypeQuery */) {
                        return true;
                    }
                case 2 /* NumericLiteral */:
                case 3 /* StringLiteral */:
                    var parent = node.parent;
                    switch (parent.kind) {
                        case 166 /* VariableDeclaration */:
                        case 114 /* Parameter */:
                        case 115 /* Property */:
                        case 176 /* EnumMember */:
                            return parent.initializer === node;
                        case 146 /* ExpressionStatement */:
                        case 147 /* IfStatement */:
                        case 148 /* DoStatement */:
                        case 149 /* WhileStatement */:
                        case 154 /* ReturnStatement */:
                        case 155 /* WithStatement */:
                        case 156 /* SwitchStatement */:
                        case 157 /* CaseClause */:
                        case 160 /* ThrowStatement */:
                        case 156 /* SwitchStatement */:
                            return parent.expression === node;
                        case 150 /* ForStatement */:
                            return parent.initializer === node || parent.condition === node || parent.iterator === node;
                        case 151 /* ForInStatement */:
                            return parent.variable === node || parent.expression === node;
                        case 134 /* TypeAssertion */:
                            return node === parent.operand;
                        default:
                            if (isExpression(parent)) {
                                return true;
                            }
                    }
            }
            return false;
        }
        function isTypeNode(node) {
            if (node.kind >= ts.SyntaxKind.FirstTypeNode && node.kind <= ts.SyntaxKind.LastTypeNode) {
                return true;
            }
            switch (node.kind) {
                case 101 /* AnyKeyword */:
                case 108 /* NumberKeyword */:
                case 110 /* StringKeyword */:
                case 102 /* BooleanKeyword */:
                    return true;
                case 89 /* VoidKeyword */:
                    return node.parent.kind !== 138 /* PrefixOperator */;
                case 3 /* StringLiteral */:
                    // Specialized signatures can have string literals as their parameters' type names
                    return node.parent.kind === 114 /* Parameter */;
                case 55 /* Identifier */:
                    // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.
                    if (node.parent.kind === 112 /* QualifiedName */) {
                        node = node.parent;
                    }
                case 112 /* QualifiedName */:
                    // At this point, node is either a qualified name or an identifier
                    var parent = node.parent;
                    if (parent.kind === 124 /* TypeQuery */) {
                        return false;
                    }
                    // Do not recursively call isTypeNode on the parent. In the example:
                    //
                    //     var a: A.B.C;
                    //
                    // Calling isTypeNode would consider the qualified name A.B a type node. Only C or
                    // A.B.C is a type node.
                    if (parent.kind >= ts.SyntaxKind.FirstTypeNode && parent.kind <= ts.SyntaxKind.LastTypeNode) {
                        return true;
                    }
                    switch (parent.kind) {
                        case 113 /* TypeParameter */:
                            return node === parent.constraint;
                        case 115 /* Property */:
                        case 114 /* Parameter */:
                        case 166 /* VariableDeclaration */:
                            return node === parent.type;
                        case 167 /* FunctionDeclaration */:
                        case 136 /* FunctionExpression */:
                        case 137 /* ArrowFunction */:
                        case 117 /* Constructor */:
                        case 116 /* Method */:
                        case 118 /* GetAccessor */:
                        case 119 /* SetAccessor */:
                            return node === parent.type;
                        case 120 /* CallSignature */:
                        case 121 /* ConstructSignature */:
                        case 122 /* IndexSignature */:
                            return node === parent.type;
                        case 134 /* TypeAssertion */:
                            return node === parent.type;
                        case 132 /* CallExpression */:
                        case 133 /* NewExpression */:
                            return parent.typeArguments.indexOf(node) >= 0;
                    }
            }
            return false;
        }
        function isInRightSideOfImportOrExportAssignment(node) {
            while (node.parent.kind === 112 /* QualifiedName */) {
                node = node.parent;
            }
            if (node.parent.kind === 174 /* ImportDeclaration */) {
                return node.parent.entityName === node;
            }
            if (node.parent.kind === 175 /* ExportAssignment */) {
                return node.parent.exportName === node;
            }
            return false;
        }
        function isRightSideOfQualifiedNameOrPropertyAccess(node) {
            return (node.parent.kind === 112 /* QualifiedName */ || node.parent.kind === 130 /* PropertyAccess */) && node.parent.right === node;
        }
        function getSymbolOfEntityName(entityName) {
            if (isDeclarationOrFunctionExpressionOrCatchVariableName(entityName)) {
                return getSymbolOfNode(entityName.parent);
            }
            if (entityName.parent.kind === 175 /* ExportAssignment */) {
                return resolveEntityName(entityName.parent.parent, entityName, ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace | 4194304 /* Import */);
            }
            if (isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            if (isExpression(entityName)) {
                if (entityName.kind === 55 /* Identifier */) {
                    // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead
                    // return the alias symbol.
                    var meaning = ts.SymbolFlags.Value | 4194304 /* Import */;
                    return resolveEntityName(entityName, entityName, meaning);
                }
                else if (entityName.kind === 112 /* QualifiedName */ || entityName.kind === 130 /* PropertyAccess */) {
                    var symbol = getNodeLinks(entityName).resolvedSymbol;
                    if (!symbol) {
                        checkPropertyAccess(entityName);
                    }
                    return getNodeLinks(entityName).resolvedSymbol;
                }
                else {
                    // Missing identifier
                    return;
                }
            }
            else if (isTypeReferenceIdentifier(entityName)) {
                var meaning = entityName.parent.kind === 123 /* TypeReference */ ? ts.SymbolFlags.Type : ts.SymbolFlags.Namespace;
                // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead
                // return the alias symbol.
                meaning |= 4194304 /* Import */;
                return resolveEntityName(entityName, entityName, meaning);
            }
            // Do we want to return undefined here?
            return undefined;
        }
        function getSymbolInfo(node) {
            switch (node.kind) {
                case 55 /* Identifier */:
                case 130 /* PropertyAccess */:
                case 112 /* QualifiedName */:
                    return getSymbolOfEntityName(node);
                case 83 /* ThisKeyword */:
                case 81 /* SuperKeyword */:
                    var type = checkExpression(node);
                    return type.symbol;
                case 103 /* ConstructorKeyword */:
                    // constructor keyword for an overload, should take us to the definition if it exist
                    var constructorDeclaration = node.parent;
                    if (constructorDeclaration && constructorDeclaration.kind === 117 /* Constructor */) {
                        return constructorDeclaration.parent.symbol;
                    }
                    return undefined;
                case 3 /* StringLiteral */:
                    // Property access
                    if (node.parent.kind === 131 /* IndexedAccess */ && node.parent.index === node) {
                        var objectType = checkExpression(node.parent.object);
                        if (objectType === unknownType)
                            return undefined;
                        var apparentType = getApparentType(objectType);
                        if (apparentType === unknownType)
                            return undefined;
                        return getPropertyOfApparentType(apparentType, node.text);
                    }
                    else if (node.parent.kind === 174 /* ImportDeclaration */ && node.parent.externalModuleName === node) {
                        var importSymbol = getSymbolOfNode(node.parent);
                        var moduleType = getTypeOfSymbol(importSymbol);
                        return moduleType ? moduleType.symbol : undefined;
                    }
                    else if (node.parent.kind === 172 /* ModuleDeclaration */) {
                        return getSymbolOfNode(node.parent);
                    }
                    break;
            }
            return undefined;
        }
        function getTypeOfNode(node) {
            if (isExpression(node)) {
                return getTypeOfExpression(node);
            }
            if (isTypeNode(node)) {
                return getTypeFromTypeNode(node);
            }
            if (isTypeDeclaration(node)) {
                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration
                var symbol = getSymbolOfNode(node);
                return getDeclaredTypeOfSymbol(symbol);
            }
            if (isTypeDeclarationName(node)) {
                var symbol = getSymbolInfo(node);
                return getDeclaredTypeOfSymbol(symbol);
            }
            if (isDeclaration(node)) {
                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration
                var symbol = getSymbolOfNode(node);
                return getTypeOfSymbol(symbol);
            }
            if (isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                var symbol = getSymbolInfo(node);
                return getTypeOfSymbol(symbol);
            }
            if (isInRightSideOfImportOrExportAssignment(node)) {
                var symbol;
                symbol = node.parent.kind === 175 /* ExportAssignment */ ? getSymbolInfo(node) : getSymbolOfPartOfRightHandSideOfImport(node);
                var declaredType = getDeclaredTypeOfSymbol(symbol);
                return declaredType !== unknownType ? declaredType : getTypeOfSymbol(symbol);
            }
            return unknownType;
        }
        function getTypeOfExpression(expr) {
            if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
                expr = expr.parent;
            }
            return checkExpression(expr);
        }
        function getAugmentedPropertiesOfApparentType(type) {
            var apparentType = getApparentType(type);
            if (apparentType.flags & ts.TypeFlags.ObjectType) {
                // Augment the apprent type with Function and Object memeber as applicaple
                var propertiesByName = {};
                var results = [];
                ts.forEach(getPropertiesOfType(apparentType), function (s) {
                    propertiesByName[s.name] = s;
                    results.push(s);
                });
                var resolved = resolveObjectTypeMembers(type);
                ts.forEachValue(resolved.members, function (s) {
                    if (symbolIsValue(s) && !propertiesByName[s.name]) {
                        propertiesByName[s.name] = s;
                        results.push(s);
                    }
                });
                if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {
                    ts.forEach(getPropertiesOfType(globalFunctionType), function (s) {
                        if (!propertiesByName[s.name]) {
                            propertiesByName[s.name] = s;
                            results.push(s);
                        }
                    });
                }
                return results;
            }
            else {
                return getPropertiesOfType(apparentType);
            }
        }
        // Emitter support
        function isExternalModuleSymbol(symbol) {
            return symbol.flags & 128 /* ValueModule */ && symbol.declarations.length === 1 && symbol.declarations[0].kind === 177 /* SourceFile */;
        }
        function isNodeDescendentOf(node, ancestor) {
            while (node) {
                if (node === ancestor)
                    return true;
                node = node.parent;
            }
            return false;
        }
        function isUniqueLocalName(name, container) {
            for (var node = container; isNodeDescendentOf(node, container); node = node.nextContainer) {
                if (node.locals && ts.hasProperty(node.locals, name) && node.locals[name].flags & (ts.SymbolFlags.Value | 524288 /* ExportValue */)) {
                    return false;
                }
            }
            return true;
        }
        function getLocalNameOfContainer(container) {
            var links = getNodeLinks(container);
            if (!links.localModuleName) {
                var prefix = "";
                var name = ts.unescapeIdentifier(container.name.text);
                while (!isUniqueLocalName(ts.escapeIdentifier(prefix + name), container)) {
                    prefix += "_";
                }
                links.localModuleName = prefix + ts.getSourceTextOfNode(container.name);
            }
            return links.localModuleName;
        }
        function getLocalNameForSymbol(symbol, location) {
            var node = location;
            while (node) {
                if ((node.kind === 172 /* ModuleDeclaration */ || node.kind === 171 /* EnumDeclaration */) && getSymbolOfNode(node) === symbol) {
                    return getLocalNameOfContainer(node);
                }
                node = node.parent;
            }
            ts.Debug.fail("getLocalNameForSymbol failed");
        }
        function getExpressionNamePrefix(node) {
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                // In general, we need to prefix an identifier with its parent name if it references
                // an exported entity from another module declaration. If we reference an exported
                // entity within the same module declaration, then whether we prefix depends on the
                // kind of entity. SymbolFlags.ExportHasLocal encompasses all the kinds that we
                // do NOT prefix.
                var exportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
                if (symbol !== exportSymbol && !(exportSymbol.flags & ts.SymbolFlags.ExportHasLocal)) {
                    symbol = exportSymbol;
                }
                if (symbol.parent) {
                    return isExternalModuleSymbol(symbol.parent) ? "exports" : getLocalNameForSymbol(getParentOfSymbol(symbol), node.parent);
                }
            }
        }
        function getPropertyAccessSubstitution(node) {
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol && (symbol.flags & 4 /* EnumMember */)) {
                var declaration = symbol.valueDeclaration;
                var constantValue;
                if (declaration.kind === 176 /* EnumMember */ && (constantValue = getNodeLinks(declaration).enumMemberValue) !== undefined) {
                    return constantValue.toString() + " /* " + ts.identifierToString(declaration.name) + " */";
                }
            }
        }
        function getExportAssignmentName(node) {
            var symbol = getExportAssignmentSymbol(getSymbolOfNode(node));
            return symbol && symbolIsValue(symbol) ? symbolToString(symbol) : undefined;
        }
        function isTopLevelValueImportedViaEntityName(node) {
            if (node.parent.kind !== 177 /* SourceFile */ || !node.entityName) {
                // parent is not source file or it is not reference to internal module
                return false;
            }
            var symbol = getSymbolOfNode(node);
            var target = resolveImport(symbol);
            return target !== unknownSymbol && ((target.flags & ts.SymbolFlags.Value) !== 0);
        }
        function shouldEmitDeclarations() {
            // If the declaration emit and there are no errors being reported in program or by checker
            // declarations can be emitted
            return program.getCompilerOptions().declaration && !program.getDiagnostics().length && !getDiagnostics().length;
        }
        function isReferencedImportDeclaration(node) {
            var symbol = getSymbolOfNode(node);
            if (getSymbolLinks(symbol).referenced) {
                return true;
            }
            // logic below will answer 'true' for exported import declaration in a nested module that itself is not exported.
            // As a consequence this might cause emitting extra.
            if (node.flags & 1 /* Export */) {
                var target = resolveImport(symbol);
                if (target !== unknownSymbol && target.flags & ts.SymbolFlags.Value) {
                    return true;
                }
            }
            return false;
        }
        function isImplementationOfOverload(node) {
            if (node.body) {
                var symbol = getSymbolOfNode(node);
                return getSignaturesOfSymbol(symbol).length > 1;
            }
            return false;
        }
        function getNodeCheckFlags(node) {
            return getNodeLinks(node).flags;
        }
        function getEnumMemberValue(node) {
            return getNodeLinks(node).enumMemberValue;
        }
        function writeTypeAtLocation(location, enclosingDeclaration, flags, writer) {
            // Get type of the symbol if this is the valid symbol otherwise get type at location
            var symbol = getSymbolOfNode(location);
            var type = symbol && !(symbol.flags & 512 /* TypeLiteral */) ? getTypeOfSymbol(symbol) : getTypeFromTypeNode(location);
            writeTypeToTextWriter(type, enclosingDeclaration, flags, writer);
        }
        function writeReturnTypeOfSignatureDeclaration(signatureDeclaration, enclosingDeclaration, flags, writer) {
            var signature = getSignatureFromDeclaration(signatureDeclaration);
            writeTypeToTextWriter(getReturnTypeOfSignature(signature), enclosingDeclaration, flags, writer);
        }
        function invokeEmitter() {
            var resolver = {
                getProgram: function () { return program; },
                getLocalNameOfContainer: getLocalNameOfContainer,
                getExpressionNamePrefix: getExpressionNamePrefix,
                getPropertyAccessSubstitution: getPropertyAccessSubstitution,
                getExportAssignmentName: getExportAssignmentName,
                isReferencedImportDeclaration: isReferencedImportDeclaration,
                getNodeCheckFlags: getNodeCheckFlags,
                getEnumMemberValue: getEnumMemberValue,
                isTopLevelValueImportedViaEntityName: isTopLevelValueImportedViaEntityName,
                shouldEmitDeclarations: shouldEmitDeclarations,
                isDeclarationVisible: isDeclarationVisible,
                isImplementationOfOverload: isImplementationOfOverload,
                writeTypeAtLocation: writeTypeAtLocation,
                writeReturnTypeOfSignatureDeclaration: writeReturnTypeOfSignatureDeclaration,
                writeSymbol: writeSymbolToTextWriter,
                isSymbolAccessible: isSymbolAccessible,
                isImportDeclarationEntityNameReferenceDeclarationVisibile: isImportDeclarationEntityNameReferenceDeclarationVisibile
            };
            checkProgram();
            return ts.emitFiles(resolver);
        }
        function initializeTypeChecker() {
            // Bind all source files and propagate errors
            ts.forEach(program.getSourceFiles(), function (file) {
                ts.bindSourceFile(file);
                ts.forEach(file.semanticErrors, addDiagnostic);
            });
            // Initialize global symbol table
            ts.forEach(program.getSourceFiles(), function (file) {
                if (!ts.isExternalModule(file)) {
                    extendSymbolTable(globals, file.locals);
                }
            });
            // Initialize special symbols
            getSymbolLinks(undefinedSymbol).type = undefinedType;
            getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments");
            getSymbolLinks(unknownSymbol).type = unknownType;
            globals[undefinedSymbol.name] = undefinedSymbol;
            // Initialize special types
            globalArraySymbol = getGlobalSymbol("Array");
            globalArrayType = getTypeOfGlobalSymbol(globalArraySymbol, 1);
            globalObjectType = getGlobalType("Object");
            globalFunctionType = getGlobalType("Function");
            globalStringType = getGlobalType("String");
            globalNumberType = getGlobalType("Number");
            globalBooleanType = getGlobalType("Boolean");
            globalRegExpType = getGlobalType("RegExp");
        }
        initializeTypeChecker();
        return checker;
    }
    ts.createTypeChecker = createTypeChecker;
})(ts || (ts = {}));
/// <reference path="..\..\src\compiler\core.ts"/>
/// <reference path="..\..\src\compiler\types.ts"/>
/// <reference path="..\..\src\compiler\scanner.ts"/>
/// <reference path="..\..\src\compiler\parser.ts"/>
/// <reference path="..\..\src\compiler\binder.ts"/>
/// <reference path="..\..\src\compiler\checker.ts"/>
/// <reference path="..\..\src\compiler\emitter.ts"/>
var program = ts.createProgram(["lib.d.ts", "compiler.ts"], {
    noResolve: true,
    out: "compiler.js",
    removeComments: true,
    target: 0 /* ES3 */
}, {
    getSourceFile: function (filename, languageVersion) {
        var source;
        if (filename === "lib.d.ts")
            source = librarySources;
        else if (filename === "compiler.ts")
            source = compilerSources;
        else
            console.error("Unexpected read file request: " + filename);
        return ts.createSourceFile(filename, source, languageVersion, "0");
    },
    writeFile: function (filename, data, writeByteOrderMark) {
        if (filename !== "compiler.js")
            console.error("Unexpected write file request: " + filename);
        // console.log(data);
    },
    getDefaultLibFilename: function () { return "lib.d.ts"; },
    getCurrentDirectory: function () { return ""; },
    getCanonicalFileName: function (filename) { return filename; },
    useCaseSensitiveFileNames: function () { return false; },
    getNewLine: function () { return "\r\n"; }
});
var errors = program.getDiagnostics();
if (errors.length)
    console.error("Unexpected syntax errors.");
var checker = program.getTypeChecker(true);
var semanticErrors = checker.getDiagnostics();
if (semanticErrors.length)
    console.error("Unexpected semantic errors.");
var emitErrors = checker.emitFiles().errors;
if (emitErrors.length)
    console.error("Unexpected emit errors.");

var endTime = Date.now();
console.log("### TIME: " + (endTime - startTime) + " ms");
