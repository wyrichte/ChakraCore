/********************************************************
*                                                       *
*   Copyright (C) Microsoft. All rights reserved.       *
*                                                       *
********************************************************/

#define HeapNew(T, ...) AllocatorNew(HeapAllocator, &HeapAllocator::Instance, T, __VA_ARGS__)
#define HeapNewZ(T, ...) AllocatorNewZ(HeapAllocator, &HeapAllocator::Instance, T, __VA_ARGS__)
#define HeapNewPlus(size, T, ...) AllocatorNewPlus(HeapAllocator, &HeapAllocator::Instance, size, T, __VA_ARGS__)
#define HeapNewPlusZ(size, T, ...) AllocatorNewPlusZ(HeapAllocator, &HeapAllocator::Instance, size, T, __VA_ARGS__)
#define HeapNewStruct(T) AllocatorNewStruct(HeapAllocator, &HeapAllocator::Instance, T);
#define HeapNewStructZ(T) AllocatorNewStructZ(HeapAllocator, &HeapAllocator::Instance, T);
#define HeapNewStructPlus(size, T, ...) AllocatorNewStructPlus(HeapAllocator, &HeapAllocator::Instance, size, T)
#define HeapNewStructPlusZ(size, T, ...) AllocatorNewStructPlusZ(HeapAllocator, &HeapAllocator::Instance, size, T)
#define HeapNewArray(T, count, ...) AllocatorNewArray(HeapAllocator, &HeapAllocator::Instance, T, count)
#define HeapNewArrayZ(T, count, ...) AllocatorNewArrayZ(HeapAllocator, &HeapAllocator::Instance, T, count)
#define HeapDelete(obj) AllocatorDelete(HeapAllocator, &HeapAllocator::Instance, obj)
#define HeapDeletePlus(size, obj) AllocatorDeletePlus(HeapAllocator, &HeapAllocator::Instance, size, obj)
#define HeapDeletePlusPrefix(size, obj) AllocatorDeletePlusPrefix(HeapAllocator, &HeapAllocator::Instance, size, obj)
#define HeapDeleteArray(count, obj) AllocatorDeleteArray(HeapAllocator, &HeapAllocator::Instance, count, obj)


#define HeapNewNoThrow(T, ...) AllocatorNewNoThrow(HeapAllocator, &HeapAllocator::Instance, T, __VA_ARGS__)
#define HeapNewNoThrowZ(T, ...) AllocatorNewNoThrowZ(HeapAllocator, &HeapAllocator::Instance, T, __VA_ARGS__)
#define HeapNewNoThrowPlus(size, T, ...) AllocatorNewNoThrowPlus(HeapAllocator, &HeapAllocator::Instance, size, T, __VA_ARGS__)
#define HeapNewNoThrowPlusZ(size, T, ...) AllocatorNewNoThrowPlusZ(HeapAllocator, &HeapAllocator::Instance, size, T, __VA_ARGS__)
#define HeapNewNoThrowPlusPrefixZ(size, T, ...) AllocatorNewNoThrowPlusPrefixZ(HeapAllocator, &HeapAllocator::Instance, size, T, __VA_ARGS__)
#define HeapNewNoThrowStruct(T) AllocatorNewNoThrowStruct(HeapAllocator, &HeapAllocator::Instance, T)
#define HeapNewNoThrowStructZ(T) AllocatorNewNoThrowStructZ(HeapAllocator, &HeapAllocator::Instance, T)
#define HeapNewNoThrowArray(T, count, ...) AllocatorNewNoThrowArray(HeapAllocator, &HeapAllocator::Instance, T, count)
#define HeapNewNoThrowArrayZ(T, count, ...) AllocatorNewNoThrowArrayZ(HeapAllocator, &HeapAllocator::Instance, T, count)

#define NoMemProtectHeapNewNoThrow(T, ...) AllocatorNewNoThrow(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), T, __VA_ARGS__)
#define NoMemProtectHeapNewNoThrowZ(T, ...) AllocatorNewNoThrowZ(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), T, __VA_ARGS__)
#define NoMemProtectHeapNewNoThrowPlus(size, T, ...) AllocatorNewNoThrowPlus(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), size, T, __VA_ARGS__)
#define NoMemProtectHeapNewNoThrowPlusZ(size, T, ...) AllocatorNewNoThrowPlusZ(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), size, T, __VA_ARGS__)
#define NoMemProtectHeapNewNoThrowPlusPrefixZ(size, T, ...) AllocatorNewNoThrowPlusPrefixZ(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), size, T, __VA_ARGS__)
#define NoMemProtectHeapNewNoThrowStruct(T) AllocatorNewNoThrowStruct(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), T)
#define NoMemProtectHeapNewNoThrowStructZ(T) AllocatorNewNoThrowStructZ(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), T)
#define NoMemProtectHeapNewNoThrowArray(T, count, ...) AllocatorNewNoThrowArray(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), T, count)
#define NoMemProtectHeapNewNoThrowArrayZ(T, count, ...) AllocatorNewNoThrowArrayZ(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), T, count)
#define NoMemProtectHeapDelete(obj) AllocatorDelete(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), obj)
#define NoMemProtectHeapDeletePlus(size, obj) AllocatorDeletePlus(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), size, obj)
#define NoMemProtectHeapDeletePlusPrefix(size, obj) AllocatorDeletePlusPrefix(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), size, obj)
#define NoMemProtectHeapDeleteArray(count, obj) AllocatorDeleteArray(HeapAllocator, HeapAllocator::GetNoMemProtectInstance(), count, obj)

#define NoCheckHeapNew(T, ...) AllocatorNew(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, T, __VA_ARGS__)
#define NoCheckHeapNewZ(T, ...) AllocatorNewZ(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, T, __VA_ARGS__)
#define NoCheckHeapNewPlus(size, T, ...) AllocatorNewPlus(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, size, T, __VA_ARGS__)
#define NoCheckHeapNewPlusZ(size, T, ...) AllocatorNewPlusZ(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, size, T, __VA_ARGS__)
#define NoCheckHeapNewStruct(T) AllocatorNewStruct(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, T)
#define NoCheckHeapNewStructZ(T) AllocatorNewStructZ(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, T)
#define NoCheckHeapNewArray(T, count, ...) AllocatorNewArray(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, T, count)
#define NoCheckHeapNewArrayZ(T, count, ...) AllocatorNewArrayZ(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, T, count)
#define NoCheckHeapDelete(obj) AllocatorDelete(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, obj)
#define NoCheckHeapDeletePlus(size, obj) AllocatorDeletePlus(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, size, obj)
#define NoCheckHeapDeleteArray(count, obj) AllocatorDeleteArray(NoCheckHeapAllocator, &NoCheckHeapAllocator::Instance, count, obj)

namespace Memory
{
#ifdef HEAP_TRACK_ALLOC

struct HeapAllocatorData;
struct HeapAllocRecord
{
    HeapAllocRecord * prev;
    HeapAllocRecord * next;
    size_t            allocId;
    size_t            size;
    TrackAllocData    allocData;
    HeapAllocatorData* data;
#if defined(CHECK_MEMORY_LEAK) || defined(LEAK_REPORT)
    StackBackTrace * stacktrace;
#endif
};
struct HeapAllocatorData
{
    void LogAlloc(HeapAllocRecord * record, size_t requestedBytes, TrackAllocData const& data);
    void LogFree(HeapAllocRecord * record);

    bool CheckLeaks();

    HeapAllocRecord * head;
    size_t allocCount;
    size_t deleteCount;
    size_t outstandingBytes;

    static uint const StackTraceDepth = 10;
};
#endif

struct HeapAllocator
{
    static const bool FakeZeroLengthArray = false;

    char * Alloc(size_t byteSize)
    {
        return AllocT<false>(byteSize);
    }
    template <bool noThrow>
    char * AllocT(size_t byteSize)
    {
#ifdef HEAP_TRACK_ALLOC
        size_t requestedBytes = byteSize;
        byteSize = AllocSizeMath::Add(requestedBytes, ::Math::Align<size_t>(sizeof(HeapAllocRecord), MEMORY_ALLOCATION_ALIGNMENT));
        TrackAllocData allocData;
        ClearTrackAllocInfo(&allocData);
#elif defined(HEAP_PERF_COUNTERS)
        size_t requestedBytes = byteSize;
        byteSize = AllocSizeMath::Add(requestedBytes, ::Math::Align<size_t>(sizeof(size_t), MEMORY_ALLOCATION_ALIGNMENT));
#endif

        if (noThrow)
        {
            FAULTINJECT_MEMORY_NOTHROW(L"Heap", byteSize);
        }
        else
        {
            FAULTINJECT_MEMORY_THROW(L"Heap", byteSize);
        }

        char * buffer;
#ifdef INTERNAL_MEM_PROTECT_HEAP_ALLOC
        if (DoUseMemProtectHeap())
        {
            void * memory = MemProtectHeapRootAlloc(memProtectHeapHandle, byteSize);
            if (memory == nullptr)
            {
                if (noThrow)
                {
                    return nullptr;
                }               
                Js::Throw::OutOfMemory();
            }
            buffer = (char *)memory;
        }
        else
#endif
        {
            buffer = (char *)malloc(byteSize);
        }

        if (!noThrow && buffer == null)
        {
            Js::Throw::OutOfMemory();            
        }

#if defined(HEAP_TRACK_ALLOC) || defined(HEAP_PERF_COUNTERS)
        if (!noThrow || buffer != null)
        {
#ifdef HEAP_TRACK_ALLOC
            cs.Enter();
            data.LogAlloc((HeapAllocRecord *)buffer, requestedBytes, allocData);
            cs.Leave();
            buffer += ::Math::Align<size_t>(sizeof(HeapAllocRecord), MEMORY_ALLOCATION_ALIGNMENT);
#else
            *(size_t *)buffer = requestedBytes;
            buffer += ::Math::Align<size_t>(sizeof(size_t), MEMORY_ALLOCATION_ALIGNMENT);

#endif
            HEAP_PERF_COUNTER_INC(LiveObject);
            HEAP_PERF_COUNTER_ADD(LiveObjectSize, requestedBytes);
        }
#endif
        return buffer;
    }

    // This exists soley to make the AllocateXXX macros more polymorphic
    char * AllocLeaf(size_t byteSize)
    {
        return Alloc(byteSize);
    }

    char * NoThrowAlloc(size_t byteSize)
    {
        return AllocT<true>(byteSize);
    }

    char * AllocZero(size_t byteSize)
    {
        char * buffer = Alloc(byteSize);
        memset(buffer, 0, byteSize);
        return buffer;
    }

    char * NoThrowAllocZero(size_t byteSize)
    {
        char * buffer = NoThrowAlloc(byteSize);
        if (buffer != null)
        {
            memset(buffer, 0, byteSize);
        }
        return buffer;
    }
    void Free(void * buffer, size_t byteSize)
    {
#ifdef HEAP_TRACK_ALLOC
        if (buffer != null)
        {
            HeapAllocRecord * record = (HeapAllocRecord *)(((char *)buffer) - ::Math::Align<size_t>(sizeof(HeapAllocRecord), MEMORY_ALLOCATION_ALIGNMENT));
            Assert(byteSize == (size_t)-1 || record->size == byteSize);

            HEAP_PERF_COUNTER_DEC(LiveObject);
            HEAP_PERF_COUNTER_SUB(LiveObjectSize, record->size);

            cs.Enter();
            data.LogFree(record);
            cs.Leave();

            buffer = record;
#if DBG
            memset(buffer, DbgMemFill, record->size + ::Math::Align<size_t>(sizeof(HeapAllocRecord), MEMORY_ALLOCATION_ALIGNMENT));
#endif
        }
#elif defined(HEAP_PERF_COUNTERS)
        if (buffer != null)
        {
            HEAP_PERF_COUNTER_DEC(LiveObject);
            size_t * allocSize = (size_t *)(((char *)buffer) - ::Math::Align<size_t>(sizeof(size_t), MEMORY_ALLOCATION_ALIGNMENT));
            HEAP_PERF_COUNTER_SUB(LiveObjectSize, *allocSize);
            buffer = allocSize;
        }
#endif
#ifdef INTERNAL_MEM_PROTECT_HEAP_ALLOC
        if (DoUseMemProtectHeap())
        {
            HRESULT hr = MemProtectHeapUnrootAndZero(memProtectHeapHandle, buffer);
            Assert(SUCCEEDED(hr));
            return;
        }                
#endif
        free(buffer);
    }

    static HeapAllocator Instance;
    static HeapAllocator * GetNoMemProtectInstance();


#ifdef TRACK_ALLOC
    // Doesn't support tracking information, dummy implementation
    HeapAllocator * TrackAllocInfo(TrackAllocData const& data);
    void ClearTrackAllocInfo(TrackAllocData* data = NULL);

#ifdef HEAP_TRACK_ALLOC
#ifndef INTERNAL_MEM_PROTECT_HEAP_ALLOC
    ~HeapAllocator();
#endif

    static void InitializeThread()
    {
        memset(&nextAllocData, 0, sizeof(nextAllocData));
    }

    static bool CheckLeaks();

    __declspec(thread) static TrackAllocData nextAllocData;
    HeapAllocatorData data;
    static CriticalSection cs;
#endif
#endif

#ifdef INTERNAL_MEM_PROTECT_HEAP_ALLOC
    HeapAllocator(bool allowMemProtect = true);
    ~HeapAllocator();

    void FinishMemProtectHeapCollect();

private:
    bool DoUseMemProtectHeap();
    static HeapAllocator NoMemProtectInstance;
#if DBG
    bool isUsed;
    bool allocMemProtect;
    void * memProtectHeapHandle;
#endif
#endif
}; // HeapAllocator.

class NoThrowHeapAllocator
{
public:
    static const bool FakeZeroLengthArray = false;
    char * Alloc(size_t byteSize);
    char * AllocZero(size_t byteSize);
    void Free(void * buffer, size_t byteSize);
    static NoThrowHeapAllocator Instance;

#ifdef TRACK_ALLOC
    // Doesn't support tracking information, dummy implementation
    NoThrowHeapAllocator * TrackAllocInfo(TrackAllocData const& data);
    void ClearTrackAllocInfo(TrackAllocData* data = NULL);
#endif
};

#ifdef INTERNAL_MEM_PROTECT_HEAP_ALLOC


class NoThrowNoMemProtectHeapAllocator
{
public:
    static const bool FakeZeroLengthArray = false;
    char * Alloc(size_t byteSize);
    char * AllocZero(size_t byteSize);
    void Free(void * buffer, size_t byteSize);
    static NoThrowNoMemProtectHeapAllocator Instance;

#ifdef TRACK_ALLOC
    // Doesn't support tracking information, dummy implementation
    NoThrowNoMemProtectHeapAllocator * TrackAllocInfo(TrackAllocData const& data);
    void ClearTrackAllocInfo(TrackAllocData* data = NULL);
#endif
};
#endif

class NoCheckHeapAllocator
{
public:
    static const bool FakeZeroLengthArray = false;
    char * Alloc(size_t byteSize)
    {
        if (processHeap == NULL)
        {
            processHeap = GetProcessHeap();
        }
        char * buffer = (char*)HeapAlloc(processHeap, 0, byteSize);
        if (buffer == null)
        {
            // NoCheck heap allocator is only used by debug only code, and if we fail to allocate
            // memory, we will just raise an exceptio nand kill the process
            DebugHeap_OOM_fatal_error();
        }
        return buffer;
    }
    char * AllocZero(size_t byteSize)
    {
        if (processHeap == NULL)
        {
            processHeap = GetProcessHeap();
        }
        char * buffer = (char*)HeapAlloc(processHeap, HEAP_ZERO_MEMORY, byteSize);
        if (buffer == null)
        {
            // NoCheck heap allocator is only used by debug only code, and if we fail to allocate
            // memory, we will just raise an exceptio nand kill the process
            DebugHeap_OOM_fatal_error();
        }
        return buffer;
    }
    void Free(void * buffer, size_t byteSize)
    {
        Assert(processHeap != NULL);
        HeapFree(processHeap, 0, buffer);
    }

#ifdef TRACK_ALLOC
    // Doesn't support tracking information, dummy implementation
    NoCheckHeapAllocator * TrackAllocInfo(TrackAllocData const& data) { return this; }
    void ClearTrackAllocInfo(TrackAllocData* data = NULL) {}
#endif
    static NoCheckHeapAllocator Instance;
    static HANDLE processHeap;
};

#ifdef CHECK_MEMORY_LEAK
class MemoryLeakCheck
{
public:
    MemoryLeakCheck() : head(NULL), tail(NULL), leakedBytes(0), leakedCount(0), enableOutput(true) {}
    ~MemoryLeakCheck();
    static void AddLeakDump(wchar_t const * dump, size_t bytes, size_t count);
    static void SetEnableOutput(bool flag) { leakCheck.enableOutput = flag; }
    static bool IsEnableOutput() { return leakCheck.enableOutput; }
private:
    static MemoryLeakCheck leakCheck;

    struct LeakRecord
    {
        wchar_t const * dump;
        LeakRecord * next;
    };

    CriticalSection cs;
    LeakRecord * head;
    LeakRecord * tail;
    size_t leakedBytes;
    size_t leakedCount;

    bool enableOutput;
};
#endif
} // namespace Memory

#ifdef INTERNAL_MEM_PROTECT_HEAP_ALLOC
//----------------------------------------
// NoThrowNoMemProtectHeapAllocator overrides
//----------------------------------------
template <>
__inline void * __cdecl
operator new(size_t byteSize, NoThrowNoMemProtectHeapAllocator * alloc, char * (NoThrowNoMemProtectHeapAllocator::*AllocFunc)(size_t))
{
    return ::operator new(byteSize, alloc, true, AllocFunc);
}

template <>
__inline void * __cdecl
operator new[](size_t byteSize, NoThrowNoMemProtectHeapAllocator * alloc, char * (NoThrowNoMemProtectHeapAllocator::*AllocFunc)(size_t))
{
    return ::operator new[](byteSize, alloc, true, AllocFunc);
}

template <>
__inline void * __cdecl
operator new(size_t byteSize, NoThrowNoMemProtectHeapAllocator * alloc, char * (NoThrowNoMemProtectHeapAllocator::*AllocFunc)(size_t), size_t plusSize)
{
    return ::operator new(byteSize, alloc, true, AllocFunc, plusSize);
}

inline void __cdecl
operator delete(void * obj, NoThrowNoMemProtectHeapAllocator * alloc, char * (NoThrowNoMemProtectHeapAllocator::*AllocFunc)(size_t))
{
    alloc->Free(obj, (size_t)-1);
}

inline void __cdecl
operator delete(void * obj, NoThrowNoMemProtectHeapAllocator * alloc, char * (NoThrowNoMemProtectHeapAllocator::*AllocFunc)(size_t), size_t plusSize)
{
    alloc->Free(obj, (size_t)-1);
}
#else
typedef NoThrowHeapAllocator NoThrowNoMemProtectHeapAllocator;
#endif

//----------------------------------------
// Default operator new/delete overrides
//----------------------------------------
#if !defined(USED_IN_STATIC_LIB)
void * __cdecl operator new(size_t byteSize);
void * __cdecl operator new[](size_t byteSize);
void __cdecl operator delete(void * obj);
void __cdecl operator delete[](void * obj);
#endif

//----------------------------------------
// HeapAllocator overrides
//----------------------------------------
inline void __cdecl
operator delete(void * obj, HeapAllocator * alloc, char * (HeapAllocator::*AllocFunc)(size_t))
{
    alloc->Free(obj, (size_t)-1);
}

inline void __cdecl
operator delete(void * obj, HeapAllocator * alloc, char * (HeapAllocator::*AllocFunc)(size_t), size_t plusSize)
{
    alloc->Free(obj, (size_t)-1);
}

//----------------------------------------
// NoThrowHeapAllocator overrides
//----------------------------------------
template <>
__inline void * __cdecl
operator new(size_t byteSize, NoThrowHeapAllocator * alloc, char * (NoThrowHeapAllocator::*AllocFunc)(size_t))
{
    return ::operator new(byteSize, alloc, true, AllocFunc);
}

template <>
__inline void * __cdecl
operator new[](size_t byteSize, NoThrowHeapAllocator * alloc, char * (NoThrowHeapAllocator::*AllocFunc)(size_t))
{
    return ::operator new[](byteSize, alloc, true, AllocFunc);
}

template <>
__inline void * __cdecl
operator new(size_t byteSize, NoThrowHeapAllocator * alloc, char * (NoThrowHeapAllocator::*AllocFunc)(size_t), size_t plusSize)
{
    return ::operator new(byteSize, alloc, true, AllocFunc, plusSize);
}

inline void __cdecl
operator delete(void * obj, NoThrowHeapAllocator * alloc, char * (NoThrowHeapAllocator::*AllocFunc)(size_t))
{
    alloc->Free(obj, (size_t)-1);
}

inline void __cdecl
operator delete(void * obj, NoThrowHeapAllocator * alloc, char * (NoThrowHeapAllocator::*AllocFunc)(size_t), size_t plusSize)
{
    alloc->Free(obj, (size_t)-1);
}


template <>
__inline void * __cdecl
operator new(size_t byteSize, NoCheckHeapAllocator * alloc, char * (NoCheckHeapAllocator::*AllocFunc)(size_t))
{
    Assert(byteSize != 0);
    void * buffer = (alloc->*AllocFunc)(byteSize);
    return buffer;
}


template <>
__inline void * __cdecl
operator new(size_t byteSize, NoCheckHeapAllocator * alloc, char * (NoCheckHeapAllocator::*AllocFunc)(size_t), size_t plusSize)
{
    Assert(byteSize != 0);
    Assert(plusSize != 0);
    void * buffer = (alloc->*AllocFunc)(AllocSizeMath::Add(byteSize, plusSize));
    return buffer;
}


__inline void * __cdecl
operator new[](size_t byteSize, NoCheckHeapAllocator * alloc, char * (NoCheckHeapAllocator::*AllocFunc)(size_t))
{
    void * buffer = (alloc->*AllocFunc)(byteSize);
    return buffer;
}

inline void __cdecl
operator delete(void * obj, NoCheckHeapAllocator * alloc, char * (NoCheckHeapAllocator::*AllocFunc)(size_t))
{
    alloc->Free(obj, (size_t)-1);
}

inline void __cdecl
operator delete(void * obj, NoCheckHeapAllocator * alloc, char * (NoCheckHeapAllocator::*AllocFunc)(size_t), size_t plusSize)
{
    alloc->Free(obj, (size_t)-1);
}
